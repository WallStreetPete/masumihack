"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ioredis";
exports.ids = ["vendor-chunks/ioredis"];
exports.modules = {

/***/ "(rsc)/./node_modules/ioredis/built/Command.js":
/*!***********************************************!*\
  !*** ./node_modules/ioredis/built/Command.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst commands_1 = __webpack_require__(/*! @ioredis/commands */ \"(rsc)/./node_modules/@ioredis/commands/built/index.js\");\nconst calculateSlot = __webpack_require__(/*! cluster-key-slot */ \"(rsc)/./node_modules/cluster-key-slot/lib/index.js\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/./node_modules/standard-as-callback/built/index.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\n/**\n * Command instance\n *\n * It's rare that you need to create a Command instance yourself.\n *\n * ```js\n * var infoCommand = new Command('info', null, function (err, result) {\n *   console.log('result', result);\n * });\n *\n * redis.sendCommand(infoCommand);\n *\n * // When no callback provided, Command instance will have a `promise` property,\n * // which will resolve/reject with the result of the command.\n * var getCommand = new Command('get', ['foo']);\n * getCommand.promise.then(function (result) {\n *   console.log('result', result);\n * });\n * ```\n */ class Command {\n    /**\n     * Creates an instance of Command.\n     * @param name Command name\n     * @param args An array of command arguments\n     * @param options\n     * @param callback The callback that handles the response.\n     * If omit, the response will be handled via Promise\n     */ constructor(name, args = [], options = {}, callback){\n        this.name = name;\n        this.inTransaction = false;\n        this.isResolved = false;\n        this.transformed = false;\n        this.replyEncoding = options.replyEncoding;\n        this.errorStack = options.errorStack;\n        this.args = args.flat();\n        this.callback = callback;\n        this.initPromise();\n        if (options.keyPrefix) {\n            // @ts-expect-error\n            const isBufferKeyPrefix = options.keyPrefix instanceof Buffer;\n            // @ts-expect-error\n            let keyPrefixBuffer = isBufferKeyPrefix ? options.keyPrefix : null;\n            this._iterateKeys((key)=>{\n                if (key instanceof Buffer) {\n                    if (keyPrefixBuffer === null) {\n                        keyPrefixBuffer = Buffer.from(options.keyPrefix);\n                    }\n                    return Buffer.concat([\n                        keyPrefixBuffer,\n                        key\n                    ]);\n                } else if (isBufferKeyPrefix) {\n                    // @ts-expect-error\n                    return Buffer.concat([\n                        options.keyPrefix,\n                        Buffer.from(String(key))\n                    ]);\n                }\n                return options.keyPrefix + key;\n            });\n        }\n        if (options.readOnly) {\n            this.isReadOnly = true;\n        }\n    }\n    /**\n     * Check whether the command has the flag\n     */ static checkFlag(flagName, commandName) {\n        return !!this.getFlagMap()[flagName][commandName];\n    }\n    static setArgumentTransformer(name, func) {\n        this._transformer.argument[name] = func;\n    }\n    static setReplyTransformer(name, func) {\n        this._transformer.reply[name] = func;\n    }\n    static getFlagMap() {\n        if (!this.flagMap) {\n            this.flagMap = Object.keys(Command.FLAGS).reduce((map, flagName)=>{\n                map[flagName] = {};\n                Command.FLAGS[flagName].forEach((commandName)=>{\n                    map[flagName][commandName] = true;\n                });\n                return map;\n            }, {});\n        }\n        return this.flagMap;\n    }\n    getSlot() {\n        if (typeof this.slot === \"undefined\") {\n            const key = this.getKeys()[0];\n            this.slot = key == null ? null : calculateSlot(key);\n        }\n        return this.slot;\n    }\n    getKeys() {\n        return this._iterateKeys();\n    }\n    /**\n     * Convert command to writable buffer or string\n     */ toWritable(_socket) {\n        let result;\n        const commandStr = \"*\" + (this.args.length + 1) + \"\\r\\n$\" + Buffer.byteLength(this.name) + \"\\r\\n\" + this.name + \"\\r\\n\";\n        if (this.bufferMode) {\n            const buffers = new MixedBuffers();\n            buffers.push(commandStr);\n            for(let i = 0; i < this.args.length; ++i){\n                const arg = this.args[i];\n                if (arg instanceof Buffer) {\n                    if (arg.length === 0) {\n                        buffers.push(\"$0\\r\\n\\r\\n\");\n                    } else {\n                        buffers.push(\"$\" + arg.length + \"\\r\\n\");\n                        buffers.push(arg);\n                        buffers.push(\"\\r\\n\");\n                    }\n                } else {\n                    buffers.push(\"$\" + Buffer.byteLength(arg) + \"\\r\\n\" + arg + \"\\r\\n\");\n                }\n            }\n            result = buffers.toBuffer();\n        } else {\n            result = commandStr;\n            for(let i = 0; i < this.args.length; ++i){\n                const arg = this.args[i];\n                result += \"$\" + Buffer.byteLength(arg) + \"\\r\\n\" + arg + \"\\r\\n\";\n            }\n        }\n        return result;\n    }\n    stringifyArguments() {\n        for(let i = 0; i < this.args.length; ++i){\n            const arg = this.args[i];\n            if (typeof arg === \"string\") {\n            // buffers and strings don't need any transformation\n            } else if (arg instanceof Buffer) {\n                this.bufferMode = true;\n            } else {\n                this.args[i] = (0, utils_1.toArg)(arg);\n            }\n        }\n    }\n    /**\n     * Convert buffer/buffer[] to string/string[],\n     * and apply reply transformer.\n     */ transformReply(result) {\n        if (this.replyEncoding) {\n            result = (0, utils_1.convertBufferToString)(result, this.replyEncoding);\n        }\n        const transformer = Command._transformer.reply[this.name];\n        if (transformer) {\n            result = transformer(result);\n        }\n        return result;\n    }\n    /**\n     * Set the wait time before terminating the attempt to execute a command\n     * and generating an error.\n     */ setTimeout(ms) {\n        if (!this._commandTimeoutTimer) {\n            this._commandTimeoutTimer = setTimeout(()=>{\n                if (!this.isResolved) {\n                    this.reject(new Error(\"Command timed out\"));\n                }\n            }, ms);\n        }\n    }\n    initPromise() {\n        const promise = new Promise((resolve, reject)=>{\n            if (!this.transformed) {\n                this.transformed = true;\n                const transformer = Command._transformer.argument[this.name];\n                if (transformer) {\n                    this.args = transformer(this.args);\n                }\n                this.stringifyArguments();\n            }\n            this.resolve = this._convertValue(resolve);\n            if (this.errorStack) {\n                this.reject = (err)=>{\n                    reject((0, utils_1.optimizeErrorStack)(err, this.errorStack.stack, __dirname));\n                };\n            } else {\n                this.reject = reject;\n            }\n        });\n        this.promise = (0, standard_as_callback_1.default)(promise, this.callback);\n    }\n    /**\n     * Iterate through the command arguments that are considered keys.\n     */ _iterateKeys(transform = (key)=>key) {\n        if (typeof this.keys === \"undefined\") {\n            this.keys = [];\n            if ((0, commands_1.exists)(this.name)) {\n                // @ts-expect-error\n                const keyIndexes = (0, commands_1.getKeyIndexes)(this.name, this.args);\n                for (const index of keyIndexes){\n                    this.args[index] = transform(this.args[index]);\n                    this.keys.push(this.args[index]);\n                }\n            }\n        }\n        return this.keys;\n    }\n    /**\n     * Convert the value from buffer to the target encoding.\n     */ _convertValue(resolve) {\n        return (value)=>{\n            try {\n                const existingTimer = this._commandTimeoutTimer;\n                if (existingTimer) {\n                    clearTimeout(existingTimer);\n                    delete this._commandTimeoutTimer;\n                }\n                resolve(this.transformReply(value));\n                this.isResolved = true;\n            } catch (err) {\n                this.reject(err);\n            }\n            return this.promise;\n        };\n    }\n}\nexports[\"default\"] = Command;\nCommand.FLAGS = {\n    VALID_IN_SUBSCRIBER_MODE: [\n        \"subscribe\",\n        \"psubscribe\",\n        \"unsubscribe\",\n        \"punsubscribe\",\n        \"ssubscribe\",\n        \"sunsubscribe\",\n        \"ping\",\n        \"quit\"\n    ],\n    VALID_IN_MONITOR_MODE: [\n        \"monitor\",\n        \"auth\"\n    ],\n    ENTER_SUBSCRIBER_MODE: [\n        \"subscribe\",\n        \"psubscribe\",\n        \"ssubscribe\"\n    ],\n    EXIT_SUBSCRIBER_MODE: [\n        \"unsubscribe\",\n        \"punsubscribe\",\n        \"sunsubscribe\"\n    ],\n    WILL_DISCONNECT: [\n        \"quit\"\n    ]\n};\nCommand._transformer = {\n    argument: {},\n    reply: {}\n};\nconst msetArgumentTransformer = function(args) {\n    if (args.length === 1) {\n        if (args[0] instanceof Map) {\n            return (0, utils_1.convertMapToArray)(args[0]);\n        }\n        if (typeof args[0] === \"object\" && args[0] !== null) {\n            return (0, utils_1.convertObjectToArray)(args[0]);\n        }\n    }\n    return args;\n};\nconst hsetArgumentTransformer = function(args) {\n    if (args.length === 2) {\n        if (args[1] instanceof Map) {\n            return [\n                args[0]\n            ].concat((0, utils_1.convertMapToArray)(args[1]));\n        }\n        if (typeof args[1] === \"object\" && args[1] !== null) {\n            return [\n                args[0]\n            ].concat((0, utils_1.convertObjectToArray)(args[1]));\n        }\n    }\n    return args;\n};\nCommand.setArgumentTransformer(\"mset\", msetArgumentTransformer);\nCommand.setArgumentTransformer(\"msetnx\", msetArgumentTransformer);\nCommand.setArgumentTransformer(\"hset\", hsetArgumentTransformer);\nCommand.setArgumentTransformer(\"hmset\", hsetArgumentTransformer);\nCommand.setReplyTransformer(\"hgetall\", function(result) {\n    if (Array.isArray(result)) {\n        const obj = {};\n        for(let i = 0; i < result.length; i += 2){\n            const key = result[i];\n            const value = result[i + 1];\n            if (key in obj) {\n                // can only be truthy if the property is special somehow, like '__proto__' or 'constructor'\n                // https://github.com/luin/ioredis/issues/1267\n                Object.defineProperty(obj, key, {\n                    value,\n                    configurable: true,\n                    enumerable: true,\n                    writable: true\n                });\n            } else {\n                obj[key] = value;\n            }\n        }\n        return obj;\n    }\n    return result;\n});\nclass MixedBuffers {\n    constructor(){\n        this.length = 0;\n        this.items = [];\n    }\n    push(x) {\n        this.length += Buffer.byteLength(x);\n        this.items.push(x);\n    }\n    toBuffer() {\n        const result = Buffer.allocUnsafe(this.length);\n        let offset = 0;\n        for (const item of this.items){\n            const length = Buffer.byteLength(item);\n            Buffer.isBuffer(item) ? item.copy(result, offset) : result.write(item, offset, length);\n            offset += length;\n        }\n        return result;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9Db21tYW5kLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLGFBQWFDLG1CQUFPQSxDQUFDLGdGQUFtQjtBQUM5QyxNQUFNQyxnQkFBZ0JELG1CQUFPQSxDQUFDLDRFQUFrQjtBQUNoRCxNQUFNRSx5QkFBeUJGLG1CQUFPQSxDQUFDLHNGQUFzQjtBQUM3RCxNQUFNRyxVQUFVSCxtQkFBT0EsQ0FBQyxrRUFBUztBQUNqQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNELE1BQU1JO0lBQ0Y7Ozs7Ozs7S0FPQyxHQUNEQyxZQUFZQyxJQUFJLEVBQUVDLE9BQU8sRUFBRSxFQUFFQyxVQUFVLENBQUMsQ0FBQyxFQUFFQyxRQUFRLENBQUU7UUFDakQsSUFBSSxDQUFDSCxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDSSxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxhQUFhLEdBQUdMLFFBQVFLLGFBQWE7UUFDMUMsSUFBSSxDQUFDQyxVQUFVLEdBQUdOLFFBQVFNLFVBQVU7UUFDcEMsSUFBSSxDQUFDUCxJQUFJLEdBQUdBLEtBQUtRLElBQUk7UUFDckIsSUFBSSxDQUFDTixRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ08sV0FBVztRQUNoQixJQUFJUixRQUFRUyxTQUFTLEVBQUU7WUFDbkIsbUJBQW1CO1lBQ25CLE1BQU1DLG9CQUFvQlYsUUFBUVMsU0FBUyxZQUFZRTtZQUN2RCxtQkFBbUI7WUFDbkIsSUFBSUMsa0JBQWtCRixvQkFDaEJWLFFBQVFTLFNBQVMsR0FDakI7WUFDTixJQUFJLENBQUNJLFlBQVksQ0FBQyxDQUFDQztnQkFDZixJQUFJQSxlQUFlSCxRQUFRO29CQUN2QixJQUFJQyxvQkFBb0IsTUFBTTt3QkFDMUJB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U0FBUzlCLE9BQU9xRixXQUFXLENBQUMsSUFBSSxDQUFDckQsTUFBTTtRQUM3QyxJQUFJc0QsU0FBUztRQUNiLEtBQUssTUFBTUMsUUFBUSxJQUFJLENBQUNKLEtBQUssQ0FBRTtZQUMzQixNQUFNbkQsU0FBU2hDLE9BQU9pQyxVQUFVLENBQUNzRDtZQUNqQ3ZGLE9BQU93RixRQUFRLENBQUNELFFBQ1ZBLEtBQUtFLElBQUksQ0FBQzNELFFBQVF3RCxVQUNsQnhELE9BQU80RCxLQUFLLENBQUNILE1BQU1ELFFBQVF0RDtZQUNqQ3NELFVBQVV0RDtRQUNkO1FBQ0EsT0FBT0Y7SUFDWDtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvQ29tbWFuZC5qcz8yMTUwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29tbWFuZHNfMSA9IHJlcXVpcmUoXCJAaW9yZWRpcy9jb21tYW5kc1wiKTtcbmNvbnN0IGNhbGN1bGF0ZVNsb3QgPSByZXF1aXJlKFwiY2x1c3Rlci1rZXktc2xvdFwiKTtcbmNvbnN0IHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEgPSByZXF1aXJlKFwic3RhbmRhcmQtYXMtY2FsbGJhY2tcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIENvbW1hbmQgaW5zdGFuY2VcbiAqXG4gKiBJdCdzIHJhcmUgdGhhdCB5b3UgbmVlZCB0byBjcmVhdGUgYSBDb21tYW5kIGluc3RhbmNlIHlvdXJzZWxmLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgaW5mb0NvbW1hbmQgPSBuZXcgQ29tbWFuZCgnaW5mbycsIG51bGwsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICogICBjb25zb2xlLmxvZygncmVzdWx0JywgcmVzdWx0KTtcbiAqIH0pO1xuICpcbiAqIHJlZGlzLnNlbmRDb21tYW5kKGluZm9Db21tYW5kKTtcbiAqXG4gKiAvLyBXaGVuIG5vIGNhbGxiYWNrIHByb3ZpZGVkLCBDb21tYW5kIGluc3RhbmNlIHdpbGwgaGF2ZSBhIGBwcm9taXNlYCBwcm9wZXJ0eSxcbiAqIC8vIHdoaWNoIHdpbGwgcmVzb2x2ZS9yZWplY3Qgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBjb21tYW5kLlxuICogdmFyIGdldENvbW1hbmQgPSBuZXcgQ29tbWFuZCgnZ2V0JywgWydmb28nXSk7XG4gKiBnZXRDb21tYW5kLnByb21pc2UudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gKiAgIGNvbnNvbGUubG9nKCdyZXN1bHQnLCByZXN1bHQpO1xuICogfSk7XG4gKiBgYGBcbiAqL1xuY2xhc3MgQ29tbWFuZCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBDb21tYW5kLlxuICAgICAqIEBwYXJhbSBuYW1lIENvbW1hbmQgbmFtZVxuICAgICAqIEBwYXJhbSBhcmdzIEFuIGFycmF5IG9mIGNvbW1hbmQgYXJndW1lbnRzXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRoYXQgaGFuZGxlcyB0aGUgcmVzcG9uc2UuXG4gICAgICogSWYgb21pdCwgdGhlIHJlc3BvbnNlIHdpbGwgYmUgaGFuZGxlZCB2aWEgUHJvbWlzZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGFyZ3MgPSBbXSwgb3B0aW9ucyA9IHt9LCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmluVHJhbnNhY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1Jlc29sdmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXBseUVuY29kaW5nID0gb3B0aW9ucy5yZXBseUVuY29kaW5nO1xuICAgICAgICB0aGlzLmVycm9yU3RhY2sgPSBvcHRpb25zLmVycm9yU3RhY2s7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3MuZmxhdCgpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMuaW5pdFByb21pc2UoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMua2V5UHJlZml4KSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBjb25zdCBpc0J1ZmZlcktleVByZWZpeCA9IG9wdGlvbnMua2V5UHJlZml4IGluc3RhbmNlb2YgQnVmZmVyO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgbGV0IGtleVByZWZpeEJ1ZmZlciA9IGlzQnVmZmVyS2V5UHJlZml4XG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLmtleVByZWZpeFxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2l0ZXJhdGVLZXlzKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlQcmVmaXhCdWZmZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleVByZWZpeEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKG9wdGlvbnMua2V5UHJlZml4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChba2V5UHJlZml4QnVmZmVyLCBrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNCdWZmZXJLZXlQcmVmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbb3B0aW9ucy5rZXlQcmVmaXgsIEJ1ZmZlci5mcm9tKFN0cmluZyhrZXkpKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5rZXlQcmVmaXggKyBrZXk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5yZWFkT25seSkge1xuICAgICAgICAgICAgdGhpcy5pc1JlYWRPbmx5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBjb21tYW5kIGhhcyB0aGUgZmxhZ1xuICAgICAqL1xuICAgIHN0YXRpYyBjaGVja0ZsYWcoZmxhZ05hbWUsIGNvbW1hbmROYW1lKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuZ2V0RmxhZ01hcCgpW2ZsYWdOYW1lXVtjb21tYW5kTmFtZV07XG4gICAgfVxuICAgIHN0YXRpYyBzZXRBcmd1bWVudFRyYW5zZm9ybWVyKG5hbWUsIGZ1bmMpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtZXIuYXJndW1lbnRbbmFtZV0gPSBmdW5jO1xuICAgIH1cbiAgICBzdGF0aWMgc2V0UmVwbHlUcmFuc2Zvcm1lcihuYW1lLCBmdW5jKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybWVyLnJlcGx5W25hbWVdID0gZnVuYztcbiAgICB9XG4gICAgc3RhdGljIGdldEZsYWdNYXAoKSB7XG4gICAgICAgIGlmICghdGhpcy5mbGFnTWFwKSB7XG4gICAgICAgICAgICB0aGlzLmZsYWdNYXAgPSBPYmplY3Qua2V5cyhDb21tYW5kLkZMQUdTKS5yZWR1Y2UoKG1hcCwgZmxhZ05hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBtYXBbZmxhZ05hbWVdID0ge307XG4gICAgICAgICAgICAgICAgQ29tbWFuZC5GTEFHU1tmbGFnTmFtZV0uZm9yRWFjaCgoY29tbWFuZE5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWFwW2ZsYWdOYW1lXVtjb21tYW5kTmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ01hcDtcbiAgICB9XG4gICAgZ2V0U2xvdCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNsb3QgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5cygpWzBdO1xuICAgICAgICAgICAgdGhpcy5zbG90ID0ga2V5ID09IG51bGwgPyBudWxsIDogY2FsY3VsYXRlU2xvdChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNsb3Q7XG4gICAgfVxuICAgIGdldEtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVyYXRlS2V5cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGNvbW1hbmQgdG8gd3JpdGFibGUgYnVmZmVyIG9yIHN0cmluZ1xuICAgICAqL1xuICAgIHRvV3JpdGFibGUoX3NvY2tldCkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBjb25zdCBjb21tYW5kU3RyID0gXCIqXCIgK1xuICAgICAgICAgICAgKHRoaXMuYXJncy5sZW5ndGggKyAxKSArXG4gICAgICAgICAgICBcIlxcclxcbiRcIiArXG4gICAgICAgICAgICBCdWZmZXIuYnl0ZUxlbmd0aCh0aGlzLm5hbWUpICtcbiAgICAgICAgICAgIFwiXFxyXFxuXCIgK1xuICAgICAgICAgICAgdGhpcy5uYW1lICtcbiAgICAgICAgICAgIFwiXFxyXFxuXCI7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlck1vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBuZXcgTWl4ZWRCdWZmZXJzKCk7XG4gICAgICAgICAgICBidWZmZXJzLnB1c2goY29tbWFuZFN0cik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXJncy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZyA9IHRoaXMuYXJnc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2goXCIkMFxcclxcblxcclxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChcIiRcIiArIGFyZy5sZW5ndGggKyBcIlxcclxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVycy5wdXNoKFwiXFxyXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2goXCIkXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgQnVmZmVyLmJ5dGVMZW5ndGgoYXJnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcclxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcclxcblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBidWZmZXJzLnRvQnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjb21tYW5kU3RyO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSB0aGlzLmFyZ3NbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9XG4gICAgICAgICAgICAgICAgICAgIFwiJFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5ieXRlTGVuZ3RoKGFyZykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHJcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHJcXG5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdHJpbmdpZnlBcmd1bWVudHMoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBhcmcgPSB0aGlzLmFyZ3NbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIC8vIGJ1ZmZlcnMgYW5kIHN0cmluZ3MgZG9uJ3QgbmVlZCBhbnkgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyTW9kZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFyZ3NbaV0gPSAoMCwgdXRpbHNfMS50b0FyZykoYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGJ1ZmZlci9idWZmZXJbXSB0byBzdHJpbmcvc3RyaW5nW10sXG4gICAgICogYW5kIGFwcGx5IHJlcGx5IHRyYW5zZm9ybWVyLlxuICAgICAqL1xuICAgIHRyYW5zZm9ybVJlcGx5KHJlc3VsdCkge1xuICAgICAgICBpZiAodGhpcy5yZXBseUVuY29kaW5nKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAoMCwgdXRpbHNfMS5jb252ZXJ0QnVmZmVyVG9TdHJpbmcpKHJlc3VsdCwgdGhpcy5yZXBseUVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lciA9IENvbW1hbmQuX3RyYW5zZm9ybWVyLnJlcGx5W3RoaXMubmFtZV07XG4gICAgICAgIGlmICh0cmFuc2Zvcm1lcikge1xuICAgICAgICAgICAgcmVzdWx0ID0gdHJhbnNmb3JtZXIocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHdhaXQgdGltZSBiZWZvcmUgdGVybWluYXRpbmcgdGhlIGF0dGVtcHQgdG8gZXhlY3V0ZSBhIGNvbW1hbmRcbiAgICAgKiBhbmQgZ2VuZXJhdGluZyBhbiBlcnJvci5cbiAgICAgKi9cbiAgICBzZXRUaW1lb3V0KG1zKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29tbWFuZFRpbWVvdXRUaW1lcikge1xuICAgICAgICAgICAgdGhpcy5fY29tbWFuZFRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KG5ldyBFcnJvcihcIkNvbW1hbmQgdGltZWQgb3V0XCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBtcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdFByb21pc2UoKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudHJhbnNmb3JtZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lciA9IENvbW1hbmQuX3RyYW5zZm9ybWVyLmFyZ3VtZW50W3RoaXMubmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXJncyA9IHRyYW5zZm9ybWVyKHRoaXMuYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RyaW5naWZ5QXJndW1lbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSB0aGlzLl9jb252ZXJ0VmFsdWUocmVzb2x2ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5lcnJvclN0YWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3QgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCgoMCwgdXRpbHNfMS5vcHRpbWl6ZUVycm9yU3RhY2spKGVyciwgdGhpcy5lcnJvclN0YWNrLnN0YWNrLCBfX2Rpcm5hbWUpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb21pc2UgPSAoMCwgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMS5kZWZhdWx0KShwcm9taXNlLCB0aGlzLmNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXRlcmF0ZSB0aHJvdWdoIHRoZSBjb21tYW5kIGFyZ3VtZW50cyB0aGF0IGFyZSBjb25zaWRlcmVkIGtleXMuXG4gICAgICovXG4gICAgX2l0ZXJhdGVLZXlzKHRyYW5zZm9ybSA9IChrZXkpID0+IGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMua2V5cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5rZXlzID0gW107XG4gICAgICAgICAgICBpZiAoKDAsIGNvbW1hbmRzXzEuZXhpc3RzKSh0aGlzLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleUluZGV4ZXMgPSAoMCwgY29tbWFuZHNfMS5nZXRLZXlJbmRleGVzKSh0aGlzLm5hbWUsIHRoaXMuYXJncyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBrZXlJbmRleGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXJnc1tpbmRleF0gPSB0cmFuc2Zvcm0odGhpcy5hcmdzW2luZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMua2V5cy5wdXNoKHRoaXMuYXJnc1tpbmRleF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5rZXlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSB2YWx1ZSBmcm9tIGJ1ZmZlciB0byB0aGUgdGFyZ2V0IGVuY29kaW5nLlxuICAgICAqL1xuICAgIF9jb252ZXJ0VmFsdWUocmVzb2x2ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVGltZXIgPSB0aGlzLl9jb21tYW5kVGltZW91dFRpbWVyO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1RpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChleGlzdGluZ1RpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NvbW1hbmRUaW1lb3V0VGltZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy50cmFuc2Zvcm1SZXBseSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ29tbWFuZDtcbkNvbW1hbmQuRkxBR1MgPSB7XG4gICAgVkFMSURfSU5fU1VCU0NSSUJFUl9NT0RFOiBbXG4gICAgICAgIFwic3Vic2NyaWJlXCIsXG4gICAgICAgIFwicHN1YnNjcmliZVwiLFxuICAgICAgICBcInVuc3Vic2NyaWJlXCIsXG4gICAgICAgIFwicHVuc3Vic2NyaWJlXCIsXG4gICAgICAgIFwic3N1YnNjcmliZVwiLFxuICAgICAgICBcInN1bnN1YnNjcmliZVwiLFxuICAgICAgICBcInBpbmdcIixcbiAgICAgICAgXCJxdWl0XCIsXG4gICAgXSxcbiAgICBWQUxJRF9JTl9NT05JVE9SX01PREU6IFtcIm1vbml0b3JcIiwgXCJhdXRoXCJdLFxuICAgIEVOVEVSX1NVQlNDUklCRVJfTU9ERTogW1wic3Vic2NyaWJlXCIsIFwicHN1YnNjcmliZVwiLCBcInNzdWJzY3JpYmVcIl0sXG4gICAgRVhJVF9TVUJTQ1JJQkVSX01PREU6IFtcInVuc3Vic2NyaWJlXCIsIFwicHVuc3Vic2NyaWJlXCIsIFwic3Vuc3Vic2NyaWJlXCJdLFxuICAgIFdJTExfRElTQ09OTkVDVDogW1wicXVpdFwiXSxcbn07XG5Db21tYW5kLl90cmFuc2Zvcm1lciA9IHtcbiAgICBhcmd1bWVudDoge30sXG4gICAgcmVwbHk6IHt9LFxufTtcbmNvbnN0IG1zZXRBcmd1bWVudFRyYW5zZm9ybWVyID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKGFyZ3NbMF0gaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb252ZXJ0TWFwVG9BcnJheSkoYXJnc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSBcIm9iamVjdFwiICYmIGFyZ3NbMF0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb252ZXJ0T2JqZWN0VG9BcnJheSkoYXJnc1swXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyZ3M7XG59O1xuY29uc3QgaHNldEFyZ3VtZW50VHJhbnNmb3JtZXIgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBpZiAoYXJnc1sxXSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIFthcmdzWzBdXS5jb25jYXQoKDAsIHV0aWxzXzEuY29udmVydE1hcFRvQXJyYXkpKGFyZ3NbMV0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMV0gPT09IFwib2JqZWN0XCIgJiYgYXJnc1sxXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFthcmdzWzBdXS5jb25jYXQoKDAsIHV0aWxzXzEuY29udmVydE9iamVjdFRvQXJyYXkpKGFyZ3NbMV0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJncztcbn07XG5Db21tYW5kLnNldEFyZ3VtZW50VHJhbnNmb3JtZXIoXCJtc2V0XCIsIG1zZXRBcmd1bWVudFRyYW5zZm9ybWVyKTtcbkNvbW1hbmQuc2V0QXJndW1lbnRUcmFuc2Zvcm1lcihcIm1zZXRueFwiLCBtc2V0QXJndW1lbnRUcmFuc2Zvcm1lcik7XG5Db21tYW5kLnNldEFyZ3VtZW50VHJhbnNmb3JtZXIoXCJoc2V0XCIsIGhzZXRBcmd1bWVudFRyYW5zZm9ybWVyKTtcbkNvbW1hbmQuc2V0QXJndW1lbnRUcmFuc2Zvcm1lcihcImhtc2V0XCIsIGhzZXRBcmd1bWVudFRyYW5zZm9ybWVyKTtcbkNvbW1hbmQuc2V0UmVwbHlUcmFuc2Zvcm1lcihcImhnZXRhbGxcIiwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSByZXN1bHRbaV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc3VsdFtpICsgMV07XG4gICAgICAgICAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIC8vIGNhbiBvbmx5IGJlIHRydXRoeSBpZiB0aGUgcHJvcGVydHkgaXMgc3BlY2lhbCBzb21laG93LCBsaWtlICdfX3Byb3RvX18nIG9yICdjb25zdHJ1Y3RvcidcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbHVpbi9pb3JlZGlzL2lzc3Vlcy8xMjY3XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufSk7XG5jbGFzcyBNaXhlZEJ1ZmZlcnMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICB9XG4gICAgcHVzaCh4KSB7XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKHgpO1xuICAgICAgICB0aGlzLml0ZW1zLnB1c2goeCk7XG4gICAgfVxuICAgIHRvQnVmZmVyKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBCdWZmZXIuYWxsb2NVbnNhZmUodGhpcy5sZW5ndGgpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGl0ZW0pO1xuICAgICAgICAgICAgQnVmZmVyLmlzQnVmZmVyKGl0ZW0pXG4gICAgICAgICAgICAgICAgPyBpdGVtLmNvcHkocmVzdWx0LCBvZmZzZXQpXG4gICAgICAgICAgICAgICAgOiByZXN1bHQud3JpdGUoaXRlbSwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNvbW1hbmRzXzEiLCJyZXF1aXJlIiwiY2FsY3VsYXRlU2xvdCIsInN0YW5kYXJkX2FzX2NhbGxiYWNrXzEiLCJ1dGlsc18xIiwiQ29tbWFuZCIsImNvbnN0cnVjdG9yIiwibmFtZSIsImFyZ3MiLCJvcHRpb25zIiwiY2FsbGJhY2siLCJpblRyYW5zYWN0aW9uIiwiaXNSZXNvbHZlZCIsInRyYW5zZm9ybWVkIiwicmVwbHlFbmNvZGluZyIsImVycm9yU3RhY2siLCJmbGF0IiwiaW5pdFByb21pc2UiLCJrZXlQcmVmaXgiLCJpc0J1ZmZlcktleVByZWZpeCIsIkJ1ZmZlciIsImtleVByZWZpeEJ1ZmZlciIsIl9pdGVyYXRlS2V5cyIsImtleSIsImZyb20iLCJjb25jYXQiLCJTdHJpbmciLCJyZWFkT25seSIsImlzUmVhZE9ubHkiLCJjaGVja0ZsYWciLCJmbGFnTmFtZSIsImNvbW1hbmROYW1lIiwiZ2V0RmxhZ01hcCIsInNldEFyZ3VtZW50VHJhbnNmb3JtZXIiLCJmdW5jIiwiX3RyYW5zZm9ybWVyIiwiYXJndW1lbnQiLCJzZXRSZXBseVRyYW5zZm9ybWVyIiwicmVwbHkiLCJmbGFnTWFwIiwia2V5cyIsIkZMQUdTIiwicmVkdWNlIiwibWFwIiwiZm9yRWFjaCIsImdldFNsb3QiLCJzbG90IiwiZ2V0S2V5cyIsInRvV3JpdGFibGUiLCJfc29ja2V0IiwicmVzdWx0IiwiY29tbWFuZFN0ciIsImxlbmd0aCIsImJ5dGVMZW5ndGgiLCJidWZmZXJNb2RlIiwiYnVmZmVycyIsIk1peGVkQnVmZmVycyIsInB1c2giLCJpIiwiYXJnIiwidG9CdWZmZXIiLCJzdHJpbmdpZnlBcmd1bWVudHMiLCJ0b0FyZyIsInRyYW5zZm9ybVJlcGx5IiwiY29udmVydEJ1ZmZlclRvU3RyaW5nIiwidHJhbnNmb3JtZXIiLCJzZXRUaW1lb3V0IiwibXMiLCJfY29tbWFuZFRpbWVvdXRUaW1lciIsInJlamVjdCIsIkVycm9yIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiX2NvbnZlcnRWYWx1ZSIsImVyciIsIm9wdGltaXplRXJyb3JTdGFjayIsInN0YWNrIiwiX19kaXJuYW1lIiwiZGVmYXVsdCIsInRyYW5zZm9ybSIsImV4aXN0cyIsImtleUluZGV4ZXMiLCJnZXRLZXlJbmRleGVzIiwiaW5kZXgiLCJleGlzdGluZ1RpbWVyIiwiY2xlYXJUaW1lb3V0IiwiVkFMSURfSU5fU1VCU0NSSUJFUl9NT0RFIiwiVkFMSURfSU5fTU9OSVRPUl9NT0RFIiwiRU5URVJfU1VCU0NSSUJFUl9NT0RFIiwiRVhJVF9TVUJTQ1JJQkVSX01PREUiLCJXSUxMX0RJU0NPTk5FQ1QiLCJtc2V0QXJndW1lbnRUcmFuc2Zvcm1lciIsIk1hcCIsImNvbnZlcnRNYXBUb0FycmF5IiwiY29udmVydE9iamVjdFRvQXJyYXkiLCJoc2V0QXJndW1lbnRUcmFuc2Zvcm1lciIsIkFycmF5IiwiaXNBcnJheSIsIm9iaiIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsIml0ZW1zIiwieCIsImFsbG9jVW5zYWZlIiwib2Zmc2V0IiwiaXRlbSIsImlzQnVmZmVyIiwiY29weSIsIndyaXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/Command.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/DataHandler.js":
/*!***************************************************!*\
  !*** ./node_modules/ioredis/built/DataHandler.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst Command_1 = __webpack_require__(/*! ./Command */ \"(rsc)/./node_modules/ioredis/built/Command.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst RedisParser = __webpack_require__(/*! redis-parser */ \"(rsc)/./node_modules/redis-parser/index.js\");\nconst SubscriptionSet_1 = __webpack_require__(/*! ./SubscriptionSet */ \"(rsc)/./node_modules/ioredis/built/SubscriptionSet.js\");\nconst debug = (0, utils_1.Debug)(\"dataHandler\");\nclass DataHandler {\n    constructor(redis, parserOptions){\n        this.redis = redis;\n        const parser = new RedisParser({\n            stringNumbers: parserOptions.stringNumbers,\n            returnBuffers: true,\n            returnError: (err)=>{\n                this.returnError(err);\n            },\n            returnFatalError: (err)=>{\n                this.returnFatalError(err);\n            },\n            returnReply: (reply)=>{\n                this.returnReply(reply);\n            }\n        });\n        // prependListener ensures the parser receives and processes data before socket timeout checks are performed\n        redis.stream.prependListener(\"data\", (data)=>{\n            parser.execute(data);\n        });\n        // prependListener() doesn't enable flowing mode automatically - we need to resume the stream manually\n        redis.stream.resume();\n    }\n    returnFatalError(err) {\n        err.message += \". Please report this.\";\n        this.redis.recoverFromFatalError(err, err, {\n            offlineQueue: false\n        });\n    }\n    returnError(err) {\n        const item = this.shiftCommand(err);\n        if (!item) {\n            return;\n        }\n        err.command = {\n            name: item.command.name,\n            args: item.command.args\n        };\n        this.redis.handleReconnection(err, item);\n    }\n    returnReply(reply) {\n        if (this.handleMonitorReply(reply)) {\n            return;\n        }\n        if (this.handleSubscriberReply(reply)) {\n            return;\n        }\n        const item = this.shiftCommand(reply);\n        if (!item) {\n            return;\n        }\n        if (Command_1.default.checkFlag(\"ENTER_SUBSCRIBER_MODE\", item.command.name)) {\n            this.redis.condition.subscriber = new SubscriptionSet_1.default();\n            this.redis.condition.subscriber.add(item.command.name, reply[1].toString());\n            if (!fillSubCommand(item.command, reply[2])) {\n                this.redis.commandQueue.unshift(item);\n            }\n        } else if (Command_1.default.checkFlag(\"EXIT_SUBSCRIBER_MODE\", item.command.name)) {\n            if (!fillUnsubCommand(item.command, reply[2])) {\n                this.redis.commandQueue.unshift(item);\n            }\n        } else {\n            item.command.resolve(reply);\n        }\n    }\n    handleSubscriberReply(reply) {\n        if (!this.redis.condition.subscriber) {\n            return false;\n        }\n        const replyType = Array.isArray(reply) ? reply[0].toString() : null;\n        debug('receive reply \"%s\" in subscriber mode', replyType);\n        switch(replyType){\n            case \"message\":\n                if (this.redis.listeners(\"message\").length > 0) {\n                    // Check if there're listeners to avoid unnecessary `toString()`.\n                    this.redis.emit(\"message\", reply[1].toString(), reply[2] ? reply[2].toString() : \"\");\n                }\n                this.redis.emit(\"messageBuffer\", reply[1], reply[2]);\n                break;\n            case \"pmessage\":\n                {\n                    const pattern = reply[1].toString();\n                    if (this.redis.listeners(\"pmessage\").length > 0) {\n                        this.redis.emit(\"pmessage\", pattern, reply[2].toString(), reply[3].toString());\n                    }\n                    this.redis.emit(\"pmessageBuffer\", pattern, reply[2], reply[3]);\n                    break;\n                }\n            case \"smessage\":\n                {\n                    if (this.redis.listeners(\"smessage\").length > 0) {\n                        this.redis.emit(\"smessage\", reply[1].toString(), reply[2] ? reply[2].toString() : \"\");\n                    }\n                    this.redis.emit(\"smessageBuffer\", reply[1], reply[2]);\n                    break;\n                }\n            case \"ssubscribe\":\n            case \"subscribe\":\n            case \"psubscribe\":\n                {\n                    const channel = reply[1].toString();\n                    this.redis.condition.subscriber.add(replyType, channel);\n                    const item = this.shiftCommand(reply);\n                    if (!item) {\n                        return;\n                    }\n                    if (!fillSubCommand(item.command, reply[2])) {\n                        this.redis.commandQueue.unshift(item);\n                    }\n                    break;\n                }\n            case \"sunsubscribe\":\n            case \"unsubscribe\":\n            case \"punsubscribe\":\n                {\n                    const channel = reply[1] ? reply[1].toString() : null;\n                    if (channel) {\n                        this.redis.condition.subscriber.del(replyType, channel);\n                    }\n                    const count = reply[2];\n                    if (Number(count) === 0) {\n                        this.redis.condition.subscriber = false;\n                    }\n                    const item = this.shiftCommand(reply);\n                    if (!item) {\n                        return;\n                    }\n                    if (!fillUnsubCommand(item.command, count)) {\n                        this.redis.commandQueue.unshift(item);\n                    }\n                    break;\n                }\n            default:\n                {\n                    const item = this.shiftCommand(reply);\n                    if (!item) {\n                        return;\n                    }\n                    item.command.resolve(reply);\n                }\n        }\n        return true;\n    }\n    handleMonitorReply(reply) {\n        if (this.redis.status !== \"monitoring\") {\n            return false;\n        }\n        const replyStr = reply.toString();\n        if (replyStr === \"OK\") {\n            // Valid commands in the monitoring mode are AUTH and MONITOR,\n            // both of which always reply with 'OK'.\n            // So if we got an 'OK', we can make certain that\n            // the reply is made to AUTH & MONITOR.\n            return false;\n        }\n        // Since commands sent in the monitoring mode will trigger an exception,\n        // any replies we received in the monitoring mode should consider to be\n        // realtime monitor data instead of result of commands.\n        const len = replyStr.indexOf(\" \");\n        const timestamp = replyStr.slice(0, len);\n        const argIndex = replyStr.indexOf('\"');\n        const args = replyStr.slice(argIndex + 1, -1).split('\" \"').map((elem)=>elem.replace(/\\\\\"/g, '\"'));\n        const dbAndSource = replyStr.slice(len + 2, argIndex - 2).split(\" \");\n        this.redis.emit(\"monitor\", timestamp, args, dbAndSource[1], dbAndSource[0]);\n        return true;\n    }\n    shiftCommand(reply) {\n        const item = this.redis.commandQueue.shift();\n        if (!item) {\n            const message = \"Command queue state error. If you can reproduce this, please report it.\";\n            const error = new Error(message + (reply instanceof Error ? ` Last error: ${reply.message}` : ` Last reply: ${reply.toString()}`));\n            this.redis.emit(\"error\", error);\n            return null;\n        }\n        return item;\n    }\n}\nexports[\"default\"] = DataHandler;\nconst remainingRepliesMap = new WeakMap();\nfunction fillSubCommand(command, count) {\n    let remainingReplies = remainingRepliesMap.has(command) ? remainingRepliesMap.get(command) : command.args.length;\n    remainingReplies -= 1;\n    if (remainingReplies <= 0) {\n        command.resolve(count);\n        remainingRepliesMap.delete(command);\n        return true;\n    }\n    remainingRepliesMap.set(command, remainingReplies);\n    return false;\n}\nfunction fillUnsubCommand(command, count) {\n    let remainingReplies = remainingRepliesMap.has(command) ? remainingRepliesMap.get(command) : command.args.length;\n    if (remainingReplies === 0) {\n        if (Number(count) === 0) {\n            remainingRepliesMap.delete(command);\n            command.resolve(count);\n            return true;\n        }\n        return false;\n    }\n    remainingReplies -= 1;\n    if (remainingReplies <= 0) {\n        command.resolve(count);\n        return true;\n    }\n    remainingRepliesMap.set(command, remainingReplies);\n    return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9EYXRhSGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyxZQUFZQyxtQkFBT0EsQ0FBQyxnRUFBVztBQUNyQyxNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQyxrRUFBUztBQUNqQyxNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQyxnRUFBYztBQUMxQyxNQUFNRyxvQkFBb0JILG1CQUFPQSxDQUFDLGdGQUFtQjtBQUNyRCxNQUFNSSxRQUFRLENBQUMsR0FBR0gsUUFBUUksS0FBSyxFQUFFO0FBQ2pDLE1BQU1DO0lBQ0ZDLFlBQVlDLEtBQUssRUFBRUMsYUFBYSxDQUFFO1FBQzlCLElBQUksQ0FBQ0QsS0FBSyxHQUFHQTtRQUNiLE1BQU1FLFNBQVMsSUFBSVIsWUFBWTtZQUMzQlMsZUFBZUYsY0FBY0UsYUFBYTtZQUMxQ0MsZUFBZTtZQUNmQyxhQUFhLENBQUNDO2dCQUNWLElBQUksQ0FBQ0QsV0FBVyxDQUFDQztZQUNyQjtZQUNBQyxrQkFBa0IsQ0FBQ0Q7Z0JBQ2YsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQ0Q7WUFDMUI7WUFDQUUsYUFBYSxDQUFDQztnQkFDVixJQUFJLENBQUNELFdBQVcsQ0FBQ0M7WUFDckI7UUFDSjtRQUNBLDRHQUE0RztRQUM1R1QsTUFBTVUsTUFBTSxDQUFDQyxlQUFlLENBQUMsUUFBUSxDQUFDQztZQUNsQ1YsT0FBT1csT0FBTyxDQUFDRDtRQUNuQjtRQUNBLHNHQUFzRztRQUN0R1osTUFBTVUsTUFBTSxDQUFDSSxNQUFNO0lBQ3ZCO0lBQ0FQLGlCQUFpQkQsR0FBRyxFQUFFO1FBQ2xCQSxJQUFJUyxPQUFPLElBQUk7UUFDZixJQUFJLENBQUNmLEtBQUssQ0FBQ2dCLHFCQUFxQixDQUFDVixLQUFLQSxLQUFLO1lBQUVXLGNBQWM7UUFBTTtJQUNyRTtJQUNBWixZQUFZQyxHQUFHLEVBQUU7UUFDYixN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QUlBLG9CQUFvQixHQUFHO1FBQ3ZCN0MsUUFBUWdCLE9BQU8sQ0FBQ1U7UUFDaEJpQixvQkFBb0JLLE1BQU0sQ0FBQ2hEO1FBQzNCLE9BQU87SUFDWDtJQUNBMkMsb0JBQW9CTSxHQUFHLENBQUNqRCxTQUFTNkM7SUFDakMsT0FBTztBQUNYO0FBQ0EsU0FBUzlCLGlCQUFpQmYsT0FBTyxFQUFFMEIsS0FBSztJQUNwQyxJQUFJbUIsbUJBQW1CRixvQkFBb0JHLEdBQUcsQ0FBQzlDLFdBQ3pDMkMsb0JBQW9CSSxHQUFHLENBQUMvQyxXQUN4QkEsUUFBUUUsSUFBSSxDQUFDbUIsTUFBTTtJQUN6QixJQUFJd0IscUJBQXFCLEdBQUc7UUFDeEIsSUFBSWxCLE9BQU9ELFdBQVcsR0FBRztZQUNyQmlCLG9CQUFvQkssTUFBTSxDQUFDaEQ7WUFDM0JBLFFBQVFnQixPQUFPLENBQUNVO1lBQ2hCLE9BQU87UUFDWDtRQUNBLE9BQU87SUFDWDtJQUNBbUIsb0JBQW9CO0lBQ3BCLElBQUlBLG9CQUFvQixHQUFHO1FBQ3ZCN0MsUUFBUWdCLE9BQU8sQ0FBQ1U7UUFDaEIsT0FBTztJQUNYO0lBQ0FpQixvQkFBb0JNLEdBQUcsQ0FBQ2pELFNBQVM2QztJQUNqQyxPQUFPO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9EYXRhSGFuZGxlci5qcz9lMzg2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQ29tbWFuZF8xID0gcmVxdWlyZShcIi4vQ29tbWFuZFwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IFJlZGlzUGFyc2VyID0gcmVxdWlyZShcInJlZGlzLXBhcnNlclwiKTtcbmNvbnN0IFN1YnNjcmlwdGlvblNldF8xID0gcmVxdWlyZShcIi4vU3Vic2NyaXB0aW9uU2V0XCIpO1xuY29uc3QgZGVidWcgPSAoMCwgdXRpbHNfMS5EZWJ1ZykoXCJkYXRhSGFuZGxlclwiKTtcbmNsYXNzIERhdGFIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihyZWRpcywgcGFyc2VyT3B0aW9ucykge1xuICAgICAgICB0aGlzLnJlZGlzID0gcmVkaXM7XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBSZWRpc1BhcnNlcih7XG4gICAgICAgICAgICBzdHJpbmdOdW1iZXJzOiBwYXJzZXJPcHRpb25zLnN0cmluZ051bWJlcnMsXG4gICAgICAgICAgICByZXR1cm5CdWZmZXJzOiB0cnVlLFxuICAgICAgICAgICAgcmV0dXJuRXJyb3I6IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJldHVybkVycm9yKGVycik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmV0dXJuRmF0YWxFcnJvcjogKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmV0dXJuRmF0YWxFcnJvcihlcnIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJldHVyblJlcGx5OiAocmVwbHkpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJldHVyblJlcGx5KHJlcGx5KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBwcmVwZW5kTGlzdGVuZXIgZW5zdXJlcyB0aGUgcGFyc2VyIHJlY2VpdmVzIGFuZCBwcm9jZXNzZXMgZGF0YSBiZWZvcmUgc29ja2V0IHRpbWVvdXQgY2hlY2tzIGFyZSBwZXJmb3JtZWRcbiAgICAgICAgcmVkaXMuc3RyZWFtLnByZXBlbmRMaXN0ZW5lcihcImRhdGFcIiwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHBhcnNlci5leGVjdXRlKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gcHJlcGVuZExpc3RlbmVyKCkgZG9lc24ndCBlbmFibGUgZmxvd2luZyBtb2RlIGF1dG9tYXRpY2FsbHkgLSB3ZSBuZWVkIHRvIHJlc3VtZSB0aGUgc3RyZWFtIG1hbnVhbGx5XG4gICAgICAgIHJlZGlzLnN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gICAgcmV0dXJuRmF0YWxFcnJvcihlcnIpIHtcbiAgICAgICAgZXJyLm1lc3NhZ2UgKz0gXCIuIFBsZWFzZSByZXBvcnQgdGhpcy5cIjtcbiAgICAgICAgdGhpcy5yZWRpcy5yZWNvdmVyRnJvbUZhdGFsRXJyb3IoZXJyLCBlcnIsIHsgb2ZmbGluZVF1ZXVlOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuRXJyb3IoZXJyKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLnNoaWZ0Q29tbWFuZChlcnIpO1xuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlcnIuY29tbWFuZCA9IHtcbiAgICAgICAgICAgIG5hbWU6IGl0ZW0uY29tbWFuZC5uYW1lLFxuICAgICAgICAgICAgYXJnczogaXRlbS5jb21tYW5kLmFyZ3MsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVkaXMuaGFuZGxlUmVjb25uZWN0aW9uKGVyciwgaXRlbSk7XG4gICAgfVxuICAgIHJldHVyblJlcGx5KHJlcGx5KSB7XG4gICAgICAgIGlmICh0aGlzLmhhbmRsZU1vbml0b3JSZXBseShyZXBseSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYW5kbGVTdWJzY3JpYmVyUmVwbHkocmVwbHkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuc2hpZnRDb21tYW5kKHJlcGx5KTtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKENvbW1hbmRfMS5kZWZhdWx0LmNoZWNrRmxhZyhcIkVOVEVSX1NVQlNDUklCRVJfTU9ERVwiLCBpdGVtLmNvbW1hbmQubmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVkaXMuY29uZGl0aW9uLnN1YnNjcmliZXIgPSBuZXcgU3Vic2NyaXB0aW9uU2V0XzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5yZWRpcy5jb25kaXRpb24uc3Vic2NyaWJlci5hZGQoaXRlbS5jb21tYW5kLm5hbWUsIHJlcGx5WzFdLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgaWYgKCFmaWxsU3ViQ29tbWFuZChpdGVtLmNvbW1hbmQsIHJlcGx5WzJdKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVkaXMuY29tbWFuZFF1ZXVlLnVuc2hpZnQoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ29tbWFuZF8xLmRlZmF1bHQuY2hlY2tGbGFnKFwiRVhJVF9TVUJTQ1JJQkVSX01PREVcIiwgaXRlbS5jb21tYW5kLm5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoIWZpbGxVbnN1YkNvbW1hbmQoaXRlbS5jb21tYW5kLCByZXBseVsyXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZGlzLmNvbW1hbmRRdWV1ZS51bnNoaWZ0KGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlbS5jb21tYW5kLnJlc29sdmUocmVwbHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVN1YnNjcmliZXJSZXBseShyZXBseSkge1xuICAgICAgICBpZiAoIXRoaXMucmVkaXMuY29uZGl0aW9uLnN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXBseVR5cGUgPSBBcnJheS5pc0FycmF5KHJlcGx5KSA/IHJlcGx5WzBdLnRvU3RyaW5nKCkgOiBudWxsO1xuICAgICAgICBkZWJ1ZygncmVjZWl2ZSByZXBseSBcIiVzXCIgaW4gc3Vic2NyaWJlciBtb2RlJywgcmVwbHlUeXBlKTtcbiAgICAgICAgc3dpdGNoIChyZXBseVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVkaXMubGlzdGVuZXJzKFwibWVzc2FnZVwiKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZXJlJ3JlIGxpc3RlbmVycyB0byBhdm9pZCB1bm5lY2Vzc2FyeSBgdG9TdHJpbmcoKWAuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVkaXMuZW1pdChcIm1lc3NhZ2VcIiwgcmVwbHlbMV0udG9TdHJpbmcoKSwgcmVwbHlbMl0gPyByZXBseVsyXS50b1N0cmluZygpIDogXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVkaXMuZW1pdChcIm1lc3NhZ2VCdWZmZXJcIiwgcmVwbHlbMV0sIHJlcGx5WzJdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJwbWVzc2FnZVwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHJlcGx5WzFdLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVkaXMubGlzdGVuZXJzKFwicG1lc3NhZ2VcIikubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZGlzLmVtaXQoXCJwbWVzc2FnZVwiLCBwYXR0ZXJuLCByZXBseVsyXS50b1N0cmluZygpLCByZXBseVszXS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWRpcy5lbWl0KFwicG1lc3NhZ2VCdWZmZXJcIiwgcGF0dGVybiwgcmVwbHlbMl0sIHJlcGx5WzNdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzbWVzc2FnZVwiOiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVkaXMubGlzdGVuZXJzKFwic21lc3NhZ2VcIikubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZGlzLmVtaXQoXCJzbWVzc2FnZVwiLCByZXBseVsxXS50b1N0cmluZygpLCByZXBseVsyXSA/IHJlcGx5WzJdLnRvU3RyaW5nKCkgOiBcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWRpcy5lbWl0KFwic21lc3NhZ2VCdWZmZXJcIiwgcmVwbHlbMV0sIHJlcGx5WzJdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzc3Vic2NyaWJlXCI6XG4gICAgICAgICAgICBjYXNlIFwic3Vic2NyaWJlXCI6XG4gICAgICAgICAgICBjYXNlIFwicHN1YnNjcmliZVwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IHJlcGx5WzFdLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWRpcy5jb25kaXRpb24uc3Vic2NyaWJlci5hZGQocmVwbHlUeXBlLCBjaGFubmVsKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5zaGlmdENvbW1hbmQocmVwbHkpO1xuICAgICAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZmlsbFN1YkNvbW1hbmQoaXRlbS5jb21tYW5kLCByZXBseVsyXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWRpcy5jb21tYW5kUXVldWUudW5zaGlmdChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic3Vuc3Vic2NyaWJlXCI6XG4gICAgICAgICAgICBjYXNlIFwidW5zdWJzY3JpYmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwdW5zdWJzY3JpYmVcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSByZXBseVsxXSA/IHJlcGx5WzFdLnRvU3RyaW5nKCkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVkaXMuY29uZGl0aW9uLnN1YnNjcmliZXIuZGVsKHJlcGx5VHlwZSwgY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gcmVwbHlbMl07XG4gICAgICAgICAgICAgICAgaWYgKE51bWJlcihjb3VudCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWRpcy5jb25kaXRpb24uc3Vic2NyaWJlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5zaGlmdENvbW1hbmQocmVwbHkpO1xuICAgICAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZmlsbFVuc3ViQ29tbWFuZChpdGVtLmNvbW1hbmQsIGNvdW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZGlzLmNvbW1hbmRRdWV1ZS51bnNoaWZ0KGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5zaGlmdENvbW1hbmQocmVwbHkpO1xuICAgICAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW0uY29tbWFuZC5yZXNvbHZlKHJlcGx5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaGFuZGxlTW9uaXRvclJlcGx5KHJlcGx5KSB7XG4gICAgICAgIGlmICh0aGlzLnJlZGlzLnN0YXR1cyAhPT0gXCJtb25pdG9yaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXBseVN0ciA9IHJlcGx5LnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChyZXBseVN0ciA9PT0gXCJPS1wiKSB7XG4gICAgICAgICAgICAvLyBWYWxpZCBjb21tYW5kcyBpbiB0aGUgbW9uaXRvcmluZyBtb2RlIGFyZSBBVVRIIGFuZCBNT05JVE9SLFxuICAgICAgICAgICAgLy8gYm90aCBvZiB3aGljaCBhbHdheXMgcmVwbHkgd2l0aCAnT0snLlxuICAgICAgICAgICAgLy8gU28gaWYgd2UgZ290IGFuICdPSycsIHdlIGNhbiBtYWtlIGNlcnRhaW4gdGhhdFxuICAgICAgICAgICAgLy8gdGhlIHJlcGx5IGlzIG1hZGUgdG8gQVVUSCAmIE1PTklUT1IuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2UgY29tbWFuZHMgc2VudCBpbiB0aGUgbW9uaXRvcmluZyBtb2RlIHdpbGwgdHJpZ2dlciBhbiBleGNlcHRpb24sXG4gICAgICAgIC8vIGFueSByZXBsaWVzIHdlIHJlY2VpdmVkIGluIHRoZSBtb25pdG9yaW5nIG1vZGUgc2hvdWxkIGNvbnNpZGVyIHRvIGJlXG4gICAgICAgIC8vIHJlYWx0aW1lIG1vbml0b3IgZGF0YSBpbnN0ZWFkIG9mIHJlc3VsdCBvZiBjb21tYW5kcy5cbiAgICAgICAgY29uc3QgbGVuID0gcmVwbHlTdHIuaW5kZXhPZihcIiBcIik7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IHJlcGx5U3RyLnNsaWNlKDAsIGxlbik7XG4gICAgICAgIGNvbnN0IGFyZ0luZGV4ID0gcmVwbHlTdHIuaW5kZXhPZignXCInKTtcbiAgICAgICAgY29uc3QgYXJncyA9IHJlcGx5U3RyXG4gICAgICAgICAgICAuc2xpY2UoYXJnSW5kZXggKyAxLCAtMSlcbiAgICAgICAgICAgIC5zcGxpdCgnXCIgXCInKVxuICAgICAgICAgICAgLm1hcCgoZWxlbSkgPT4gZWxlbS5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykpO1xuICAgICAgICBjb25zdCBkYkFuZFNvdXJjZSA9IHJlcGx5U3RyLnNsaWNlKGxlbiArIDIsIGFyZ0luZGV4IC0gMikuc3BsaXQoXCIgXCIpO1xuICAgICAgICB0aGlzLnJlZGlzLmVtaXQoXCJtb25pdG9yXCIsIHRpbWVzdGFtcCwgYXJncywgZGJBbmRTb3VyY2VbMV0sIGRiQW5kU291cmNlWzBdKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNoaWZ0Q29tbWFuZChyZXBseSkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5yZWRpcy5jb21tYW5kUXVldWUuc2hpZnQoKTtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gXCJDb21tYW5kIHF1ZXVlIHN0YXRlIGVycm9yLiBJZiB5b3UgY2FuIHJlcHJvZHVjZSB0aGlzLCBwbGVhc2UgcmVwb3J0IGl0LlwiO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSArXG4gICAgICAgICAgICAgICAgKHJlcGx5IGluc3RhbmNlb2YgRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgPyBgIExhc3QgZXJyb3I6ICR7cmVwbHkubWVzc2FnZX1gXG4gICAgICAgICAgICAgICAgICAgIDogYCBMYXN0IHJlcGx5OiAke3JlcGx5LnRvU3RyaW5nKCl9YCkpO1xuICAgICAgICAgICAgdGhpcy5yZWRpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gRGF0YUhhbmRsZXI7XG5jb25zdCByZW1haW5pbmdSZXBsaWVzTWFwID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGZpbGxTdWJDb21tYW5kKGNvbW1hbmQsIGNvdW50KSB7XG4gICAgbGV0IHJlbWFpbmluZ1JlcGxpZXMgPSByZW1haW5pbmdSZXBsaWVzTWFwLmhhcyhjb21tYW5kKVxuICAgICAgICA/IHJlbWFpbmluZ1JlcGxpZXNNYXAuZ2V0KGNvbW1hbmQpXG4gICAgICAgIDogY29tbWFuZC5hcmdzLmxlbmd0aDtcbiAgICByZW1haW5pbmdSZXBsaWVzIC09IDE7XG4gICAgaWYgKHJlbWFpbmluZ1JlcGxpZXMgPD0gMCkge1xuICAgICAgICBjb21tYW5kLnJlc29sdmUoY291bnQpO1xuICAgICAgICByZW1haW5pbmdSZXBsaWVzTWFwLmRlbGV0ZShjb21tYW5kKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJlbWFpbmluZ1JlcGxpZXNNYXAuc2V0KGNvbW1hbmQsIHJlbWFpbmluZ1JlcGxpZXMpO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGZpbGxVbnN1YkNvbW1hbmQoY29tbWFuZCwgY291bnQpIHtcbiAgICBsZXQgcmVtYWluaW5nUmVwbGllcyA9IHJlbWFpbmluZ1JlcGxpZXNNYXAuaGFzKGNvbW1hbmQpXG4gICAgICAgID8gcmVtYWluaW5nUmVwbGllc01hcC5nZXQoY29tbWFuZClcbiAgICAgICAgOiBjb21tYW5kLmFyZ3MubGVuZ3RoO1xuICAgIGlmIChyZW1haW5pbmdSZXBsaWVzID09PSAwKSB7XG4gICAgICAgIGlmIChOdW1iZXIoY291bnQpID09PSAwKSB7XG4gICAgICAgICAgICByZW1haW5pbmdSZXBsaWVzTWFwLmRlbGV0ZShjb21tYW5kKTtcbiAgICAgICAgICAgIGNvbW1hbmQucmVzb2x2ZShjb3VudCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJlbWFpbmluZ1JlcGxpZXMgLT0gMTtcbiAgICBpZiAocmVtYWluaW5nUmVwbGllcyA8PSAwKSB7XG4gICAgICAgIGNvbW1hbmQucmVzb2x2ZShjb3VudCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZW1haW5pbmdSZXBsaWVzTWFwLnNldChjb21tYW5kLCByZW1haW5pbmdSZXBsaWVzKTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDb21tYW5kXzEiLCJyZXF1aXJlIiwidXRpbHNfMSIsIlJlZGlzUGFyc2VyIiwiU3Vic2NyaXB0aW9uU2V0XzEiLCJkZWJ1ZyIsIkRlYnVnIiwiRGF0YUhhbmRsZXIiLCJjb25zdHJ1Y3RvciIsInJlZGlzIiwicGFyc2VyT3B0aW9ucyIsInBhcnNlciIsInN0cmluZ051bWJlcnMiLCJyZXR1cm5CdWZmZXJzIiwicmV0dXJuRXJyb3IiLCJlcnIiLCJyZXR1cm5GYXRhbEVycm9yIiwicmV0dXJuUmVwbHkiLCJyZXBseSIsInN0cmVhbSIsInByZXBlbmRMaXN0ZW5lciIsImRhdGEiLCJleGVjdXRlIiwicmVzdW1lIiwibWVzc2FnZSIsInJlY292ZXJGcm9tRmF0YWxFcnJvciIsIm9mZmxpbmVRdWV1ZSIsIml0ZW0iLCJzaGlmdENvbW1hbmQiLCJjb21tYW5kIiwibmFtZSIsImFyZ3MiLCJoYW5kbGVSZWNvbm5lY3Rpb24iLCJoYW5kbGVNb25pdG9yUmVwbHkiLCJoYW5kbGVTdWJzY3JpYmVyUmVwbHkiLCJkZWZhdWx0IiwiY2hlY2tGbGFnIiwiY29uZGl0aW9uIiwic3Vic2NyaWJlciIsImFkZCIsInRvU3RyaW5nIiwiZmlsbFN1YkNvbW1hbmQiLCJjb21tYW5kUXVldWUiLCJ1bnNoaWZ0IiwiZmlsbFVuc3ViQ29tbWFuZCIsInJlc29sdmUiLCJyZXBseVR5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJsaXN0ZW5lcnMiLCJsZW5ndGgiLCJlbWl0IiwicGF0dGVybiIsImNoYW5uZWwiLCJkZWwiLCJjb3VudCIsIk51bWJlciIsInN0YXR1cyIsInJlcGx5U3RyIiwibGVuIiwiaW5kZXhPZiIsInRpbWVzdGFtcCIsInNsaWNlIiwiYXJnSW5kZXgiLCJzcGxpdCIsIm1hcCIsImVsZW0iLCJyZXBsYWNlIiwiZGJBbmRTb3VyY2UiLCJzaGlmdCIsImVycm9yIiwiRXJyb3IiLCJyZW1haW5pbmdSZXBsaWVzTWFwIiwiV2Vha01hcCIsInJlbWFpbmluZ1JlcGxpZXMiLCJoYXMiLCJnZXQiLCJkZWxldGUiLCJzZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/DataHandler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/Pipeline.js":
/*!************************************************!*\
  !*** ./node_modules/ioredis/built/Pipeline.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst calculateSlot = __webpack_require__(/*! cluster-key-slot */ \"(rsc)/./node_modules/cluster-key-slot/lib/index.js\");\nconst commands_1 = __webpack_require__(/*! @ioredis/commands */ \"(rsc)/./node_modules/@ioredis/commands/built/index.js\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/./node_modules/standard-as-callback/built/index.js\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst Command_1 = __webpack_require__(/*! ./Command */ \"(rsc)/./node_modules/ioredis/built/Command.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst Commander_1 = __webpack_require__(/*! ./utils/Commander */ \"(rsc)/./node_modules/ioredis/built/utils/Commander.js\");\n/*\n  This function derives from the cluster-key-slot implementation.\n  Instead of checking that all keys have the same slot, it checks that all slots are served by the same set of nodes.\n  If this is satisfied, it returns the first key's slot.\n*/ function generateMultiWithNodes(redis, keys) {\n    const slot = calculateSlot(keys[0]);\n    const target = redis._groupsBySlot[slot];\n    for(let i = 1; i < keys.length; i++){\n        if (redis._groupsBySlot[calculateSlot(keys[i])] !== target) {\n            return -1;\n        }\n    }\n    return slot;\n}\nclass Pipeline extends Commander_1.default {\n    constructor(redis){\n        super();\n        this.redis = redis;\n        this.isPipeline = true;\n        this.replyPending = 0;\n        this._queue = [];\n        this._result = [];\n        this._transactions = 0;\n        this._shaToScript = {};\n        this.isCluster = this.redis.constructor.name === \"Cluster\" || this.redis.isCluster;\n        this.options = redis.options;\n        Object.keys(redis.scriptsSet).forEach((name)=>{\n            const script = redis.scriptsSet[name];\n            this._shaToScript[script.sha] = script;\n            this[name] = redis[name];\n            this[name + \"Buffer\"] = redis[name + \"Buffer\"];\n        });\n        redis.addedBuiltinSet.forEach((name)=>{\n            this[name] = redis[name];\n            this[name + \"Buffer\"] = redis[name + \"Buffer\"];\n        });\n        this.promise = new Promise((resolve, reject)=>{\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n        const _this = this;\n        Object.defineProperty(this, \"length\", {\n            get: function() {\n                return _this._queue.length;\n            }\n        });\n    }\n    fillResult(value, position) {\n        if (this._queue[position].name === \"exec\" && Array.isArray(value[1])) {\n            const execLength = value[1].length;\n            for(let i = 0; i < execLength; i++){\n                if (value[1][i] instanceof Error) {\n                    continue;\n                }\n                const cmd = this._queue[position - (execLength - i)];\n                try {\n                    value[1][i] = cmd.transformReply(value[1][i]);\n                } catch (err) {\n                    value[1][i] = err;\n                }\n            }\n        }\n        this._result[position] = value;\n        if (--this.replyPending) {\n            return;\n        }\n        if (this.isCluster) {\n            let retriable = true;\n            let commonError;\n            for(let i = 0; i < this._result.length; ++i){\n                const error = this._result[i][0];\n                const command = this._queue[i];\n                if (error) {\n                    if (command.name === \"exec\" && error.message === \"EXECABORT Transaction discarded because of previous errors.\") {\n                        continue;\n                    }\n                    if (!commonError) {\n                        commonError = {\n                            name: error.name,\n                            message: error.message\n                        };\n                    } else if (commonError.name !== error.name || commonError.message !== error.message) {\n                        retriable = false;\n                        break;\n                    }\n                } else if (!command.inTransaction) {\n                    const isReadOnly = (0, commands_1.exists)(command.name) && (0, commands_1.hasFlag)(command.name, \"readonly\");\n                    if (!isReadOnly) {\n                        retriable = false;\n                        break;\n                    }\n                }\n            }\n            if (commonError && retriable) {\n                const _this = this;\n                const errv = commonError.message.split(\" \");\n                const queue = this._queue;\n                let inTransaction = false;\n                this._queue = [];\n                for(let i = 0; i < queue.length; ++i){\n                    if (errv[0] === \"ASK\" && !inTransaction && queue[i].name !== \"asking\" && (!queue[i - 1] || queue[i - 1].name !== \"asking\")) {\n                        const asking = new Command_1.default(\"asking\");\n                        asking.ignore = true;\n                        this.sendCommand(asking);\n                    }\n                    queue[i].initPromise();\n                    this.sendCommand(queue[i]);\n                    inTransaction = queue[i].inTransaction;\n                }\n                let matched = true;\n                if (typeof this.leftRedirections === \"undefined\") {\n                    this.leftRedirections = {};\n                }\n                const exec = function() {\n                    _this.exec();\n                };\n                const cluster = this.redis;\n                cluster.handleError(commonError, this.leftRedirections, {\n                    moved: function(_slot, key) {\n                        _this.preferKey = key;\n                        cluster.slots[errv[1]] = [\n                            key\n                        ];\n                        cluster._groupsBySlot[errv[1]] = cluster._groupsIds[cluster.slots[errv[1]].join(\";\")];\n                        cluster.refreshSlotsCache();\n                        _this.exec();\n                    },\n                    ask: function(_slot, key) {\n                        _this.preferKey = key;\n                        _this.exec();\n                    },\n                    tryagain: exec,\n                    clusterDown: exec,\n                    connectionClosed: exec,\n                    maxRedirections: ()=>{\n                        matched = false;\n                    },\n                    defaults: ()=>{\n                        matched = false;\n                    }\n                });\n                if (matched) {\n                    return;\n                }\n            }\n        }\n        let ignoredCount = 0;\n        for(let i = 0; i < this._queue.length - ignoredCount; ++i){\n            if (this._queue[i + ignoredCount].ignore) {\n                ignoredCount += 1;\n            }\n            this._result[i] = this._result[i + ignoredCount];\n        }\n        this.resolve(this._result.slice(0, this._result.length - ignoredCount));\n    }\n    sendCommand(command) {\n        if (this._transactions > 0) {\n            command.inTransaction = true;\n        }\n        const position = this._queue.length;\n        command.pipelineIndex = position;\n        command.promise.then((result)=>{\n            this.fillResult([\n                null,\n                result\n            ], position);\n        }).catch((error)=>{\n            this.fillResult([\n                error\n            ], position);\n        });\n        this._queue.push(command);\n        return this;\n    }\n    addBatch(commands) {\n        let command, commandName, args;\n        for(let i = 0; i < commands.length; ++i){\n            command = commands[i];\n            commandName = command[0];\n            args = command.slice(1);\n            this[commandName].apply(this, args);\n        }\n        return this;\n    }\n}\nexports[\"default\"] = Pipeline;\n// @ts-expect-error\nconst multi = Pipeline.prototype.multi;\n// @ts-expect-error\nPipeline.prototype.multi = function() {\n    this._transactions += 1;\n    return multi.apply(this, arguments);\n};\n// @ts-expect-error\nconst execBuffer = Pipeline.prototype.execBuffer;\n// @ts-expect-error\nPipeline.prototype.execBuffer = (0, util_1.deprecate)(function() {\n    if (this._transactions > 0) {\n        this._transactions -= 1;\n    }\n    return execBuffer.apply(this, arguments);\n}, \"Pipeline#execBuffer: Use Pipeline#exec instead\");\n// NOTE: To avoid an unhandled promise rejection, this will unconditionally always return this.promise,\n// which always has the rejection handled by standard-as-callback\n// adding the provided rejection callback.\n//\n// If a different promise instance were returned, that promise would cause its own unhandled promise rejection\n// errors, even if that promise unconditionally resolved to **the resolved value of** this.promise.\nPipeline.prototype.exec = function(callback) {\n    // Wait for the cluster to be connected, since we need nodes information before continuing\n    if (this.isCluster && !this.redis.slots.length) {\n        if (this.redis.status === \"wait\") this.redis.connect().catch(utils_1.noop);\n        if (callback && !this.nodeifiedPromise) {\n            this.nodeifiedPromise = true;\n            (0, standard_as_callback_1.default)(this.promise, callback);\n        }\n        this.redis.delayUntilReady((err)=>{\n            if (err) {\n                this.reject(err);\n                return;\n            }\n            this.exec(callback);\n        });\n        return this.promise;\n    }\n    if (this._transactions > 0) {\n        this._transactions -= 1;\n        return execBuffer.apply(this, arguments);\n    }\n    if (!this.nodeifiedPromise) {\n        this.nodeifiedPromise = true;\n        (0, standard_as_callback_1.default)(this.promise, callback);\n    }\n    if (!this._queue.length) {\n        this.resolve([]);\n    }\n    let pipelineSlot;\n    if (this.isCluster) {\n        // List of the first key for each command\n        const sampleKeys = [];\n        for(let i = 0; i < this._queue.length; i++){\n            const keys = this._queue[i].getKeys();\n            if (keys.length) {\n                sampleKeys.push(keys[0]);\n            }\n            // For each command, check that the keys belong to the same slot\n            if (keys.length && calculateSlot.generateMulti(keys) < 0) {\n                this.reject(new Error(\"All the keys in a pipeline command should belong to the same slot\"));\n                return this.promise;\n            }\n        }\n        if (sampleKeys.length) {\n            pipelineSlot = generateMultiWithNodes(this.redis, sampleKeys);\n            if (pipelineSlot < 0) {\n                this.reject(new Error(\"All keys in the pipeline should belong to the same slots allocation group\"));\n                return this.promise;\n            }\n        } else {\n            // Send the pipeline to a random node\n            pipelineSlot = Math.random() * 16384 | 0;\n        }\n    }\n    const _this = this;\n    execPipeline();\n    return this.promise;\n    function execPipeline() {\n        let writePending = _this.replyPending = _this._queue.length;\n        let node;\n        if (_this.isCluster) {\n            node = {\n                slot: pipelineSlot,\n                redis: _this.redis.connectionPool.nodes.all[_this.preferKey]\n            };\n        }\n        let data = \"\";\n        let buffers;\n        const stream = {\n            isPipeline: true,\n            destination: _this.isCluster ? node : {\n                redis: _this.redis\n            },\n            write (writable) {\n                if (typeof writable !== \"string\") {\n                    if (!buffers) {\n                        buffers = [];\n                    }\n                    if (data) {\n                        buffers.push(Buffer.from(data, \"utf8\"));\n                        data = \"\";\n                    }\n                    buffers.push(writable);\n                } else {\n                    data += writable;\n                }\n                if (!--writePending) {\n                    if (buffers) {\n                        if (data) {\n                            buffers.push(Buffer.from(data, \"utf8\"));\n                        }\n                        stream.destination.redis.stream.write(Buffer.concat(buffers));\n                    } else {\n                        stream.destination.redis.stream.write(data);\n                    }\n                    // Reset writePending for resending\n                    writePending = _this._queue.length;\n                    data = \"\";\n                    buffers = undefined;\n                }\n            }\n        };\n        for(let i = 0; i < _this._queue.length; ++i){\n            _this.redis.sendCommand(_this._queue[i], stream, node);\n        }\n        return _this.promise;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9QaXBlbGluZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyxnQkFBZ0JDLG1CQUFPQSxDQUFDLDRFQUFrQjtBQUNoRCxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyxnRkFBbUI7QUFDOUMsTUFBTUUseUJBQXlCRixtQkFBT0EsQ0FBQyxzRkFBc0I7QUFDN0QsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUMsa0JBQU07QUFDN0IsTUFBTUksWUFBWUosbUJBQU9BLENBQUMsZ0VBQVc7QUFDckMsTUFBTUssVUFBVUwsbUJBQU9BLENBQUMsa0VBQVM7QUFDakMsTUFBTU0sY0FBY04sbUJBQU9BLENBQUMsZ0ZBQW1CO0FBQy9DOzs7O0FBSUEsR0FDQSxTQUFTTyx1QkFBdUJDLEtBQUssRUFBRUMsSUFBSTtJQUN2QyxNQUFNQyxPQUFPWCxjQUFjVSxJQUFJLENBQUMsRUFBRTtJQUNsQyxNQUFNRSxTQUFTSCxNQUFNSSxhQUFhLENBQUNGLEtBQUs7SUFDeEMsSUFBSyxJQUFJRyxJQUFJLEdBQUdBLElBQUlKLEtBQUtLLE1BQU0sRUFBRUQsSUFBSztRQUNsQyxJQUFJTCxNQUFNSSxhQUFhLENBQUNiLGNBQWNVLElBQUksQ0FBQ0ksRUFBRSxFQUFFLEtBQUtGLFFBQVE7WUFDeEQsT0FBTyxDQUFDO1FBQ1o7SUFDSjtJQUNBLE9BQU9EO0FBQ1g7QUFDQSxNQUFNSyxpQkFBaUJULFlBQVlVLE9BQU87SUFDdENDLFlBQVlULEtBQUssQ0FBRTtRQUNmLEtBQUs7UUFDTCxJQUFJLENBQUNBLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNVLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLE1BQU0sR0FBRyxFQUFFO1FBQ2hCLElBQUksQ0FBQ0MsT0FBTyxHQUFHLEVBQUU7UUFDakIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDQyxZQUFZLEdBQUcsQ0FBQztRQUNyQixJQUFJLENBQUNDLFNBQVMsR0FDVixJQUFJLENBQUNoQixLQUFLLENBQUNTLFdBQVcsQ0FBQ1EsSUFBSSxLQUFLLGFBQWEsSUFBSSxDQUFDakIsS0FBSyxDQUFDZ0IsU0FBUztRQUNyRSxJQUFJLENBQUNFLE9BQU8sR0FBR2xCLE1BQU1rQixPQUFPO1FBQzVCL0IsT0FBT2MsSUFBSSxDQUFDRCxNQUFNbUIsVUFBVSxFQUFFQyxPQUFPLENBQUMsQ0FBQ0g7WUFDbkMsTUFBTUksU0FBU3JCLE1BQU1tQixVQUFVLENBQUNGLEtBQUs7WUFDckMsSUFBSSxDQUFDRixZQUFZLENBQUNNLE9BQU9DLEdBQUcsQ0FBQyxHQUFHRDtZQUNoQyxJQUFJLENBQUNKLEtBQUssR0FBR2pCLEtBQUssQ0FBQ2lCLEtBQUs7WUFDeEIsSUFBSSxDQUFDQSxPQUFPLFNBQVMsR0FBR2pCLEtBQUssQ0FBQ2lCLE9BQU8sU0FBUztRQUNsRDtRQUNBakIsTUFBTXVCLGVBQWUsQ0FBQ0gsT0FBTyxDQUFDLENBQUNIO1lBQzNCLElBQUksQ0FBQ0EsS0FBSyxHQUFHakIsS0FBSyxDQUFDaUIsS0FBSztZQUN4QixJQUFJLENBQUNBLE9BQU8sU0FBUyxHQUFHakIsS0FBSyxDQUFDaUIsT0FBTyxTQUFTO1FBQ2xEO1FBQ0EsSUFBSSxDQUFDTyxPQUFPLEdBQUcsSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztZQUNqQyxJQUFJLENBQUNELE9BQU8sR0FBR0E7WUFDZixJQUFJLENBQUNDLE1BQU0sR0FBR0E7UUFDbEI7UUFDQSxNQUFNQyxRQUFRLElBQUk7UUFDbEJ6QyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFVBQVU7WUFDbEN5QyxLQUFLO2dCQUNELE9BQU9ELE1BQU1oQixNQUFNLENBQUNOLE1BQU07WUFDOUI7UUFDSjtJQUNKO0lBQ0F3QixXQUFXeEMsS0FBSyxFQUFFeUMsUUFBUSxFQUFFO1FBQ3hCLElBQUksSUFBSSxDQUFDbkIsTUFBTSxDQUFDbUIsU0FBUyxDQUFDZCxJQUFJLEtBQUssVUFBVWUsTUFBTUMsT0FBTyxDQUFDM0MsS0FBSyxDQUFDLEVBQUUsR0FBRztZQUNsRSxNQUFNNEMsYUFBYTVDLEtBQUssQ0FBQyxFQUFFLENBQUNnQixNQUFNO1lBQ2xDLElBQUssSUFBSUQsSUFBSSxHQUFHQSxJQUFJNkIsWUFBWTdCLElBQUs7Z0JBQ2pDLElBQUlmLEtBQUssQ0FBQyxFQUFFLENBQUNlLEVBQUUsWUFBWThCLE9BQU87b0JBQzlCO2dCQUNKO2dCQUNBLE1BQU1DLE1BQU0sSUFBSSxDQUFDeEIsTUFBTSxDQUFDbUIsV0FBWUcsQ0FBQUEsYUFBYTdCLENBQUFBLEVBQUc7Z0JBQ3BELElBQUk7b0JBQ0FmLEtBQUssQ0FBQyxFQUFFLENBQUNlLEVBQUUsR0FBRytCLElBQUlDLGNBQWMsQ0FBQy9DLEtBQUssQ0FBQyxFQUFFLENBQUNlLEVBQUU7Z0JBQ2hELEVBQ0EsT0FBT2lDLEtBQUs7b0JBQ1JoRCxLQUFLLENBQUMsRUFBRSxDQUFDZSxFQUFFLEdBQUdpQztnQkFDbEI7WUFDSjtRQUNKO1FBQ0EsSUFBSSxDQUFDekIsT0FBTyxDQUFDa0IsU0FBUyxHQUFHekM7UUFDekIsSUFBSSxFQUFFLElBQUksQ0FBQ3FCLFlBQVksRUFBRTtZQUNyQjtRQUNKO1FBQ0EsSUFBSSxJQUFJLENBQUNLLFNBQVMsRUFBRTtZQUNoQixJQUFJdUIsWUFBWTtZQUNoQixJQUFJQztZQUNKLElBQUssSUFBSW5DLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNRLE9BQU8sQ0FBQ1AsTUFBTSxFQUFFLEVBQUVELEVBQUc7Z0JBQzFDLE1BQU1vQyxRQUFRLElBQUksQ0FBQzVCLE9BQU8sQ0FBQ1IsRUFBRSxDQUFDLEVBQUU7Z0JBQ2hDLE1BQU1xQyxVQUFVLElBQUksQ0FBQzlCLE1BQU0sQ0FBQ1AsRUFBRTtnQkFDOUIsSUFBSW9DLE9BQU87b0JBQ1AsSUFBSUMsUUFBUXpCLElBQUksS0FBSyxVQUNqQndCLE1BQU1FLE9BQU8sS0FDVCwrREFBK0Q7d0JBQ25FO29CQUNKO29CQUNBLElBQUksQ0FBQ0gsYUFBYTt3QkFDZEEsY0FBYzs0QkFDVnZCLE1BQU13QixNQUFNeEIsSUFBSTs0QkFDaEIwQixTQUFTRixNQUFNRSxPQUFPO3dCQUMxQjtvQkFDSixPQUNLLElBQUlILFlBQVl2QixJQUFJLEtBQUt3QixNQUFNeEIsSUFBSSxJQUNwQ3VCLFlBQVlHLE9BQU8sS0FBS0YsTUFBTUUsT0FBTyxFQUFFO3dCQUN2Q0osWUFBWTt3QkFDWjtvQkFDSjtnQkFDSixPQUNLLElBQUksQ0FBQ0csUUFBUUUsYUFBYSxFQUFFO29CQUM3QixNQUFNQyxhQUFhLENBQUMsR0FBR3BELFdBQVdxRCxNQUFNLEVBQUVKLFFBQVF6QixJQUFJLEtBQUssQ0FBQyxHQUFHeEIsV0FBV3NELE9BQU8sRUFBRUwsUUFBUXpCLElBQUksRUFBRTtvQkFDakcsSUFBSSxDQUFDNEIsWUFBWTt3QkFDYk4sWUFBWTt3QkFDWjtvQkFDSjtnQkFDSjtZQUNKO1lBQ0EsSUFBSUMsZUFBZUQsV0FBVztnQkFDMUIsTUFBTVgsUUFBUSxJQUFJO2dCQUNsQixNQUFNb0IsT0FBT1IsWUFBWUcsT0FBTyxDQUFDTSxLQUFLLENBQUM7Z0JBQ3ZDLE1BQU1DLFFBQVEsSUFBSSxDQUFDdEMsTUFBTTtnQkFDekIsSUFBSWdDLGdCQUFnQjtnQkFDcEIsSUFBSSxDQUFDaEMsTUFBTSxHQUFHLEVBQUU7Z0JBQ2hCLElBQUssSUFBSVAsSUFBSSxHQUFHQSxJQUFJNkMsTUFBTTVDLE1BQU0sRUFBRSxFQUFFRCxFQUFHO29CQUNuQyxJQUFJMkMsSUFBSSxDQUFDLEVBQUUsS0FBSyxTQUNaLENBQUNKLGlCQUNETSxLQUFLLENBQUM3QyxFQUFFLENBQUNZLElBQUksS0FBSyxZQUNqQixFQUFDaUMsS0FBSyxDQUFDN0MsSUFBSSxFQUFFLElBQUk2QyxLQUFLLENBQUM3QyxJQUFJLEVBQUUsQ0FBQ1ksSUFBSSxLQUFLLFFBQU8sR0FBSTt3QkFDbkQsTUFBTWtDLFNBQVMsSUFBSXZELFVBQVVZLE9BQU8sQ0FBQzt3QkFDckMyQyxPQUFPQyxNQUFNLEdBQUc7d0JBQ2hCLElBQUksQ0FBQ0MsV0FBVyxDQUFDRjtvQkFDckI7b0JBQ0FELEtBQUssQ0FBQzdDLEVBQUUsQ0FBQ2lELFdBQVc7b0JBQ3BCLElBQUksQ0FBQ0QsV0FBVyxDQUFDSCxLQUFLLENBQUM3QyxFQUFFO29CQUN6QnVDLGdCQUFnQk0sS0FBSyxDQUFDN0MsRUFBRSxDQUFDdUMsYUFBYTtnQkFDMUM7Z0JBQ0EsSUFBSVcsVUFBVTtnQkFDZCxJQUFJLE9BQU8sSUFBSSxDQUFDQyxnQkFBZ0IsS0FBSyxhQUFhO29CQUM5QyxJQUFJLENBQUNBLGdCQUFnQixHQUFHLENBQUM7Z0JBQzdCO2dCQUNBLE1BQU1DLE9BQU87b0JBQ1Q3QixNQUFNNkIsSUFBSTtnQkFDZDtnQkFDQSxNQUFNQyxVQUFVLElBQUksQ0FBQzFELEtBQUs7Z0JBQzFCMEQsUUFBUUMsV0FBVyxDQUFDbkIsYUFBYSxJQUFJLENBQUNnQixnQkFBZ0IsRUFBRTtvQkFDcERJLE9BQU8sU0FBVUMsS0FBSyxFQUFFQyxHQUFHO3dCQUN2QmxDLE1BQU1tQyxTQUFTLEdBQUdEO3dCQUNsQkosUUFBUU0sS0FBSyxDQUFDaEIsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHOzRCQUFDYzt5QkFBSTt3QkFDOUJKLFFBQVF0RCxhQUFhLENBQUM0QyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQzFCVSxRQUFRTyxVQUFVLENBQUNQLFFBQVFNLEtBQUssQ0FBQ2hCLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQ2tCLElBQUksQ0FBQyxLQUFLO3dCQUN4RFIsUUFBUVMsaUJBQWlCO3dCQUN6QnZDLE1BQU02QixJQUFJO29CQUNkO29CQUNBVyxLQUFLLFNBQVVQLEtBQUssRUFBRUMsR0FBRzt3QkFDckJsQyxNQUFNbUMsU0FBUyxHQUFHRDt3QkFDbEJsQyxNQUFNNkIsSUFBSTtvQkFDZDtvQkFDQVksVUFBVVo7b0JBQ1ZhLGFBQWFiO29CQUNiYyxrQkFBa0JkO29CQUNsQmUsaUJBQWlCO3dCQUNiakIsVUFBVTtvQkFDZDtvQkFDQWtCLFVBQVU7d0JBQ05sQixVQUFVO29CQUNkO2dCQUNKO2dCQUNBLElBQUlBLFNBQVM7b0JBQ1Q7Z0JBQ0o7WUFDSjtRQUNKO1FBQ0EsSUFBSW1CLGVBQWU7UUFDbkIsSUFBSyxJQUFJckUsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ08sTUFBTSxDQUFDTixNQUFNLEdBQUdvRSxjQUFjLEVBQUVyRSxFQUFHO1lBQ3hELElBQUksSUFBSSxDQUFDTyxNQUFNLENBQUNQLElBQUlxRSxhQUFhLENBQUN0QixNQUFNLEVBQUU7Z0JBQ3RDc0IsZ0JBQWdCO1lBQ3BCO1lBQ0EsSUFBSSxDQUFDN0QsT0FBTyxDQUFDUixFQUFFLEdBQUcsSUFBSSxDQUFDUSxPQUFPLENBQUNSLElBQUlxRSxhQUFhO1FBQ3BEO1FBQ0EsSUFBSSxDQUFDaEQsT0FBTyxDQUFDLElBQUksQ0FBQ2IsT0FBTyxDQUFDOEQsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDOUQsT0FBTyxDQUFDUCxNQUFNLEdBQUdvRTtJQUM3RDtJQUNBckIsWUFBWVgsT0FBTyxFQUFFO1FBQ2pCLElBQUksSUFBSSxDQUFDNUIsYUFBYSxHQUFHLEdBQUc7WUFDeEI0QixRQUFRRSxhQUFhLEdBQUc7UUFDNUI7UUFDQSxNQUFNYixXQUFXLElBQUksQ0FBQ25CLE1BQU0sQ0FBQ04sTUFBTTtRQUNuQ29DLFFBQVFrQyxhQUFhLEdBQUc3QztRQUN4QlcsUUFBUWxCLE9BQU8sQ0FDVnFELElBQUksQ0FBQyxDQUFDQztZQUNQLElBQUksQ0FBQ2hELFVBQVUsQ0FBQztnQkFBQztnQkFBTWdEO2FBQU8sRUFBRS9DO1FBQ3BDLEdBQ0tnRCxLQUFLLENBQUMsQ0FBQ3RDO1lBQ1IsSUFBSSxDQUFDWCxVQUFVLENBQUM7Z0JBQUNXO2FBQU0sRUFBRVY7UUFDN0I7UUFDQSxJQUFJLENBQUNuQixNQUFNLENBQUNvRSxJQUFJLENBQUN0QztRQUNqQixPQUFPLElBQUk7SUFDZjtJQUNBdUMsU0FBU0MsUUFBUSxFQUFFO1FBQ2YsSUFBSXhDLFNBQVN5QyxhQUFhQztRQUMxQixJQUFLLElBQUkvRSxJQUFJLEdBQUdBLElBQUk2RSxTQUFTNUUsTUFBTSxFQUFFLEVBQUVELEVBQUc7WUFDdENxQyxVQUFVd0MsUUFBUSxDQUFDN0UsRUFBRTtZQUNyQjhFLGNBQWN6QyxPQUFPLENBQUMsRUFBRTtZQUN4QjBDLE9BQU8xQyxRQUFRaUMsS0FBSyxDQUFDO1lBQ3JCLElBQUksQ0FBQ1EsWUFBWSxDQUFDRSxLQUFLLENBQUMsSUFBSSxFQUFFRDtRQUNsQztRQUNBLE9BQU8sSUFBSTtJQUNmO0FBQ0o7QUFDQS9GLGtCQUFlLEdBQUdrQjtBQUNsQixtQkFBbUI7QUFDbkIsTUFBTStFLFFBQVEvRSxTQUFTZ0YsU0FBUyxDQUFDRCxLQUFLO0FBQ3RDLG1CQUFtQjtBQUNuQi9FLFNBQVNnRixTQUFTLENBQUNELEtBQUssR0FBRztJQUN2QixJQUFJLENBQUN4RSxhQUFhLElBQUk7SUFDdEIsT0FBT3dFLE1BQU1ELEtBQUssQ0FBQyxJQUFJLEVBQUVHO0FBQzdCO0FBQ0EsbUJBQW1CO0FBQ25CLE1BQU1DLGFBQWFsRixTQUFTZ0YsU0FBUyxDQUFDRSxVQUFVO0FBQ2hELG1CQUFtQjtBQUNuQmxGLFNBQVNnRixTQUFTLENBQUNFLFVBQVUsR0FBRyxDQUFDLEdBQUc5RixPQUFPK0YsU0FBUyxFQUFFO0lBQ2xELElBQUksSUFBSSxDQUFDNUUsYUFBYSxHQUFHLEdBQUc7UUFDeEIsSUFBSSxDQUFDQSxhQUFhLElBQUk7SUFDMUI7SUFDQSxPQUFPMkUsV0FBV0osS0FBSyxDQUFDLElBQUksRUFBRUc7QUFDbEMsR0FBRztBQUNILHVHQUF1RztBQUN2RyxpRUFBaUU7QUFDakUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRiw4R0FBOEc7QUFDOUcsbUdBQW1HO0FBQ25HakYsU0FBU2dGLFNBQVMsQ0FBQzlCLElBQUksR0FBRyxTQUFVa0MsUUFBUTtJQUN4QywwRkFBMEY7SUFDMUYsSUFBSSxJQUFJLENBQUMzRSxTQUFTLElBQUksQ0FBQyxJQUFJLENBQUNoQixLQUFLLENBQUNnRSxLQUFLLENBQUMxRCxNQUFNLEVBQUU7UUFDNUMsSUFBSSxJQUFJLENBQUNOLEtBQUssQ0FBQzRGLE1BQU0sS0FBSyxRQUN0QixJQUFJLENBQUM1RixLQUFLLENBQUM2RixPQUFPLEdBQUdkLEtBQUssQ0FBQ2xGLFFBQVFpRyxJQUFJO1FBQzNDLElBQUlILFlBQVksQ0FBQyxJQUFJLENBQUNJLGdCQUFnQixFQUFFO1lBQ3BDLElBQUksQ0FBQ0EsZ0JBQWdCLEdBQUc7WUFDdkIsSUFBR3JHLHVCQUF1QmMsT0FBTyxFQUFFLElBQUksQ0FBQ2dCLE9BQU8sRUFBRW1FO1FBQ3REO1FBQ0EsSUFBSSxDQUFDM0YsS0FBSyxDQUFDZ0csZUFBZSxDQUFDLENBQUMxRDtZQUN4QixJQUFJQSxLQUFLO2dCQUNMLElBQUksQ0FBQ1gsTUFBTSxDQUFDVztnQkFDWjtZQUNKO1lBQ0EsSUFBSSxDQUFDbUIsSUFBSSxDQUFDa0M7UUFDZDtRQUNBLE9BQU8sSUFBSSxDQUFDbkUsT0FBTztJQUN2QjtJQUNBLElBQUksSUFBSSxDQUFDVixhQUFhLEdBQUcsR0FBRztRQUN4QixJQUFJLENBQUNBLGFBQWEsSUFBSTtRQUN0QixPQUFPMkUsV0FBV0osS0FBSyxDQUFDLElBQUksRUFBRUc7SUFDbEM7SUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDTyxnQkFBZ0IsRUFBRTtRQUN4QixJQUFJLENBQUNBLGdCQUFnQixHQUFHO1FBQ3ZCLElBQUdyRyx1QkFBdUJjLE9BQU8sRUFBRSxJQUFJLENBQUNnQixPQUFPLEVBQUVtRTtJQUN0RDtJQUNBLElBQUksQ0FBQyxJQUFJLENBQUMvRSxNQUFNLENBQUNOLE1BQU0sRUFBRTtRQUNyQixJQUFJLENBQUNvQixPQUFPLENBQUMsRUFBRTtJQUNuQjtJQUNBLElBQUl1RTtJQUNKLElBQUksSUFBSSxDQUFDakYsU0FBUyxFQUFFO1FBQ2hCLHlDQUF5QztRQUN6QyxNQUFNa0YsYUFBYSxFQUFFO1FBQ3JCLElBQUssSUFBSTdGLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNPLE1BQU0sQ0FBQ04sTUFBTSxFQUFFRCxJQUFLO1lBQ3pDLE1BQU1KLE9BQU8sSUFBSSxDQUFDVyxNQUFNLENBQUNQLEVBQUUsQ0FBQzhGLE9BQU87WUFDbkMsSUFBSWxHLEtBQUtLLE1BQU0sRUFBRTtnQkFDYjRGLFdBQVdsQixJQUFJLENBQUMvRSxJQUFJLENBQUMsRUFBRTtZQUMzQjtZQUNBLGdFQUFnRTtZQUNoRSxJQUFJQSxLQUFLSyxNQUFNLElBQUlmLGNBQWM2RyxhQUFhLENBQUNuRyxRQUFRLEdBQUc7Z0JBQ3RELElBQUksQ0FBQzBCLE1BQU0sQ0FBQyxJQUFJUSxNQUFNO2dCQUN0QixPQUFPLElBQUksQ0FBQ1gsT0FBTztZQUN2QjtRQUNKO1FBQ0EsSUFBSTBFLFdBQVc1RixNQUFNLEVBQUU7WUFDbkIyRixlQUFlbEcsdUJBQXVCLElBQUksQ0FBQ0MsS0FBSyxFQUFFa0c7WUFDbEQsSUFBSUQsZUFBZSxHQUFHO2dCQUNsQixJQUFJLENBQUN0RSxNQUFNLENBQUMsSUFBSVEsTUFBTTtnQkFDdEIsT0FBTyxJQUFJLENBQUNYLE9BQU87WUFDdkI7UUFDSixPQUNLO1lBQ0QscUNBQXFDO1lBQ3JDeUUsZUFBZSxLQUFNSyxNQUFNLEtBQUssUUFBUztRQUM3QztJQUNKO0lBQ0EsTUFBTTFFLFFBQVEsSUFBSTtJQUNsQjJFO0lBQ0EsT0FBTyxJQUFJLENBQUMvRSxPQUFPO0lBQ25CLFNBQVMrRTtRQUNMLElBQUlDLGVBQWdCNUUsTUFBTWpCLFlBQVksR0FBR2lCLE1BQU1oQixNQUFNLENBQUNOLE1BQU07UUFDNUQsSUFBSW1HO1FBQ0osSUFBSTdFLE1BQU1aLFNBQVMsRUFBRTtZQUNqQnlGLE9BQU87Z0JBQ0h2RyxNQUFNK0Y7Z0JBQ05qRyxPQUFPNEIsTUFBTTVCLEtBQUssQ0FBQzBHLGNBQWMsQ0FBQ0MsS0FBSyxDQUFDQyxHQUFHLENBQUNoRixNQUFNbUMsU0FBUyxDQUFDO1lBQ2hFO1FBQ0o7UUFDQSxJQUFJOEMsT0FBTztRQUNYLElBQUlDO1FBQ0osTUFBTUMsU0FBUztZQUNYckcsWUFBWTtZQUNac0csYUFBYXBGLE1BQU1aLFNBQVMsR0FBR3lGLE9BQU87Z0JBQUV6RyxPQUFPNEIsTUFBTTVCLEtBQUs7WUFBQztZQUMzRGlILE9BQU1DLFFBQVE7Z0JBQ1YsSUFBSSxPQUFPQSxhQUFhLFVBQVU7b0JBQzlCLElBQUksQ0FBQ0osU0FBUzt3QkFDVkEsVUFBVSxFQUFFO29CQUNoQjtvQkFDQSxJQUFJRCxNQUFNO3dCQUNOQyxRQUFROUIsSUFBSSxDQUFDbUMsT0FBT0MsSUFBSSxDQUFDUCxNQUFNO3dCQUMvQkEsT0FBTztvQkFDWDtvQkFDQUMsUUFBUTlCLElBQUksQ0FBQ2tDO2dCQUNqQixPQUNLO29CQUNETCxRQUFRSztnQkFDWjtnQkFDQSxJQUFJLENBQUMsRUFBRVYsY0FBYztvQkFDakIsSUFBSU0sU0FBUzt3QkFDVCxJQUFJRCxNQUFNOzRCQUNOQyxRQUFROUIsSUFBSSxDQUFDbUMsT0FBT0MsSUFBSSxDQUFDUCxNQUFNO3dCQUNuQzt3QkFDQUUsT0FBT0MsV0FBVyxDQUFDaEgsS0FBSyxDQUFDK0csTUFBTSxDQUFDRSxLQUFLLENBQUNFLE9BQU9FLE1BQU0sQ0FBQ1A7b0JBQ3hELE9BQ0s7d0JBQ0RDLE9BQU9DLFdBQVcsQ0FBQ2hILEtBQUssQ0FBQytHLE1BQU0sQ0FBQ0UsS0FBSyxDQUFDSjtvQkFDMUM7b0JBQ0EsbUNBQW1DO29CQUNuQ0wsZUFBZTVFLE1BQU1oQixNQUFNLENBQUNOLE1BQU07b0JBQ2xDdUcsT0FBTztvQkFDUEMsVUFBVVE7Z0JBQ2Q7WUFDSjtRQUNKO1FBQ0EsSUFBSyxJQUFJakgsSUFBSSxHQUFHQSxJQUFJdUIsTUFBTWhCLE1BQU0sQ0FBQ04sTUFBTSxFQUFFLEVBQUVELEVBQUc7WUFDMUN1QixNQUFNNUIsS0FBSyxDQUFDcUQsV0FBVyxDQUFDekIsTUFBTWhCLE1BQU0sQ0FBQ1AsRUFBRSxFQUFFMEcsUUFBUU47UUFDckQ7UUFDQSxPQUFPN0UsTUFBTUosT0FBTztJQUN4QjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvUGlwZWxpbmUuanM/MDQ1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNhbGN1bGF0ZVNsb3QgPSByZXF1aXJlKFwiY2x1c3Rlci1rZXktc2xvdFwiKTtcbmNvbnN0IGNvbW1hbmRzXzEgPSByZXF1aXJlKFwiQGlvcmVkaXMvY29tbWFuZHNcIik7XG5jb25zdCBzdGFuZGFyZF9hc19jYWxsYmFja18xID0gcmVxdWlyZShcInN0YW5kYXJkLWFzLWNhbGxiYWNrXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcInV0aWxcIik7XG5jb25zdCBDb21tYW5kXzEgPSByZXF1aXJlKFwiLi9Db21tYW5kXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgQ29tbWFuZGVyXzEgPSByZXF1aXJlKFwiLi91dGlscy9Db21tYW5kZXJcIik7XG4vKlxuICBUaGlzIGZ1bmN0aW9uIGRlcml2ZXMgZnJvbSB0aGUgY2x1c3Rlci1rZXktc2xvdCBpbXBsZW1lbnRhdGlvbi5cbiAgSW5zdGVhZCBvZiBjaGVja2luZyB0aGF0IGFsbCBrZXlzIGhhdmUgdGhlIHNhbWUgc2xvdCwgaXQgY2hlY2tzIHRoYXQgYWxsIHNsb3RzIGFyZSBzZXJ2ZWQgYnkgdGhlIHNhbWUgc2V0IG9mIG5vZGVzLlxuICBJZiB0aGlzIGlzIHNhdGlzZmllZCwgaXQgcmV0dXJucyB0aGUgZmlyc3Qga2V5J3Mgc2xvdC5cbiovXG5mdW5jdGlvbiBnZW5lcmF0ZU11bHRpV2l0aE5vZGVzKHJlZGlzLCBrZXlzKSB7XG4gICAgY29uc3Qgc2xvdCA9IGNhbGN1bGF0ZVNsb3Qoa2V5c1swXSk7XG4gICAgY29uc3QgdGFyZ2V0ID0gcmVkaXMuX2dyb3Vwc0J5U2xvdFtzbG90XTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJlZGlzLl9ncm91cHNCeVNsb3RbY2FsY3VsYXRlU2xvdChrZXlzW2ldKV0gIT09IHRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzbG90O1xufVxuY2xhc3MgUGlwZWxpbmUgZXh0ZW5kcyBDb21tYW5kZXJfMS5kZWZhdWx0IHtcbiAgICBjb25zdHJ1Y3RvcihyZWRpcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJlZGlzID0gcmVkaXM7XG4gICAgICAgIHRoaXMuaXNQaXBlbGluZSA9IHRydWU7XG4gICAgICAgIHRoaXMucmVwbHlQZW5kaW5nID0gMDtcbiAgICAgICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5fcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9ucyA9IDA7XG4gICAgICAgIHRoaXMuX3NoYVRvU2NyaXB0ID0ge307XG4gICAgICAgIHRoaXMuaXNDbHVzdGVyID1cbiAgICAgICAgICAgIHRoaXMucmVkaXMuY29uc3RydWN0b3IubmFtZSA9PT0gXCJDbHVzdGVyXCIgfHwgdGhpcy5yZWRpcy5pc0NsdXN0ZXI7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHJlZGlzLm9wdGlvbnM7XG4gICAgICAgIE9iamVjdC5rZXlzKHJlZGlzLnNjcmlwdHNTZXQpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjcmlwdCA9IHJlZGlzLnNjcmlwdHNTZXRbbmFtZV07XG4gICAgICAgICAgICB0aGlzLl9zaGFUb1NjcmlwdFtzY3JpcHQuc2hhXSA9IHNjcmlwdDtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSByZWRpc1tuYW1lXTtcbiAgICAgICAgICAgIHRoaXNbbmFtZSArIFwiQnVmZmVyXCJdID0gcmVkaXNbbmFtZSArIFwiQnVmZmVyXCJdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVkaXMuYWRkZWRCdWlsdGluU2V0LmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSByZWRpc1tuYW1lXTtcbiAgICAgICAgICAgIHRoaXNbbmFtZSArIFwiQnVmZmVyXCJdID0gcmVkaXNbbmFtZSArIFwiQnVmZmVyXCJdO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsZW5ndGhcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9xdWV1ZS5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZmlsbFJlc3VsdCh2YWx1ZSwgcG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuX3F1ZXVlW3Bvc2l0aW9uXS5uYW1lID09PSBcImV4ZWNcIiAmJiBBcnJheS5pc0FycmF5KHZhbHVlWzFdKSkge1xuICAgICAgICAgICAgY29uc3QgZXhlY0xlbmd0aCA9IHZhbHVlWzFdLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhlY0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlWzFdW2ldIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNtZCA9IHRoaXMuX3F1ZXVlW3Bvc2l0aW9uIC0gKGV4ZWNMZW5ndGggLSBpKV07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbMV1baV0gPSBjbWQudHJhbnNmb3JtUmVwbHkodmFsdWVbMV1baV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlWzFdW2ldID0gZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXN1bHRbcG9zaXRpb25dID0gdmFsdWU7XG4gICAgICAgIGlmICgtLXRoaXMucmVwbHlQZW5kaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNDbHVzdGVyKSB7XG4gICAgICAgICAgICBsZXQgcmV0cmlhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBjb21tb25FcnJvcjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9yZXN1bHRbaV1bMF07XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWFuZCA9IHRoaXMuX3F1ZXVlW2ldO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWFuZC5uYW1lID09PSBcImV4ZWNcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkVYRUNBQk9SVCBUcmFuc2FjdGlvbiBkaXNjYXJkZWQgYmVjYXVzZSBvZiBwcmV2aW91cyBlcnJvcnMuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tbW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1vbkVycm9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGVycm9yLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29tbW9uRXJyb3IubmFtZSAhPT0gZXJyb3IubmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbW9uRXJyb3IubWVzc2FnZSAhPT0gZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cmlhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY29tbWFuZC5pblRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVhZE9ubHkgPSAoMCwgY29tbWFuZHNfMS5leGlzdHMpKGNvbW1hbmQubmFtZSkgJiYgKDAsIGNvbW1hbmRzXzEuaGFzRmxhZykoY29tbWFuZC5uYW1lLCBcInJlYWRvbmx5XCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHJpYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tbW9uRXJyb3IgJiYgcmV0cmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycnYgPSBjb21tb25FcnJvci5tZXNzYWdlLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgICAgICAgICAgICAgIGxldCBpblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJ2WzBdID09PSBcIkFTS1wiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhaW5UcmFuc2FjdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVbaV0ubmFtZSAhPT0gXCJhc2tpbmdcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFxdWV1ZVtpIC0gMV0gfHwgcXVldWVbaSAtIDFdLm5hbWUgIT09IFwiYXNraW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhc2tpbmcgPSBuZXcgQ29tbWFuZF8xLmRlZmF1bHQoXCJhc2tpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc2tpbmcuaWdub3JlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZENvbW1hbmQoYXNraW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVtpXS5pbml0UHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRDb21tYW5kKHF1ZXVlW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaW5UcmFuc2FjdGlvbiA9IHF1ZXVlW2ldLmluVHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMubGVmdFJlZGlyZWN0aW9ucyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZnRSZWRpcmVjdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZXhlYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXhlYygpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgY2x1c3RlciA9IHRoaXMucmVkaXM7XG4gICAgICAgICAgICAgICAgY2x1c3Rlci5oYW5kbGVFcnJvcihjb21tb25FcnJvciwgdGhpcy5sZWZ0UmVkaXJlY3Rpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVkOiBmdW5jdGlvbiAoX3Nsb3QsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJlZmVyS2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2x1c3Rlci5zbG90c1tlcnJ2WzFdXSA9IFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2x1c3Rlci5fZ3JvdXBzQnlTbG90W2VycnZbMV1dID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHVzdGVyLl9ncm91cHNJZHNbY2x1c3Rlci5zbG90c1tlcnJ2WzFdXS5qb2luKFwiO1wiKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjbHVzdGVyLnJlZnJlc2hTbG90c0NhY2hlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5leGVjKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFzazogZnVuY3Rpb24gKF9zbG90LCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnByZWZlcktleSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmV4ZWMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdHJ5YWdhaW46IGV4ZWMsXG4gICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJEb3duOiBleGVjLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uQ2xvc2VkOiBleGVjLFxuICAgICAgICAgICAgICAgICAgICBtYXhSZWRpcmVjdGlvbnM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdHM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBpZ25vcmVkQ291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3F1ZXVlLmxlbmd0aCAtIGlnbm9yZWRDb3VudDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcXVldWVbaSArIGlnbm9yZWRDb3VudF0uaWdub3JlKSB7XG4gICAgICAgICAgICAgICAgaWdub3JlZENvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSB0aGlzLl9yZXN1bHRbaSArIGlnbm9yZWRDb3VudF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNvbHZlKHRoaXMuX3Jlc3VsdC5zbGljZSgwLCB0aGlzLl9yZXN1bHQubGVuZ3RoIC0gaWdub3JlZENvdW50KSk7XG4gICAgfVxuICAgIHNlbmRDb21tYW5kKGNvbW1hbmQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9ucyA+IDApIHtcbiAgICAgICAgICAgIGNvbW1hbmQuaW5UcmFuc2FjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLl9xdWV1ZS5sZW5ndGg7XG4gICAgICAgIGNvbW1hbmQucGlwZWxpbmVJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICBjb21tYW5kLnByb21pc2VcbiAgICAgICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZmlsbFJlc3VsdChbbnVsbCwgcmVzdWx0XSwgcG9zaXRpb24pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5maWxsUmVzdWx0KFtlcnJvcl0sIHBvc2l0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnB1c2goY29tbWFuZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGRCYXRjaChjb21tYW5kcykge1xuICAgICAgICBsZXQgY29tbWFuZCwgY29tbWFuZE5hbWUsIGFyZ3M7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbW1hbmQgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgICAgIGNvbW1hbmROYW1lID0gY29tbWFuZFswXTtcbiAgICAgICAgICAgIGFyZ3MgPSBjb21tYW5kLnNsaWNlKDEpO1xuICAgICAgICAgICAgdGhpc1tjb21tYW5kTmFtZV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUGlwZWxpbmU7XG4vLyBAdHMtZXhwZWN0LWVycm9yXG5jb25zdCBtdWx0aSA9IFBpcGVsaW5lLnByb3RvdHlwZS5tdWx0aTtcbi8vIEB0cy1leHBlY3QtZXJyb3JcblBpcGVsaW5lLnByb3RvdHlwZS5tdWx0aSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl90cmFuc2FjdGlvbnMgKz0gMTtcbiAgICByZXR1cm4gbXVsdGkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG4vLyBAdHMtZXhwZWN0LWVycm9yXG5jb25zdCBleGVjQnVmZmVyID0gUGlwZWxpbmUucHJvdG90eXBlLmV4ZWNCdWZmZXI7XG4vLyBAdHMtZXhwZWN0LWVycm9yXG5QaXBlbGluZS5wcm90b3R5cGUuZXhlY0J1ZmZlciA9ICgwLCB1dGlsXzEuZGVwcmVjYXRlKShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9ucyA+IDApIHtcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb25zIC09IDE7XG4gICAgfVxuICAgIHJldHVybiBleGVjQnVmZmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59LCBcIlBpcGVsaW5lI2V4ZWNCdWZmZXI6IFVzZSBQaXBlbGluZSNleGVjIGluc3RlYWRcIik7XG4vLyBOT1RFOiBUbyBhdm9pZCBhbiB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24sIHRoaXMgd2lsbCB1bmNvbmRpdGlvbmFsbHkgYWx3YXlzIHJldHVybiB0aGlzLnByb21pc2UsXG4vLyB3aGljaCBhbHdheXMgaGFzIHRoZSByZWplY3Rpb24gaGFuZGxlZCBieSBzdGFuZGFyZC1hcy1jYWxsYmFja1xuLy8gYWRkaW5nIHRoZSBwcm92aWRlZCByZWplY3Rpb24gY2FsbGJhY2suXG4vL1xuLy8gSWYgYSBkaWZmZXJlbnQgcHJvbWlzZSBpbnN0YW5jZSB3ZXJlIHJldHVybmVkLCB0aGF0IHByb21pc2Ugd291bGQgY2F1c2UgaXRzIG93biB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb25cbi8vIGVycm9ycywgZXZlbiBpZiB0aGF0IHByb21pc2UgdW5jb25kaXRpb25hbGx5IHJlc29sdmVkIHRvICoqdGhlIHJlc29sdmVkIHZhbHVlIG9mKiogdGhpcy5wcm9taXNlLlxuUGlwZWxpbmUucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAvLyBXYWl0IGZvciB0aGUgY2x1c3RlciB0byBiZSBjb25uZWN0ZWQsIHNpbmNlIHdlIG5lZWQgbm9kZXMgaW5mb3JtYXRpb24gYmVmb3JlIGNvbnRpbnVpbmdcbiAgICBpZiAodGhpcy5pc0NsdXN0ZXIgJiYgIXRoaXMucmVkaXMuc2xvdHMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZGlzLnN0YXR1cyA9PT0gXCJ3YWl0XCIpXG4gICAgICAgICAgICB0aGlzLnJlZGlzLmNvbm5lY3QoKS5jYXRjaCh1dGlsc18xLm5vb3ApO1xuICAgICAgICBpZiAoY2FsbGJhY2sgJiYgIXRoaXMubm9kZWlmaWVkUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy5ub2RlaWZpZWRQcm9taXNlID0gdHJ1ZTtcbiAgICAgICAgICAgICgwLCBzdGFuZGFyZF9hc19jYWxsYmFja18xLmRlZmF1bHQpKHRoaXMucHJvbWlzZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVkaXMuZGVsYXlVbnRpbFJlYWR5KChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXhlYyhjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb25zID4gMCkge1xuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbnMgLT0gMTtcbiAgICAgICAgcmV0dXJuIGV4ZWNCdWZmZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm5vZGVpZmllZFByb21pc2UpIHtcbiAgICAgICAgdGhpcy5ub2RlaWZpZWRQcm9taXNlID0gdHJ1ZTtcbiAgICAgICAgKDAsIHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEuZGVmYXVsdCkodGhpcy5wcm9taXNlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZShbXSk7XG4gICAgfVxuICAgIGxldCBwaXBlbGluZVNsb3Q7XG4gICAgaWYgKHRoaXMuaXNDbHVzdGVyKSB7XG4gICAgICAgIC8vIExpc3Qgb2YgdGhlIGZpcnN0IGtleSBmb3IgZWFjaCBjb21tYW5kXG4gICAgICAgIGNvbnN0IHNhbXBsZUtleXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9xdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMuX3F1ZXVlW2ldLmdldEtleXMoKTtcbiAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNhbXBsZUtleXMucHVzaChrZXlzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZvciBlYWNoIGNvbW1hbmQsIGNoZWNrIHRoYXQgdGhlIGtleXMgYmVsb25nIHRvIHRoZSBzYW1lIHNsb3RcbiAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCAmJiBjYWxjdWxhdGVTbG90LmdlbmVyYXRlTXVsdGkoa2V5cykgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3QobmV3IEVycm9yKFwiQWxsIHRoZSBrZXlzIGluIGEgcGlwZWxpbmUgY29tbWFuZCBzaG91bGQgYmVsb25nIHRvIHRoZSBzYW1lIHNsb3RcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNhbXBsZUtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwaXBlbGluZVNsb3QgPSBnZW5lcmF0ZU11bHRpV2l0aE5vZGVzKHRoaXMucmVkaXMsIHNhbXBsZUtleXMpO1xuICAgICAgICAgICAgaWYgKHBpcGVsaW5lU2xvdCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChuZXcgRXJyb3IoXCJBbGwga2V5cyBpbiB0aGUgcGlwZWxpbmUgc2hvdWxkIGJlbG9uZyB0byB0aGUgc2FtZSBzbG90cyBhbGxvY2F0aW9uIGdyb3VwXCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU2VuZCB0aGUgcGlwZWxpbmUgdG8gYSByYW5kb20gbm9kZVxuICAgICAgICAgICAgcGlwZWxpbmVTbG90ID0gKE1hdGgucmFuZG9tKCkgKiAxNjM4NCkgfCAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICBleGVjUGlwZWxpbmUoKTtcbiAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICAgIGZ1bmN0aW9uIGV4ZWNQaXBlbGluZSgpIHtcbiAgICAgICAgbGV0IHdyaXRlUGVuZGluZyA9IChfdGhpcy5yZXBseVBlbmRpbmcgPSBfdGhpcy5fcXVldWUubGVuZ3RoKTtcbiAgICAgICAgbGV0IG5vZGU7XG4gICAgICAgIGlmIChfdGhpcy5pc0NsdXN0ZXIpIHtcbiAgICAgICAgICAgIG5vZGUgPSB7XG4gICAgICAgICAgICAgICAgc2xvdDogcGlwZWxpbmVTbG90LFxuICAgICAgICAgICAgICAgIHJlZGlzOiBfdGhpcy5yZWRpcy5jb25uZWN0aW9uUG9vbC5ub2Rlcy5hbGxbX3RoaXMucHJlZmVyS2V5XSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGEgPSBcIlwiO1xuICAgICAgICBsZXQgYnVmZmVycztcbiAgICAgICAgY29uc3Qgc3RyZWFtID0ge1xuICAgICAgICAgICAgaXNQaXBlbGluZTogdHJ1ZSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBfdGhpcy5pc0NsdXN0ZXIgPyBub2RlIDogeyByZWRpczogX3RoaXMucmVkaXMgfSxcbiAgICAgICAgICAgIHdyaXRlKHdyaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3cml0YWJsZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJ1ZmZlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVycy5wdXNoKEJ1ZmZlci5mcm9tKGRhdGEsIFwidXRmOFwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2god3JpdGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSArPSB3cml0YWJsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEtLXdyaXRlUGVuZGluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2goQnVmZmVyLmZyb20oZGF0YSwgXCJ1dGY4XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5kZXN0aW5hdGlvbi5yZWRpcy5zdHJlYW0ud3JpdGUoQnVmZmVyLmNvbmNhdChidWZmZXJzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZGVzdGluYXRpb24ucmVkaXMuc3RyZWFtLndyaXRlKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHdyaXRlUGVuZGluZyBmb3IgcmVzZW5kaW5nXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlUGVuZGluZyA9IF90aGlzLl9xdWV1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgX3RoaXMuX3F1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBfdGhpcy5yZWRpcy5zZW5kQ29tbWFuZChfdGhpcy5fcXVldWVbaV0sIHN0cmVhbSwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzLnByb21pc2U7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNhbGN1bGF0ZVNsb3QiLCJyZXF1aXJlIiwiY29tbWFuZHNfMSIsInN0YW5kYXJkX2FzX2NhbGxiYWNrXzEiLCJ1dGlsXzEiLCJDb21tYW5kXzEiLCJ1dGlsc18xIiwiQ29tbWFuZGVyXzEiLCJnZW5lcmF0ZU11bHRpV2l0aE5vZGVzIiwicmVkaXMiLCJrZXlzIiwic2xvdCIsInRhcmdldCIsIl9ncm91cHNCeVNsb3QiLCJpIiwibGVuZ3RoIiwiUGlwZWxpbmUiLCJkZWZhdWx0IiwiY29uc3RydWN0b3IiLCJpc1BpcGVsaW5lIiwicmVwbHlQZW5kaW5nIiwiX3F1ZXVlIiwiX3Jlc3VsdCIsIl90cmFuc2FjdGlvbnMiLCJfc2hhVG9TY3JpcHQiLCJpc0NsdXN0ZXIiLCJuYW1lIiwib3B0aW9ucyIsInNjcmlwdHNTZXQiLCJmb3JFYWNoIiwic2NyaXB0Iiwic2hhIiwiYWRkZWRCdWlsdGluU2V0IiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiX3RoaXMiLCJnZXQiLCJmaWxsUmVzdWx0IiwicG9zaXRpb24iLCJBcnJheSIsImlzQXJyYXkiLCJleGVjTGVuZ3RoIiwiRXJyb3IiLCJjbWQiLCJ0cmFuc2Zvcm1SZXBseSIsImVyciIsInJldHJpYWJsZSIsImNvbW1vbkVycm9yIiwiZXJyb3IiLCJjb21tYW5kIiwibWVzc2FnZSIsImluVHJhbnNhY3Rpb24iLCJpc1JlYWRPbmx5IiwiZXhpc3RzIiwiaGFzRmxhZyIsImVycnYiLCJzcGxpdCIsInF1ZXVlIiwiYXNraW5nIiwiaWdub3JlIiwic2VuZENvbW1hbmQiLCJpbml0UHJvbWlzZSIsIm1hdGNoZWQiLCJsZWZ0UmVkaXJlY3Rpb25zIiwiZXhlYyIsImNsdXN0ZXIiLCJoYW5kbGVFcnJvciIsIm1vdmVkIiwiX3Nsb3QiLCJrZXkiLCJwcmVmZXJLZXkiLCJzbG90cyIsIl9ncm91cHNJZHMiLCJqb2luIiwicmVmcmVzaFNsb3RzQ2FjaGUiLCJhc2siLCJ0cnlhZ2FpbiIsImNsdXN0ZXJEb3duIiwiY29ubmVjdGlvbkNsb3NlZCIsIm1heFJlZGlyZWN0aW9ucyIsImRlZmF1bHRzIiwiaWdub3JlZENvdW50Iiwic2xpY2UiLCJwaXBlbGluZUluZGV4IiwidGhlbiIsInJlc3VsdCIsImNhdGNoIiwicHVzaCIsImFkZEJhdGNoIiwiY29tbWFuZHMiLCJjb21tYW5kTmFtZSIsImFyZ3MiLCJhcHBseSIsIm11bHRpIiwicHJvdG90eXBlIiwiYXJndW1lbnRzIiwiZXhlY0J1ZmZlciIsImRlcHJlY2F0ZSIsImNhbGxiYWNrIiwic3RhdHVzIiwiY29ubmVjdCIsIm5vb3AiLCJub2RlaWZpZWRQcm9taXNlIiwiZGVsYXlVbnRpbFJlYWR5IiwicGlwZWxpbmVTbG90Iiwic2FtcGxlS2V5cyIsImdldEtleXMiLCJnZW5lcmF0ZU11bHRpIiwiTWF0aCIsInJhbmRvbSIsImV4ZWNQaXBlbGluZSIsIndyaXRlUGVuZGluZyIsIm5vZGUiLCJjb25uZWN0aW9uUG9vbCIsIm5vZGVzIiwiYWxsIiwiZGF0YSIsImJ1ZmZlcnMiLCJzdHJlYW0iLCJkZXN0aW5hdGlvbiIsIndyaXRlIiwid3JpdGFibGUiLCJCdWZmZXIiLCJmcm9tIiwiY29uY2F0IiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/Pipeline.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/Redis.js":
/*!*********************************************!*\
  !*** ./node_modules/ioredis/built/Redis.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst commands_1 = __webpack_require__(/*! @ioredis/commands */ \"(rsc)/./node_modules/@ioredis/commands/built/index.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/./node_modules/standard-as-callback/built/index.js\");\nconst cluster_1 = __webpack_require__(/*! ./cluster */ \"(rsc)/./node_modules/ioredis/built/cluster/index.js\");\nconst Command_1 = __webpack_require__(/*! ./Command */ \"(rsc)/./node_modules/ioredis/built/Command.js\");\nconst connectors_1 = __webpack_require__(/*! ./connectors */ \"(rsc)/./node_modules/ioredis/built/connectors/index.js\");\nconst SentinelConnector_1 = __webpack_require__(/*! ./connectors/SentinelConnector */ \"(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/index.js\");\nconst eventHandler = __webpack_require__(/*! ./redis/event_handler */ \"(rsc)/./node_modules/ioredis/built/redis/event_handler.js\");\nconst RedisOptions_1 = __webpack_require__(/*! ./redis/RedisOptions */ \"(rsc)/./node_modules/ioredis/built/redis/RedisOptions.js\");\nconst ScanStream_1 = __webpack_require__(/*! ./ScanStream */ \"(rsc)/./node_modules/ioredis/built/ScanStream.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(rsc)/./node_modules/ioredis/built/transaction.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst applyMixin_1 = __webpack_require__(/*! ./utils/applyMixin */ \"(rsc)/./node_modules/ioredis/built/utils/applyMixin.js\");\nconst Commander_1 = __webpack_require__(/*! ./utils/Commander */ \"(rsc)/./node_modules/ioredis/built/utils/Commander.js\");\nconst lodash_1 = __webpack_require__(/*! ./utils/lodash */ \"(rsc)/./node_modules/ioredis/built/utils/lodash.js\");\nconst Deque = __webpack_require__(/*! denque */ \"(rsc)/./node_modules/denque/index.js\");\nconst debug = (0, utils_1.Debug)(\"redis\");\n/**\n * This is the major component of ioredis.\n * Use it to connect to a standalone Redis server or Sentinels.\n *\n * ```typescript\n * const redis = new Redis(); // Default port is 6379\n * async function main() {\n *   redis.set(\"foo\", \"bar\");\n *   redis.get(\"foo\", (err, result) => {\n *     // `result` should be \"bar\"\n *     console.log(err, result);\n *   });\n *   // Or use Promise\n *   const result = await redis.get(\"foo\");\n * }\n * ```\n */ class Redis extends Commander_1.default {\n    constructor(arg1, arg2, arg3){\n        super();\n        this.status = \"wait\";\n        /**\n         * @ignore\n         */ this.isCluster = false;\n        this.reconnectTimeout = null;\n        this.connectionEpoch = 0;\n        this.retryAttempts = 0;\n        this.manuallyClosing = false;\n        // Prepare autopipelines structures\n        this._autoPipelines = new Map();\n        this._runningAutoPipelines = new Set();\n        this.parseOptions(arg1, arg2, arg3);\n        events_1.EventEmitter.call(this);\n        this.resetCommandQueue();\n        this.resetOfflineQueue();\n        if (this.options.Connector) {\n            this.connector = new this.options.Connector(this.options);\n        } else if (this.options.sentinels) {\n            const sentinelConnector = new SentinelConnector_1.default(this.options);\n            sentinelConnector.emitter = this;\n            this.connector = sentinelConnector;\n        } else {\n            this.connector = new connectors_1.StandaloneConnector(this.options);\n        }\n        if (this.options.scripts) {\n            Object.entries(this.options.scripts).forEach(([name, definition])=>{\n                this.defineCommand(name, definition);\n            });\n        }\n        // end(or wait) -> connecting -> connect -> ready -> end\n        if (this.options.lazyConnect) {\n            this.setStatus(\"wait\");\n        } else {\n            this.connect().catch(lodash_1.noop);\n        }\n    }\n    /**\n     * Create a Redis instance.\n     * This is the same as `new Redis()` but is included for compatibility with node-redis.\n     */ static createClient(...args) {\n        return new Redis(...args);\n    }\n    get autoPipelineQueueSize() {\n        let queued = 0;\n        for (const pipeline of this._autoPipelines.values()){\n            queued += pipeline.length;\n        }\n        return queued;\n    }\n    /**\n     * Create a connection to Redis.\n     * This method will be invoked automatically when creating a new Redis instance\n     * unless `lazyConnect: true` is passed.\n     *\n     * When calling this method manually, a Promise is returned, which will\n     * be resolved when the connection status is ready.\n     */ connect(callback) {\n        const promise = new Promise((resolve, reject)=>{\n            if (this.status === \"connecting\" || this.status === \"connect\" || this.status === \"ready\") {\n                reject(new Error(\"Redis is already connecting/connected\"));\n                return;\n            }\n            this.connectionEpoch += 1;\n            this.setStatus(\"connecting\");\n            const { options } = this;\n            this.condition = {\n                select: options.db,\n                auth: options.username ? [\n                    options.username,\n                    options.password\n                ] : options.password,\n                subscriber: false\n            };\n            const _this = this;\n            (0, standard_as_callback_1.default)(this.connector.connect(function(type, err) {\n                _this.silentEmit(type, err);\n            }), function(err, stream) {\n                if (err) {\n                    _this.flushQueue(err);\n                    _this.silentEmit(\"error\", err);\n                    reject(err);\n                    _this.setStatus(\"end\");\n                    return;\n                }\n                let CONNECT_EVENT = options.tls ? \"secureConnect\" : \"connect\";\n                if (\"sentinels\" in options && options.sentinels && !options.enableTLSForSentinelMode) {\n                    CONNECT_EVENT = \"connect\";\n                }\n                _this.stream = stream;\n                if (options.noDelay) {\n                    stream.setNoDelay(true);\n                }\n                // Node ignores setKeepAlive before connect, therefore we wait for the event:\n                // https://github.com/nodejs/node/issues/31663\n                if (typeof options.keepAlive === \"number\") {\n                    if (stream.connecting) {\n                        stream.once(CONNECT_EVENT, ()=>{\n                            stream.setKeepAlive(true, options.keepAlive);\n                        });\n                    } else {\n                        stream.setKeepAlive(true, options.keepAlive);\n                    }\n                }\n                if (stream.connecting) {\n                    stream.once(CONNECT_EVENT, eventHandler.connectHandler(_this));\n                    if (options.connectTimeout) {\n                        /*\n                         * Typically, Socket#setTimeout(0) will clear the timer\n                         * set before. However, in some platforms (Electron 3.x~4.x),\n                         * the timer will not be cleared. So we introduce a variable here.\n                         *\n                         * See https://github.com/electron/electron/issues/14915\n                         */ let connectTimeoutCleared = false;\n                        stream.setTimeout(options.connectTimeout, function() {\n                            if (connectTimeoutCleared) {\n                                return;\n                            }\n                            stream.setTimeout(0);\n                            stream.destroy();\n                            const err = new Error(\"connect ETIMEDOUT\");\n                            // @ts-expect-error\n                            err.errorno = \"ETIMEDOUT\";\n                            // @ts-expect-error\n                            err.code = \"ETIMEDOUT\";\n                            // @ts-expect-error\n                            err.syscall = \"connect\";\n                            eventHandler.errorHandler(_this)(err);\n                        });\n                        stream.once(CONNECT_EVENT, function() {\n                            connectTimeoutCleared = true;\n                            stream.setTimeout(0);\n                        });\n                    }\n                } else if (stream.destroyed) {\n                    const firstError = _this.connector.firstError;\n                    if (firstError) {\n                        process.nextTick(()=>{\n                            eventHandler.errorHandler(_this)(firstError);\n                        });\n                    }\n                    process.nextTick(eventHandler.closeHandler(_this));\n                } else {\n                    process.nextTick(eventHandler.connectHandler(_this));\n                }\n                if (!stream.destroyed) {\n                    stream.once(\"error\", eventHandler.errorHandler(_this));\n                    stream.once(\"close\", eventHandler.closeHandler(_this));\n                }\n                const connectionReadyHandler = function() {\n                    _this.removeListener(\"close\", connectionCloseHandler);\n                    resolve();\n                };\n                var connectionCloseHandler = function() {\n                    _this.removeListener(\"ready\", connectionReadyHandler);\n                    reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n                };\n                _this.once(\"ready\", connectionReadyHandler);\n                _this.once(\"close\", connectionCloseHandler);\n            });\n        });\n        return (0, standard_as_callback_1.default)(promise, callback);\n    }\n    /**\n     * Disconnect from Redis.\n     *\n     * This method closes the connection immediately,\n     * and may lose some pending replies that haven't written to client.\n     * If you want to wait for the pending replies, use Redis#quit instead.\n     */ disconnect(reconnect = false) {\n        if (!reconnect) {\n            this.manuallyClosing = true;\n        }\n        if (this.reconnectTimeout && !reconnect) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n        }\n        if (this.status === \"wait\") {\n            eventHandler.closeHandler(this)();\n        } else {\n            this.connector.disconnect();\n        }\n    }\n    /**\n     * Disconnect from Redis.\n     *\n     * @deprecated\n     */ end() {\n        this.disconnect();\n    }\n    /**\n     * Create a new instance with the same options as the current one.\n     *\n     * @example\n     * ```js\n     * var redis = new Redis(6380);\n     * var anotherRedis = redis.duplicate();\n     * ```\n     */ duplicate(override) {\n        return new Redis({\n            ...this.options,\n            ...override\n        });\n    }\n    /**\n     * Mode of the connection.\n     *\n     * One of `\"normal\"`, `\"subscriber\"`, or `\"monitor\"`. When the connection is\n     * not in `\"normal\"` mode, certain commands are not allowed.\n     */ get mode() {\n        var _a;\n        return this.options.monitor ? \"monitor\" : ((_a = this.condition) === null || _a === void 0 ? void 0 : _a.subscriber) ? \"subscriber\" : \"normal\";\n    }\n    /**\n     * Listen for all requests received by the server in real time.\n     *\n     * This command will create a new connection to Redis and send a\n     * MONITOR command via the new connection in order to avoid disturbing\n     * the current connection.\n     *\n     * @param callback The callback function. If omit, a promise will be returned.\n     * @example\n     * ```js\n     * var redis = new Redis();\n     * redis.monitor(function (err, monitor) {\n     *   // Entering monitoring mode.\n     *   monitor.on('monitor', function (time, args, source, database) {\n     *     console.log(time + \": \" + util.inspect(args));\n     *   });\n     * });\n     *\n     * // supports promise as well as other commands\n     * redis.monitor().then(function (monitor) {\n     *   monitor.on('monitor', function (time, args, source, database) {\n     *     console.log(time + \": \" + util.inspect(args));\n     *   });\n     * });\n     * ```\n     */ monitor(callback) {\n        const monitorInstance = this.duplicate({\n            monitor: true,\n            lazyConnect: false\n        });\n        return (0, standard_as_callback_1.default)(new Promise(function(resolve, reject) {\n            monitorInstance.once(\"error\", reject);\n            monitorInstance.once(\"monitoring\", function() {\n                resolve(monitorInstance);\n            });\n        }), callback);\n    }\n    /**\n     * Send a command to Redis\n     *\n     * This method is used internally and in most cases you should not\n     * use it directly. If you need to send a command that is not supported\n     * by the library, you can use the `call` method:\n     *\n     * ```js\n     * const redis = new Redis();\n     *\n     * redis.call('set', 'foo', 'bar');\n     * // or\n     * redis.call(['set', 'foo', 'bar']);\n     * ```\n     *\n     * @ignore\n     */ sendCommand(command, stream) {\n        var _a, _b;\n        if (this.status === \"wait\") {\n            this.connect().catch(lodash_1.noop);\n        }\n        if (this.status === \"end\") {\n            command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n            return command.promise;\n        }\n        if (((_a = this.condition) === null || _a === void 0 ? void 0 : _a.subscriber) && !Command_1.default.checkFlag(\"VALID_IN_SUBSCRIBER_MODE\", command.name)) {\n            command.reject(new Error(\"Connection in subscriber mode, only subscriber commands may be used\"));\n            return command.promise;\n        }\n        if (typeof this.options.commandTimeout === \"number\") {\n            command.setTimeout(this.options.commandTimeout);\n        }\n        let writable = this.status === \"ready\" || !stream && this.status === \"connect\" && (0, commands_1.exists)(command.name) && (0, commands_1.hasFlag)(command.name, \"loading\");\n        if (!this.stream) {\n            writable = false;\n        } else if (!this.stream.writable) {\n            writable = false;\n        // @ts-expect-error\n        } else if (this.stream._writableState && this.stream._writableState.ended) {\n            // TODO: We should be able to remove this as the PR has already been merged.\n            // https://github.com/iojs/io.js/pull/1217\n            writable = false;\n        }\n        if (!writable) {\n            if (!this.options.enableOfflineQueue) {\n                command.reject(new Error(\"Stream isn't writeable and enableOfflineQueue options is false\"));\n                return command.promise;\n            }\n            if (command.name === \"quit\" && this.offlineQueue.length === 0) {\n                this.disconnect();\n                command.resolve(Buffer.from(\"OK\"));\n                return command.promise;\n            }\n            // @ts-expect-error\n            if (debug.enabled) {\n                debug(\"queue command[%s]: %d -> %s(%o)\", this._getDescription(), this.condition.select, command.name, command.args);\n            }\n            this.offlineQueue.push({\n                command: command,\n                stream: stream,\n                select: this.condition.select\n            });\n        } else {\n            // @ts-expect-error\n            if (debug.enabled) {\n                debug(\"write command[%s]: %d -> %s(%o)\", this._getDescription(), (_b = this.condition) === null || _b === void 0 ? void 0 : _b.select, command.name, command.args);\n            }\n            if (stream) {\n                if (\"isPipeline\" in stream && stream.isPipeline) {\n                    stream.write(command.toWritable(stream.destination.redis.stream));\n                } else {\n                    stream.write(command.toWritable(stream));\n                }\n            } else {\n                this.stream.write(command.toWritable(this.stream));\n            }\n            this.commandQueue.push({\n                command: command,\n                stream: stream,\n                select: this.condition.select\n            });\n            if (Command_1.default.checkFlag(\"WILL_DISCONNECT\", command.name)) {\n                this.manuallyClosing = true;\n            }\n            if (this.options.socketTimeout !== undefined && this.socketTimeoutTimer === undefined) {\n                this.setSocketTimeout();\n            }\n        }\n        if (command.name === \"select\" && (0, utils_1.isInt)(command.args[0])) {\n            const db = parseInt(command.args[0], 10);\n            if (this.condition.select !== db) {\n                this.condition.select = db;\n                this.emit(\"select\", db);\n                debug(\"switch to db [%d]\", this.condition.select);\n            }\n        }\n        return command.promise;\n    }\n    setSocketTimeout() {\n        this.socketTimeoutTimer = setTimeout(()=>{\n            this.stream.destroy(new Error(`Socket timeout. Expecting data, but didn't receive any in ${this.options.socketTimeout}ms.`));\n            this.socketTimeoutTimer = undefined;\n        }, this.options.socketTimeout);\n        // this handler must run after the \"data\" handler in \"DataHandler\"\n        // so that `this.commandQueue.length` will be updated\n        this.stream.once(\"data\", ()=>{\n            clearTimeout(this.socketTimeoutTimer);\n            this.socketTimeoutTimer = undefined;\n            if (this.commandQueue.length === 0) return;\n            this.setSocketTimeout();\n        });\n    }\n    scanStream(options) {\n        return this.createScanStream(\"scan\", {\n            options\n        });\n    }\n    scanBufferStream(options) {\n        return this.createScanStream(\"scanBuffer\", {\n            options\n        });\n    }\n    sscanStream(key, options) {\n        return this.createScanStream(\"sscan\", {\n            key,\n            options\n        });\n    }\n    sscanBufferStream(key, options) {\n        return this.createScanStream(\"sscanBuffer\", {\n            key,\n            options\n        });\n    }\n    hscanStream(key, options) {\n        return this.createScanStream(\"hscan\", {\n            key,\n            options\n        });\n    }\n    hscanBufferStream(key, options) {\n        return this.createScanStream(\"hscanBuffer\", {\n            key,\n            options\n        });\n    }\n    zscanStream(key, options) {\n        return this.createScanStream(\"zscan\", {\n            key,\n            options\n        });\n    }\n    zscanBufferStream(key, options) {\n        return this.createScanStream(\"zscanBuffer\", {\n            key,\n            options\n        });\n    }\n    /**\n     * Emit only when there's at least one listener.\n     *\n     * @ignore\n     */ silentEmit(eventName, arg) {\n        let error;\n        if (eventName === \"error\") {\n            error = arg;\n            if (this.status === \"end\") {\n                return;\n            }\n            if (this.manuallyClosing) {\n                // ignore connection related errors when manually disconnecting\n                if (error instanceof Error && (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG || // @ts-expect-error\n                error.syscall === \"connect\" || // @ts-expect-error\n                error.syscall === \"read\")) {\n                    return;\n                }\n            }\n        }\n        if (this.listeners(eventName).length > 0) {\n            return this.emit.apply(this, arguments);\n        }\n        if (error && error instanceof Error) {\n            console.error(\"[ioredis] Unhandled error event:\", error.stack);\n        }\n        return false;\n    }\n    /**\n     * @ignore\n     */ recoverFromFatalError(_commandError, err, options) {\n        this.flushQueue(err, options);\n        this.silentEmit(\"error\", err);\n        this.disconnect(true);\n    }\n    /**\n     * @ignore\n     */ handleReconnection(err, item) {\n        var _a;\n        let needReconnect = false;\n        if (this.options.reconnectOnError) {\n            needReconnect = this.options.reconnectOnError(err);\n        }\n        switch(needReconnect){\n            case 1:\n            case true:\n                if (this.status !== \"reconnecting\") {\n                    this.disconnect(true);\n                }\n                item.command.reject(err);\n                break;\n            case 2:\n                if (this.status !== \"reconnecting\") {\n                    this.disconnect(true);\n                }\n                if (((_a = this.condition) === null || _a === void 0 ? void 0 : _a.select) !== item.select && item.command.name !== \"select\") {\n                    this.select(item.select);\n                }\n                // TODO\n                // @ts-expect-error\n                this.sendCommand(item.command);\n                break;\n            default:\n                item.command.reject(err);\n        }\n    }\n    /**\n     * Get description of the connection. Used for debugging.\n     */ _getDescription() {\n        let description;\n        if (\"path\" in this.options && this.options.path) {\n            description = this.options.path;\n        } else if (this.stream && this.stream.remoteAddress && this.stream.remotePort) {\n            description = this.stream.remoteAddress + \":\" + this.stream.remotePort;\n        } else if (\"host\" in this.options && this.options.host) {\n            description = this.options.host + \":\" + this.options.port;\n        } else {\n            // Unexpected\n            description = \"\";\n        }\n        if (this.options.connectionName) {\n            description += ` (${this.options.connectionName})`;\n        }\n        return description;\n    }\n    resetCommandQueue() {\n        this.commandQueue = new Deque();\n    }\n    resetOfflineQueue() {\n        this.offlineQueue = new Deque();\n    }\n    parseOptions(...args) {\n        const options = {};\n        let isTls = false;\n        for(let i = 0; i < args.length; ++i){\n            const arg = args[i];\n            if (arg === null || typeof arg === \"undefined\") {\n                continue;\n            }\n            if (typeof arg === \"object\") {\n                (0, lodash_1.defaults)(options, arg);\n            } else if (typeof arg === \"string\") {\n                (0, lodash_1.defaults)(options, (0, utils_1.parseURL)(arg));\n                if (arg.startsWith(\"rediss://\")) {\n                    isTls = true;\n                }\n            } else if (typeof arg === \"number\") {\n                options.port = arg;\n            } else {\n                throw new Error(\"Invalid argument \" + arg);\n            }\n        }\n        if (isTls) {\n            (0, lodash_1.defaults)(options, {\n                tls: true\n            });\n        }\n        (0, lodash_1.defaults)(options, Redis.defaultOptions);\n        if (typeof options.port === \"string\") {\n            options.port = parseInt(options.port, 10);\n        }\n        if (typeof options.db === \"string\") {\n            options.db = parseInt(options.db, 10);\n        }\n        // @ts-expect-error\n        this.options = (0, utils_1.resolveTLSProfile)(options);\n    }\n    /**\n     * Change instance's status\n     */ setStatus(status, arg) {\n        // @ts-expect-error\n        if (debug.enabled) {\n            debug(\"status[%s]: %s -> %s\", this._getDescription(), this.status || \"[empty]\", status);\n        }\n        this.status = status;\n        process.nextTick(this.emit.bind(this, status, arg));\n    }\n    createScanStream(command, { key, options = {} }) {\n        return new ScanStream_1.default({\n            objectMode: true,\n            key: key,\n            redis: this,\n            command: command,\n            ...options\n        });\n    }\n    /**\n     * Flush offline queue and command queue with error.\n     *\n     * @param error The error object to send to the commands\n     * @param options options\n     */ flushQueue(error, options) {\n        options = (0, lodash_1.defaults)({}, options, {\n            offlineQueue: true,\n            commandQueue: true\n        });\n        let item;\n        if (options.offlineQueue) {\n            while(item = this.offlineQueue.shift()){\n                item.command.reject(error);\n            }\n        }\n        if (options.commandQueue) {\n            if (this.commandQueue.length > 0) {\n                if (this.stream) {\n                    this.stream.removeAllListeners(\"data\");\n                }\n                while(item = this.commandQueue.shift()){\n                    item.command.reject(error);\n                }\n            }\n        }\n    }\n    /**\n     * Check whether Redis has finished loading the persistent data and is able to\n     * process commands.\n     */ _readyCheck(callback) {\n        const _this = this;\n        this.info(function(err, res) {\n            if (err) {\n                if (err.message && err.message.includes(\"NOPERM\")) {\n                    console.warn(`Skipping the ready check because INFO command fails: \"${err.message}\". You can disable ready check with \"enableReadyCheck\". More: https://github.com/luin/ioredis/wiki/Disable-ready-check.`);\n                    return callback(null, {});\n                }\n                return callback(err);\n            }\n            if (typeof res !== \"string\") {\n                return callback(null, res);\n            }\n            const info = {};\n            const lines = res.split(\"\\r\\n\");\n            for(let i = 0; i < lines.length; ++i){\n                const [fieldName, ...fieldValueParts] = lines[i].split(\":\");\n                const fieldValue = fieldValueParts.join(\":\");\n                if (fieldValue) {\n                    info[fieldName] = fieldValue;\n                }\n            }\n            if (!info.loading || info.loading === \"0\") {\n                callback(null, info);\n            } else {\n                const loadingEtaMs = (info.loading_eta_seconds || 1) * 1000;\n                const retryTime = _this.options.maxLoadingRetryTime && _this.options.maxLoadingRetryTime < loadingEtaMs ? _this.options.maxLoadingRetryTime : loadingEtaMs;\n                debug(\"Redis server still loading, trying again in \" + retryTime + \"ms\");\n                setTimeout(function() {\n                    _this._readyCheck(callback);\n                }, retryTime);\n            }\n        }).catch(lodash_1.noop);\n    }\n}\nRedis.Cluster = cluster_1.default;\nRedis.Command = Command_1.default;\n/**\n * Default options\n */ Redis.defaultOptions = RedisOptions_1.DEFAULT_REDIS_OPTIONS;\n(0, applyMixin_1.default)(Redis, events_1.EventEmitter);\n(0, transaction_1.addTransactionSupport)(Redis.prototype);\nexports[\"default\"] = Redis;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9SZWRpcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyxhQUFhQyxtQkFBT0EsQ0FBQyxnRkFBbUI7QUFDOUMsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUUseUJBQXlCRixtQkFBT0EsQ0FBQyxzRkFBc0I7QUFDN0QsTUFBTUcsWUFBWUgsbUJBQU9BLENBQUMsc0VBQVc7QUFDckMsTUFBTUksWUFBWUosbUJBQU9BLENBQUMsZ0VBQVc7QUFDckMsTUFBTUssZUFBZUwsbUJBQU9BLENBQUMsNEVBQWM7QUFDM0MsTUFBTU0sc0JBQXNCTixtQkFBT0EsQ0FBQyxnSEFBZ0M7QUFDcEUsTUFBTU8sZUFBZVAsbUJBQU9BLENBQUMsd0ZBQXVCO0FBQ3BELE1BQU1RLGlCQUFpQlIsbUJBQU9BLENBQUMsc0ZBQXNCO0FBQ3JELE1BQU1TLGVBQWVULG1CQUFPQSxDQUFDLHNFQUFjO0FBQzNDLE1BQU1VLGdCQUFnQlYsbUJBQU9BLENBQUMsd0VBQWU7QUFDN0MsTUFBTVcsVUFBVVgsbUJBQU9BLENBQUMsa0VBQVM7QUFDakMsTUFBTVksZUFBZVosbUJBQU9BLENBQUMsa0ZBQW9CO0FBQ2pELE1BQU1hLGNBQWNiLG1CQUFPQSxDQUFDLGdGQUFtQjtBQUMvQyxNQUFNYyxXQUFXZCxtQkFBT0EsQ0FBQywwRUFBZ0I7QUFDekMsTUFBTWUsUUFBUWYsbUJBQU9BLENBQUMsb0RBQVE7QUFDOUIsTUFBTWdCLFFBQVEsQ0FBQyxHQUFHTCxRQUFRTSxLQUFLLEVBQUU7QUFDakM7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDRCxNQUFNQyxjQUFjTCxZQUFZTSxPQUFPO0lBQ25DQyxZQUFZQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsSUFBSSxDQUFFO1FBQzFCLEtBQUs7UUFDTCxJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNk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ZHVsZXMvaW9yZWRpcy9idWlsdC9SZWRpcy5qcz80OGFiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29tbWFuZHNfMSA9IHJlcXVpcmUoXCJAaW9yZWRpcy9jb21tYW5kc1wiKTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEgPSByZXF1aXJlKFwic3RhbmRhcmQtYXMtY2FsbGJhY2tcIik7XG5jb25zdCBjbHVzdGVyXzEgPSByZXF1aXJlKFwiLi9jbHVzdGVyXCIpO1xuY29uc3QgQ29tbWFuZF8xID0gcmVxdWlyZShcIi4vQ29tbWFuZFwiKTtcbmNvbnN0IGNvbm5lY3RvcnNfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3RvcnNcIik7XG5jb25zdCBTZW50aW5lbENvbm5lY3Rvcl8xID0gcmVxdWlyZShcIi4vY29ubmVjdG9ycy9TZW50aW5lbENvbm5lY3RvclwiKTtcbmNvbnN0IGV2ZW50SGFuZGxlciA9IHJlcXVpcmUoXCIuL3JlZGlzL2V2ZW50X2hhbmRsZXJcIik7XG5jb25zdCBSZWRpc09wdGlvbnNfMSA9IHJlcXVpcmUoXCIuL3JlZGlzL1JlZGlzT3B0aW9uc1wiKTtcbmNvbnN0IFNjYW5TdHJlYW1fMSA9IHJlcXVpcmUoXCIuL1NjYW5TdHJlYW1cIik7XG5jb25zdCB0cmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIi4vdHJhbnNhY3Rpb25cIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBhcHBseU1peGluXzEgPSByZXF1aXJlKFwiLi91dGlscy9hcHBseU1peGluXCIpO1xuY29uc3QgQ29tbWFuZGVyXzEgPSByZXF1aXJlKFwiLi91dGlscy9Db21tYW5kZXJcIik7XG5jb25zdCBsb2Rhc2hfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2xvZGFzaFwiKTtcbmNvbnN0IERlcXVlID0gcmVxdWlyZShcImRlbnF1ZVwiKTtcbmNvbnN0IGRlYnVnID0gKDAsIHV0aWxzXzEuRGVidWcpKFwicmVkaXNcIik7XG4vKipcbiAqIFRoaXMgaXMgdGhlIG1ham9yIGNvbXBvbmVudCBvZiBpb3JlZGlzLlxuICogVXNlIGl0IHRvIGNvbm5lY3QgdG8gYSBzdGFuZGFsb25lIFJlZGlzIHNlcnZlciBvciBTZW50aW5lbHMuXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgcmVkaXMgPSBuZXcgUmVkaXMoKTsgLy8gRGVmYXVsdCBwb3J0IGlzIDYzNzlcbiAqIGFzeW5jIGZ1bmN0aW9uIG1haW4oKSB7XG4gKiAgIHJlZGlzLnNldChcImZvb1wiLCBcImJhclwiKTtcbiAqICAgcmVkaXMuZ2V0KFwiZm9vXCIsIChlcnIsIHJlc3VsdCkgPT4ge1xuICogICAgIC8vIGByZXN1bHRgIHNob3VsZCBiZSBcImJhclwiXG4gKiAgICAgY29uc29sZS5sb2coZXJyLCByZXN1bHQpO1xuICogICB9KTtcbiAqICAgLy8gT3IgdXNlIFByb21pc2VcbiAqICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVkaXMuZ2V0KFwiZm9vXCIpO1xuICogfVxuICogYGBgXG4gKi9cbmNsYXNzIFJlZGlzIGV4dGVuZHMgQ29tbWFuZGVyXzEuZGVmYXVsdCB7XG4gICAgY29uc3RydWN0b3IoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IFwid2FpdFwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGlnbm9yZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0NsdXN0ZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uRXBvY2ggPSAwO1xuICAgICAgICB0aGlzLnJldHJ5QXR0ZW1wdHMgPSAwO1xuICAgICAgICB0aGlzLm1hbnVhbGx5Q2xvc2luZyA9IGZhbHNlO1xuICAgICAgICAvLyBQcmVwYXJlIGF1dG9waXBlbGluZXMgc3RydWN0dXJlc1xuICAgICAgICB0aGlzLl9hdXRvUGlwZWxpbmVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9ydW5uaW5nQXV0b1BpcGVsaW5lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5wYXJzZU9wdGlvbnMoYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICAgIGV2ZW50c18xLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnJlc2V0Q29tbWFuZFF1ZXVlKCk7XG4gICAgICAgIHRoaXMucmVzZXRPZmZsaW5lUXVldWUoKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5Db25uZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yID0gbmV3IHRoaXMub3B0aW9ucy5Db25uZWN0b3IodGhpcy5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc2VudGluZWxzKSB7XG4gICAgICAgICAgICBjb25zdCBzZW50aW5lbENvbm5lY3RvciA9IG5ldyBTZW50aW5lbENvbm5lY3Rvcl8xLmRlZmF1bHQodGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIHNlbnRpbmVsQ29ubmVjdG9yLmVtaXR0ZXIgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IgPSBzZW50aW5lbENvbm5lY3RvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yID0gbmV3IGNvbm5lY3RvcnNfMS5TdGFuZGFsb25lQ29ubmVjdG9yKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zY3JpcHRzKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyh0aGlzLm9wdGlvbnMuc2NyaXB0cykuZm9yRWFjaCgoW25hbWUsIGRlZmluaXRpb25dKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWZpbmVDb21tYW5kKG5hbWUsIGRlZmluaXRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZW5kKG9yIHdhaXQpIC0+IGNvbm5lY3RpbmcgLT4gY29ubmVjdCAtPiByZWFkeSAtPiBlbmRcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYXp5Q29ubmVjdCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJ3YWl0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCkuY2F0Y2gobG9kYXNoXzEubm9vcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgUmVkaXMgaW5zdGFuY2UuXG4gICAgICogVGhpcyBpcyB0aGUgc2FtZSBhcyBgbmV3IFJlZGlzKClgIGJ1dCBpcyBpbmNsdWRlZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vZGUtcmVkaXMuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUNsaWVudCguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVkaXMoLi4uYXJncyk7XG4gICAgfVxuICAgIGdldCBhdXRvUGlwZWxpbmVRdWV1ZVNpemUoKSB7XG4gICAgICAgIGxldCBxdWV1ZWQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHBpcGVsaW5lIG9mIHRoaXMuX2F1dG9QaXBlbGluZXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHF1ZXVlZCArPSBwaXBlbGluZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHF1ZXVlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY29ubmVjdGlvbiB0byBSZWRpcy5cbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGJlIGludm9rZWQgYXV0b21hdGljYWxseSB3aGVuIGNyZWF0aW5nIGEgbmV3IFJlZGlzIGluc3RhbmNlXG4gICAgICogdW5sZXNzIGBsYXp5Q29ubmVjdDogdHJ1ZWAgaXMgcGFzc2VkLlxuICAgICAqXG4gICAgICogV2hlbiBjYWxsaW5nIHRoaXMgbWV0aG9kIG1hbnVhbGx5LCBhIFByb21pc2UgaXMgcmV0dXJuZWQsIHdoaWNoIHdpbGxcbiAgICAgKiBiZSByZXNvbHZlZCB3aGVuIHRoZSBjb25uZWN0aW9uIHN0YXR1cyBpcyByZWFkeS5cbiAgICAgKi9cbiAgICBjb25uZWN0KGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwiY29ubmVjdGluZ1wiIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPT09IFwiY29ubmVjdFwiIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPT09IFwicmVhZHlcIikge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJSZWRpcyBpcyBhbHJlYWR5IGNvbm5lY3RpbmcvY29ubmVjdGVkXCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25FcG9jaCArPSAxO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJjb25uZWN0aW5nXCIpO1xuICAgICAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5jb25kaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0OiBvcHRpb25zLmRiLFxuICAgICAgICAgICAgICAgIGF1dGg6IG9wdGlvbnMudXNlcm5hbWVcbiAgICAgICAgICAgICAgICAgICAgPyBbb3B0aW9ucy51c2VybmFtZSwgb3B0aW9ucy5wYXNzd29yZF1cbiAgICAgICAgICAgICAgICAgICAgOiBvcHRpb25zLnBhc3N3b3JkLFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXI6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICgwLCBzdGFuZGFyZF9hc19jYWxsYmFja18xLmRlZmF1bHQpKHRoaXMuY29ubmVjdG9yLmNvbm5lY3QoZnVuY3Rpb24gKHR5cGUsIGVycikge1xuICAgICAgICAgICAgICAgIF90aGlzLnNpbGVudEVtaXQodHlwZSwgZXJyKTtcbiAgICAgICAgICAgIH0pLCBmdW5jdGlvbiAoZXJyLCBzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmZsdXNoUXVldWUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2lsZW50RW1pdChcImVycm9yXCIsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0dXMoXCJlbmRcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IENPTk5FQ1RfRVZFTlQgPSBvcHRpb25zLnRscyA/IFwic2VjdXJlQ29ubmVjdFwiIDogXCJjb25uZWN0XCI7XG4gICAgICAgICAgICAgICAgaWYgKFwic2VudGluZWxzXCIgaW4gb3B0aW9ucyAmJlxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNlbnRpbmVscyAmJlxuICAgICAgICAgICAgICAgICAgICAhb3B0aW9ucy5lbmFibGVUTFNGb3JTZW50aW5lbE1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgQ09OTkVDVF9FVkVOVCA9IFwiY29ubmVjdFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubm9EZWxheSkge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0uc2V0Tm9EZWxheSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTm9kZSBpZ25vcmVzIHNldEtlZXBBbGl2ZSBiZWZvcmUgY29ubmVjdCwgdGhlcmVmb3JlIHdlIHdhaXQgZm9yIHRoZSBldmVudDpcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzMxNjYzXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmtlZXBBbGl2ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLmNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5vbmNlKENPTk5FQ1RfRVZFTlQsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0uc2V0S2VlcEFsaXZlKHRydWUsIG9wdGlvbnMua2VlcEFsaXZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnNldEtlZXBBbGl2ZSh0cnVlLCBvcHRpb25zLmtlZXBBbGl2ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5jb25uZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5vbmNlKENPTk5FQ1RfRVZFTlQsIGV2ZW50SGFuZGxlci5jb25uZWN0SGFuZGxlcihfdGhpcykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jb25uZWN0VGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFR5cGljYWxseSwgU29ja2V0I3NldFRpbWVvdXQoMCkgd2lsbCBjbGVhciB0aGUgdGltZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHNldCBiZWZvcmUuIEhvd2V2ZXIsIGluIHNvbWUgcGxhdGZvcm1zIChFbGVjdHJvbiAzLnh+NC54KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoZSB0aW1lciB3aWxsIG5vdCBiZSBjbGVhcmVkLiBTbyB3ZSBpbnRyb2R1Y2UgYSB2YXJpYWJsZSBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZWxlY3Ryb24vZWxlY3Ryb24vaXNzdWVzLzE0OTE1XG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb25uZWN0VGltZW91dENsZWFyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5zZXRUaW1lb3V0KG9wdGlvbnMuY29ubmVjdFRpbWVvdXQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdFRpbWVvdXRDbGVhcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnNldFRpbWVvdXQoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXCJjb25uZWN0IEVUSU1FRE9VVFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLmVycm9ybm8gPSBcIkVUSU1FRE9VVFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIuY29kZSA9IFwiRVRJTUVET1VUXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyci5zeXNjYWxsID0gXCJjb25uZWN0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyLmVycm9ySGFuZGxlcihfdGhpcykoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLm9uY2UoQ09OTkVDVF9FVkVOVCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RUaW1lb3V0Q2xlYXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnNldFRpbWVvdXQoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdHJlYW0uZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0RXJyb3IgPSBfdGhpcy5jb25uZWN0b3IuZmlyc3RFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlci5lcnJvckhhbmRsZXIoX3RoaXMpKGZpcnN0RXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhldmVudEhhbmRsZXIuY2xvc2VIYW5kbGVyKF90aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGV2ZW50SGFuZGxlci5jb25uZWN0SGFuZGxlcihfdGhpcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXN0cmVhbS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLm9uY2UoXCJlcnJvclwiLCBldmVudEhhbmRsZXIuZXJyb3JIYW5kbGVyKF90aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5vbmNlKFwiY2xvc2VcIiwgZXZlbnRIYW5kbGVyLmNsb3NlSGFuZGxlcihfdGhpcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uUmVhZHlIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIGNvbm5lY3Rpb25DbG9zZUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgY29ubmVjdGlvbkNsb3NlSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVtb3ZlTGlzdGVuZXIoXCJyZWFkeVwiLCBjb25uZWN0aW9uUmVhZHlIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcih1dGlsc18xLkNPTk5FQ1RJT05fQ0xPU0VEX0VSUk9SX01TRykpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX3RoaXMub25jZShcInJlYWR5XCIsIGNvbm5lY3Rpb25SZWFkeUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIF90aGlzLm9uY2UoXCJjbG9zZVwiLCBjb25uZWN0aW9uQ2xvc2VIYW5kbGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgwLCBzdGFuZGFyZF9hc19jYWxsYmFja18xLmRlZmF1bHQpKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdCBmcm9tIFJlZGlzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY2xvc2VzIHRoZSBjb25uZWN0aW9uIGltbWVkaWF0ZWx5LFxuICAgICAqIGFuZCBtYXkgbG9zZSBzb21lIHBlbmRpbmcgcmVwbGllcyB0aGF0IGhhdmVuJ3Qgd3JpdHRlbiB0byBjbGllbnQuXG4gICAgICogSWYgeW91IHdhbnQgdG8gd2FpdCBmb3IgdGhlIHBlbmRpbmcgcmVwbGllcywgdXNlIFJlZGlzI3F1aXQgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KHJlY29ubmVjdCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghcmVjb25uZWN0KSB7XG4gICAgICAgICAgICB0aGlzLm1hbnVhbGx5Q2xvc2luZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjb25uZWN0VGltZW91dCAmJiAhcmVjb25uZWN0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcIndhaXRcIikge1xuICAgICAgICAgICAgZXZlbnRIYW5kbGVyLmNsb3NlSGFuZGxlcih0aGlzKSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3QgZnJvbSBSZWRpcy5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgZW5kKCkge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIHdpdGggdGhlIHNhbWUgb3B0aW9ucyBhcyB0aGUgY3VycmVudCBvbmUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIHJlZGlzID0gbmV3IFJlZGlzKDYzODApO1xuICAgICAqIHZhciBhbm90aGVyUmVkaXMgPSByZWRpcy5kdXBsaWNhdGUoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBkdXBsaWNhdGUob3ZlcnJpZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWRpcyh7IC4uLnRoaXMub3B0aW9ucywgLi4ub3ZlcnJpZGUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vZGUgb2YgdGhlIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBPbmUgb2YgYFwibm9ybWFsXCJgLCBgXCJzdWJzY3JpYmVyXCJgLCBvciBgXCJtb25pdG9yXCJgLiBXaGVuIHRoZSBjb25uZWN0aW9uIGlzXG4gICAgICogbm90IGluIGBcIm5vcm1hbFwiYCBtb2RlLCBjZXJ0YWluIGNvbW1hbmRzIGFyZSBub3QgYWxsb3dlZC5cbiAgICAgKi9cbiAgICBnZXQgbW9kZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLm1vbml0b3JcbiAgICAgICAgICAgID8gXCJtb25pdG9yXCJcbiAgICAgICAgICAgIDogKChfYSA9IHRoaXMuY29uZGl0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3Vic2NyaWJlcilcbiAgICAgICAgICAgICAgICA/IFwic3Vic2NyaWJlclwiXG4gICAgICAgICAgICAgICAgOiBcIm5vcm1hbFwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gZm9yIGFsbCByZXF1ZXN0cyByZWNlaXZlZCBieSB0aGUgc2VydmVyIGluIHJlYWwgdGltZS5cbiAgICAgKlxuICAgICAqIFRoaXMgY29tbWFuZCB3aWxsIGNyZWF0ZSBhIG5ldyBjb25uZWN0aW9uIHRvIFJlZGlzIGFuZCBzZW5kIGFcbiAgICAgKiBNT05JVE9SIGNvbW1hbmQgdmlhIHRoZSBuZXcgY29ubmVjdGlvbiBpbiBvcmRlciB0byBhdm9pZCBkaXN0dXJiaW5nXG4gICAgICogdGhlIGN1cnJlbnQgY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uIElmIG9taXQsIGEgcHJvbWlzZSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiB2YXIgcmVkaXMgPSBuZXcgUmVkaXMoKTtcbiAgICAgKiByZWRpcy5tb25pdG9yKGZ1bmN0aW9uIChlcnIsIG1vbml0b3IpIHtcbiAgICAgKiAgIC8vIEVudGVyaW5nIG1vbml0b3JpbmcgbW9kZS5cbiAgICAgKiAgIG1vbml0b3Iub24oJ21vbml0b3InLCBmdW5jdGlvbiAodGltZSwgYXJncywgc291cmNlLCBkYXRhYmFzZSkge1xuICAgICAqICAgICBjb25zb2xlLmxvZyh0aW1lICsgXCI6IFwiICsgdXRpbC5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gc3VwcG9ydHMgcHJvbWlzZSBhcyB3ZWxsIGFzIG90aGVyIGNvbW1hbmRzXG4gICAgICogcmVkaXMubW9uaXRvcigpLnRoZW4oZnVuY3Rpb24gKG1vbml0b3IpIHtcbiAgICAgKiAgIG1vbml0b3Iub24oJ21vbml0b3InLCBmdW5jdGlvbiAodGltZSwgYXJncywgc291cmNlLCBkYXRhYmFzZSkge1xuICAgICAqICAgICBjb25zb2xlLmxvZyh0aW1lICsgXCI6IFwiICsgdXRpbC5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG1vbml0b3IoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgbW9uaXRvckluc3RhbmNlID0gdGhpcy5kdXBsaWNhdGUoe1xuICAgICAgICAgICAgbW9uaXRvcjogdHJ1ZSxcbiAgICAgICAgICAgIGxhenlDb25uZWN0OiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoMCwgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMS5kZWZhdWx0KShuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBtb25pdG9ySW5zdGFuY2Uub25jZShcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgICBtb25pdG9ySW5zdGFuY2Uub25jZShcIm1vbml0b3JpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUobW9uaXRvckluc3RhbmNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgY29tbWFuZCB0byBSZWRpc1xuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCBpbnRlcm5hbGx5IGFuZCBpbiBtb3N0IGNhc2VzIHlvdSBzaG91bGQgbm90XG4gICAgICogdXNlIGl0IGRpcmVjdGx5LiBJZiB5b3UgbmVlZCB0byBzZW5kIGEgY29tbWFuZCB0aGF0IGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgKiBieSB0aGUgbGlicmFyeSwgeW91IGNhbiB1c2UgdGhlIGBjYWxsYCBtZXRob2Q6XG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IHJlZGlzID0gbmV3IFJlZGlzKCk7XG4gICAgICpcbiAgICAgKiByZWRpcy5jYWxsKCdzZXQnLCAnZm9vJywgJ2JhcicpO1xuICAgICAqIC8vIG9yXG4gICAgICogcmVkaXMuY2FsbChbJ3NldCcsICdmb28nLCAnYmFyJ10pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHNlbmRDb21tYW5kKGNvbW1hbmQsIHN0cmVhbSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwid2FpdFwiKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3QoKS5jYXRjaChsb2Rhc2hfMS5ub29wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwiZW5kXCIpIHtcbiAgICAgICAgICAgIGNvbW1hbmQucmVqZWN0KG5ldyBFcnJvcih1dGlsc18xLkNPTk5FQ1RJT05fQ0xPU0VEX0VSUk9SX01TRykpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmQucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKChfYSA9IHRoaXMuY29uZGl0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3Vic2NyaWJlcikgJiZcbiAgICAgICAgICAgICFDb21tYW5kXzEuZGVmYXVsdC5jaGVja0ZsYWcoXCJWQUxJRF9JTl9TVUJTQ1JJQkVSX01PREVcIiwgY29tbWFuZC5uYW1lKSkge1xuICAgICAgICAgICAgY29tbWFuZC5yZWplY3QobmV3IEVycm9yKFwiQ29ubmVjdGlvbiBpbiBzdWJzY3JpYmVyIG1vZGUsIG9ubHkgc3Vic2NyaWJlciBjb21tYW5kcyBtYXkgYmUgdXNlZFwiKSk7XG4gICAgICAgICAgICByZXR1cm4gY29tbWFuZC5wcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmNvbW1hbmRUaW1lb3V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBjb21tYW5kLnNldFRpbWVvdXQodGhpcy5vcHRpb25zLmNvbW1hbmRUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgd3JpdGFibGUgPSB0aGlzLnN0YXR1cyA9PT0gXCJyZWFkeVwiIHx8XG4gICAgICAgICAgICAoIXN0cmVhbSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID09PSBcImNvbm5lY3RcIiAmJlxuICAgICAgICAgICAgICAgICgwLCBjb21tYW5kc18xLmV4aXN0cykoY29tbWFuZC5uYW1lKSAmJlxuICAgICAgICAgICAgICAgICgwLCBjb21tYW5kc18xLmhhc0ZsYWcpKGNvbW1hbmQubmFtZSwgXCJsb2FkaW5nXCIpKTtcbiAgICAgICAgaWYgKCF0aGlzLnN0cmVhbSkge1xuICAgICAgICAgICAgd3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5zdHJlYW0ud3JpdGFibGUpIHtcbiAgICAgICAgICAgIHdyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdHJlYW0uX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5zdHJlYW0uX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFdlIHNob3VsZCBiZSBhYmxlIHRvIHJlbW92ZSB0aGlzIGFzIHRoZSBQUiBoYXMgYWxyZWFkeSBiZWVuIG1lcmdlZC5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pb2pzL2lvLmpzL3B1bGwvMTIxN1xuICAgICAgICAgICAgd3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXdyaXRhYmxlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5lbmFibGVPZmZsaW5lUXVldWUpIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kLnJlamVjdChuZXcgRXJyb3IoXCJTdHJlYW0gaXNuJ3Qgd3JpdGVhYmxlIGFuZCBlbmFibGVPZmZsaW5lUXVldWUgb3B0aW9ucyBpcyBmYWxzZVwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmQucHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb21tYW5kLm5hbWUgPT09IFwicXVpdFwiICYmIHRoaXMub2ZmbGluZVF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIGNvbW1hbmQucmVzb2x2ZShCdWZmZXIuZnJvbShcIk9LXCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZC5wcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgaWYgKGRlYnVnLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInF1ZXVlIGNvbW1hbmRbJXNdOiAlZCAtPiAlcyglbylcIiwgdGhpcy5fZ2V0RGVzY3JpcHRpb24oKSwgdGhpcy5jb25kaXRpb24uc2VsZWN0LCBjb21tYW5kLm5hbWUsIGNvbW1hbmQuYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9mZmxpbmVRdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBjb21tYW5kLFxuICAgICAgICAgICAgICAgIHN0cmVhbTogc3RyZWFtLFxuICAgICAgICAgICAgICAgIHNlbGVjdDogdGhpcy5jb25kaXRpb24uc2VsZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBpZiAoZGVidWcuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwid3JpdGUgY29tbWFuZFslc106ICVkIC0+ICVzKCVvKVwiLCB0aGlzLl9nZXREZXNjcmlwdGlvbigpLCAoX2IgPSB0aGlzLmNvbmRpdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNlbGVjdCwgY29tbWFuZC5uYW1lLCBjb21tYW5kLmFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIGlmIChcImlzUGlwZWxpbmVcIiBpbiBzdHJlYW0gJiYgc3RyZWFtLmlzUGlwZWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLndyaXRlKGNvbW1hbmQudG9Xcml0YWJsZShzdHJlYW0uZGVzdGluYXRpb24ucmVkaXMuc3RyZWFtKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ud3JpdGUoY29tbWFuZC50b1dyaXRhYmxlKHN0cmVhbSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKGNvbW1hbmQudG9Xcml0YWJsZSh0aGlzLnN0cmVhbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb21tYW5kUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogY29tbWFuZCxcbiAgICAgICAgICAgICAgICBzdHJlYW06IHN0cmVhbSxcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IHRoaXMuY29uZGl0aW9uLnNlbGVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKENvbW1hbmRfMS5kZWZhdWx0LmNoZWNrRmxhZyhcIldJTExfRElTQ09OTkVDVFwiLCBjb21tYW5kLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYW51YWxseUNsb3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zb2NrZXRUaW1lb3V0ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5zb2NrZXRUaW1lb3V0VGltZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U29ja2V0VGltZW91dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21tYW5kLm5hbWUgPT09IFwic2VsZWN0XCIgJiYgKDAsIHV0aWxzXzEuaXNJbnQpKGNvbW1hbmQuYXJnc1swXSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRiID0gcGFyc2VJbnQoY29tbWFuZC5hcmdzWzBdLCAxMCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25kaXRpb24uc2VsZWN0ICE9PSBkYikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uLnNlbGVjdCA9IGRiO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInNlbGVjdFwiLCBkYik7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJzd2l0Y2ggdG8gZGIgWyVkXVwiLCB0aGlzLmNvbmRpdGlvbi5zZWxlY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21tYW5kLnByb21pc2U7XG4gICAgfVxuICAgIHNldFNvY2tldFRpbWVvdXQoKSB7XG4gICAgICAgIHRoaXMuc29ja2V0VGltZW91dFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5kZXN0cm95KG5ldyBFcnJvcihgU29ja2V0IHRpbWVvdXQuIEV4cGVjdGluZyBkYXRhLCBidXQgZGlkbid0IHJlY2VpdmUgYW55IGluICR7dGhpcy5vcHRpb25zLnNvY2tldFRpbWVvdXR9bXMuYCkpO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXRUaW1lb3V0VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy5zb2NrZXRUaW1lb3V0KTtcbiAgICAgICAgLy8gdGhpcyBoYW5kbGVyIG11c3QgcnVuIGFmdGVyIHRoZSBcImRhdGFcIiBoYW5kbGVyIGluIFwiRGF0YUhhbmRsZXJcIlxuICAgICAgICAvLyBzbyB0aGF0IGB0aGlzLmNvbW1hbmRRdWV1ZS5sZW5ndGhgIHdpbGwgYmUgdXBkYXRlZFxuICAgICAgICB0aGlzLnN0cmVhbS5vbmNlKFwiZGF0YVwiLCAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zb2NrZXRUaW1lb3V0VGltZXIpO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXRUaW1lb3V0VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21tYW5kUXVldWUubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuc2V0U29ja2V0VGltZW91dCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2NhblN0cmVhbShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNjYW5TdHJlYW0oXCJzY2FuXCIsIHsgb3B0aW9ucyB9KTtcbiAgICB9XG4gICAgc2NhbkJ1ZmZlclN0cmVhbShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNjYW5TdHJlYW0oXCJzY2FuQnVmZmVyXCIsIHsgb3B0aW9ucyB9KTtcbiAgICB9XG4gICAgc3NjYW5TdHJlYW0oa2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNjYW5TdHJlYW0oXCJzc2NhblwiLCB7IGtleSwgb3B0aW9ucyB9KTtcbiAgICB9XG4gICAgc3NjYW5CdWZmZXJTdHJlYW0oa2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNjYW5TdHJlYW0oXCJzc2NhbkJ1ZmZlclwiLCB7IGtleSwgb3B0aW9ucyB9KTtcbiAgICB9XG4gICAgaHNjYW5TdHJlYW0oa2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNjYW5TdHJlYW0oXCJoc2NhblwiLCB7IGtleSwgb3B0aW9ucyB9KTtcbiAgICB9XG4gICAgaHNjYW5CdWZmZXJTdHJlYW0oa2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNjYW5TdHJlYW0oXCJoc2NhbkJ1ZmZlclwiLCB7IGtleSwgb3B0aW9ucyB9KTtcbiAgICB9XG4gICAgenNjYW5TdHJlYW0oa2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNjYW5TdHJlYW0oXCJ6c2NhblwiLCB7IGtleSwgb3B0aW9ucyB9KTtcbiAgICB9XG4gICAgenNjYW5CdWZmZXJTdHJlYW0oa2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNjYW5TdHJlYW0oXCJ6c2NhbkJ1ZmZlclwiLCB7IGtleSwgb3B0aW9ucyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdCBvbmx5IHdoZW4gdGhlcmUncyBhdCBsZWFzdCBvbmUgbGlzdGVuZXIuXG4gICAgICpcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgc2lsZW50RW1pdChldmVudE5hbWUsIGFyZykge1xuICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgZXJyb3IgPSBhcmc7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwiZW5kXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5tYW51YWxseUNsb3NpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgY29ubmVjdGlvbiByZWxhdGVkIGVycm9ycyB3aGVuIG1hbnVhbGx5IGRpc2Nvbm5lY3RpbmdcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICAoZXJyb3IubWVzc2FnZSA9PT0gdXRpbHNfMS5DT05ORUNUSU9OX0NMT1NFRF9FUlJPUl9NU0cgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLnN5c2NhbGwgPT09IFwiY29ubmVjdFwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5zeXNjYWxsID09PSBcInJlYWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5saXN0ZW5lcnMoZXZlbnROYW1lKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yICYmIGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbaW9yZWRpc10gVW5oYW5kbGVkIGVycm9yIGV2ZW50OlwiLCBlcnJvci5zdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgcmVjb3ZlckZyb21GYXRhbEVycm9yKF9jb21tYW5kRXJyb3IsIGVyciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmZsdXNoUXVldWUoZXJyLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5zaWxlbnRFbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgaGFuZGxlUmVjb25uZWN0aW9uKGVyciwgaXRlbSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBuZWVkUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVjb25uZWN0T25FcnJvcikge1xuICAgICAgICAgICAgbmVlZFJlY29ubmVjdCA9IHRoaXMub3B0aW9ucy5yZWNvbm5lY3RPbkVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChuZWVkUmVjb25uZWN0KSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIHRydWU6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBcInJlY29ubmVjdGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXRlbS5jb21tYW5kLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gXCJyZWNvbm5lY3RpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gdGhpcy5jb25kaXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZWxlY3QpICE9PSBpdGVtLnNlbGVjdCAmJlxuICAgICAgICAgICAgICAgICAgICBpdGVtLmNvbW1hbmQubmFtZSAhPT0gXCJzZWxlY3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdChpdGVtLnNlbGVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kQ29tbWFuZChpdGVtLmNvbW1hbmQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpdGVtLmNvbW1hbmQucmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGRlc2NyaXB0aW9uIG9mIHRoZSBjb25uZWN0aW9uLiBVc2VkIGZvciBkZWJ1Z2dpbmcuXG4gICAgICovXG4gICAgX2dldERlc2NyaXB0aW9uKCkge1xuICAgICAgICBsZXQgZGVzY3JpcHRpb247XG4gICAgICAgIGlmIChcInBhdGhcIiBpbiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnBhdGgpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gdGhpcy5vcHRpb25zLnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdHJlYW0gJiZcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLnJlbW90ZUFkZHJlc3MgJiZcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLnJlbW90ZVBvcnQpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gdGhpcy5zdHJlYW0ucmVtb3RlQWRkcmVzcyArIFwiOlwiICsgdGhpcy5zdHJlYW0ucmVtb3RlUG9ydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChcImhvc3RcIiBpbiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmhvc3QpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gdGhpcy5vcHRpb25zLmhvc3QgKyBcIjpcIiArIHRoaXMub3B0aW9ucy5wb3J0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVW5leHBlY3RlZFxuICAgICAgICAgICAgZGVzY3JpcHRpb24gPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29ubmVjdGlvbk5hbWUpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uICs9IGAgKCR7dGhpcy5vcHRpb25zLmNvbm5lY3Rpb25OYW1lfSlgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICB9XG4gICAgcmVzZXRDb21tYW5kUXVldWUoKSB7XG4gICAgICAgIHRoaXMuY29tbWFuZFF1ZXVlID0gbmV3IERlcXVlKCk7XG4gICAgfVxuICAgIHJlc2V0T2ZmbGluZVF1ZXVlKCkge1xuICAgICAgICB0aGlzLm9mZmxpbmVRdWV1ZSA9IG5ldyBEZXF1ZSgpO1xuICAgIH1cbiAgICBwYXJzZU9wdGlvbnMoLi4uYXJncykge1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgIGxldCBpc1RscyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV07XG4gICAgICAgICAgICBpZiAoYXJnID09PSBudWxsIHx8IHR5cGVvZiBhcmcgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgKDAsIGxvZGFzaF8xLmRlZmF1bHRzKShvcHRpb25zLCBhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICgwLCBsb2Rhc2hfMS5kZWZhdWx0cykob3B0aW9ucywgKDAsIHV0aWxzXzEucGFyc2VVUkwpKGFyZykpO1xuICAgICAgICAgICAgICAgIGlmIChhcmcuc3RhcnRzV2l0aChcInJlZGlzczovL1wiKSkge1xuICAgICAgICAgICAgICAgICAgICBpc1RscyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucG9ydCA9IGFyZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnQgXCIgKyBhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Rscykge1xuICAgICAgICAgICAgKDAsIGxvZGFzaF8xLmRlZmF1bHRzKShvcHRpb25zLCB7IHRsczogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgbG9kYXNoXzEuZGVmYXVsdHMpKG9wdGlvbnMsIFJlZGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnBvcnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucG9ydCA9IHBhcnNlSW50KG9wdGlvbnMucG9ydCwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kYiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgb3B0aW9ucy5kYiA9IHBhcnNlSW50KG9wdGlvbnMuZGIsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHRoaXMub3B0aW9ucyA9ICgwLCB1dGlsc18xLnJlc29sdmVUTFNQcm9maWxlKShvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlIGluc3RhbmNlJ3Mgc3RhdHVzXG4gICAgICovXG4gICAgc2V0U3RhdHVzKHN0YXR1cywgYXJnKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgaWYgKGRlYnVnLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIGRlYnVnKFwic3RhdHVzWyVzXTogJXMgLT4gJXNcIiwgdGhpcy5fZ2V0RGVzY3JpcHRpb24oKSwgdGhpcy5zdGF0dXMgfHwgXCJbZW1wdHldXCIsIHN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2sodGhpcy5lbWl0LmJpbmQodGhpcywgc3RhdHVzLCBhcmcpKTtcbiAgICB9XG4gICAgY3JlYXRlU2NhblN0cmVhbShjb21tYW5kLCB7IGtleSwgb3B0aW9ucyA9IHt9IH0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTY2FuU3RyZWFtXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICByZWRpczogdGhpcyxcbiAgICAgICAgICAgIGNvbW1hbmQ6IGNvbW1hbmQsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmx1c2ggb2ZmbGluZSBxdWV1ZSBhbmQgY29tbWFuZCBxdWV1ZSB3aXRoIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVycm9yIFRoZSBlcnJvciBvYmplY3QgdG8gc2VuZCB0byB0aGUgY29tbWFuZHNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25zXG4gICAgICovXG4gICAgZmx1c2hRdWV1ZShlcnJvciwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gKDAsIGxvZGFzaF8xLmRlZmF1bHRzKSh7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgb2ZmbGluZVF1ZXVlOiB0cnVlLFxuICAgICAgICAgICAgY29tbWFuZFF1ZXVlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGl0ZW07XG4gICAgICAgIGlmIChvcHRpb25zLm9mZmxpbmVRdWV1ZSkge1xuICAgICAgICAgICAgd2hpbGUgKChpdGVtID0gdGhpcy5vZmZsaW5lUXVldWUuc2hpZnQoKSkpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmNvbW1hbmQucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jb21tYW5kUXVldWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbW1hbmRRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLnJlbW92ZUFsbExpc3RlbmVycyhcImRhdGFcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlICgoaXRlbSA9IHRoaXMuY29tbWFuZFF1ZXVlLnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uY29tbWFuZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIFJlZGlzIGhhcyBmaW5pc2hlZCBsb2FkaW5nIHRoZSBwZXJzaXN0ZW50IGRhdGEgYW5kIGlzIGFibGUgdG9cbiAgICAgKiBwcm9jZXNzIGNvbW1hbmRzLlxuICAgICAqL1xuICAgIF9yZWFkeUNoZWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5pbmZvKGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIubWVzc2FnZSAmJiBlcnIubWVzc2FnZS5pbmNsdWRlcyhcIk5PUEVSTVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFNraXBwaW5nIHRoZSByZWFkeSBjaGVjayBiZWNhdXNlIElORk8gY29tbWFuZCBmYWlsczogXCIke2Vyci5tZXNzYWdlfVwiLiBZb3UgY2FuIGRpc2FibGUgcmVhZHkgY2hlY2sgd2l0aCBcImVuYWJsZVJlYWR5Q2hlY2tcIi4gTW9yZTogaHR0cHM6Ly9naXRodWIuY29tL2x1aW4vaW9yZWRpcy93aWtpL0Rpc2FibGUtcmVhZHktY2hlY2suYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXMgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gcmVzLnNwbGl0KFwiXFxyXFxuXCIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtmaWVsZE5hbWUsIC4uLmZpZWxkVmFsdWVQYXJ0c10gPSBsaW5lc1tpXS5zcGxpdChcIjpcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRWYWx1ZSA9IGZpZWxkVmFsdWVQYXJ0cy5qb2luKFwiOlwiKTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpbmZvW2ZpZWxkTmFtZV0gPSBmaWVsZFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaW5mby5sb2FkaW5nIHx8IGluZm8ubG9hZGluZyA9PT0gXCIwXCIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBpbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRpbmdFdGFNcyA9IChpbmZvLmxvYWRpbmdfZXRhX3NlY29uZHMgfHwgMSkgKiAxMDAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldHJ5VGltZSA9IF90aGlzLm9wdGlvbnMubWF4TG9hZGluZ1JldHJ5VGltZSAmJlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vcHRpb25zLm1heExvYWRpbmdSZXRyeVRpbWUgPCBsb2FkaW5nRXRhTXNcbiAgICAgICAgICAgICAgICAgICAgPyBfdGhpcy5vcHRpb25zLm1heExvYWRpbmdSZXRyeVRpbWVcbiAgICAgICAgICAgICAgICAgICAgOiBsb2FkaW5nRXRhTXM7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJSZWRpcyBzZXJ2ZXIgc3RpbGwgbG9hZGluZywgdHJ5aW5nIGFnYWluIGluIFwiICsgcmV0cnlUaW1lICsgXCJtc1wiKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlYWR5Q2hlY2soY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0sIHJldHJ5VGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKGxvZGFzaF8xLm5vb3ApO1xuICAgIH1cbn1cblJlZGlzLkNsdXN0ZXIgPSBjbHVzdGVyXzEuZGVmYXVsdDtcblJlZGlzLkNvbW1hbmQgPSBDb21tYW5kXzEuZGVmYXVsdDtcbi8qKlxuICogRGVmYXVsdCBvcHRpb25zXG4gKi9cblJlZGlzLmRlZmF1bHRPcHRpb25zID0gUmVkaXNPcHRpb25zXzEuREVGQVVMVF9SRURJU19PUFRJT05TO1xuKDAsIGFwcGx5TWl4aW5fMS5kZWZhdWx0KShSZWRpcywgZXZlbnRzXzEuRXZlbnRFbWl0dGVyKTtcbigwLCB0cmFuc2FjdGlvbl8xLmFkZFRyYW5zYWN0aW9uU3VwcG9ydCkoUmVkaXMucHJvdG90eXBlKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJlZGlzO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY29tbWFuZHNfMSIsInJlcXVpcmUiLCJldmVudHNfMSIsInN0YW5kYXJkX2FzX2NhbGxiYWNrXzEiLCJjbHVzdGVyXzEiLCJDb21tYW5kXzEiLCJjb25uZWN0b3JzXzEiLCJTZW50aW5lbENvbm5lY3Rvcl8xIiwiZXZlbnRIYW5kbGVyIiwiUmVkaXNPcHRpb25zXzEiLCJTY2FuU3RyZWFtXzEiLCJ0cmFuc2FjdGlvbl8xIiwidXRpbHNfMSIsImFwcGx5TWl4aW5fMSIsIkNvbW1hbmRlcl8xIiwibG9kYXNoXzEiLCJEZXF1ZSIsImRlYnVnIiwiRGVidWciLCJSZWRpcyIsImRlZmF1bHQiLCJjb25zdHJ1Y3RvciIsImFyZzEiLCJhcmcyIiwiYXJnMyIsInN0YXR1cyIsImlzQ2x1c3RlciIsInJlY29ubmVjdFRpbWVvdXQiLCJjb25uZWN0aW9uRXBvY2giLCJyZXRyeUF0dGVtcHRzIiwibWFudWFsbHlDbG9zaW5nIiwiX2F1dG9QaXBlbGluZXMiLCJNYXAiLCJfcnVubmluZ0F1dG9QaXBlbGluZXMiLCJTZXQiLCJwYXJzZU9wdGlvbnMiLCJFdmVudEVtaXR0ZXIiLCJjYWxsIiwicmVzZXRDb21tYW5kUXVldWUiLCJyZXNldE9mZmxpbmVRdWV1ZSIsIm9wdGlvbnMiLCJDb25uZWN0b3IiLCJjb25uZWN0b3IiLCJzZW50aW5lbHMiLCJzZW50aW5lbENvbm5lY3RvciIsImVtaXR0ZXIiLCJTdGFuZGFsb25lQ29ubmVjdG9yIiwic2NyaXB0cyIsImVudHJpZXMiLCJmb3JFYWNoIiwibmFtZSIsImRlZmluaXRpb24iLCJkZWZpbmVDb21tYW5kIiwibGF6eUNvbm5lY3QiLCJzZXRTdGF0dXMiLCJjb25uZWN0IiwiY2F0Y2giLCJub29wIiwiY3JlYXRlQ2xpZW50IiwiYXJncyIsImF1dG9QaXBlbGluZVF1ZXVlU2l6ZSIsInF1ZXVlZCIsInBpcGVsaW5lIiwidmFsdWVzIiwibGVuZ3RoIiwiY2FsbGJhY2siLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJFcnJvciIsImNvbmRpdGlvbiIsInNlbGVjdCIsImRiIiwiYXV0aCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJzdWJzY3JpYmVyIiwiX3RoaXMiLCJ0eXBlIiwiZXJyIiwic2lsZW50RW1pdCIsInN0cmVhbSIsImZsdXNoUXVldWUiLCJDT05ORUNUX0VWRU5UIiwidGxzIiwiZW5hYmxlVExTRm9yU2VudGluZWxNb2RlIiwibm9EZWxheSIsInNldE5vRGVsYXkiLCJrZWVwQWxpdmUiLCJjb25uZWN0aW5nIiwib25jZSIsInNldEtlZXBBbGl2ZSIsImNvbm5lY3RIYW5kbGVyIiwiY29ubmVjdFRpbWVvdXQiLCJjb25uZWN0VGltZW91dENsZWFyZWQiLCJzZXRUaW1lb3V0IiwiZGVzdHJveSIsImVycm9ybm8iLCJjb2RlIiwic3lzY2FsbCIsImVycm9ySGFuZGxlciIsImRlc3Ryb3llZCIsImZpcnN0RXJyb3IiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJjbG9zZUhhbmRsZXIiLCJjb25uZWN0aW9uUmVhZHlIYW5kbGVyIiwicmVtb3ZlTGlzdGVuZXIiLCJjb25uZWN0aW9uQ2xvc2VIYW5kbGVyIiwiQ09OTkVDVElPTl9DTE9TRURfRVJST1JfTVNHIiwiZGlzY29ubmVjdCIsInJlY29ubmVjdCIsImNsZWFyVGltZW91dCIsImVuZCIsImR1cGxpY2F0ZSIsIm92ZXJyaWRlIiwibW9kZSIsIl9hIiwibW9uaXRvciIsIm1vbml0b3JJbnN0YW5jZSIsInNlbmRDb21tYW5kIiwiY29tbWFuZCIsIl9iIiwiY2hlY2tGbGFnIiwiY29tbWFuZFRpbWVvdXQiLCJ3cml0YWJsZSIsImV4aXN0cyIsImhhc0ZsYWciLCJfd3JpdGFibGVTdGF0ZSIsImVuZGVkIiwiZW5hYmxlT2ZmbGluZVF1ZXVlIiwib2ZmbGluZVF1ZXVlIiwiQnVmZmVyIiwiZnJvbSIsImVuYWJsZWQiLCJfZ2V0RGVzY3JpcHRpb24iLCJwdXNoIiwiaXNQaXBlbGluZSIsIndyaXRlIiwidG9Xcml0YWJsZSIsImRlc3RpbmF0aW9uIiwicmVkaXMiLCJjb21tYW5kUXVldWUiLCJzb2NrZXRUaW1lb3V0IiwidW5kZWZpbmVkIiwic29ja2V0VGltZW91dFRpbWVyIiwic2V0U29ja2V0VGltZW91dCIsImlzSW50IiwicGFyc2VJbnQiLCJlbWl0Iiwic2NhblN0cmVhbSIsImNyZWF0ZVNjYW5TdHJlYW0iLCJzY2FuQnVmZmVyU3RyZWFtIiwic3NjYW5TdHJlYW0iLCJrZXkiLCJzc2NhbkJ1ZmZlclN0cmVhbSIsImhzY2FuU3RyZWFtIiwiaHNjYW5CdWZmZXJTdHJlYW0iLCJ6c2NhblN0cmVhbSIsInpzY2FuQnVmZmVyU3RyZWFtIiwiZXZlbnROYW1lIiwiYXJnIiwiZXJyb3IiLCJtZXNzYWdlIiwibGlzdGVuZXJzIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJjb25zb2xlIiwic3RhY2siLCJyZWNvdmVyRnJvbUZhdGFsRXJyb3IiLCJfY29tbWFuZEVycm9yIiwiaGFuZGxlUmVjb25uZWN0aW9uIiwiaXRlbSIsIm5lZWRSZWNvbm5lY3QiLCJyZWNvbm5lY3RPbkVycm9yIiwiZGVzY3JpcHRpb24iLCJwYXRoIiwicmVtb3RlQWRkcmVzcyIsInJlbW90ZVBvcnQiLCJob3N0IiwicG9ydCIsImNvbm5lY3Rpb25OYW1lIiwiaXNUbHMiLCJpIiwiZGVmYXVsdHMiLCJwYXJzZVVSTCIsInN0YXJ0c1dpdGgiLCJkZWZhdWx0T3B0aW9ucyIsInJlc29sdmVUTFNQcm9maWxlIiwiYmluZCIsIm9iamVjdE1vZGUiLCJzaGlmdCIsInJlbW92ZUFsbExpc3RlbmVycyIsIl9yZWFkeUNoZWNrIiwiaW5mbyIsInJlcyIsImluY2x1ZGVzIiwid2FybiIsImxpbmVzIiwic3BsaXQiLCJmaWVsZE5hbWUiLCJmaWVsZFZhbHVlUGFydHMiLCJmaWVsZFZhbHVlIiwiam9pbiIsImxvYWRpbmciLCJsb2FkaW5nRXRhTXMiLCJsb2FkaW5nX2V0YV9zZWNvbmRzIiwicmV0cnlUaW1lIiwibWF4TG9hZGluZ1JldHJ5VGltZSIsIkNsdXN0ZXIiLCJDb21tYW5kIiwiREVGQVVMVF9SRURJU19PUFRJT05TIiwiYWRkVHJhbnNhY3Rpb25TdXBwb3J0IiwicHJvdG90eXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/Redis.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/ScanStream.js":
/*!**************************************************!*\
  !*** ./node_modules/ioredis/built/ScanStream.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\n/**\n * Convenient class to convert the process of scanning keys to a readable stream.\n */ class ScanStream extends stream_1.Readable {\n    constructor(opt){\n        super(opt);\n        this.opt = opt;\n        this._redisCursor = \"0\";\n        this._redisDrained = false;\n    }\n    _read() {\n        if (this._redisDrained) {\n            this.push(null);\n            return;\n        }\n        const args = [\n            this._redisCursor\n        ];\n        if (this.opt.key) {\n            args.unshift(this.opt.key);\n        }\n        if (this.opt.match) {\n            args.push(\"MATCH\", this.opt.match);\n        }\n        if (this.opt.type) {\n            args.push(\"TYPE\", this.opt.type);\n        }\n        if (this.opt.count) {\n            args.push(\"COUNT\", String(this.opt.count));\n        }\n        if (this.opt.noValues) {\n            args.push(\"NOVALUES\");\n        }\n        this.opt.redis[this.opt.command](args, (err, res)=>{\n            if (err) {\n                this.emit(\"error\", err);\n                return;\n            }\n            this._redisCursor = res[0] instanceof Buffer ? res[0].toString() : res[0];\n            if (this._redisCursor === \"0\") {\n                this._redisDrained = true;\n            }\n            this.push(res[1]);\n        });\n    }\n    close() {\n        this._redisDrained = true;\n    }\n}\nexports[\"default\"] = ScanStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9TY2FuU3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFdBQVdDLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pDOztDQUVDLEdBQ0QsTUFBTUMsbUJBQW1CRixTQUFTRyxRQUFRO0lBQ3RDQyxZQUFZQyxHQUFHLENBQUU7UUFDYixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQSxHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7SUFDekI7SUFDQUMsUUFBUTtRQUNKLElBQUksSUFBSSxDQUFDRCxhQUFhLEVBQUU7WUFDcEIsSUFBSSxDQUFDRSxJQUFJLENBQUM7WUFDVjtRQUNKO1FBQ0EsTUFBTUMsT0FBTztZQUFDLElBQUksQ0FBQ0osWUFBWTtTQUFDO1FBQ2hDLElBQUksSUFBSSxDQUFDRCxHQUFHLENBQUNNLEdBQUcsRUFBRTtZQUNkRCxLQUFLRSxPQUFPLENBQUMsSUFBSSxDQUFDUCxHQUFHLENBQUNNLEdBQUc7UUFDN0I7UUFDQSxJQUFJLElBQUksQ0FBQ04sR0FBRyxDQUFDUSxLQUFLLEVBQUU7WUFDaEJILEtBQUtELElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQ0osR0FBRyxDQUFDUSxLQUFLO1FBQ3JDO1FBQ0EsSUFBSSxJQUFJLENBQUNSLEdBQUcsQ0FBQ1MsSUFBSSxFQUFFO1lBQ2ZKLEtBQUtELElBQUksQ0FBQyxRQUFRLElBQUksQ0FBQ0osR0FBRyxDQUFDUyxJQUFJO1FBQ25DO1FBQ0EsSUFBSSxJQUFJLENBQUNULEdBQUcsQ0FBQ1UsS0FBSyxFQUFFO1lBQ2hCTCxLQUFLRCxJQUFJLENBQUMsU0FBU08sT0FBTyxJQUFJLENBQUNYLEdBQUcsQ0FBQ1UsS0FBSztRQUM1QztRQUNBLElBQUksSUFBSSxDQUFDVixHQUFHLENBQUNZLFFBQVEsRUFBRTtZQUNuQlAsS0FBS0QsSUFBSSxDQUFDO1FBQ2Q7UUFDQSxJQUFJLENBQUNKLEdBQUcsQ0FBQ2EsS0FBSyxDQUFDLElBQUksQ0FBQ2IsR0FBRyxDQUFDYyxPQUFPLENBQUMsQ0FBQ1QsTUFBTSxDQUFDVSxLQUFLQztZQUN6QyxJQUFJRCxLQUFLO2dCQUNMLElBQUksQ0FBQ0UsSUFBSSxDQUFDLFNBQVNGO2dCQUNuQjtZQUNKO1lBQ0EsSUFBSSxDQUFDZCxZQUFZLEdBQUdlLEdBQUcsQ0FBQyxFQUFFLFlBQVlFLFNBQVNGLEdBQUcsQ0FBQyxFQUFFLENBQUNHLFFBQVEsS0FBS0gsR0FBRyxDQUFDLEVBQUU7WUFDekUsSUFBSSxJQUFJLENBQUNmLFlBQVksS0FBSyxLQUFLO2dCQUMzQixJQUFJLENBQUNDLGFBQWEsR0FBRztZQUN6QjtZQUNBLElBQUksQ0FBQ0UsSUFBSSxDQUFDWSxHQUFHLENBQUMsRUFBRTtRQUNwQjtJQUNKO0lBQ0FJLFFBQVE7UUFDSixJQUFJLENBQUNsQixhQUFhLEdBQUc7SUFDekI7QUFDSjtBQUNBVCxrQkFBZSxHQUFHSSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L1NjYW5TdHJlYW0uanM/MzM4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbi8qKlxuICogQ29udmVuaWVudCBjbGFzcyB0byBjb252ZXJ0IHRoZSBwcm9jZXNzIG9mIHNjYW5uaW5nIGtleXMgdG8gYSByZWFkYWJsZSBzdHJlYW0uXG4gKi9cbmNsYXNzIFNjYW5TdHJlYW0gZXh0ZW5kcyBzdHJlYW1fMS5SZWFkYWJsZSB7XG4gICAgY29uc3RydWN0b3Iob3B0KSB7XG4gICAgICAgIHN1cGVyKG9wdCk7XG4gICAgICAgIHRoaXMub3B0ID0gb3B0O1xuICAgICAgICB0aGlzLl9yZWRpc0N1cnNvciA9IFwiMFwiO1xuICAgICAgICB0aGlzLl9yZWRpc0RyYWluZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgX3JlYWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZWRpc0RyYWluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaChudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmdzID0gW3RoaXMuX3JlZGlzQ3Vyc29yXTtcbiAgICAgICAgaWYgKHRoaXMub3B0LmtleSkge1xuICAgICAgICAgICAgYXJncy51bnNoaWZ0KHRoaXMub3B0LmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0Lm1hdGNoKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goXCJNQVRDSFwiLCB0aGlzLm9wdC5tYXRjaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0LnR5cGUpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChcIlRZUEVcIiwgdGhpcy5vcHQudHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0LmNvdW50KSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goXCJDT1VOVFwiLCBTdHJpbmcodGhpcy5vcHQuY291bnQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHQubm9WYWx1ZXMpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChcIk5PVkFMVUVTXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0LnJlZGlzW3RoaXMub3B0LmNvbW1hbmRdKGFyZ3MsIChlcnIsIHJlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVkaXNDdXJzb3IgPSByZXNbMF0gaW5zdGFuY2VvZiBCdWZmZXIgPyByZXNbMF0udG9TdHJpbmcoKSA6IHJlc1swXTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZWRpc0N1cnNvciA9PT0gXCIwXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWRpc0RyYWluZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wdXNoKHJlc1sxXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5fcmVkaXNEcmFpbmVkID0gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBTY2FuU3RyZWFtO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic3RyZWFtXzEiLCJyZXF1aXJlIiwiU2NhblN0cmVhbSIsIlJlYWRhYmxlIiwiY29uc3RydWN0b3IiLCJvcHQiLCJfcmVkaXNDdXJzb3IiLCJfcmVkaXNEcmFpbmVkIiwiX3JlYWQiLCJwdXNoIiwiYXJncyIsImtleSIsInVuc2hpZnQiLCJtYXRjaCIsInR5cGUiLCJjb3VudCIsIlN0cmluZyIsIm5vVmFsdWVzIiwicmVkaXMiLCJjb21tYW5kIiwiZXJyIiwicmVzIiwiZW1pdCIsIkJ1ZmZlciIsInRvU3RyaW5nIiwiY2xvc2UiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/ScanStream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/Script.js":
/*!**********************************************!*\
  !*** ./node_modules/ioredis/built/Script.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nconst Command_1 = __webpack_require__(/*! ./Command */ \"(rsc)/./node_modules/ioredis/built/Command.js\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/./node_modules/standard-as-callback/built/index.js\");\nclass Script {\n    constructor(lua, numberOfKeys = null, keyPrefix = \"\", readOnly = false){\n        this.lua = lua;\n        this.numberOfKeys = numberOfKeys;\n        this.keyPrefix = keyPrefix;\n        this.readOnly = readOnly;\n        this.sha = (0, crypto_1.createHash)(\"sha1\").update(lua).digest(\"hex\");\n        const sha = this.sha;\n        const socketHasScriptLoaded = new WeakSet();\n        this.Command = class CustomScriptCommand extends Command_1.default {\n            toWritable(socket) {\n                const origReject = this.reject;\n                this.reject = (err)=>{\n                    if (err.message.indexOf(\"NOSCRIPT\") !== -1) {\n                        socketHasScriptLoaded.delete(socket);\n                    }\n                    origReject.call(this, err);\n                };\n                if (!socketHasScriptLoaded.has(socket)) {\n                    socketHasScriptLoaded.add(socket);\n                    this.name = \"eval\";\n                    this.args[0] = lua;\n                } else if (this.name === \"eval\") {\n                    this.name = \"evalsha\";\n                    this.args[0] = sha;\n                }\n                return super.toWritable(socket);\n            }\n        };\n    }\n    execute(container, args, options, callback) {\n        if (typeof this.numberOfKeys === \"number\") {\n            args.unshift(this.numberOfKeys);\n        }\n        if (this.keyPrefix) {\n            options.keyPrefix = this.keyPrefix;\n        }\n        if (this.readOnly) {\n            options.readOnly = true;\n        }\n        const evalsha = new this.Command(\"evalsha\", [\n            this.sha,\n            ...args\n        ], options);\n        evalsha.promise = evalsha.promise.catch((err)=>{\n            if (err.message.indexOf(\"NOSCRIPT\") === -1) {\n                throw err;\n            }\n            // Resend the same custom evalsha command that gets transformed\n            // to an eval in case it's not loaded yet on the connection.\n            const resend = new this.Command(\"evalsha\", [\n                this.sha,\n                ...args\n            ], options);\n            const client = container.isPipeline ? container.redis : container;\n            return client.sendCommand(resend);\n        });\n        (0, standard_as_callback_1.default)(evalsha.promise, callback);\n        return container.sendCommand(evalsha);\n    }\n}\nexports[\"default\"] = Script;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9TY3JpcHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsV0FBV0MsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUMsWUFBWUQsbUJBQU9BLENBQUMsZ0VBQVc7QUFDckMsTUFBTUUseUJBQXlCRixtQkFBT0EsQ0FBQyxzRkFBc0I7QUFDN0QsTUFBTUc7SUFDRkMsWUFBWUMsR0FBRyxFQUFFQyxlQUFlLElBQUksRUFBRUMsWUFBWSxFQUFFLEVBQUVDLFdBQVcsS0FBSyxDQUFFO1FBQ3BFLElBQUksQ0FBQ0gsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0MsWUFBWSxHQUFHQTtRQUNwQixJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDQyxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0MsR0FBRyxHQUFHLENBQUMsR0FBR1YsU0FBU1csVUFBVSxFQUFFLFFBQVFDLE1BQU0sQ0FBQ04sS0FBS08sTUFBTSxDQUFDO1FBQy9ELE1BQU1ILE1BQU0sSUFBSSxDQUFDQSxHQUFHO1FBQ3BCLE1BQU1JLHdCQUF3QixJQUFJQztRQUNsQyxJQUFJLENBQUNDLE9BQU8sR0FBRyxNQUFNQyw0QkFBNEJmLFVBQVVnQixPQUFPO1lBQzlEQyxXQUFXQyxNQUFNLEVBQUU7Z0JBQ2YsTUFBTUMsYUFBYSxJQUFJLENBQUNDLE1BQU07Z0JBQzlCLElBQUksQ0FBQ0EsTUFBTSxHQUFHLENBQUNDO29CQUNYLElBQUlBLElBQUlDLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDLGdCQUFnQixDQUFDLEdBQUc7d0JBQ3hDWCxzQkFBc0JZLE1BQU0sQ0FBQ047b0JBQ2pDO29CQUNBQyxXQUFXTSxJQUFJLENBQUMsSUFBSSxFQUFFSjtnQkFDMUI7Z0JBQ0EsSUFBSSxDQUFDVCxzQkFBc0JjLEdBQUcsQ0FBQ1IsU0FBUztvQkFDcENOLHNCQUFzQmUsR0FBRyxDQUFDVDtvQkFDMUIsSUFBSSxDQUFDVSxJQUFJLEdBQUc7b0JBQ1osSUFBSSxDQUFDQyxJQUFJLENBQUMsRUFBRSxHQUFHekI7Z0JBQ25CLE9BQ0ssSUFBSSxJQUFJLENBQUN3QixJQUFJLEtBQUssUUFBUTtvQkFDM0IsSUFBSSxDQUFDQSxJQUFJLEdBQUc7b0JBQ1osSUFBSSxDQUFDQyxJQUFJLENBQUMsRUFBRSxHQUFHckI7Z0JBQ25CO2dCQUNBLE9BQU8sS0FBSyxDQUFDUyxXQUFXQztZQUM1QjtRQUNKO0lBQ0o7SUFDQVksUUFBUUMsU0FBUyxFQUFFRixJQUFJLEVBQUVHLE9BQU8sRUFBRUMsUUFBUSxFQUFFO1FBQ3hDLElBQUksT0FBTyxJQUFJLENBQUM1QixZQUFZLEtBQUssVUFBVTtZQUN2Q3dCLEtBQUtLLE9BQU8sQ0FBQyxJQUFJLENBQUM3QixZQUFZO1FBQ2xDO1FBQ0EsSUFBSSxJQUFJLENBQUNDLFNBQVMsRUFBRTtZQUNoQjBCLFFBQVExQixTQUFTLEdBQUcsSUFBSSxDQUFDQSxTQUFTO1FBQ3RDO1FBQ0EsSUFBSSxJQUFJLENBQUNDLFFBQVEsRUFBRTtZQUNmeUIsUUFBUXpCLFFBQVEsR0FBRztRQUN2QjtRQUNBLE1BQU00QixVQUFVLElBQUksSUFBSSxDQUFDckIsT0FBTyxDQUFDLFdBQVc7WUFBQyxJQUFJLENBQUNOLEdBQUc7ZUFBS3FCO1NBQUssRUFBRUc7UUFDakVHLFFBQVFDLE9BQU8sR0FBR0QsUUFBUUMsT0FBTyxDQUFDQyxLQUFLLENBQUMsQ0FBQ2hCO1lBQ3JDLElBQUlBLElBQUlDLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDLGdCQUFnQixDQUFDLEdBQUc7Z0JBQ3hDLE1BQU1GO1lBQ1Y7WUFDQSwrREFBK0Q7WUFDL0QsNERBQTREO1lBQzVELE1BQU1pQixTQUFTLElBQUksSUFBSSxDQUFDeEIsT0FBTyxDQUFDLFdBQVc7Z0JBQUMsSUFBSSxDQUFDTixHQUFHO21CQUFLcUI7YUFBSyxFQUFFRztZQUNoRSxNQUFNTyxTQUFTUixVQUFVUyxVQUFVLEdBQUdULFVBQVVVLEtBQUssR0FBR1Y7WUFDeEQsT0FBT1EsT0FBT0csV0FBVyxDQUFDSjtRQUM5QjtRQUNDLElBQUdyQyx1QkFBdUJlLE9BQU8sRUFBRW1CLFFBQVFDLE9BQU8sRUFBRUg7UUFDckQsT0FBT0YsVUFBVVcsV0FBVyxDQUFDUDtJQUNqQztBQUNKO0FBQ0F2QyxrQkFBZSxHQUFHTSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L1NjcmlwdC5qcz9mOTgwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xuY29uc3QgQ29tbWFuZF8xID0gcmVxdWlyZShcIi4vQ29tbWFuZFwiKTtcbmNvbnN0IHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEgPSByZXF1aXJlKFwic3RhbmRhcmQtYXMtY2FsbGJhY2tcIik7XG5jbGFzcyBTY3JpcHQge1xuICAgIGNvbnN0cnVjdG9yKGx1YSwgbnVtYmVyT2ZLZXlzID0gbnVsbCwga2V5UHJlZml4ID0gXCJcIiwgcmVhZE9ubHkgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmx1YSA9IGx1YTtcbiAgICAgICAgdGhpcy5udW1iZXJPZktleXMgPSBudW1iZXJPZktleXM7XG4gICAgICAgIHRoaXMua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICAgICAgICB0aGlzLnJlYWRPbmx5ID0gcmVhZE9ubHk7XG4gICAgICAgIHRoaXMuc2hhID0gKDAsIGNyeXB0b18xLmNyZWF0ZUhhc2gpKFwic2hhMVwiKS51cGRhdGUobHVhKS5kaWdlc3QoXCJoZXhcIik7XG4gICAgICAgIGNvbnN0IHNoYSA9IHRoaXMuc2hhO1xuICAgICAgICBjb25zdCBzb2NrZXRIYXNTY3JpcHRMb2FkZWQgPSBuZXcgV2Vha1NldCgpO1xuICAgICAgICB0aGlzLkNvbW1hbmQgPSBjbGFzcyBDdXN0b21TY3JpcHRDb21tYW5kIGV4dGVuZHMgQ29tbWFuZF8xLmRlZmF1bHQge1xuICAgICAgICAgICAgdG9Xcml0YWJsZShzb2NrZXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnUmVqZWN0ID0gdGhpcy5yZWplY3Q7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3QgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIubWVzc2FnZS5pbmRleE9mKFwiTk9TQ1JJUFRcIikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXRIYXNTY3JpcHRMb2FkZWQuZGVsZXRlKHNvY2tldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3JpZ1JlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoIXNvY2tldEhhc1NjcmlwdExvYWRlZC5oYXMoc29ja2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXRIYXNTY3JpcHRMb2FkZWQuYWRkKHNvY2tldCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IFwiZXZhbFwiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFyZ3NbMF0gPSBsdWE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubmFtZSA9PT0gXCJldmFsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gXCJldmFsc2hhXCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXJnc1swXSA9IHNoYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnRvV3JpdGFibGUoc29ja2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZXhlY3V0ZShjb250YWluZXIsIGFyZ3MsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5udW1iZXJPZktleXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGFyZ3MudW5zaGlmdCh0aGlzLm51bWJlck9mS2V5cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMua2V5UHJlZml4KSB7XG4gICAgICAgICAgICBvcHRpb25zLmtleVByZWZpeCA9IHRoaXMua2V5UHJlZml4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICBvcHRpb25zLnJlYWRPbmx5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmFsc2hhID0gbmV3IHRoaXMuQ29tbWFuZChcImV2YWxzaGFcIiwgW3RoaXMuc2hhLCAuLi5hcmdzXSwgb3B0aW9ucyk7XG4gICAgICAgIGV2YWxzaGEucHJvbWlzZSA9IGV2YWxzaGEucHJvbWlzZS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyLm1lc3NhZ2UuaW5kZXhPZihcIk5PU0NSSVBUXCIpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlc2VuZCB0aGUgc2FtZSBjdXN0b20gZXZhbHNoYSBjb21tYW5kIHRoYXQgZ2V0cyB0cmFuc2Zvcm1lZFxuICAgICAgICAgICAgLy8gdG8gYW4gZXZhbCBpbiBjYXNlIGl0J3Mgbm90IGxvYWRlZCB5ZXQgb24gdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICBjb25zdCByZXNlbmQgPSBuZXcgdGhpcy5Db21tYW5kKFwiZXZhbHNoYVwiLCBbdGhpcy5zaGEsIC4uLmFyZ3NdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IGNvbnRhaW5lci5pc1BpcGVsaW5lID8gY29udGFpbmVyLnJlZGlzIDogY29udGFpbmVyO1xuICAgICAgICAgICAgcmV0dXJuIGNsaWVudC5zZW5kQ29tbWFuZChyZXNlbmQpO1xuICAgICAgICB9KTtcbiAgICAgICAgKDAsIHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEuZGVmYXVsdCkoZXZhbHNoYS5wcm9taXNlLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBjb250YWluZXIuc2VuZENvbW1hbmQoZXZhbHNoYSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gU2NyaXB0O1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY3J5cHRvXzEiLCJyZXF1aXJlIiwiQ29tbWFuZF8xIiwic3RhbmRhcmRfYXNfY2FsbGJhY2tfMSIsIlNjcmlwdCIsImNvbnN0cnVjdG9yIiwibHVhIiwibnVtYmVyT2ZLZXlzIiwia2V5UHJlZml4IiwicmVhZE9ubHkiLCJzaGEiLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwiZGlnZXN0Iiwic29ja2V0SGFzU2NyaXB0TG9hZGVkIiwiV2Vha1NldCIsIkNvbW1hbmQiLCJDdXN0b21TY3JpcHRDb21tYW5kIiwiZGVmYXVsdCIsInRvV3JpdGFibGUiLCJzb2NrZXQiLCJvcmlnUmVqZWN0IiwicmVqZWN0IiwiZXJyIiwibWVzc2FnZSIsImluZGV4T2YiLCJkZWxldGUiLCJjYWxsIiwiaGFzIiwiYWRkIiwibmFtZSIsImFyZ3MiLCJleGVjdXRlIiwiY29udGFpbmVyIiwib3B0aW9ucyIsImNhbGxiYWNrIiwidW5zaGlmdCIsImV2YWxzaGEiLCJwcm9taXNlIiwiY2F0Y2giLCJyZXNlbmQiLCJjbGllbnQiLCJpc1BpcGVsaW5lIiwicmVkaXMiLCJzZW5kQ29tbWFuZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/Script.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/SubscriptionSet.js":
/*!*******************************************************!*\
  !*** ./node_modules/ioredis/built/SubscriptionSet.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n/**\n * Tiny class to simplify dealing with subscription set\n */ class SubscriptionSet {\n    constructor(){\n        this.set = {\n            subscribe: {},\n            psubscribe: {},\n            ssubscribe: {}\n        };\n    }\n    add(set, channel) {\n        this.set[mapSet(set)][channel] = true;\n    }\n    del(set, channel) {\n        delete this.set[mapSet(set)][channel];\n    }\n    channels(set) {\n        return Object.keys(this.set[mapSet(set)]);\n    }\n    isEmpty() {\n        return this.channels(\"subscribe\").length === 0 && this.channels(\"psubscribe\").length === 0 && this.channels(\"ssubscribe\").length === 0;\n    }\n}\nexports[\"default\"] = SubscriptionSet;\nfunction mapSet(set) {\n    if (set === \"unsubscribe\") {\n        return \"subscribe\";\n    }\n    if (set === \"punsubscribe\") {\n        return \"psubscribe\";\n    }\n    if (set === \"sunsubscribe\") {\n        return \"ssubscribe\";\n    }\n    return set;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9TdWJzY3JpcHRpb25TZXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0Q7O0NBRUMsR0FDRCxNQUFNQztJQUNGQyxhQUFjO1FBQ1YsSUFBSSxDQUFDQyxHQUFHLEdBQUc7WUFDUEMsV0FBVyxDQUFDO1lBQ1pDLFlBQVksQ0FBQztZQUNiQyxZQUFZLENBQUM7UUFDakI7SUFDSjtJQUNBQyxJQUFJSixHQUFHLEVBQUVLLE9BQU8sRUFBRTtRQUNkLElBQUksQ0FBQ0wsR0FBRyxDQUFDTSxPQUFPTixLQUFLLENBQUNLLFFBQVEsR0FBRztJQUNyQztJQUNBRSxJQUFJUCxHQUFHLEVBQUVLLE9BQU8sRUFBRTtRQUNkLE9BQU8sSUFBSSxDQUFDTCxHQUFHLENBQUNNLE9BQU9OLEtBQUssQ0FBQ0ssUUFBUTtJQUN6QztJQUNBRyxTQUFTUixHQUFHLEVBQUU7UUFDVixPQUFPTixPQUFPZSxJQUFJLENBQUMsSUFBSSxDQUFDVCxHQUFHLENBQUNNLE9BQU9OLEtBQUs7SUFDNUM7SUFDQVUsVUFBVTtRQUNOLE9BQVEsSUFBSSxDQUFDRixRQUFRLENBQUMsYUFBYUcsTUFBTSxLQUFLLEtBQzFDLElBQUksQ0FBQ0gsUUFBUSxDQUFDLGNBQWNHLE1BQU0sS0FBSyxLQUN2QyxJQUFJLENBQUNILFFBQVEsQ0FBQyxjQUFjRyxNQUFNLEtBQUs7SUFDL0M7QUFDSjtBQUNBZixrQkFBZSxHQUFHRTtBQUNsQixTQUFTUSxPQUFPTixHQUFHO0lBQ2YsSUFBSUEsUUFBUSxlQUFlO1FBQ3ZCLE9BQU87SUFDWDtJQUNBLElBQUlBLFFBQVEsZ0JBQWdCO1FBQ3hCLE9BQU87SUFDWDtJQUNBLElBQUlBLFFBQVEsZ0JBQWdCO1FBQ3hCLE9BQU87SUFDWDtJQUNBLE9BQU9BO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9TdWJzY3JpcHRpb25TZXQuanM/ZjFmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogVGlueSBjbGFzcyB0byBzaW1wbGlmeSBkZWFsaW5nIHdpdGggc3Vic2NyaXB0aW9uIHNldFxuICovXG5jbGFzcyBTdWJzY3JpcHRpb25TZXQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNldCA9IHtcbiAgICAgICAgICAgIHN1YnNjcmliZToge30sXG4gICAgICAgICAgICBwc3Vic2NyaWJlOiB7fSxcbiAgICAgICAgICAgIHNzdWJzY3JpYmU6IHt9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhZGQoc2V0LCBjaGFubmVsKSB7XG4gICAgICAgIHRoaXMuc2V0W21hcFNldChzZXQpXVtjaGFubmVsXSA9IHRydWU7XG4gICAgfVxuICAgIGRlbChzZXQsIGNoYW5uZWwpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2V0W21hcFNldChzZXQpXVtjaGFubmVsXTtcbiAgICB9XG4gICAgY2hhbm5lbHMoc2V0KSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnNldFttYXBTZXQoc2V0KV0pO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuY2hhbm5lbHMoXCJzdWJzY3JpYmVcIikubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzKFwicHN1YnNjcmliZVwiKS5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHMoXCJzc3Vic2NyaWJlXCIpLmxlbmd0aCA9PT0gMCk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gU3Vic2NyaXB0aW9uU2V0O1xuZnVuY3Rpb24gbWFwU2V0KHNldCkge1xuICAgIGlmIChzZXQgPT09IFwidW5zdWJzY3JpYmVcIikge1xuICAgICAgICByZXR1cm4gXCJzdWJzY3JpYmVcIjtcbiAgICB9XG4gICAgaWYgKHNldCA9PT0gXCJwdW5zdWJzY3JpYmVcIikge1xuICAgICAgICByZXR1cm4gXCJwc3Vic2NyaWJlXCI7XG4gICAgfVxuICAgIGlmIChzZXQgPT09IFwic3Vuc3Vic2NyaWJlXCIpIHtcbiAgICAgICAgcmV0dXJuIFwic3N1YnNjcmliZVwiO1xuICAgIH1cbiAgICByZXR1cm4gc2V0O1xufVxuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU3Vic2NyaXB0aW9uU2V0IiwiY29uc3RydWN0b3IiLCJzZXQiLCJzdWJzY3JpYmUiLCJwc3Vic2NyaWJlIiwic3N1YnNjcmliZSIsImFkZCIsImNoYW5uZWwiLCJtYXBTZXQiLCJkZWwiLCJjaGFubmVscyIsImtleXMiLCJpc0VtcHR5IiwibGVuZ3RoIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/SubscriptionSet.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/autoPipelining.js":
/*!******************************************************!*\
  !*** ./node_modules/ioredis/built/autoPipelining.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.executeWithAutoPipelining = exports.getFirstValueInFlattenedArray = exports.shouldUseAutoPipelining = exports.notAllowedAutoPipelineCommands = exports.kCallbacks = exports.kExec = void 0;\nconst lodash_1 = __webpack_require__(/*! ./utils/lodash */ \"(rsc)/./node_modules/ioredis/built/utils/lodash.js\");\nconst calculateSlot = __webpack_require__(/*! cluster-key-slot */ \"(rsc)/./node_modules/cluster-key-slot/lib/index.js\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/./node_modules/standard-as-callback/built/index.js\");\nexports.kExec = Symbol(\"exec\");\nexports.kCallbacks = Symbol(\"callbacks\");\nexports.notAllowedAutoPipelineCommands = [\n    \"auth\",\n    \"info\",\n    \"script\",\n    \"quit\",\n    \"cluster\",\n    \"pipeline\",\n    \"multi\",\n    \"subscribe\",\n    \"psubscribe\",\n    \"unsubscribe\",\n    \"unpsubscribe\",\n    \"select\"\n];\nfunction executeAutoPipeline(client, slotKey) {\n    /*\n      If a pipeline is already executing, keep queueing up commands\n      since ioredis won't serve two pipelines at the same time\n    */ if (client._runningAutoPipelines.has(slotKey)) {\n        return;\n    }\n    if (!client._autoPipelines.has(slotKey)) {\n        /*\n          Rare edge case. Somehow, something has deleted this running autopipeline in an immediate\n          call to executeAutoPipeline.\n         \n          Maybe the callback in the pipeline.exec is sometimes called in the same tick,\n          e.g. if redis is disconnected?\n        */ return;\n    }\n    client._runningAutoPipelines.add(slotKey);\n    // Get the pipeline and immediately delete it so that new commands are queued on a new pipeline\n    const pipeline = client._autoPipelines.get(slotKey);\n    client._autoPipelines.delete(slotKey);\n    const callbacks = pipeline[exports.kCallbacks];\n    // Stop keeping a reference to callbacks immediately after the callbacks stop being used.\n    // This allows the GC to reclaim objects referenced by callbacks, especially with 16384 slots\n    // in Redis.Cluster\n    pipeline[exports.kCallbacks] = null;\n    // Perform the call\n    pipeline.exec(function(err, results) {\n        client._runningAutoPipelines.delete(slotKey);\n        /*\n          Invoke all callback in nextTick so the stack is cleared\n          and callbacks can throw errors without affecting other callbacks.\n        */ if (err) {\n            for(let i = 0; i < callbacks.length; i++){\n                process.nextTick(callbacks[i], err);\n            }\n        } else {\n            for(let i = 0; i < callbacks.length; i++){\n                process.nextTick(callbacks[i], ...results[i]);\n            }\n        }\n        // If there is another pipeline on the same node, immediately execute it without waiting for nextTick\n        if (client._autoPipelines.has(slotKey)) {\n            executeAutoPipeline(client, slotKey);\n        }\n    });\n}\nfunction shouldUseAutoPipelining(client, functionName, commandName) {\n    return functionName && client.options.enableAutoPipelining && !client.isPipeline && !exports.notAllowedAutoPipelineCommands.includes(commandName) && !client.options.autoPipeliningIgnoredCommands.includes(commandName);\n}\nexports.shouldUseAutoPipelining = shouldUseAutoPipelining;\nfunction getFirstValueInFlattenedArray(args) {\n    for(let i = 0; i < args.length; i++){\n        const arg = args[i];\n        if (typeof arg === \"string\") {\n            return arg;\n        } else if (Array.isArray(arg) || (0, lodash_1.isArguments)(arg)) {\n            if (arg.length === 0) {\n                continue;\n            }\n            return arg[0];\n        }\n        const flattened = [\n            arg\n        ].flat();\n        if (flattened.length > 0) {\n            return flattened[0];\n        }\n    }\n    return undefined;\n}\nexports.getFirstValueInFlattenedArray = getFirstValueInFlattenedArray;\nfunction executeWithAutoPipelining(client, functionName, commandName, args, callback) {\n    // On cluster mode let's wait for slots to be available\n    if (client.isCluster && !client.slots.length) {\n        if (client.status === \"wait\") client.connect().catch(lodash_1.noop);\n        return (0, standard_as_callback_1.default)(new Promise(function(resolve, reject) {\n            client.delayUntilReady((err)=>{\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                executeWithAutoPipelining(client, functionName, commandName, args, null).then(resolve, reject);\n            });\n        }), callback);\n    }\n    // If we have slot information, we can improve routing by grouping slots served by the same subset of nodes\n    // Note that the first value in args may be a (possibly empty) array.\n    // ioredis will only flatten one level of the array, in the Command constructor.\n    const prefix = client.options.keyPrefix || \"\";\n    const slotKey = client.isCluster ? client.slots[calculateSlot(`${prefix}${getFirstValueInFlattenedArray(args)}`)].join(\",\") : \"main\";\n    if (!client._autoPipelines.has(slotKey)) {\n        const pipeline = client.pipeline();\n        pipeline[exports.kExec] = false;\n        pipeline[exports.kCallbacks] = [];\n        client._autoPipelines.set(slotKey, pipeline);\n    }\n    const pipeline = client._autoPipelines.get(slotKey);\n    /*\n      Mark the pipeline as scheduled.\n      The symbol will make sure that the pipeline is only scheduled once per tick.\n      New commands are appended to an already scheduled pipeline.\n    */ if (!pipeline[exports.kExec]) {\n        pipeline[exports.kExec] = true;\n        /*\n          Deferring with setImmediate so we have a chance to capture multiple\n          commands that can be scheduled by I/O events already in the event loop queue.\n        */ setImmediate(executeAutoPipeline, client, slotKey);\n    }\n    // Create the promise which will execute the command in the pipeline.\n    const autoPipelinePromise = new Promise(function(resolve, reject) {\n        pipeline[exports.kCallbacks].push(function(err, value) {\n            if (err) {\n                reject(err);\n                return;\n            }\n            resolve(value);\n        });\n        if (functionName === \"call\") {\n            args.unshift(commandName);\n        }\n        pipeline[functionName](...args);\n    });\n    return (0, standard_as_callback_1.default)(autoPipelinePromise, callback);\n}\nexports.executeWithAutoPipelining = executeWithAutoPipelining;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9hdXRvUGlwZWxpbmluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUNBQWlDLEdBQUdBLHFDQUFxQyxHQUFHQSwrQkFBK0IsR0FBR0Esc0NBQXNDLEdBQUdBLGtCQUFrQixHQUFHQSxhQUFhLEdBQUcsS0FBSztBQUNqTSxNQUFNUSxXQUFXQyxtQkFBT0EsQ0FBQywwRUFBZ0I7QUFDekMsTUFBTUMsZ0JBQWdCRCxtQkFBT0EsQ0FBQyw0RUFBa0I7QUFDaEQsTUFBTUUseUJBQXlCRixtQkFBT0EsQ0FBQyxzRkFBc0I7QUFDN0RULGFBQWEsR0FBR1ksT0FBTztBQUN2Qlosa0JBQWtCLEdBQUdZLE9BQU87QUFDNUJaLHNDQUFzQyxHQUFHO0lBQ3JDO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNIO0FBQ0QsU0FBU2Esb0JBQW9CQyxNQUFNLEVBQUVDLE9BQU87SUFDeEM7OztJQUdBLEdBQ0EsSUFBSUQsT0FBT0UscUJBQXFCLENBQUNDLEdBQUcsQ0FBQ0YsVUFBVTtRQUMzQztJQUNKO0lBQ0EsSUFBSSxDQUFDRCxPQUFPSSxjQUFjLENBQUNELEdBQUcsQ0FBQ0YsVUFBVTtRQUNyQzs7Ozs7O1FBTUEsR0FDQTtJQUNKO0lBQ0FELE9BQU9FLHFCQUFxQixDQUFDRyxHQUFHLENBQUNKO0lBQ2pDLCtGQUErRjtJQUMvRixNQUFNSyxXQUFXTixPQUFPSSxjQUFjLENBQUNHLEdBQUcsQ0FBQ047SUFDM0NELE9BQU9JLGNBQWMsQ0FBQ0ksTUFBTSxDQUFDUDtJQUM3QixNQUFNUSxZQUFZSCxRQUFRLENBQUNwQixRQUFRTSxVQUFVLENBQUM7SUFDOUMseUZBQXlGO0lBQ3pGLDZGQUE2RjtJQUM3RixtQkFBbUI7SUFDbkJjLFFBQVEsQ0FBQ3BCLFFBQVFNLFVBQVUsQ0FBQyxHQUFH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QUE4Qm1DLE1BQU0sQ0FBQyxFQUFFLENBQUN1QixJQUFJLENBQUMsT0FDcEY7SUFDTixJQUFJLENBQUMvQyxPQUFPSSxjQUFjLENBQUNELEdBQUcsQ0FBQ0YsVUFBVTtRQUNyQyxNQUFNSyxXQUFXTixPQUFPTSxRQUFRO1FBQ2hDQSxRQUFRLENBQUNwQixRQUFRTyxLQUFLLENBQUMsR0FBRztRQUMxQmEsUUFBUSxDQUFDcEIsUUFBUU0sVUFBVSxDQUFDLEdBQUcsRUFBRTtRQUNqQ1EsT0FBT0ksY0FBYyxDQUFDNEMsR0FBRyxDQUFDL0MsU0FBU0s7SUFDdkM7SUFDQSxNQUFNQSxXQUFXTixPQUFPSSxjQUFjLENBQUNHLEdBQUcsQ0FBQ047SUFDM0M7Ozs7SUFJQSxHQUNBLElBQUksQ0FBQ0ssUUFBUSxDQUFDcEIsUUFBUU8sS0FBSyxDQUFDLEVBQUU7UUFDMUJhLFFBQVEsQ0FBQ3BCLFFBQVFPLEtBQUssQ0FBQyxHQUFHO1FBQzFCOzs7UUFHQSxHQUNBd0QsYUFBYWxELHFCQUFxQkMsUUFBUUM7SUFDOUM7SUFDQSxxRUFBcUU7SUFDckUsTUFBTWlELHNCQUFzQixJQUFJVixRQUFRLFNBQVVDLE9BQU8sRUFBRUMsTUFBTTtRQUM3RHBDLFFBQVEsQ0FBQ3BCLFFBQVFNLFVBQVUsQ0FBQyxDQUFDMkQsSUFBSSxDQUFDLFNBQVV4QyxHQUFHLEVBQUV4QixLQUFLO1lBQ2xELElBQUl3QixLQUFLO2dCQUNMK0IsT0FBTy9CO2dCQUNQO1lBQ0o7WUFDQThCLFFBQVF0RDtRQUNaO1FBQ0EsSUFBSThCLGlCQUFpQixRQUFRO1lBQ3pCTyxLQUFLNEIsT0FBTyxDQUFDbEM7UUFDakI7UUFDQVosUUFBUSxDQUFDVyxhQUFhLElBQUlPO0lBQzlCO0lBQ0EsT0FBTyxDQUFDLEdBQUczQix1QkFBdUIwQyxPQUFPLEVBQUVXLHFCQUFxQmxCO0FBQ3BFO0FBQ0E5QyxpQ0FBaUMsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9hdXRvUGlwZWxpbmluZy5qcz8xODQ4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leGVjdXRlV2l0aEF1dG9QaXBlbGluaW5nID0gZXhwb3J0cy5nZXRGaXJzdFZhbHVlSW5GbGF0dGVuZWRBcnJheSA9IGV4cG9ydHMuc2hvdWxkVXNlQXV0b1BpcGVsaW5pbmcgPSBleHBvcnRzLm5vdEFsbG93ZWRBdXRvUGlwZWxpbmVDb21tYW5kcyA9IGV4cG9ydHMua0NhbGxiYWNrcyA9IGV4cG9ydHMua0V4ZWMgPSB2b2lkIDA7XG5jb25zdCBsb2Rhc2hfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2xvZGFzaFwiKTtcbmNvbnN0IGNhbGN1bGF0ZVNsb3QgPSByZXF1aXJlKFwiY2x1c3Rlci1rZXktc2xvdFwiKTtcbmNvbnN0IHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEgPSByZXF1aXJlKFwic3RhbmRhcmQtYXMtY2FsbGJhY2tcIik7XG5leHBvcnRzLmtFeGVjID0gU3ltYm9sKFwiZXhlY1wiKTtcbmV4cG9ydHMua0NhbGxiYWNrcyA9IFN5bWJvbChcImNhbGxiYWNrc1wiKTtcbmV4cG9ydHMubm90QWxsb3dlZEF1dG9QaXBlbGluZUNvbW1hbmRzID0gW1xuICAgIFwiYXV0aFwiLFxuICAgIFwiaW5mb1wiLFxuICAgIFwic2NyaXB0XCIsXG4gICAgXCJxdWl0XCIsXG4gICAgXCJjbHVzdGVyXCIsXG4gICAgXCJwaXBlbGluZVwiLFxuICAgIFwibXVsdGlcIixcbiAgICBcInN1YnNjcmliZVwiLFxuICAgIFwicHN1YnNjcmliZVwiLFxuICAgIFwidW5zdWJzY3JpYmVcIixcbiAgICBcInVucHN1YnNjcmliZVwiLFxuICAgIFwic2VsZWN0XCIsXG5dO1xuZnVuY3Rpb24gZXhlY3V0ZUF1dG9QaXBlbGluZShjbGllbnQsIHNsb3RLZXkpIHtcbiAgICAvKlxuICAgICAgSWYgYSBwaXBlbGluZSBpcyBhbHJlYWR5IGV4ZWN1dGluZywga2VlcCBxdWV1ZWluZyB1cCBjb21tYW5kc1xuICAgICAgc2luY2UgaW9yZWRpcyB3b24ndCBzZXJ2ZSB0d28gcGlwZWxpbmVzIGF0IHRoZSBzYW1lIHRpbWVcbiAgICAqL1xuICAgIGlmIChjbGllbnQuX3J1bm5pbmdBdXRvUGlwZWxpbmVzLmhhcyhzbG90S2V5KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2xpZW50Ll9hdXRvUGlwZWxpbmVzLmhhcyhzbG90S2V5KSkge1xuICAgICAgICAvKlxuICAgICAgICAgIFJhcmUgZWRnZSBjYXNlLiBTb21laG93LCBzb21ldGhpbmcgaGFzIGRlbGV0ZWQgdGhpcyBydW5uaW5nIGF1dG9waXBlbGluZSBpbiBhbiBpbW1lZGlhdGVcbiAgICAgICAgICBjYWxsIHRvIGV4ZWN1dGVBdXRvUGlwZWxpbmUuXG4gICAgICAgICBcbiAgICAgICAgICBNYXliZSB0aGUgY2FsbGJhY2sgaW4gdGhlIHBpcGVsaW5lLmV4ZWMgaXMgc29tZXRpbWVzIGNhbGxlZCBpbiB0aGUgc2FtZSB0aWNrLFxuICAgICAgICAgIGUuZy4gaWYgcmVkaXMgaXMgZGlzY29ubmVjdGVkP1xuICAgICAgICAqL1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsaWVudC5fcnVubmluZ0F1dG9QaXBlbGluZXMuYWRkKHNsb3RLZXkpO1xuICAgIC8vIEdldCB0aGUgcGlwZWxpbmUgYW5kIGltbWVkaWF0ZWx5IGRlbGV0ZSBpdCBzbyB0aGF0IG5ldyBjb21tYW5kcyBhcmUgcXVldWVkIG9uIGEgbmV3IHBpcGVsaW5lXG4gICAgY29uc3QgcGlwZWxpbmUgPSBjbGllbnQuX2F1dG9QaXBlbGluZXMuZ2V0KHNsb3RLZXkpO1xuICAgIGNsaWVudC5fYXV0b1BpcGVsaW5lcy5kZWxldGUoc2xvdEtleSk7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gcGlwZWxpbmVbZXhwb3J0cy5rQ2FsbGJhY2tzXTtcbiAgICAvLyBTdG9wIGtlZXBpbmcgYSByZWZlcmVuY2UgdG8gY2FsbGJhY2tzIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjYWxsYmFja3Mgc3RvcCBiZWluZyB1c2VkLlxuICAgIC8vIFRoaXMgYWxsb3dzIHRoZSBHQyB0byByZWNsYWltIG9iamVjdHMgcmVmZXJlbmNlZCBieSBjYWxsYmFja3MsIGVzcGVjaWFsbHkgd2l0aCAxNjM4NCBzbG90c1xuICAgIC8vIGluIFJlZGlzLkNsdXN0ZXJcbiAgICBwaXBlbGluZVtleHBvcnRzLmtDYWxsYmFja3NdID0gbnVsbDtcbiAgICAvLyBQZXJmb3JtIHRoZSBjYWxsXG4gICAgcGlwZWxpbmUuZXhlYyhmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICAgIGNsaWVudC5fcnVubmluZ0F1dG9QaXBlbGluZXMuZGVsZXRlKHNsb3RLZXkpO1xuICAgICAgICAvKlxuICAgICAgICAgIEludm9rZSBhbGwgY2FsbGJhY2sgaW4gbmV4dFRpY2sgc28gdGhlIHN0YWNrIGlzIGNsZWFyZWRcbiAgICAgICAgICBhbmQgY2FsbGJhY2tzIGNhbiB0aHJvdyBlcnJvcnMgd2l0aG91dCBhZmZlY3Rpbmcgb3RoZXIgY2FsbGJhY2tzLlxuICAgICAgICAqL1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2tzW2ldLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrc1tpXSwgLi4ucmVzdWx0c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW5vdGhlciBwaXBlbGluZSBvbiB0aGUgc2FtZSBub2RlLCBpbW1lZGlhdGVseSBleGVjdXRlIGl0IHdpdGhvdXQgd2FpdGluZyBmb3IgbmV4dFRpY2tcbiAgICAgICAgaWYgKGNsaWVudC5fYXV0b1BpcGVsaW5lcy5oYXMoc2xvdEtleSkpIHtcbiAgICAgICAgICAgIGV4ZWN1dGVBdXRvUGlwZWxpbmUoY2xpZW50LCBzbG90S2V5KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gc2hvdWxkVXNlQXV0b1BpcGVsaW5pbmcoY2xpZW50LCBmdW5jdGlvbk5hbWUsIGNvbW1hbmROYW1lKSB7XG4gICAgcmV0dXJuIChmdW5jdGlvbk5hbWUgJiZcbiAgICAgICAgY2xpZW50Lm9wdGlvbnMuZW5hYmxlQXV0b1BpcGVsaW5pbmcgJiZcbiAgICAgICAgIWNsaWVudC5pc1BpcGVsaW5lICYmXG4gICAgICAgICFleHBvcnRzLm5vdEFsbG93ZWRBdXRvUGlwZWxpbmVDb21tYW5kcy5pbmNsdWRlcyhjb21tYW5kTmFtZSkgJiZcbiAgICAgICAgIWNsaWVudC5vcHRpb25zLmF1dG9QaXBlbGluaW5nSWdub3JlZENvbW1hbmRzLmluY2x1ZGVzKGNvbW1hbmROYW1lKSk7XG59XG5leHBvcnRzLnNob3VsZFVzZUF1dG9QaXBlbGluaW5nID0gc2hvdWxkVXNlQXV0b1BpcGVsaW5pbmc7XG5mdW5jdGlvbiBnZXRGaXJzdFZhbHVlSW5GbGF0dGVuZWRBcnJheShhcmdzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV07XG4gICAgICAgIGlmICh0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSB8fCAoMCwgbG9kYXNoXzEuaXNBcmd1bWVudHMpKGFyZykpIHtcbiAgICAgICAgICAgIGlmIChhcmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJnWzBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZsYXR0ZW5lZCA9IFthcmddLmZsYXQoKTtcbiAgICAgICAgaWYgKGZsYXR0ZW5lZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlbmVkWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmdldEZpcnN0VmFsdWVJbkZsYXR0ZW5lZEFycmF5ID0gZ2V0Rmlyc3RWYWx1ZUluRmxhdHRlbmVkQXJyYXk7XG5mdW5jdGlvbiBleGVjdXRlV2l0aEF1dG9QaXBlbGluaW5nKGNsaWVudCwgZnVuY3Rpb25OYW1lLCBjb21tYW5kTmFtZSwgYXJncywgY2FsbGJhY2spIHtcbiAgICAvLyBPbiBjbHVzdGVyIG1vZGUgbGV0J3Mgd2FpdCBmb3Igc2xvdHMgdG8gYmUgYXZhaWxhYmxlXG4gICAgaWYgKGNsaWVudC5pc0NsdXN0ZXIgJiYgIWNsaWVudC5zbG90cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGNsaWVudC5zdGF0dXMgPT09IFwid2FpdFwiKVxuICAgICAgICAgICAgY2xpZW50LmNvbm5lY3QoKS5jYXRjaChsb2Rhc2hfMS5ub29wKTtcbiAgICAgICAgcmV0dXJuICgwLCBzdGFuZGFyZF9hc19jYWxsYmFja18xLmRlZmF1bHQpKG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGNsaWVudC5kZWxheVVudGlsUmVhZHkoKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhlY3V0ZVdpdGhBdXRvUGlwZWxpbmluZyhjbGllbnQsIGZ1bmN0aW9uTmFtZSwgY29tbWFuZE5hbWUsIGFyZ3MsIG51bGwpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBoYXZlIHNsb3QgaW5mb3JtYXRpb24sIHdlIGNhbiBpbXByb3ZlIHJvdXRpbmcgYnkgZ3JvdXBpbmcgc2xvdHMgc2VydmVkIGJ5IHRoZSBzYW1lIHN1YnNldCBvZiBub2Rlc1xuICAgIC8vIE5vdGUgdGhhdCB0aGUgZmlyc3QgdmFsdWUgaW4gYXJncyBtYXkgYmUgYSAocG9zc2libHkgZW1wdHkpIGFycmF5LlxuICAgIC8vIGlvcmVkaXMgd2lsbCBvbmx5IGZsYXR0ZW4gb25lIGxldmVsIG9mIHRoZSBhcnJheSwgaW4gdGhlIENvbW1hbmQgY29uc3RydWN0b3IuXG4gICAgY29uc3QgcHJlZml4ID0gY2xpZW50Lm9wdGlvbnMua2V5UHJlZml4IHx8IFwiXCI7XG4gICAgY29uc3Qgc2xvdEtleSA9IGNsaWVudC5pc0NsdXN0ZXJcbiAgICAgICAgPyBjbGllbnQuc2xvdHNbY2FsY3VsYXRlU2xvdChgJHtwcmVmaXh9JHtnZXRGaXJzdFZhbHVlSW5GbGF0dGVuZWRBcnJheShhcmdzKX1gKV0uam9pbihcIixcIilcbiAgICAgICAgOiBcIm1haW5cIjtcbiAgICBpZiAoIWNsaWVudC5fYXV0b1BpcGVsaW5lcy5oYXMoc2xvdEtleSkpIHtcbiAgICAgICAgY29uc3QgcGlwZWxpbmUgPSBjbGllbnQucGlwZWxpbmUoKTtcbiAgICAgICAgcGlwZWxpbmVbZXhwb3J0cy5rRXhlY10gPSBmYWxzZTtcbiAgICAgICAgcGlwZWxpbmVbZXhwb3J0cy5rQ2FsbGJhY2tzXSA9IFtdO1xuICAgICAgICBjbGllbnQuX2F1dG9QaXBlbGluZXMuc2V0KHNsb3RLZXksIHBpcGVsaW5lKTtcbiAgICB9XG4gICAgY29uc3QgcGlwZWxpbmUgPSBjbGllbnQuX2F1dG9QaXBlbGluZXMuZ2V0KHNsb3RLZXkpO1xuICAgIC8qXG4gICAgICBNYXJrIHRoZSBwaXBlbGluZSBhcyBzY2hlZHVsZWQuXG4gICAgICBUaGUgc3ltYm9sIHdpbGwgbWFrZSBzdXJlIHRoYXQgdGhlIHBpcGVsaW5lIGlzIG9ubHkgc2NoZWR1bGVkIG9uY2UgcGVyIHRpY2suXG4gICAgICBOZXcgY29tbWFuZHMgYXJlIGFwcGVuZGVkIHRvIGFuIGFscmVhZHkgc2NoZWR1bGVkIHBpcGVsaW5lLlxuICAgICovXG4gICAgaWYgKCFwaXBlbGluZVtleHBvcnRzLmtFeGVjXSkge1xuICAgICAgICBwaXBlbGluZVtleHBvcnRzLmtFeGVjXSA9IHRydWU7XG4gICAgICAgIC8qXG4gICAgICAgICAgRGVmZXJyaW5nIHdpdGggc2V0SW1tZWRpYXRlIHNvIHdlIGhhdmUgYSBjaGFuY2UgdG8gY2FwdHVyZSBtdWx0aXBsZVxuICAgICAgICAgIGNvbW1hbmRzIHRoYXQgY2FuIGJlIHNjaGVkdWxlZCBieSBJL08gZXZlbnRzIGFscmVhZHkgaW4gdGhlIGV2ZW50IGxvb3AgcXVldWUuXG4gICAgICAgICovXG4gICAgICAgIHNldEltbWVkaWF0ZShleGVjdXRlQXV0b1BpcGVsaW5lLCBjbGllbnQsIHNsb3RLZXkpO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgdGhlIHByb21pc2Ugd2hpY2ggd2lsbCBleGVjdXRlIHRoZSBjb21tYW5kIGluIHRoZSBwaXBlbGluZS5cbiAgICBjb25zdCBhdXRvUGlwZWxpbmVQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwaXBlbGluZVtleHBvcnRzLmtDYWxsYmFja3NdLnB1c2goZnVuY3Rpb24gKGVyciwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmdW5jdGlvbk5hbWUgPT09IFwiY2FsbFwiKSB7XG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQoY29tbWFuZE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHBpcGVsaW5lW2Z1bmN0aW9uTmFtZV0oLi4uYXJncyk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgwLCBzdGFuZGFyZF9hc19jYWxsYmFja18xLmRlZmF1bHQpKGF1dG9QaXBlbGluZVByb21pc2UsIGNhbGxiYWNrKTtcbn1cbmV4cG9ydHMuZXhlY3V0ZVdpdGhBdXRvUGlwZWxpbmluZyA9IGV4ZWN1dGVXaXRoQXV0b1BpcGVsaW5pbmc7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJleGVjdXRlV2l0aEF1dG9QaXBlbGluaW5nIiwiZ2V0Rmlyc3RWYWx1ZUluRmxhdHRlbmVkQXJyYXkiLCJzaG91bGRVc2VBdXRvUGlwZWxpbmluZyIsIm5vdEFsbG93ZWRBdXRvUGlwZWxpbmVDb21tYW5kcyIsImtDYWxsYmFja3MiLCJrRXhlYyIsImxvZGFzaF8xIiwicmVxdWlyZSIsImNhbGN1bGF0ZVNsb3QiLCJzdGFuZGFyZF9hc19jYWxsYmFja18xIiwiU3ltYm9sIiwiZXhlY3V0ZUF1dG9QaXBlbGluZSIsImNsaWVudCIsInNsb3RLZXkiLCJfcnVubmluZ0F1dG9QaXBlbGluZXMiLCJoYXMiLCJfYXV0b1BpcGVsaW5lcyIsImFkZCIsInBpcGVsaW5lIiwiZ2V0IiwiZGVsZXRlIiwiY2FsbGJhY2tzIiwiZXhlYyIsImVyciIsInJlc3VsdHMiLCJpIiwibGVuZ3RoIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiZnVuY3Rpb25OYW1lIiwiY29tbWFuZE5hbWUiLCJvcHRpb25zIiwiZW5hYmxlQXV0b1BpcGVsaW5pbmciLCJpc1BpcGVsaW5lIiwiaW5jbHVkZXMiLCJhdXRvUGlwZWxpbmluZ0lnbm9yZWRDb21tYW5kcyIsImFyZ3MiLCJhcmciLCJBcnJheSIsImlzQXJyYXkiLCJpc0FyZ3VtZW50cyIsImZsYXR0ZW5lZCIsImZsYXQiLCJ1bmRlZmluZWQiLCJjYWxsYmFjayIsImlzQ2x1c3RlciIsInNsb3RzIiwic3RhdHVzIiwiY29ubmVjdCIsImNhdGNoIiwibm9vcCIsImRlZmF1bHQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImRlbGF5VW50aWxSZWFkeSIsInRoZW4iLCJwcmVmaXgiLCJrZXlQcmVmaXgiLCJqb2luIiwic2V0Iiwic2V0SW1tZWRpYXRlIiwiYXV0b1BpcGVsaW5lUHJvbWlzZSIsInB1c2giLCJ1bnNoaWZ0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/autoPipelining.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/cluster/ClusterOptions.js":
/*!**************************************************************!*\
  !*** ./node_modules/ioredis/built/cluster/ClusterOptions.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DEFAULT_CLUSTER_OPTIONS = void 0;\nconst dns_1 = __webpack_require__(/*! dns */ \"dns\");\nexports.DEFAULT_CLUSTER_OPTIONS = {\n    clusterRetryStrategy: (times)=>Math.min(100 + times * 2, 2000),\n    enableOfflineQueue: true,\n    enableReadyCheck: true,\n    scaleReads: \"master\",\n    maxRedirections: 16,\n    retryDelayOnMoved: 0,\n    retryDelayOnFailover: 100,\n    retryDelayOnClusterDown: 100,\n    retryDelayOnTryAgain: 100,\n    slotsRefreshTimeout: 1000,\n    useSRVRecords: false,\n    resolveSrv: dns_1.resolveSrv,\n    dnsLookup: dns_1.lookup,\n    enableAutoPipelining: false,\n    autoPipeliningIgnoredCommands: [],\n    shardedSubscribers: false\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL0NsdXN0ZXJPcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwrQkFBK0IsR0FBRyxLQUFLO0FBQ3ZDLE1BQU1HLFFBQVFDLG1CQUFPQSxDQUFDLGdCQUFLO0FBQzNCSiwrQkFBK0IsR0FBRztJQUM5Qkssc0JBQXNCLENBQUNDLFFBQVVDLEtBQUtDLEdBQUcsQ0FBQyxNQUFNRixRQUFRLEdBQUc7SUFDM0RHLG9CQUFvQjtJQUNwQkMsa0JBQWtCO0lBQ2xCQyxZQUFZO0lBQ1pDLGlCQUFpQjtJQUNqQkMsbUJBQW1CO0lBQ25CQyxzQkFBc0I7SUFDdEJDLHlCQUF5QjtJQUN6QkMsc0JBQXNCO0lBQ3RCQyxxQkFBcUI7SUFDckJDLGVBQWU7SUFDZkMsWUFBWWhCLE1BQU1nQixVQUFVO0lBQzVCQyxXQUFXakIsTUFBTWtCLE1BQU07SUFDdkJDLHNCQUFzQjtJQUN0QkMsK0JBQStCLEVBQUU7SUFDakNDLG9CQUFvQjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2NsdXN0ZXIvQ2x1c3Rlck9wdGlvbnMuanM/NjQ4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuREVGQVVMVF9DTFVTVEVSX09QVElPTlMgPSB2b2lkIDA7XG5jb25zdCBkbnNfMSA9IHJlcXVpcmUoXCJkbnNcIik7XG5leHBvcnRzLkRFRkFVTFRfQ0xVU1RFUl9PUFRJT05TID0ge1xuICAgIGNsdXN0ZXJSZXRyeVN0cmF0ZWd5OiAodGltZXMpID0+IE1hdGgubWluKDEwMCArIHRpbWVzICogMiwgMjAwMCksXG4gICAgZW5hYmxlT2ZmbGluZVF1ZXVlOiB0cnVlLFxuICAgIGVuYWJsZVJlYWR5Q2hlY2s6IHRydWUsXG4gICAgc2NhbGVSZWFkczogXCJtYXN0ZXJcIixcbiAgICBtYXhSZWRpcmVjdGlvbnM6IDE2LFxuICAgIHJldHJ5RGVsYXlPbk1vdmVkOiAwLFxuICAgIHJldHJ5RGVsYXlPbkZhaWxvdmVyOiAxMDAsXG4gICAgcmV0cnlEZWxheU9uQ2x1c3RlckRvd246IDEwMCxcbiAgICByZXRyeURlbGF5T25UcnlBZ2FpbjogMTAwLFxuICAgIHNsb3RzUmVmcmVzaFRpbWVvdXQ6IDEwMDAsXG4gICAgdXNlU1JWUmVjb3JkczogZmFsc2UsXG4gICAgcmVzb2x2ZVNydjogZG5zXzEucmVzb2x2ZVNydixcbiAgICBkbnNMb29rdXA6IGRuc18xLmxvb2t1cCxcbiAgICBlbmFibGVBdXRvUGlwZWxpbmluZzogZmFsc2UsXG4gICAgYXV0b1BpcGVsaW5pbmdJZ25vcmVkQ29tbWFuZHM6IFtdLFxuICAgIHNoYXJkZWRTdWJzY3JpYmVyczogZmFsc2UsXG59O1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiREVGQVVMVF9DTFVTVEVSX09QVElPTlMiLCJkbnNfMSIsInJlcXVpcmUiLCJjbHVzdGVyUmV0cnlTdHJhdGVneSIsInRpbWVzIiwiTWF0aCIsIm1pbiIsImVuYWJsZU9mZmxpbmVRdWV1ZSIsImVuYWJsZVJlYWR5Q2hlY2siLCJzY2FsZVJlYWRzIiwibWF4UmVkaXJlY3Rpb25zIiwicmV0cnlEZWxheU9uTW92ZWQiLCJyZXRyeURlbGF5T25GYWlsb3ZlciIsInJldHJ5RGVsYXlPbkNsdXN0ZXJEb3duIiwicmV0cnlEZWxheU9uVHJ5QWdhaW4iLCJzbG90c1JlZnJlc2hUaW1lb3V0IiwidXNlU1JWUmVjb3JkcyIsInJlc29sdmVTcnYiLCJkbnNMb29rdXAiLCJsb29rdXAiLCJlbmFibGVBdXRvUGlwZWxpbmluZyIsImF1dG9QaXBlbGluaW5nSWdub3JlZENvbW1hbmRzIiwic2hhcmRlZFN1YnNjcmliZXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/cluster/ClusterOptions.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/cluster/ClusterSubscriber.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ioredis/built/cluster/ClusterSubscriber.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/ioredis/built/cluster/util.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst Redis_1 = __webpack_require__(/*! ../Redis */ \"(rsc)/./node_modules/ioredis/built/Redis.js\");\nconst debug = (0, utils_1.Debug)(\"cluster:subscriber\");\nclass ClusterSubscriber {\n    constructor(connectionPool, emitter, isSharded = false){\n        this.connectionPool = connectionPool;\n        this.emitter = emitter;\n        this.isSharded = isSharded;\n        this.started = false;\n        //There is only one connection for the entire pool\n        this.subscriber = null;\n        //The slot range for which this subscriber is responsible\n        this.slotRange = [];\n        this.onSubscriberEnd = ()=>{\n            if (!this.started) {\n                debug(\"subscriber has disconnected, but ClusterSubscriber is not started, so not reconnecting.\");\n                return;\n            }\n            // If the subscriber closes whilst it's still the active connection,\n            // we might as well try to connecting to a new node if possible to\n            // minimise the number of missed publishes.\n            debug(\"subscriber has disconnected, selecting a new one...\");\n            this.selectSubscriber();\n        };\n        // If the current node we're using as the subscriber disappears\n        // from the node pool for some reason, we will select a new one\n        // to connect to.\n        // Note that this event is only triggered if the connection to\n        // the node has been used; cluster subscriptions are setup with\n        // lazyConnect = true. It's possible for the subscriber node to\n        // disappear without this method being called!\n        // See https://github.com/luin/ioredis/pull/1589\n        this.connectionPool.on(\"-node\", (_, key)=>{\n            if (!this.started || !this.subscriber) {\n                return;\n            }\n            if ((0, util_1.getNodeKey)(this.subscriber.options) === key) {\n                debug(\"subscriber has left, selecting a new one...\");\n                this.selectSubscriber();\n            }\n        });\n        this.connectionPool.on(\"+node\", ()=>{\n            if (!this.started || this.subscriber) {\n                return;\n            }\n            debug(\"a new node is discovered and there is no subscriber, selecting a new one...\");\n            this.selectSubscriber();\n        });\n    }\n    getInstance() {\n        return this.subscriber;\n    }\n    /**\n     * Associate this subscriber to a specific slot range.\n     *\n     * Returns the range or an empty array if the slot range couldn't be associated.\n     *\n     * BTW: This is more for debugging and testing purposes.\n     *\n     * @param range\n     */ associateSlotRange(range) {\n        if (this.isSharded) {\n            this.slotRange = range;\n        }\n        return this.slotRange;\n    }\n    start() {\n        this.started = true;\n        this.selectSubscriber();\n        debug(\"started\");\n    }\n    stop() {\n        this.started = false;\n        if (this.subscriber) {\n            this.subscriber.disconnect();\n            this.subscriber = null;\n        }\n    }\n    isStarted() {\n        return this.started;\n    }\n    selectSubscriber() {\n        const lastActiveSubscriber = this.lastActiveSubscriber;\n        // Disconnect the previous subscriber even if there\n        // will not be a new one.\n        if (lastActiveSubscriber) {\n            lastActiveSubscriber.off(\"end\", this.onSubscriberEnd);\n            lastActiveSubscriber.disconnect();\n        }\n        if (this.subscriber) {\n            this.subscriber.off(\"end\", this.onSubscriberEnd);\n            this.subscriber.disconnect();\n        }\n        const sampleNode = (0, utils_1.sample)(this.connectionPool.getNodes());\n        if (!sampleNode) {\n            debug(\"selecting subscriber failed since there is no node discovered in the cluster yet\");\n            this.subscriber = null;\n            return;\n        }\n        const { options } = sampleNode;\n        debug(\"selected a subscriber %s:%s\", options.host, options.port);\n        /*\n         * Create a specialized Redis connection for the subscription.\n         * Note that auto reconnection is enabled here.\n         *\n         * `enableReadyCheck` is also enabled because although subscription is allowed\n         * while redis is loading data from the disk, we can check if the password\n         * provided for the subscriber is correct, and if not, the current subscriber\n         * will be disconnected and a new subscriber will be selected.\n         */ let connectionPrefix = \"subscriber\";\n        if (this.isSharded) connectionPrefix = \"ssubscriber\";\n        this.subscriber = new Redis_1.default({\n            port: options.port,\n            host: options.host,\n            username: options.username,\n            password: options.password,\n            enableReadyCheck: true,\n            connectionName: (0, util_1.getConnectionName)(connectionPrefix, options.connectionName),\n            lazyConnect: true,\n            tls: options.tls,\n            // Don't try to reconnect the subscriber connection. If the connection fails\n            // we will get an end event (handled below), at which point we'll pick a new\n            // node from the pool and try to connect to that as the subscriber connection.\n            retryStrategy: null\n        });\n        // Ignore the errors since they're handled in the connection pool.\n        this.subscriber.on(\"error\", utils_1.noop);\n        // The node we lost connection to may not come back up in a\n        // reasonable amount of time (e.g. a slave that's taken down\n        // for maintainence), we could potentially miss many published\n        // messages so we should reconnect as quickly as possible, to\n        // a different node if needed.\n        this.subscriber.once(\"end\", this.onSubscriberEnd);\n        // Re-subscribe previous channels\n        const previousChannels = {\n            subscribe: [],\n            psubscribe: [],\n            ssubscribe: []\n        };\n        if (lastActiveSubscriber) {\n            const condition = lastActiveSubscriber.condition || lastActiveSubscriber.prevCondition;\n            if (condition && condition.subscriber) {\n                previousChannels.subscribe = condition.subscriber.channels(\"subscribe\");\n                previousChannels.psubscribe = condition.subscriber.channels(\"psubscribe\");\n                previousChannels.ssubscribe = condition.subscriber.channels(\"ssubscribe\");\n            }\n        }\n        if (previousChannels.subscribe.length || previousChannels.psubscribe.length || previousChannels.ssubscribe.length) {\n            let pending = 0;\n            for (const type of [\n                \"subscribe\",\n                \"psubscribe\",\n                \"ssubscribe\"\n            ]){\n                const channels = previousChannels[type];\n                if (channels.length) {\n                    pending += 1;\n                    debug(\"%s %d channels\", type, channels.length);\n                    this.subscriber[type](channels).then(()=>{\n                        if (!--pending) {\n                            this.lastActiveSubscriber = this.subscriber;\n                        }\n                    }).catch(()=>{\n                        // TODO: should probably disconnect the subscriber and try again.\n                        debug(\"failed to %s %d channels\", type, channels.length);\n                    });\n                }\n            }\n        } else {\n            this.lastActiveSubscriber = this.subscriber;\n        }\n        for (const event of [\n            \"message\",\n            \"messageBuffer\"\n        ]){\n            this.subscriber.on(event, (arg1, arg2)=>{\n                this.emitter.emit(event, arg1, arg2);\n            });\n        }\n        for (const event of [\n            \"pmessage\",\n            \"pmessageBuffer\"\n        ]){\n            this.subscriber.on(event, (arg1, arg2, arg3)=>{\n                this.emitter.emit(event, arg1, arg2, arg3);\n            });\n        }\n        if (this.isSharded == true) {\n            for (const event of [\n                \"smessage\",\n                \"smessageBuffer\"\n            ]){\n                this.subscriber.on(event, (arg1, arg2)=>{\n                    this.emitter.emit(event, arg1, arg2);\n                });\n            }\n        }\n    }\n}\nexports[\"default\"] = ClusterSubscriber;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL0NsdXN0ZXJTdWJzY3JpYmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFNBQVNDLG1CQUFPQSxDQUFDLGtFQUFRO0FBQy9CLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLG1FQUFVO0FBQ2xDLE1BQU1FLFVBQVVGLG1CQUFPQSxDQUFDLDZEQUFVO0FBQ2xDLE1BQU1HLFFBQVEsQ0FBQyxHQUFHRixRQUFRRyxLQUFLLEVBQUU7QUFDakMsTUFBTUM7SUFDRkMsWUFBWUMsY0FBYyxFQUFFQyxPQUFPLEVBQUVDLFlBQVksS0FBSyxDQUFFO1FBQ3BELElBQUksQ0FBQ0YsY0FBYyxHQUFHQTtRQUN0QixJQUFJLENBQUNDLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDZixrREFBa0Q7UUFDbEQsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEIseURBQXlEO1FBQ3pELElBQUksQ0FBQ0MsU0FBUyxHQUFHLEVBQUU7UUFDbkIsSUFBSSxDQUFDQyxlQUFlLEdBQUc7WUFDbkIsSUFBSSxDQUFDLElBQUksQ0FBQ0gsT0FBTyxFQUFFO2dCQUNmUCxNQUFNO2dCQUNOO1lBQ0o7WUFDQSxvRUFBb0U7WUFDcEUsa0VBQWtFO1lBQ2xFLDJDQUEyQztZQUMzQ0EsTUFBTTtZQUNOLElBQUksQ0FBQ1csZ0JBQWdCO1FBQ3pCO1FBQ0EsK0RBQStEO1FBQy9ELCtEQUErRDtRQUMvRCxpQkFBaUI7UUFDakIsOERBQThEO1FBQzlELCtEQUErRDtRQUMvRCwrREFBK0Q7UUFDL0QsOENBQThDO1FBQzlDLGdEQUFnRDtRQUNoRCxJQUFJLENBQUNQLGNBQWMsQ0FBQ1EsRUFBRSxDQUFDLFNBQVMsQ0FBQ0MsR0FBR0M7WUFDaEMsSUFBSSxDQUFDLElBQUksQ0FBQ1As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QUNKLEdBQ0s4QyxLQUFLLENBQUM7d0JBQ1AsaUVBQWlFO3dCQUNqRXRELE1BQU0sNEJBQTRCb0QsTUFBTUgsU0FBU0MsTUFBTTtvQkFDM0Q7Z0JBQ0o7WUFDSjtRQUNKLE9BQ0s7WUFDRCxJQUFJLENBQUMxQixvQkFBb0IsR0FBRyxJQUFJLENBQUNoQixVQUFVO1FBQy9DO1FBQ0EsS0FBSyxNQUFNK0MsU0FBUztZQUNoQjtZQUNBO1NBQ0gsQ0FBRTtZQUNDLElBQUksQ0FBQy9DLFVBQVUsQ0FBQ0ksRUFBRSxDQUFDMkMsT0FBTyxDQUFDQyxNQUFNQztnQkFDN0IsSUFBSSxDQUFDcEQsT0FBTyxDQUFDcUQsSUFBSSxDQUFDSCxPQUFPQyxNQUFNQztZQUNuQztRQUNKO1FBQ0EsS0FBSyxNQUFNRixTQUFTO1lBQUM7WUFBWTtTQUFpQixDQUFFO1lBQ2hELElBQUksQ0FBQy9DLFVBQVUsQ0FBQ0ksRUFBRSxDQUFDMkMsT0FBTyxDQUFDQyxNQUFNQyxNQUFNRTtnQkFDbkMsSUFBSSxDQUFDdEQsT0FBTyxDQUFDcUQsSUFBSSxDQUFDSCxPQUFPQyxNQUFNQyxNQUFNRTtZQUN6QztRQUNKO1FBQ0EsSUFBSSxJQUFJLENBQUNyRCxTQUFTLElBQUksTUFBTTtZQUN4QixLQUFLLE1BQU1pRCxTQUFTO2dCQUNoQjtnQkFDQTthQUNILENBQUU7Z0JBQ0MsSUFBSSxDQUFDL0MsVUFBVSxDQUFDSSxFQUFFLENBQUMyQyxPQUFPLENBQUNDLE1BQU1DO29CQUM3QixJQUFJLENBQUNwRCxPQUFPLENBQUNxRCxJQUFJLENBQUNILE9BQU9DLE1BQU1DO2dCQUNuQztZQUNKO1FBQ0o7SUFDSjtBQUNKO0FBQ0EvRCxrQkFBZSxHQUFHUSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2NsdXN0ZXIvQ2x1c3RlclN1YnNjcmliZXIuanM/OTA3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgUmVkaXNfMSA9IHJlcXVpcmUoXCIuLi9SZWRpc1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIHV0aWxzXzEuRGVidWcpKFwiY2x1c3RlcjpzdWJzY3JpYmVyXCIpO1xuY2xhc3MgQ2x1c3RlclN1YnNjcmliZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25Qb29sLCBlbWl0dGVyLCBpc1NoYXJkZWQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb29sID0gY29ubmVjdGlvblBvb2w7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgICAgIHRoaXMuaXNTaGFyZGVkID0gaXNTaGFyZGVkO1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgLy9UaGVyZSBpcyBvbmx5IG9uZSBjb25uZWN0aW9uIGZvciB0aGUgZW50aXJlIHBvb2xcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyID0gbnVsbDtcbiAgICAgICAgLy9UaGUgc2xvdCByYW5nZSBmb3Igd2hpY2ggdGhpcyBzdWJzY3JpYmVyIGlzIHJlc3BvbnNpYmxlXG4gICAgICAgIHRoaXMuc2xvdFJhbmdlID0gW107XG4gICAgICAgIHRoaXMub25TdWJzY3JpYmVyRW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInN1YnNjcmliZXIgaGFzIGRpc2Nvbm5lY3RlZCwgYnV0IENsdXN0ZXJTdWJzY3JpYmVyIGlzIG5vdCBzdGFydGVkLCBzbyBub3QgcmVjb25uZWN0aW5nLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgc3Vic2NyaWJlciBjbG9zZXMgd2hpbHN0IGl0J3Mgc3RpbGwgdGhlIGFjdGl2ZSBjb25uZWN0aW9uLFxuICAgICAgICAgICAgLy8gd2UgbWlnaHQgYXMgd2VsbCB0cnkgdG8gY29ubmVjdGluZyB0byBhIG5ldyBub2RlIGlmIHBvc3NpYmxlIHRvXG4gICAgICAgICAgICAvLyBtaW5pbWlzZSB0aGUgbnVtYmVyIG9mIG1pc3NlZCBwdWJsaXNoZXMuXG4gICAgICAgICAgICBkZWJ1ZyhcInN1YnNjcmliZXIgaGFzIGRpc2Nvbm5lY3RlZCwgc2VsZWN0aW5nIGEgbmV3IG9uZS4uLlwiKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0U3Vic2NyaWJlcigpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBub2RlIHdlJ3JlIHVzaW5nIGFzIHRoZSBzdWJzY3JpYmVyIGRpc2FwcGVhcnNcbiAgICAgICAgLy8gZnJvbSB0aGUgbm9kZSBwb29sIGZvciBzb21lIHJlYXNvbiwgd2Ugd2lsbCBzZWxlY3QgYSBuZXcgb25lXG4gICAgICAgIC8vIHRvIGNvbm5lY3QgdG8uXG4gICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGV2ZW50IGlzIG9ubHkgdHJpZ2dlcmVkIGlmIHRoZSBjb25uZWN0aW9uIHRvXG4gICAgICAgIC8vIHRoZSBub2RlIGhhcyBiZWVuIHVzZWQ7IGNsdXN0ZXIgc3Vic2NyaXB0aW9ucyBhcmUgc2V0dXAgd2l0aFxuICAgICAgICAvLyBsYXp5Q29ubmVjdCA9IHRydWUuIEl0J3MgcG9zc2libGUgZm9yIHRoZSBzdWJzY3JpYmVyIG5vZGUgdG9cbiAgICAgICAgLy8gZGlzYXBwZWFyIHdpdGhvdXQgdGhpcyBtZXRob2QgYmVpbmcgY2FsbGVkIVxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2x1aW4vaW9yZWRpcy9wdWxsLzE1ODlcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9vbC5vbihcIi1ub2RlXCIsIChfLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGFydGVkIHx8ICF0aGlzLnN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIHV0aWxfMS5nZXROb2RlS2V5KSh0aGlzLnN1YnNjcmliZXIub3B0aW9ucykgPT09IGtleSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwic3Vic2NyaWJlciBoYXMgbGVmdCwgc2VsZWN0aW5nIGEgbmV3IG9uZS4uLlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdFN1YnNjcmliZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvb2wub24oXCIrbm9kZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCB8fCB0aGlzLnN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWJ1ZyhcImEgbmV3IG5vZGUgaXMgZGlzY292ZXJlZCBhbmQgdGhlcmUgaXMgbm8gc3Vic2NyaWJlciwgc2VsZWN0aW5nIGEgbmV3IG9uZS4uLlwiKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0U3Vic2NyaWJlcigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0SW5zdGFuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnNjcmliZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc29jaWF0ZSB0aGlzIHN1YnNjcmliZXIgdG8gYSBzcGVjaWZpYyBzbG90IHJhbmdlLlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgcmFuZ2Ugb3IgYW4gZW1wdHkgYXJyYXkgaWYgdGhlIHNsb3QgcmFuZ2UgY291bGRuJ3QgYmUgYXNzb2NpYXRlZC5cbiAgICAgKlxuICAgICAqIEJUVzogVGhpcyBpcyBtb3JlIGZvciBkZWJ1Z2dpbmcgYW5kIHRlc3RpbmcgcHVycG9zZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmFuZ2VcbiAgICAgKi9cbiAgICBhc3NvY2lhdGVTbG90UmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTaGFyZGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNsb3RSYW5nZSA9IHJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNsb3RSYW5nZTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2VsZWN0U3Vic2NyaWJlcigpO1xuICAgICAgICBkZWJ1ZyhcInN0YXJ0ZWRcIik7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1N0YXJ0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0ZWQ7XG4gICAgfVxuICAgIHNlbGVjdFN1YnNjcmliZXIoKSB7XG4gICAgICAgIGNvbnN0IGxhc3RBY3RpdmVTdWJzY3JpYmVyID0gdGhpcy5sYXN0QWN0aXZlU3Vic2NyaWJlcjtcbiAgICAgICAgLy8gRGlzY29ubmVjdCB0aGUgcHJldmlvdXMgc3Vic2NyaWJlciBldmVuIGlmIHRoZXJlXG4gICAgICAgIC8vIHdpbGwgbm90IGJlIGEgbmV3IG9uZS5cbiAgICAgICAgaWYgKGxhc3RBY3RpdmVTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICBsYXN0QWN0aXZlU3Vic2NyaWJlci5vZmYoXCJlbmRcIiwgdGhpcy5vblN1YnNjcmliZXJFbmQpO1xuICAgICAgICAgICAgbGFzdEFjdGl2ZVN1YnNjcmliZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlci5vZmYoXCJlbmRcIiwgdGhpcy5vblN1YnNjcmliZXJFbmQpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzYW1wbGVOb2RlID0gKDAsIHV0aWxzXzEuc2FtcGxlKSh0aGlzLmNvbm5lY3Rpb25Qb29sLmdldE5vZGVzKCkpO1xuICAgICAgICBpZiAoIXNhbXBsZU5vZGUpIHtcbiAgICAgICAgICAgIGRlYnVnKFwic2VsZWN0aW5nIHN1YnNjcmliZXIgZmFpbGVkIHNpbmNlIHRoZXJlIGlzIG5vIG5vZGUgZGlzY292ZXJlZCBpbiB0aGUgY2x1c3RlciB5ZXRcIik7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXIgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gc2FtcGxlTm9kZTtcbiAgICAgICAgZGVidWcoXCJzZWxlY3RlZCBhIHN1YnNjcmliZXIgJXM6JXNcIiwgb3B0aW9ucy5ob3N0LCBvcHRpb25zLnBvcnQpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBDcmVhdGUgYSBzcGVjaWFsaXplZCBSZWRpcyBjb25uZWN0aW9uIGZvciB0aGUgc3Vic2NyaXB0aW9uLlxuICAgICAgICAgKiBOb3RlIHRoYXQgYXV0byByZWNvbm5lY3Rpb24gaXMgZW5hYmxlZCBoZXJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBgZW5hYmxlUmVhZHlDaGVja2AgaXMgYWxzbyBlbmFibGVkIGJlY2F1c2UgYWx0aG91Z2ggc3Vic2NyaXB0aW9uIGlzIGFsbG93ZWRcbiAgICAgICAgICogd2hpbGUgcmVkaXMgaXMgbG9hZGluZyBkYXRhIGZyb20gdGhlIGRpc2ssIHdlIGNhbiBjaGVjayBpZiB0aGUgcGFzc3dvcmRcbiAgICAgICAgICogcHJvdmlkZWQgZm9yIHRoZSBzdWJzY3JpYmVyIGlzIGNvcnJlY3QsIGFuZCBpZiBub3QsIHRoZSBjdXJyZW50IHN1YnNjcmliZXJcbiAgICAgICAgICogd2lsbCBiZSBkaXNjb25uZWN0ZWQgYW5kIGEgbmV3IHN1YnNjcmliZXIgd2lsbCBiZSBzZWxlY3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIGxldCBjb25uZWN0aW9uUHJlZml4ID0gXCJzdWJzY3JpYmVyXCI7XG4gICAgICAgIGlmICh0aGlzLmlzU2hhcmRlZClcbiAgICAgICAgICAgIGNvbm5lY3Rpb25QcmVmaXggPSBcInNzdWJzY3JpYmVyXCI7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlciA9IG5ldyBSZWRpc18xLmRlZmF1bHQoe1xuICAgICAgICAgICAgcG9ydDogb3B0aW9ucy5wb3J0LFxuICAgICAgICAgICAgaG9zdDogb3B0aW9ucy5ob3N0LFxuICAgICAgICAgICAgdXNlcm5hbWU6IG9wdGlvbnMudXNlcm5hbWUsXG4gICAgICAgICAgICBwYXNzd29yZDogb3B0aW9ucy5wYXNzd29yZCxcbiAgICAgICAgICAgIGVuYWJsZVJlYWR5Q2hlY2s6IHRydWUsXG4gICAgICAgICAgICBjb25uZWN0aW9uTmFtZTogKDAsIHV0aWxfMS5nZXRDb25uZWN0aW9uTmFtZSkoY29ubmVjdGlvblByZWZpeCwgb3B0aW9ucy5jb25uZWN0aW9uTmFtZSksXG4gICAgICAgICAgICBsYXp5Q29ubmVjdDogdHJ1ZSxcbiAgICAgICAgICAgIHRsczogb3B0aW9ucy50bHMsXG4gICAgICAgICAgICAvLyBEb24ndCB0cnkgdG8gcmVjb25uZWN0IHRoZSBzdWJzY3JpYmVyIGNvbm5lY3Rpb24uIElmIHRoZSBjb25uZWN0aW9uIGZhaWxzXG4gICAgICAgICAgICAvLyB3ZSB3aWxsIGdldCBhbiBlbmQgZXZlbnQgKGhhbmRsZWQgYmVsb3cpLCBhdCB3aGljaCBwb2ludCB3ZSdsbCBwaWNrIGEgbmV3XG4gICAgICAgICAgICAvLyBub2RlIGZyb20gdGhlIHBvb2wgYW5kIHRyeSB0byBjb25uZWN0IHRvIHRoYXQgYXMgdGhlIHN1YnNjcmliZXIgY29ubmVjdGlvbi5cbiAgICAgICAgICAgIHJldHJ5U3RyYXRlZ3k6IG51bGwsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGVycm9ycyBzaW5jZSB0aGV5J3JlIGhhbmRsZWQgaW4gdGhlIGNvbm5lY3Rpb24gcG9vbC5cbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyLm9uKFwiZXJyb3JcIiwgdXRpbHNfMS5ub29wKTtcbiAgICAgICAgLy8gVGhlIG5vZGUgd2UgbG9zdCBjb25uZWN0aW9uIHRvIG1heSBub3QgY29tZSBiYWNrIHVwIGluIGFcbiAgICAgICAgLy8gcmVhc29uYWJsZSBhbW91bnQgb2YgdGltZSAoZS5nLiBhIHNsYXZlIHRoYXQncyB0YWtlbiBkb3duXG4gICAgICAgIC8vIGZvciBtYWludGFpbmVuY2UpLCB3ZSBjb3VsZCBwb3RlbnRpYWxseSBtaXNzIG1hbnkgcHVibGlzaGVkXG4gICAgICAgIC8vIG1lc3NhZ2VzIHNvIHdlIHNob3VsZCByZWNvbm5lY3QgYXMgcXVpY2tseSBhcyBwb3NzaWJsZSwgdG9cbiAgICAgICAgLy8gYSBkaWZmZXJlbnQgbm9kZSBpZiBuZWVkZWQuXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlci5vbmNlKFwiZW5kXCIsIHRoaXMub25TdWJzY3JpYmVyRW5kKTtcbiAgICAgICAgLy8gUmUtc3Vic2NyaWJlIHByZXZpb3VzIGNoYW5uZWxzXG4gICAgICAgIGNvbnN0IHByZXZpb3VzQ2hhbm5lbHMgPSB7IHN1YnNjcmliZTogW10sIHBzdWJzY3JpYmU6IFtdLCBzc3Vic2NyaWJlOiBbXSB9O1xuICAgICAgICBpZiAobGFzdEFjdGl2ZVN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IGxhc3RBY3RpdmVTdWJzY3JpYmVyLmNvbmRpdGlvbiB8fCBsYXN0QWN0aXZlU3Vic2NyaWJlci5wcmV2Q29uZGl0aW9uO1xuICAgICAgICAgICAgaWYgKGNvbmRpdGlvbiAmJiBjb25kaXRpb24uc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzQ2hhbm5lbHMuc3Vic2NyaWJlID0gY29uZGl0aW9uLnN1YnNjcmliZXIuY2hhbm5lbHMoXCJzdWJzY3JpYmVcIik7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNDaGFubmVscy5wc3Vic2NyaWJlID1cbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uLnN1YnNjcmliZXIuY2hhbm5lbHMoXCJwc3Vic2NyaWJlXCIpO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzQ2hhbm5lbHMuc3N1YnNjcmliZSA9XG4gICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbi5zdWJzY3JpYmVyLmNoYW5uZWxzKFwic3N1YnNjcmliZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldmlvdXNDaGFubmVscy5zdWJzY3JpYmUubGVuZ3RoIHx8XG4gICAgICAgICAgICBwcmV2aW91c0NoYW5uZWxzLnBzdWJzY3JpYmUubGVuZ3RoIHx8XG4gICAgICAgICAgICBwcmV2aW91c0NoYW5uZWxzLnNzdWJzY3JpYmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcGVuZGluZyA9IDA7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgW1wic3Vic2NyaWJlXCIsIFwicHN1YnNjcmliZVwiLCBcInNzdWJzY3JpYmVcIl0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVscyA9IHByZXZpb3VzQ2hhbm5lbHNbdHlwZV07XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5uZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiJXMgJWQgY2hhbm5lbHNcIiwgdHlwZSwgY2hhbm5lbHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyW3R5cGVdKGNoYW5uZWxzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEtLXBlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RBY3RpdmVTdWJzY3JpYmVyID0gdGhpcy5zdWJzY3JpYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHNob3VsZCBwcm9iYWJseSBkaXNjb25uZWN0IHRoZSBzdWJzY3JpYmVyIGFuZCB0cnkgYWdhaW4uXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImZhaWxlZCB0byAlcyAlZCBjaGFubmVsc1wiLCB0eXBlLCBjaGFubmVscy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RBY3RpdmVTdWJzY3JpYmVyID0gdGhpcy5zdWJzY3JpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgW1xuICAgICAgICAgICAgXCJtZXNzYWdlXCIsXG4gICAgICAgICAgICBcIm1lc3NhZ2VCdWZmZXJcIixcbiAgICAgICAgXSkge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyLm9uKGV2ZW50LCAoYXJnMSwgYXJnMikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KGV2ZW50LCBhcmcxLCBhcmcyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgW1wicG1lc3NhZ2VcIiwgXCJwbWVzc2FnZUJ1ZmZlclwiXSkge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyLm9uKGV2ZW50LCAoYXJnMSwgYXJnMiwgYXJnMykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KGV2ZW50LCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzU2hhcmRlZCA9PSB0cnVlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIFtcbiAgICAgICAgICAgICAgICBcInNtZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgXCJzbWVzc2FnZUJ1ZmZlclwiLFxuICAgICAgICAgICAgXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlci5vbihldmVudCwgKGFyZzEsIGFyZzIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoZXZlbnQsIGFyZzEsIGFyZzIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ2x1c3RlclN1YnNjcmliZXI7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ1dGlsXzEiLCJyZXF1aXJlIiwidXRpbHNfMSIsIlJlZGlzXzEiLCJkZWJ1ZyIsIkRlYnVnIiwiQ2x1c3RlclN1YnNjcmliZXIiLCJjb25zdHJ1Y3RvciIsImNvbm5lY3Rpb25Qb29sIiwiZW1pdHRlciIsImlzU2hhcmRlZCIsInN0YXJ0ZWQiLCJzdWJzY3JpYmVyIiwic2xvdFJhbmdlIiwib25TdWJzY3JpYmVyRW5kIiwic2VsZWN0U3Vic2NyaWJlciIsIm9uIiwiXyIsImtleSIsImdldE5vZGVLZXkiLCJvcHRpb25zIiwiZ2V0SW5zdGFuY2UiLCJhc3NvY2lhdGVTbG90UmFuZ2UiLCJyYW5nZSIsInN0YXJ0Iiwic3RvcCIsImRpc2Nvbm5lY3QiLCJpc1N0YXJ0ZWQiLCJsYXN0QWN0aXZlU3Vic2NyaWJlciIsIm9mZiIsInNhbXBsZU5vZGUiLCJzYW1wbGUiLCJnZXROb2RlcyIsImhvc3QiLCJwb3J0IiwiY29ubmVjdGlvblByZWZpeCIsImRlZmF1bHQiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiZW5hYmxlUmVhZHlDaGVjayIsImNvbm5lY3Rpb25OYW1lIiwiZ2V0Q29ubmVjdGlvbk5hbWUiLCJsYXp5Q29ubmVjdCIsInRscyIsInJldHJ5U3RyYXRlZ3kiLCJub29wIiwib25jZSIsInByZXZpb3VzQ2hhbm5lbHMiLCJzdWJzY3JpYmUiLCJwc3Vic2NyaWJlIiwic3N1YnNjcmliZSIsImNvbmRpdGlvbiIsInByZXZDb25kaXRpb24iLCJjaGFubmVscyIsImxlbmd0aCIsInBlbmRpbmciLCJ0eXBlIiwidGhlbiIsImNhdGNoIiwiZXZlbnQiLCJhcmcxIiwiYXJnMiIsImVtaXQiLCJhcmczIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/cluster/ClusterSubscriber.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/cluster/ClusterSubscriberGroup.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ioredis/built/cluster/ClusterSubscriberGroup.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst ClusterSubscriber_1 = __webpack_require__(/*! ./ClusterSubscriber */ \"(rsc)/./node_modules/ioredis/built/cluster/ClusterSubscriber.js\");\nconst ConnectionPool_1 = __webpack_require__(/*! ./ConnectionPool */ \"(rsc)/./node_modules/ioredis/built/cluster/ConnectionPool.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/ioredis/built/cluster/util.js\");\nconst calculateSlot = __webpack_require__(/*! cluster-key-slot */ \"(rsc)/./node_modules/cluster-key-slot/lib/index.js\");\nconst debug = (0, utils_1.Debug)(\"cluster:subscriberGroup\");\n/**\n * Redis differs between \"normal\" and sharded PubSub. If using the \"normal\" PubSub feature, exactly one\n * ClusterSubscriber exists per cluster instance. This works because the Redis cluster bus forwards m\n * messages between shards. However, this has scalability limitations, which is the reason why the sharded\n * PubSub feature was added to Redis. With sharded PubSub, each shard is responsible for its own messages.\n * Given that, we need at least one ClusterSubscriber per master endpoint/node.\n *\n * This class leverages the previously exising ClusterSubscriber by adding support for multiple such subscribers\n * in alignment to the master nodes of the cluster. The ClusterSubscriber class was extended in a non-breaking way\n * to support this feature.\n */ class ClusterSubscriberGroup {\n    /**\n     * Register callbacks\n     *\n     * @param cluster\n     */ constructor(cluster){\n        this.cluster = cluster;\n        this.shardedSubscribers = new Map();\n        this.clusterSlots = [];\n        //Simple [min, max] slot ranges aren't enough because you can migrate single slots\n        this.subscriberToSlotsIndex = new Map();\n        this.channels = new Map();\n        cluster.on(\"+node\", (redis)=>{\n            this._addSubscriber(redis);\n        });\n        cluster.on(\"-node\", (redis)=>{\n            this._removeSubscriber(redis);\n        });\n        cluster.on(\"refresh\", ()=>{\n            this._refreshSlots(cluster);\n        });\n    }\n    /**\n     * Get the responsible subscriber.\n     *\n     * Returns null if no subscriber was found\n     *\n     * @param slot\n     */ getResponsibleSubscriber(slot) {\n        const nodeKey = this.clusterSlots[slot][0];\n        return this.shardedSubscribers.get(nodeKey);\n    }\n    /**\n     * Adds a channel for which this subscriber group is responsible\n     *\n     * @param channels\n     */ addChannels(channels) {\n        const slot = calculateSlot(channels[0]);\n        //Check if the all channels belong to the same slot and otherwise reject the operation\n        channels.forEach((c)=>{\n            if (calculateSlot(c) != slot) return -1;\n        });\n        const currChannels = this.channels.get(slot);\n        if (!currChannels) {\n            this.channels.set(slot, channels);\n        } else {\n            this.channels.set(slot, currChannels.concat(channels));\n        }\n        return [\n            ...this.channels.values()\n        ].flatMap((v)=>v).length;\n    }\n    /**\n     * Removes channels for which the subscriber group is responsible by optionally unsubscribing\n     * @param channels\n     */ removeChannels(channels) {\n        const slot = calculateSlot(channels[0]);\n        //Check if the all channels belong to the same slot and otherwise reject the operation\n        channels.forEach((c)=>{\n            if (calculateSlot(c) != slot) return -1;\n        });\n        const slotChannels = this.channels.get(slot);\n        if (slotChannels) {\n            const updatedChannels = slotChannels.filter((c)=>!channels.includes(c));\n            this.channels.set(slot, updatedChannels);\n        }\n        return [\n            ...this.channels.values()\n        ].flatMap((v)=>v).length;\n    }\n    /**\n     * Disconnect all subscribers\n     */ stop() {\n        for (const s of this.shardedSubscribers.values()){\n            s.stop();\n        }\n    }\n    /**\n     * Start all not yet started subscribers\n     */ start() {\n        for (const s of this.shardedSubscribers.values()){\n            if (!s.isStarted()) {\n                s.start();\n            }\n        }\n    }\n    /**\n     * Add a subscriber to the group of subscribers\n     *\n     * @param redis\n     */ _addSubscriber(redis) {\n        const pool = new ConnectionPool_1.default(redis.options);\n        if (pool.addMasterNode(redis)) {\n            const sub = new ClusterSubscriber_1.default(pool, this.cluster, true);\n            const nodeKey = (0, util_1.getNodeKey)(redis.options);\n            this.shardedSubscribers.set(nodeKey, sub);\n            sub.start();\n            // We need to attempt to resubscribe them in case the new node serves their slot\n            this._resubscribe();\n            this.cluster.emit(\"+subscriber\");\n            return sub;\n        }\n        return null;\n    }\n    /**\n     * Removes a subscriber from the group\n     * @param redis\n     */ _removeSubscriber(redis) {\n        const nodeKey = (0, util_1.getNodeKey)(redis.options);\n        const sub = this.shardedSubscribers.get(nodeKey);\n        if (sub) {\n            sub.stop();\n            this.shardedSubscribers.delete(nodeKey);\n            // Even though the subscriber to this node is going down, we might have another subscriber\n            // handling the same slots, so we need to attempt to subscribe the orphaned channels\n            this._resubscribe();\n            this.cluster.emit(\"-subscriber\");\n        }\n        return this.shardedSubscribers;\n    }\n    /**\n     * Refreshes the subscriber-related slot ranges\n     *\n     * Returns false if no refresh was needed\n     *\n     * @param cluster\n     */ _refreshSlots(cluster) {\n        //If there was an actual change, then reassign the slot ranges\n        if (this._slotsAreEqual(cluster.slots)) {\n            debug(\"Nothing to refresh because the new cluster map is equal to the previous one.\");\n        } else {\n            debug(\"Refreshing the slots of the subscriber group.\");\n            //Rebuild the slots index\n            this.subscriberToSlotsIndex = new Map();\n            for(let slot = 0; slot < cluster.slots.length; slot++){\n                const node = cluster.slots[slot][0];\n                if (!this.subscriberToSlotsIndex.has(node)) {\n                    this.subscriberToSlotsIndex.set(node, []);\n                }\n                this.subscriberToSlotsIndex.get(node).push(Number(slot));\n            }\n            //Update the subscribers from the index\n            this._resubscribe();\n            //Update the cached slots map\n            this.clusterSlots = JSON.parse(JSON.stringify(cluster.slots));\n            this.cluster.emit(\"subscribersReady\");\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Resubscribes to the previous channels\n     *\n     * @private\n     */ _resubscribe() {\n        if (this.shardedSubscribers) {\n            this.shardedSubscribers.forEach((s, nodeKey)=>{\n                const subscriberSlots = this.subscriberToSlotsIndex.get(nodeKey);\n                if (subscriberSlots) {\n                    //More for debugging purposes\n                    s.associateSlotRange(subscriberSlots);\n                    //Resubscribe on the underlying connection\n                    subscriberSlots.forEach((ss)=>{\n                        //Might return null if being disconnected\n                        const redis = s.getInstance();\n                        const channels = this.channels.get(ss);\n                        if (channels && channels.length > 0) {\n                            //Try to subscribe now\n                            if (redis) {\n                                redis.ssubscribe(channels);\n                                //If the instance isn't ready yet, then register the re-subscription for later\n                                redis.on(\"ready\", ()=>{\n                                    redis.ssubscribe(channels);\n                                });\n                            }\n                        }\n                    });\n                }\n            });\n        }\n    }\n    /**\n     * Deep equality of the cluster slots objects\n     *\n     * @param other\n     * @private\n     */ _slotsAreEqual(other) {\n        if (this.clusterSlots === undefined) return false;\n        else return JSON.stringify(this.clusterSlots) === JSON.stringify(other);\n    }\n}\nexports[\"default\"] = ClusterSubscriberGroup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL0NsdXN0ZXJTdWJzY3JpYmVyR3JvdXAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsVUFBVUMsbUJBQU9BLENBQUMsbUVBQVU7QUFDbEMsTUFBTUMsc0JBQXNCRCxtQkFBT0EsQ0FBQyw0RkFBcUI7QUFDekQsTUFBTUUsbUJBQW1CRixtQkFBT0EsQ0FBQyxzRkFBa0I7QUFDbkQsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUMsa0VBQVE7QUFDL0IsTUFBTUksZ0JBQWdCSixtQkFBT0EsQ0FBQyw0RUFBa0I7QUFDaEQsTUFBTUssUUFBUSxDQUFDLEdBQUdOLFFBQVFPLEtBQUssRUFBRTtBQUNqQzs7Ozs7Ozs7OztDQVVDLEdBQ0QsTUFBTUM7SUFDRjs7OztLQUlDLEdBQ0RDLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixJQUFJLENBQUNBLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLGtCQUFrQixHQUFHLElBQUlDO1FBQzlCLElBQUksQ0FBQ0MsWUFBWSxHQUFHLEVBQUU7UUFDdEIsa0ZBQWtGO1FBQ2xGLElBQUksQ0FBQ0Msc0JBQXNCLEdBQUcsSUFBSUY7UUFDbEMsSUFBSSxDQUFDRyxRQUFRLEdBQUcsSUFBSUg7UUFDcEJGLFFBQVFNLEVBQUUsQ0FBQyxTQUFTLENBQUNDO1lBQ2pCLElBQUksQ0FBQ0MsY0FBYyxDQUFDRDtRQUN4QjtRQUNBUCxRQUFRTSxFQUFFLENBQUMsU0FBUyxDQUFDQztZQUNqQixJQUFJLENBQUNFLGlCQUFpQixDQUFDRjtRQUMzQjtRQUNBUCxRQUFRTSxFQUFFLENBQUMsV0FBVztZQUNsQixJQUFJLENBQUNJLGFBQWEsQ0FBQ1Y7UUFDdkI7SUFDSjtJQUNBOzs7Ozs7S0FNQyxHQUNEVyx5QkFBeUJDLElBQUksRUFBRTtRQUMzQixNQUFNQyxVQUFVLElBQUksQ0FBQ1YsWUFBWSxDQUFD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QUFPO0lBQ1g7SUFDQTs7OztLQUlDLEdBQ0RELGVBQWU7UUFDWCxJQUFJLElBQUksQ0FBQ3ZDLGtCQUFrQixFQUFFO1lBQ3pCLElBQUksQ0FBQ0Esa0JBQWtCLENBQUNlLE9BQU8sQ0FBQyxDQUFDZSxHQUFHbEI7Z0JBQ2hDLE1BQU11QyxrQkFBa0IsSUFBSSxDQUFDaEQsc0JBQXNCLENBQUNVLEdBQUcsQ0FBQ0Q7Z0JBQ3hELElBQUl1QyxpQkFBaUI7b0JBQ2pCLDZCQUE2QjtvQkFDN0JyQixFQUFFc0Isa0JBQWtCLENBQUNEO29CQUNyQiwwQ0FBMEM7b0JBQzFDQSxnQkFBZ0JwQyxPQUFPLENBQUMsQ0FBQ3NDO3dCQUNyQix5Q0FBeUM7d0JBQ3pDLE1BQU0vQyxRQUFRd0IsRUFBRXdCLFdBQVc7d0JBQzNCLE1BQU1sRCxXQUFXLElBQUksQ0FBQ0EsUUFBUSxDQUFDUyxHQUFHLENBQUN3Qzt3QkFDbkMsSUFBSWpELFlBQVlBLFNBQVNtQixNQUFNLEdBQUcsR0FBRzs0QkFDakMsc0JBQXNCOzRCQUN0QixJQUFJakIsT0FBTztnQ0FDUEEsTUFBTWlELFVBQVUsQ0FBQ25EO2dDQUNqQiw4RUFBOEU7Z0NBQzlFRSxNQUFNRCxFQUFFLENBQUMsU0FBUztvQ0FDZEMsTUFBTWlELFVBQVUsQ0FBQ25EO2dDQUNyQjs0QkFDSjt3QkFDSjtvQkFDSjtnQkFDSjtZQUNKO1FBQ0o7SUFDSjtJQUNBOzs7OztLQUtDLEdBQ0RzQyxlQUFlYyxLQUFLLEVBQUU7UUFDbEIsSUFBSSxJQUFJLENBQUN0RCxZQUFZLEtBQUt1RCxXQUN0QixPQUFPO2FBRVAsT0FBT1QsS0FBS0UsU0FBUyxDQUFDLElBQUksQ0FBQ2hELFlBQVksTUFBTThDLEtBQUtFLFNBQVMsQ0FBQ007SUFDcEU7QUFDSjtBQUNBckUsa0JBQWUsR0FBR1UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL0NsdXN0ZXJTdWJzY3JpYmVyR3JvdXAuanM/MzI0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBDbHVzdGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZShcIi4vQ2x1c3RlclN1YnNjcmliZXJcIik7XG5jb25zdCBDb25uZWN0aW9uUG9vbF8xID0gcmVxdWlyZShcIi4vQ29ubmVjdGlvblBvb2xcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgY2FsY3VsYXRlU2xvdCA9IHJlcXVpcmUoXCJjbHVzdGVyLWtleS1zbG90XCIpO1xuY29uc3QgZGVidWcgPSAoMCwgdXRpbHNfMS5EZWJ1ZykoXCJjbHVzdGVyOnN1YnNjcmliZXJHcm91cFwiKTtcbi8qKlxuICogUmVkaXMgZGlmZmVycyBiZXR3ZWVuIFwibm9ybWFsXCIgYW5kIHNoYXJkZWQgUHViU3ViLiBJZiB1c2luZyB0aGUgXCJub3JtYWxcIiBQdWJTdWIgZmVhdHVyZSwgZXhhY3RseSBvbmVcbiAqIENsdXN0ZXJTdWJzY3JpYmVyIGV4aXN0cyBwZXIgY2x1c3RlciBpbnN0YW5jZS4gVGhpcyB3b3JrcyBiZWNhdXNlIHRoZSBSZWRpcyBjbHVzdGVyIGJ1cyBmb3J3YXJkcyBtXG4gKiBtZXNzYWdlcyBiZXR3ZWVuIHNoYXJkcy4gSG93ZXZlciwgdGhpcyBoYXMgc2NhbGFiaWxpdHkgbGltaXRhdGlvbnMsIHdoaWNoIGlzIHRoZSByZWFzb24gd2h5IHRoZSBzaGFyZGVkXG4gKiBQdWJTdWIgZmVhdHVyZSB3YXMgYWRkZWQgdG8gUmVkaXMuIFdpdGggc2hhcmRlZCBQdWJTdWIsIGVhY2ggc2hhcmQgaXMgcmVzcG9uc2libGUgZm9yIGl0cyBvd24gbWVzc2FnZXMuXG4gKiBHaXZlbiB0aGF0LCB3ZSBuZWVkIGF0IGxlYXN0IG9uZSBDbHVzdGVyU3Vic2NyaWJlciBwZXIgbWFzdGVyIGVuZHBvaW50L25vZGUuXG4gKlxuICogVGhpcyBjbGFzcyBsZXZlcmFnZXMgdGhlIHByZXZpb3VzbHkgZXhpc2luZyBDbHVzdGVyU3Vic2NyaWJlciBieSBhZGRpbmcgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc3VjaCBzdWJzY3JpYmVyc1xuICogaW4gYWxpZ25tZW50IHRvIHRoZSBtYXN0ZXIgbm9kZXMgb2YgdGhlIGNsdXN0ZXIuIFRoZSBDbHVzdGVyU3Vic2NyaWJlciBjbGFzcyB3YXMgZXh0ZW5kZWQgaW4gYSBub24tYnJlYWtpbmcgd2F5XG4gKiB0byBzdXBwb3J0IHRoaXMgZmVhdHVyZS5cbiAqL1xuY2xhc3MgQ2x1c3RlclN1YnNjcmliZXJHcm91cCB7XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgY2FsbGJhY2tzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2x1c3RlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNsdXN0ZXIpIHtcbiAgICAgICAgdGhpcy5jbHVzdGVyID0gY2x1c3RlcjtcbiAgICAgICAgdGhpcy5zaGFyZGVkU3Vic2NyaWJlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY2x1c3RlclNsb3RzID0gW107XG4gICAgICAgIC8vU2ltcGxlIFttaW4sIG1heF0gc2xvdCByYW5nZXMgYXJlbid0IGVub3VnaCBiZWNhdXNlIHlvdSBjYW4gbWlncmF0ZSBzaW5nbGUgc2xvdHNcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyVG9TbG90c0luZGV4ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0gbmV3IE1hcCgpO1xuICAgICAgICBjbHVzdGVyLm9uKFwiK25vZGVcIiwgKHJlZGlzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9hZGRTdWJzY3JpYmVyKHJlZGlzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNsdXN0ZXIub24oXCItbm9kZVwiLCAocmVkaXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVN1YnNjcmliZXIocmVkaXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2x1c3Rlci5vbihcInJlZnJlc2hcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVmcmVzaFNsb3RzKGNsdXN0ZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByZXNwb25zaWJsZSBzdWJzY3JpYmVyLlxuICAgICAqXG4gICAgICogUmV0dXJucyBudWxsIGlmIG5vIHN1YnNjcmliZXIgd2FzIGZvdW5kXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2xvdFxuICAgICAqL1xuICAgIGdldFJlc3BvbnNpYmxlU3Vic2NyaWJlcihzbG90KSB7XG4gICAgICAgIGNvbnN0IG5vZGVLZXkgPSB0aGlzLmNsdXN0ZXJTbG90c1tzbG90XVswXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcmRlZFN1YnNjcmliZXJzLmdldChub2RlS2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNoYW5uZWwgZm9yIHdoaWNoIHRoaXMgc3Vic2NyaWJlciBncm91cCBpcyByZXNwb25zaWJsZVxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWxzXG4gICAgICovXG4gICAgYWRkQ2hhbm5lbHMoY2hhbm5lbHMpIHtcbiAgICAgICAgY29uc3Qgc2xvdCA9IGNhbGN1bGF0ZVNsb3QoY2hhbm5lbHNbMF0pO1xuICAgICAgICAvL0NoZWNrIGlmIHRoZSBhbGwgY2hhbm5lbHMgYmVsb25nIHRvIHRoZSBzYW1lIHNsb3QgYW5kIG90aGVyd2lzZSByZWplY3QgdGhlIG9wZXJhdGlvblxuICAgICAgICBjaGFubmVscy5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FsY3VsYXRlU2xvdChjKSAhPSBzbG90KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGN1cnJDaGFubmVscyA9IHRoaXMuY2hhbm5lbHMuZ2V0KHNsb3QpO1xuICAgICAgICBpZiAoIWN1cnJDaGFubmVscykge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVscy5zZXQoc2xvdCwgY2hhbm5lbHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVscy5zZXQoc2xvdCwgY3VyckNoYW5uZWxzLmNvbmNhdChjaGFubmVscykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbLi4udGhpcy5jaGFubmVscy52YWx1ZXMoKV0uZmxhdE1hcCh2ID0+IHYpLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBjaGFubmVscyBmb3Igd2hpY2ggdGhlIHN1YnNjcmliZXIgZ3JvdXAgaXMgcmVzcG9uc2libGUgYnkgb3B0aW9uYWxseSB1bnN1YnNjcmliaW5nXG4gICAgICogQHBhcmFtIGNoYW5uZWxzXG4gICAgICovXG4gICAgcmVtb3ZlQ2hhbm5lbHMoY2hhbm5lbHMpIHtcbiAgICAgICAgY29uc3Qgc2xvdCA9IGNhbGN1bGF0ZVNsb3QoY2hhbm5lbHNbMF0pO1xuICAgICAgICAvL0NoZWNrIGlmIHRoZSBhbGwgY2hhbm5lbHMgYmVsb25nIHRvIHRoZSBzYW1lIHNsb3QgYW5kIG90aGVyd2lzZSByZWplY3QgdGhlIG9wZXJhdGlvblxuICAgICAgICBjaGFubmVscy5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FsY3VsYXRlU2xvdChjKSAhPSBzbG90KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNsb3RDaGFubmVscyA9IHRoaXMuY2hhbm5lbHMuZ2V0KHNsb3QpO1xuICAgICAgICBpZiAoc2xvdENoYW5uZWxzKSB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkQ2hhbm5lbHMgPSBzbG90Q2hhbm5lbHMuZmlsdGVyKGMgPT4gIWNoYW5uZWxzLmluY2x1ZGVzKGMpKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHMuc2V0KHNsb3QsIHVwZGF0ZWRDaGFubmVscyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLmNoYW5uZWxzLnZhbHVlcygpXS5mbGF0TWFwKHYgPT4gdikubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0IGFsbCBzdWJzY3JpYmVyc1xuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiB0aGlzLnNoYXJkZWRTdWJzY3JpYmVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgcy5zdG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgYWxsIG5vdCB5ZXQgc3RhcnRlZCBzdWJzY3JpYmVyc1xuICAgICAqL1xuICAgIHN0YXJ0KCkge1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgdGhpcy5zaGFyZGVkU3Vic2NyaWJlcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmICghcy5pc1N0YXJ0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHMuc3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBzdWJzY3JpYmVyIHRvIHRoZSBncm91cCBvZiBzdWJzY3JpYmVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIHJlZGlzXG4gICAgICovXG4gICAgX2FkZFN1YnNjcmliZXIocmVkaXMpIHtcbiAgICAgICAgY29uc3QgcG9vbCA9IG5ldyBDb25uZWN0aW9uUG9vbF8xLmRlZmF1bHQocmVkaXMub3B0aW9ucyk7XG4gICAgICAgIGlmIChwb29sLmFkZE1hc3Rlck5vZGUocmVkaXMpKSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBuZXcgQ2x1c3RlclN1YnNjcmliZXJfMS5kZWZhdWx0KHBvb2wsIHRoaXMuY2x1c3RlciwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBub2RlS2V5ID0gKDAsIHV0aWxfMS5nZXROb2RlS2V5KShyZWRpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuc2hhcmRlZFN1YnNjcmliZXJzLnNldChub2RlS2V5LCBzdWIpO1xuICAgICAgICAgICAgc3ViLnN0YXJ0KCk7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGF0dGVtcHQgdG8gcmVzdWJzY3JpYmUgdGhlbSBpbiBjYXNlIHRoZSBuZXcgbm9kZSBzZXJ2ZXMgdGhlaXIgc2xvdFxuICAgICAgICAgICAgdGhpcy5fcmVzdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuY2x1c3Rlci5lbWl0KFwiK3N1YnNjcmliZXJcIik7XG4gICAgICAgICAgICByZXR1cm4gc3ViO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgc3Vic2NyaWJlciBmcm9tIHRoZSBncm91cFxuICAgICAqIEBwYXJhbSByZWRpc1xuICAgICAqL1xuICAgIF9yZW1vdmVTdWJzY3JpYmVyKHJlZGlzKSB7XG4gICAgICAgIGNvbnN0IG5vZGVLZXkgPSAoMCwgdXRpbF8xLmdldE5vZGVLZXkpKHJlZGlzLm9wdGlvbnMpO1xuICAgICAgICBjb25zdCBzdWIgPSB0aGlzLnNoYXJkZWRTdWJzY3JpYmVycy5nZXQobm9kZUtleSk7XG4gICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgIHN1Yi5zdG9wKCk7XG4gICAgICAgICAgICB0aGlzLnNoYXJkZWRTdWJzY3JpYmVycy5kZWxldGUobm9kZUtleSk7XG4gICAgICAgICAgICAvLyBFdmVuIHRob3VnaCB0aGUgc3Vic2NyaWJlciB0byB0aGlzIG5vZGUgaXMgZ29pbmcgZG93biwgd2UgbWlnaHQgaGF2ZSBhbm90aGVyIHN1YnNjcmliZXJcbiAgICAgICAgICAgIC8vIGhhbmRsaW5nIHRoZSBzYW1lIHNsb3RzLCBzbyB3ZSBuZWVkIHRvIGF0dGVtcHQgdG8gc3Vic2NyaWJlIHRoZSBvcnBoYW5lZCBjaGFubmVsc1xuICAgICAgICAgICAgdGhpcy5fcmVzdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuY2x1c3Rlci5lbWl0KFwiLXN1YnNjcmliZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcmRlZFN1YnNjcmliZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWZyZXNoZXMgdGhlIHN1YnNjcmliZXItcmVsYXRlZCBzbG90IHJhbmdlc1xuICAgICAqXG4gICAgICogUmV0dXJucyBmYWxzZSBpZiBubyByZWZyZXNoIHdhcyBuZWVkZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbHVzdGVyXG4gICAgICovXG4gICAgX3JlZnJlc2hTbG90cyhjbHVzdGVyKSB7XG4gICAgICAgIC8vSWYgdGhlcmUgd2FzIGFuIGFjdHVhbCBjaGFuZ2UsIHRoZW4gcmVhc3NpZ24gdGhlIHNsb3QgcmFuZ2VzXG4gICAgICAgIGlmICh0aGlzLl9zbG90c0FyZUVxdWFsKGNsdXN0ZXIuc2xvdHMpKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcIk5vdGhpbmcgdG8gcmVmcmVzaCBiZWNhdXNlIHRoZSBuZXcgY2x1c3RlciBtYXAgaXMgZXF1YWwgdG8gdGhlIHByZXZpb3VzIG9uZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWJ1ZyhcIlJlZnJlc2hpbmcgdGhlIHNsb3RzIG9mIHRoZSBzdWJzY3JpYmVyIGdyb3VwLlwiKTtcbiAgICAgICAgICAgIC8vUmVidWlsZCB0aGUgc2xvdHMgaW5kZXhcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlclRvU2xvdHNJbmRleCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHNsb3QgPSAwOyBzbG90IDwgY2x1c3Rlci5zbG90cy5sZW5ndGg7IHNsb3QrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBjbHVzdGVyLnNsb3RzW3Nsb3RdWzBdO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdWJzY3JpYmVyVG9TbG90c0luZGV4Lmhhcyhub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZXJUb1Nsb3RzSW5kZXguc2V0KG5vZGUsIFtdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyVG9TbG90c0luZGV4LmdldChub2RlKS5wdXNoKE51bWJlcihzbG90KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1VwZGF0ZSB0aGUgc3Vic2NyaWJlcnMgZnJvbSB0aGUgaW5kZXhcbiAgICAgICAgICAgIHRoaXMuX3Jlc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAvL1VwZGF0ZSB0aGUgY2FjaGVkIHNsb3RzIG1hcFxuICAgICAgICAgICAgdGhpcy5jbHVzdGVyU2xvdHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNsdXN0ZXIuc2xvdHMpKTtcbiAgICAgICAgICAgIHRoaXMuY2x1c3Rlci5lbWl0KFwic3Vic2NyaWJlcnNSZWFkeVwiKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzdWJzY3JpYmVzIHRvIHRoZSBwcmV2aW91cyBjaGFubmVsc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVzdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmICh0aGlzLnNoYXJkZWRTdWJzY3JpYmVycykge1xuICAgICAgICAgICAgdGhpcy5zaGFyZGVkU3Vic2NyaWJlcnMuZm9yRWFjaCgocywgbm9kZUtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YnNjcmliZXJTbG90cyA9IHRoaXMuc3Vic2NyaWJlclRvU2xvdHNJbmRleC5nZXQobm9kZUtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHN1YnNjcmliZXJTbG90cykge1xuICAgICAgICAgICAgICAgICAgICAvL01vcmUgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlc1xuICAgICAgICAgICAgICAgICAgICBzLmFzc29jaWF0ZVNsb3RSYW5nZShzdWJzY3JpYmVyU2xvdHMpO1xuICAgICAgICAgICAgICAgICAgICAvL1Jlc3Vic2NyaWJlIG9uIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlclNsb3RzLmZvckVhY2goKHNzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL01pZ2h0IHJldHVybiBudWxsIGlmIGJlaW5nIGRpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVkaXMgPSBzLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVscyA9IHRoaXMuY2hhbm5lbHMuZ2V0KHNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFubmVscyAmJiBjaGFubmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UcnkgdG8gc3Vic2NyaWJlIG5vd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWRpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWRpcy5zc3Vic2NyaWJlKGNoYW5uZWxzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiB0aGUgaW5zdGFuY2UgaXNuJ3QgcmVhZHkgeWV0LCB0aGVuIHJlZ2lzdGVyIHRoZSByZS1zdWJzY3JpcHRpb24gZm9yIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZGlzLm9uKFwicmVhZHlcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXMuc3N1YnNjcmliZShjaGFubmVscyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVlcCBlcXVhbGl0eSBvZiB0aGUgY2x1c3RlciBzbG90cyBvYmplY3RzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3RoZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zbG90c0FyZUVxdWFsKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNsdXN0ZXJTbG90cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5jbHVzdGVyU2xvdHMpID09PSBKU09OLnN0cmluZ2lmeShvdGhlcik7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ2x1c3RlclN1YnNjcmliZXJHcm91cDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInV0aWxzXzEiLCJyZXF1aXJlIiwiQ2x1c3RlclN1YnNjcmliZXJfMSIsIkNvbm5lY3Rpb25Qb29sXzEiLCJ1dGlsXzEiLCJjYWxjdWxhdGVTbG90IiwiZGVidWciLCJEZWJ1ZyIsIkNsdXN0ZXJTdWJzY3JpYmVyR3JvdXAiLCJjb25zdHJ1Y3RvciIsImNsdXN0ZXIiLCJzaGFyZGVkU3Vic2NyaWJlcnMiLCJNYXAiLCJjbHVzdGVyU2xvdHMiLCJzdWJzY3JpYmVyVG9TbG90c0luZGV4IiwiY2hhbm5lbHMiLCJvbiIsInJlZGlzIiwiX2FkZFN1YnNjcmliZXIiLCJfcmVtb3ZlU3Vic2NyaWJlciIsIl9yZWZyZXNoU2xvdHMiLCJnZXRSZXNwb25zaWJsZVN1YnNjcmliZXIiLCJzbG90Iiwibm9kZUtleSIsImdldCIsImFkZENoYW5uZWxzIiwiZm9yRWFjaCIsImMiLCJjdXJyQ2hhbm5lbHMiLCJzZXQiLCJjb25jYXQiLCJ2YWx1ZXMiLCJmbGF0TWFwIiwidiIsImxlbmd0aCIsInJlbW92ZUNoYW5uZWxzIiwic2xvdENoYW5uZWxzIiwidXBkYXRlZENoYW5uZWxzIiwiZmlsdGVyIiwiaW5jbHVkZXMiLCJzdG9wIiwicyIsInN0YXJ0IiwiaXNTdGFydGVkIiwicG9vbCIsImRlZmF1bHQiLCJvcHRpb25zIiwiYWRkTWFzdGVyTm9kZSIsInN1YiIsImdldE5vZGVLZXkiLCJfcmVzdWJzY3JpYmUiLCJlbWl0IiwiZGVsZXRlIiwiX3Nsb3RzQXJlRXF1YWwiLCJzbG90cyIsIm5vZGUiLCJoYXMiLCJwdXNoIiwiTnVtYmVyIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5Iiwic3Vic2NyaWJlclNsb3RzIiwiYXNzb2NpYXRlU2xvdFJhbmdlIiwic3MiLCJnZXRJbnN0YW5jZSIsInNzdWJzY3JpYmUiLCJvdGhlciIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/cluster/ClusterSubscriberGroup.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/cluster/ConnectionPool.js":
/*!**************************************************************!*\
  !*** ./node_modules/ioredis/built/cluster/ConnectionPool.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/ioredis/built/cluster/util.js\");\nconst Redis_1 = __webpack_require__(/*! ../Redis */ \"(rsc)/./node_modules/ioredis/built/Redis.js\");\nconst debug = (0, utils_1.Debug)(\"cluster:connectionPool\");\nclass ConnectionPool extends events_1.EventEmitter {\n    constructor(redisOptions){\n        super();\n        this.redisOptions = redisOptions;\n        // master + slave = all\n        this.nodes = {\n            all: {},\n            master: {},\n            slave: {}\n        };\n        this.specifiedOptions = {};\n    }\n    getNodes(role = \"all\") {\n        const nodes = this.nodes[role];\n        return Object.keys(nodes).map((key)=>nodes[key]);\n    }\n    getInstanceByKey(key) {\n        return this.nodes.all[key];\n    }\n    getSampleInstance(role) {\n        const keys = Object.keys(this.nodes[role]);\n        const sampleKey = (0, utils_1.sample)(keys);\n        return this.nodes[role][sampleKey];\n    }\n    /**\n     * Add a master node to the pool\n     * @param node\n     */ addMasterNode(node) {\n        const key = (0, util_1.getNodeKey)(node.options);\n        const redis = this.createRedisFromOptions(node, node.options.readOnly);\n        //Master nodes aren't read-only\n        if (!node.options.readOnly) {\n            this.nodes.all[key] = redis;\n            this.nodes.master[key] = redis;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Creates a Redis connection instance from the node options\n     * @param node\n     * @param readOnly\n     */ createRedisFromOptions(node, readOnly) {\n        const redis = new Redis_1.default((0, utils_1.defaults)({\n            // Never try to reconnect when a node is lose,\n            // instead, waiting for a `MOVED` error and\n            // fetch the slots again.\n            retryStrategy: null,\n            // Offline queue should be enabled so that\n            // we don't need to wait for the `ready` event\n            // before sending commands to the node.\n            enableOfflineQueue: true,\n            readOnly: readOnly\n        }, node, this.redisOptions, {\n            lazyConnect: true\n        }));\n        return redis;\n    }\n    /**\n     * Find or create a connection to the node\n     */ findOrCreate(node, readOnly = false) {\n        const key = (0, util_1.getNodeKey)(node);\n        readOnly = Boolean(readOnly);\n        if (this.specifiedOptions[key]) {\n            Object.assign(node, this.specifiedOptions[key]);\n        } else {\n            this.specifiedOptions[key] = node;\n        }\n        let redis;\n        if (this.nodes.all[key]) {\n            redis = this.nodes.all[key];\n            if (redis.options.readOnly !== readOnly) {\n                redis.options.readOnly = readOnly;\n                debug(\"Change role of %s to %s\", key, readOnly ? \"slave\" : \"master\");\n                redis[readOnly ? \"readonly\" : \"readwrite\"]().catch(utils_1.noop);\n                if (readOnly) {\n                    delete this.nodes.master[key];\n                    this.nodes.slave[key] = redis;\n                } else {\n                    delete this.nodes.slave[key];\n                    this.nodes.master[key] = redis;\n                }\n            }\n        } else {\n            debug(\"Connecting to %s as %s\", key, readOnly ? \"slave\" : \"master\");\n            redis = this.createRedisFromOptions(node, readOnly);\n            this.nodes.all[key] = redis;\n            this.nodes[readOnly ? \"slave\" : \"master\"][key] = redis;\n            redis.once(\"end\", ()=>{\n                this.removeNode(key);\n                this.emit(\"-node\", redis, key);\n                if (!Object.keys(this.nodes.all).length) {\n                    this.emit(\"drain\");\n                }\n            });\n            this.emit(\"+node\", redis, key);\n            redis.on(\"error\", function(error) {\n                this.emit(\"nodeError\", error, key);\n            });\n        }\n        return redis;\n    }\n    /**\n     * Reset the pool with a set of nodes.\n     * The old node will be removed.\n     */ reset(nodes) {\n        debug(\"Reset with %O\", nodes);\n        const newNodes = {};\n        nodes.forEach((node)=>{\n            const key = (0, util_1.getNodeKey)(node);\n            // Don't override the existing (master) node\n            // when the current one is slave.\n            if (!(node.readOnly && newNodes[key])) {\n                newNodes[key] = node;\n            }\n        });\n        Object.keys(this.nodes.all).forEach((key)=>{\n            if (!newNodes[key]) {\n                debug(\"Disconnect %s because the node does not hold any slot\", key);\n                this.nodes.all[key].disconnect();\n                this.removeNode(key);\n            }\n        });\n        Object.keys(newNodes).forEach((key)=>{\n            const node = newNodes[key];\n            this.findOrCreate(node, node.readOnly);\n        });\n    }\n    /**\n     * Remove a node from the pool.\n     */ removeNode(key) {\n        const { nodes } = this;\n        if (nodes.all[key]) {\n            debug(\"Remove %s from the pool\", key);\n            delete nodes.all[key];\n        }\n        delete nodes.master[key];\n        delete nodes.slave[key];\n    }\n}\nexports[\"default\"] = ConnectionPool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL0Nvbm5lY3Rpb25Qb29sLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFdBQVdDLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pDLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLG1FQUFVO0FBQ2xDLE1BQU1FLFNBQVNGLG1CQUFPQSxDQUFDLGtFQUFRO0FBQy9CLE1BQU1HLFVBQVVILG1CQUFPQSxDQUFDLDZEQUFVO0FBQ2xDLE1BQU1JLFFBQVEsQ0FBQyxHQUFHSCxRQUFRSSxLQUFLLEVBQUU7QUFDakMsTUFBTUMsdUJBQXVCUCxTQUFTUSxZQUFZO0lBQzlDQyxZQUFZQyxZQUFZLENBQUU7UUFDdEIsS0FBSztRQUNMLElBQUksQ0FBQ0EsWUFBWSxHQUFHQTtRQUNwQix1QkFBdUI7UUFDdkIsSUFBSSxDQUFDQyxLQUFLLEdBQUc7WUFDVEMsS0FBSyxDQUFDO1lBQ05DLFFBQVEsQ0FBQztZQUNUQyxPQUFPLENBQUM7UUFDWjtRQUNBLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUcsQ0FBQztJQUM3QjtJQUNBQyxTQUFTQyxPQUFPLEtBQUssRUFBRTtRQUNuQixNQUFNTixRQUFRLElBQUksQ0FBQ0EsS0FBSyxDQUFDTSxLQUFLO1FBQzlCLE9BQU9yQixPQUFPc0IsSUFBSSxDQUFDUCxPQUFPUSxHQUFHLENBQUMsQ0FBQ0MsTUFBUVQsS0FBSyxDQUFDUyxJQUFJO0lBQ3JEO0lBQ0FDLGlCQUFpQkQsR0FBRyxFQUFFO1FBQ2xCLE9BQU8sSUFBSSxDQUFDVCxLQUFLLENBQUNDLEdBQUcsQ0FBQ1EsSUFBSTtJQUM5QjtJQUNBRSxrQkFBa0JMLElBQUksRUFBRTtRQUNwQixNQUFNQyxPQUFPdEIsT0FBT3NCLElBQUksQ0FBQyxJQUFJLENBQUNQLEtBQUssQ0FBQ00sS0FBSztRQUN6QyxNQUFNTSxZQUFZLENBQUMsR0FBR3JCLFFB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dUIsUUFBUSxDQUFDN0IsSUFBSTtZQUMxQixJQUFJLENBQUNpQixZQUFZLENBQUNYLE1BQU1BLEtBQUtLLFFBQVE7UUFDekM7SUFDSjtJQUNBOztLQUVDLEdBQ0RZLFdBQVd2QixHQUFHLEVBQUU7UUFDWixNQUFNLEVBQUVULEtBQUssRUFBRSxHQUFHLElBQUk7UUFDdEIsSUFBSUEsTUFBTUMsR0FBRyxDQUFDUSxJQUFJLEVBQUU7WUFDaEJmLE1BQU0sMkJBQTJCZTtZQUNqQyxPQUFPVCxNQUFNQyxHQUFHLENBQUNRLElBQUk7UUFDekI7UUFDQSxPQUFPVCxNQUFNRSxNQUFNLENBQUNPLElBQUk7UUFDeEIsT0FBT1QsTUFBTUcsS0FBSyxDQUFDTSxJQUFJO0lBQzNCO0FBQ0o7QUFDQXRCLGtCQUFlLEdBQUdTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY2x1c3Rlci9Db25uZWN0aW9uUG9vbC5qcz8wZDNlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCBSZWRpc18xID0gcmVxdWlyZShcIi4uL1JlZGlzXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgdXRpbHNfMS5EZWJ1ZykoXCJjbHVzdGVyOmNvbm5lY3Rpb25Qb29sXCIpO1xuY2xhc3MgQ29ubmVjdGlvblBvb2wgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHJlZGlzT3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJlZGlzT3B0aW9ucyA9IHJlZGlzT3B0aW9ucztcbiAgICAgICAgLy8gbWFzdGVyICsgc2xhdmUgPSBhbGxcbiAgICAgICAgdGhpcy5ub2RlcyA9IHtcbiAgICAgICAgICAgIGFsbDoge30sXG4gICAgICAgICAgICBtYXN0ZXI6IHt9LFxuICAgICAgICAgICAgc2xhdmU6IHt9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNwZWNpZmllZE9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgZ2V0Tm9kZXMocm9sZSA9IFwiYWxsXCIpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSB0aGlzLm5vZGVzW3JvbGVdO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMobm9kZXMpLm1hcCgoa2V5KSA9PiBub2Rlc1trZXldKTtcbiAgICB9XG4gICAgZ2V0SW5zdGFuY2VCeUtleShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXMuYWxsW2tleV07XG4gICAgfVxuICAgIGdldFNhbXBsZUluc3RhbmNlKHJvbGUpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMubm9kZXNbcm9sZV0pO1xuICAgICAgICBjb25zdCBzYW1wbGVLZXkgPSAoMCwgdXRpbHNfMS5zYW1wbGUpKGtleXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlc1tyb2xlXVtzYW1wbGVLZXldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBtYXN0ZXIgbm9kZSB0byB0aGUgcG9vbFxuICAgICAqIEBwYXJhbSBub2RlXG4gICAgICovXG4gICAgYWRkTWFzdGVyTm9kZShub2RlKSB7XG4gICAgICAgIGNvbnN0IGtleSA9ICgwLCB1dGlsXzEuZ2V0Tm9kZUtleSkobm9kZS5vcHRpb25zKTtcbiAgICAgICAgY29uc3QgcmVkaXMgPSB0aGlzLmNyZWF0ZVJlZGlzRnJvbU9wdGlvbnMobm9kZSwgbm9kZS5vcHRpb25zLnJlYWRPbmx5KTtcbiAgICAgICAgLy9NYXN0ZXIgbm9kZXMgYXJlbid0IHJlYWQtb25seVxuICAgICAgICBpZiAoIW5vZGUub3B0aW9ucy5yZWFkT25seSkge1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5hbGxba2V5XSA9IHJlZGlzO1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5tYXN0ZXJba2V5XSA9IHJlZGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgUmVkaXMgY29ubmVjdGlvbiBpbnN0YW5jZSBmcm9tIHRoZSBub2RlIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAqIEBwYXJhbSByZWFkT25seVxuICAgICAqL1xuICAgIGNyZWF0ZVJlZGlzRnJvbU9wdGlvbnMobm9kZSwgcmVhZE9ubHkpIHtcbiAgICAgICAgY29uc3QgcmVkaXMgPSBuZXcgUmVkaXNfMS5kZWZhdWx0KCgwLCB1dGlsc18xLmRlZmF1bHRzKSh7XG4gICAgICAgICAgICAvLyBOZXZlciB0cnkgdG8gcmVjb25uZWN0IHdoZW4gYSBub2RlIGlzIGxvc2UsXG4gICAgICAgICAgICAvLyBpbnN0ZWFkLCB3YWl0aW5nIGZvciBhIGBNT1ZFRGAgZXJyb3IgYW5kXG4gICAgICAgICAgICAvLyBmZXRjaCB0aGUgc2xvdHMgYWdhaW4uXG4gICAgICAgICAgICByZXRyeVN0cmF0ZWd5OiBudWxsLFxuICAgICAgICAgICAgLy8gT2ZmbGluZSBxdWV1ZSBzaG91bGQgYmUgZW5hYmxlZCBzbyB0aGF0XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHdhaXQgZm9yIHRoZSBgcmVhZHlgIGV2ZW50XG4gICAgICAgICAgICAvLyBiZWZvcmUgc2VuZGluZyBjb21tYW5kcyB0byB0aGUgbm9kZS5cbiAgICAgICAgICAgIGVuYWJsZU9mZmxpbmVRdWV1ZTogdHJ1ZSxcbiAgICAgICAgICAgIHJlYWRPbmx5OiByZWFkT25seSxcbiAgICAgICAgfSwgbm9kZSwgdGhpcy5yZWRpc09wdGlvbnMsIHsgbGF6eUNvbm5lY3Q6IHRydWUgfSkpO1xuICAgICAgICByZXR1cm4gcmVkaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgb3IgY3JlYXRlIGEgY29ubmVjdGlvbiB0byB0aGUgbm9kZVxuICAgICAqL1xuICAgIGZpbmRPckNyZWF0ZShub2RlLCByZWFkT25seSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGtleSA9ICgwLCB1dGlsXzEuZ2V0Tm9kZUtleSkobm9kZSk7XG4gICAgICAgIHJlYWRPbmx5ID0gQm9vbGVhbihyZWFkT25seSk7XG4gICAgICAgIGlmICh0aGlzLnNwZWNpZmllZE9wdGlvbnNba2V5XSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihub2RlLCB0aGlzLnNwZWNpZmllZE9wdGlvbnNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNwZWNpZmllZE9wdGlvbnNba2V5XSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlZGlzO1xuICAgICAgICBpZiAodGhpcy5ub2Rlcy5hbGxba2V5XSkge1xuICAgICAgICAgICAgcmVkaXMgPSB0aGlzLm5vZGVzLmFsbFtrZXldO1xuICAgICAgICAgICAgaWYgKHJlZGlzLm9wdGlvbnMucmVhZE9ubHkgIT09IHJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgcmVkaXMub3B0aW9ucy5yZWFkT25seSA9IHJlYWRPbmx5O1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiQ2hhbmdlIHJvbGUgb2YgJXMgdG8gJXNcIiwga2V5LCByZWFkT25seSA/IFwic2xhdmVcIiA6IFwibWFzdGVyXCIpO1xuICAgICAgICAgICAgICAgIHJlZGlzW3JlYWRPbmx5ID8gXCJyZWFkb25seVwiIDogXCJyZWFkd3JpdGVcIl0oKS5jYXRjaCh1dGlsc18xLm5vb3ApO1xuICAgICAgICAgICAgICAgIGlmIChyZWFkT25seSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5ub2Rlcy5tYXN0ZXJba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5zbGF2ZVtrZXldID0gcmVkaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5ub2Rlcy5zbGF2ZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLm1hc3RlcltrZXldID0gcmVkaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoXCJDb25uZWN0aW5nIHRvICVzIGFzICVzXCIsIGtleSwgcmVhZE9ubHkgPyBcInNsYXZlXCIgOiBcIm1hc3RlclwiKTtcbiAgICAgICAgICAgIHJlZGlzID0gdGhpcy5jcmVhdGVSZWRpc0Zyb21PcHRpb25zKG5vZGUsIHJlYWRPbmx5KTtcbiAgICAgICAgICAgIHRoaXMubm9kZXMuYWxsW2tleV0gPSByZWRpcztcbiAgICAgICAgICAgIHRoaXMubm9kZXNbcmVhZE9ubHkgPyBcInNsYXZlXCIgOiBcIm1hc3RlclwiXVtrZXldID0gcmVkaXM7XG4gICAgICAgICAgICByZWRpcy5vbmNlKFwiZW5kXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGUoa2V5KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCItbm9kZVwiLCByZWRpcywga2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMubm9kZXMuYWxsKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZHJhaW5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCIrbm9kZVwiLCByZWRpcywga2V5KTtcbiAgICAgICAgICAgIHJlZGlzLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibm9kZUVycm9yXCIsIGVycm9yLCBrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgcG9vbCB3aXRoIGEgc2V0IG9mIG5vZGVzLlxuICAgICAqIFRoZSBvbGQgbm9kZSB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICovXG4gICAgcmVzZXQobm9kZXMpIHtcbiAgICAgICAgZGVidWcoXCJSZXNldCB3aXRoICVPXCIsIG5vZGVzKTtcbiAgICAgICAgY29uc3QgbmV3Tm9kZXMgPSB7fTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gKDAsIHV0aWxfMS5nZXROb2RlS2V5KShub2RlKTtcbiAgICAgICAgICAgIC8vIERvbid0IG92ZXJyaWRlIHRoZSBleGlzdGluZyAobWFzdGVyKSBub2RlXG4gICAgICAgICAgICAvLyB3aGVuIHRoZSBjdXJyZW50IG9uZSBpcyBzbGF2ZS5cbiAgICAgICAgICAgIGlmICghKG5vZGUucmVhZE9ubHkgJiYgbmV3Tm9kZXNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBuZXdOb2Rlc1trZXldID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMubm9kZXMuYWxsKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICghbmV3Tm9kZXNba2V5XSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiRGlzY29ubmVjdCAlcyBiZWNhdXNlIHRoZSBub2RlIGRvZXMgbm90IGhvbGQgYW55IHNsb3RcIiwga2V5KTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLmFsbFtrZXldLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5rZXlzKG5ld05vZGVzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBuZXdOb2Rlc1trZXldO1xuICAgICAgICAgICAgdGhpcy5maW5kT3JDcmVhdGUobm9kZSwgbm9kZS5yZWFkT25seSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBub2RlIGZyb20gdGhlIHBvb2wuXG4gICAgICovXG4gICAgcmVtb3ZlTm9kZShrZXkpIHtcbiAgICAgICAgY29uc3QgeyBub2RlcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKG5vZGVzLmFsbFtrZXldKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcIlJlbW92ZSAlcyBmcm9tIHRoZSBwb29sXCIsIGtleSk7XG4gICAgICAgICAgICBkZWxldGUgbm9kZXMuYWxsW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIG5vZGVzLm1hc3RlcltrZXldO1xuICAgICAgICBkZWxldGUgbm9kZXMuc2xhdmVba2V5XTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBDb25uZWN0aW9uUG9vbDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImV2ZW50c18xIiwicmVxdWlyZSIsInV0aWxzXzEiLCJ1dGlsXzEiLCJSZWRpc18xIiwiZGVidWciLCJEZWJ1ZyIsIkNvbm5lY3Rpb25Qb29sIiwiRXZlbnRFbWl0dGVyIiwiY29uc3RydWN0b3IiLCJyZWRpc09wdGlvbnMiLCJub2RlcyIsImFsbCIsIm1hc3RlciIsInNsYXZlIiwic3BlY2lmaWVkT3B0aW9ucyIsImdldE5vZGVzIiwicm9sZSIsImtleXMiLCJtYXAiLCJrZXkiLCJnZXRJbnN0YW5jZUJ5S2V5IiwiZ2V0U2FtcGxlSW5zdGFuY2UiLCJzYW1wbGVLZXkiLCJzYW1wbGUiLCJhZGRNYXN0ZXJOb2RlIiwibm9kZSIsImdldE5vZGVLZXkiLCJvcHRpb25zIiwicmVkaXMiLCJjcmVhdGVSZWRpc0Zyb21PcHRpb25zIiwicmVhZE9ubHkiLCJkZWZhdWx0IiwiZGVmYXVsdHMiLCJyZXRyeVN0cmF0ZWd5IiwiZW5hYmxlT2ZmbGluZVF1ZXVlIiwibGF6eUNvbm5lY3QiLCJmaW5kT3JDcmVhdGUiLCJCb29sZWFuIiwiYXNzaWduIiwiY2F0Y2giLCJub29wIiwib25jZSIsInJlbW92ZU5vZGUiLCJlbWl0IiwibGVuZ3RoIiwib24iLCJlcnJvciIsInJlc2V0IiwibmV3Tm9kZXMiLCJmb3JFYWNoIiwiZGlzY29ubmVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/cluster/ConnectionPool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/cluster/DelayQueue.js":
/*!**********************************************************!*\
  !*** ./node_modules/ioredis/built/cluster/DelayQueue.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst Deque = __webpack_require__(/*! denque */ \"(rsc)/./node_modules/denque/index.js\");\nconst debug = (0, utils_1.Debug)(\"delayqueue\");\n/**\n * Queue that runs items after specified duration\n */ class DelayQueue {\n    constructor(){\n        this.queues = {};\n        this.timeouts = {};\n    }\n    /**\n     * Add a new item to the queue\n     *\n     * @param bucket bucket name\n     * @param item function that will run later\n     * @param options\n     */ push(bucket, item, options) {\n        const callback = options.callback || process.nextTick;\n        if (!this.queues[bucket]) {\n            this.queues[bucket] = new Deque();\n        }\n        const queue = this.queues[bucket];\n        queue.push(item);\n        if (!this.timeouts[bucket]) {\n            this.timeouts[bucket] = setTimeout(()=>{\n                callback(()=>{\n                    this.timeouts[bucket] = null;\n                    this.execute(bucket);\n                });\n            }, options.timeout);\n        }\n    }\n    execute(bucket) {\n        const queue = this.queues[bucket];\n        if (!queue) {\n            return;\n        }\n        const { length } = queue;\n        if (!length) {\n            return;\n        }\n        debug(\"send %d commands in %s queue\", length, bucket);\n        this.queues[bucket] = null;\n        while(queue.length > 0){\n            queue.shift()();\n        }\n    }\n}\nexports[\"default\"] = DelayQueue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL0RlbGF5UXVldWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsVUFBVUMsbUJBQU9BLENBQUMsbUVBQVU7QUFDbEMsTUFBTUMsUUFBUUQsbUJBQU9BLENBQUMsb0RBQVE7QUFDOUIsTUFBTUUsUUFBUSxDQUFDLEdBQUdILFFBQVFJLEtBQUssRUFBRTtBQUNqQzs7Q0FFQyxHQUNELE1BQU1DO0lBQ0ZDLGFBQWM7UUFDVixJQUFJLENBQUNDLE1BQU0sR0FBRyxDQUFDO1FBQ2YsSUFBSSxDQUFDQyxRQUFRLEdBQUcsQ0FBQztJQUNyQjtJQUNBOzs7Ozs7S0FNQyxHQUNEQyxLQUFLQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsT0FBTyxFQUFFO1FBQ3hCLE1BQU1DLFdBQVdELFFBQVFDLFFBQVEsSUFBSUMsUUFBUUMsUUFBUTtRQUNyRCxJQUFJLENBQUMsSUFBSSxDQUFDUixNQUFNLENBQUNHLE9BQU8sRUFBRTtZQUN0QixJQUFJLENBQUNILE1BQU0sQ0FBQ0csT0FBTyxHQUFHLElBQUlSO1FBQzlCO1FBQ0EsTUFBTWMsUUFBUSxJQUFJLENBQUNULE1BQU0sQ0FBQ0csT0FBTztRQUNqQ00sTUFBTVAsSUFBSSxDQUFDRTtRQUNYLElBQUksQ0FBQyxJQUFJLENBQUNILFFBQVEsQ0FBQ0UsT0FBTyxFQUFFO1lBQ3hCLElBQUksQ0FBQ0YsUUFBUSxDQUFDRSxPQUFPLEdBQUdPLFdBQVc7Z0JBQy9CSixTQUFTO29CQUNMLElBQUksQ0FBQ0wsUUFBUSxDQUFDRSxPQUFPLEdBQUc7b0JBQ3hCLElBQUksQ0FBQ1EsT0FBTyxDQUFDUjtnQkFDakI7WUFDSixHQUFHRSxRQUFRTyxPQUFPO1FBQ3RCO0lBQ0o7SUFDQUQsUUFBUVIsTUFBTSxFQUFFO1FBQ1osTUFBTU0sUUFBUSxJQUFJLENBQUNULE1BQU0sQ0FBQ0csT0FBTztRQUNqQyxJQUFJLENBQUNNLE9BQU87WUFDUjtRQUNKO1FBQ0EsTUFBTSxFQUFFSSxNQUFNLEVBQUUsR0FBR0o7UUFDbkIsSUFBSSxDQUFDSSxRQUFRO1lBQ1Q7UUFDSjtRQUNBakIsTUFBTSxnQ0FBZ0NpQixRQUFRVjtRQUM5QyxJQUFJLENBQUNILE1BQU0sQ0FBQ0csT0FBTyxHQUFHO1FBQ3RCLE1BQU9NLE1BQU1JLE1BQU0sR0FBRyxFQUFHO1lBQ3JCSixNQUFNSyxLQUFLO1FBQ2Y7SUFDSjtBQUNKO0FBQ0F2QixrQkFBZSxHQUFHTyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2NsdXN0ZXIvRGVsYXlRdWV1ZS5qcz9jNWVmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IERlcXVlID0gcmVxdWlyZShcImRlbnF1ZVwiKTtcbmNvbnN0IGRlYnVnID0gKDAsIHV0aWxzXzEuRGVidWcpKFwiZGVsYXlxdWV1ZVwiKTtcbi8qKlxuICogUXVldWUgdGhhdCBydW5zIGl0ZW1zIGFmdGVyIHNwZWNpZmllZCBkdXJhdGlvblxuICovXG5jbGFzcyBEZWxheVF1ZXVlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5xdWV1ZXMgPSB7fTtcbiAgICAgICAgdGhpcy50aW1lb3V0cyA9IHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBuZXcgaXRlbSB0byB0aGUgcXVldWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBidWNrZXQgYnVja2V0IG5hbWVcbiAgICAgKiBAcGFyYW0gaXRlbSBmdW5jdGlvbiB0aGF0IHdpbGwgcnVuIGxhdGVyXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBwdXNoKGJ1Y2tldCwgaXRlbSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgcHJvY2Vzcy5uZXh0VGljaztcbiAgICAgICAgaWYgKCF0aGlzLnF1ZXVlc1tidWNrZXRdKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlc1tidWNrZXRdID0gbmV3IERlcXVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVldWUgPSB0aGlzLnF1ZXVlc1tidWNrZXRdO1xuICAgICAgICBxdWV1ZS5wdXNoKGl0ZW0pO1xuICAgICAgICBpZiAoIXRoaXMudGltZW91dHNbYnVja2V0XSkge1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0c1tidWNrZXRdID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRzW2J1Y2tldF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4ZWN1dGUoYnVja2V0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIG9wdGlvbnMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXhlY3V0ZShidWNrZXQpIHtcbiAgICAgICAgY29uc3QgcXVldWUgPSB0aGlzLnF1ZXVlc1tidWNrZXRdO1xuICAgICAgICBpZiAoIXF1ZXVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBsZW5ndGggfSA9IHF1ZXVlO1xuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKFwic2VuZCAlZCBjb21tYW5kcyBpbiAlcyBxdWV1ZVwiLCBsZW5ndGgsIGJ1Y2tldCk7XG4gICAgICAgIHRoaXMucXVldWVzW2J1Y2tldF0gPSBudWxsO1xuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcXVldWUuc2hpZnQoKSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gRGVsYXlRdWV1ZTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInV0aWxzXzEiLCJyZXF1aXJlIiwiRGVxdWUiLCJkZWJ1ZyIsIkRlYnVnIiwiRGVsYXlRdWV1ZSIsImNvbnN0cnVjdG9yIiwicXVldWVzIiwidGltZW91dHMiLCJwdXNoIiwiYnVja2V0IiwiaXRlbSIsIm9wdGlvbnMiLCJjYWxsYmFjayIsInByb2Nlc3MiLCJuZXh0VGljayIsInF1ZXVlIiwic2V0VGltZW91dCIsImV4ZWN1dGUiLCJ0aW1lb3V0IiwibGVuZ3RoIiwic2hpZnQiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/cluster/DelayQueue.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/cluster/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/ioredis/built/cluster/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst commands_1 = __webpack_require__(/*! @ioredis/commands */ \"(rsc)/./node_modules/@ioredis/commands/built/index.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst redis_errors_1 = __webpack_require__(/*! redis-errors */ \"(rsc)/./node_modules/redis-errors/index.js\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/./node_modules/standard-as-callback/built/index.js\");\nconst Command_1 = __webpack_require__(/*! ../Command */ \"(rsc)/./node_modules/ioredis/built/Command.js\");\nconst ClusterAllFailedError_1 = __webpack_require__(/*! ../errors/ClusterAllFailedError */ \"(rsc)/./node_modules/ioredis/built/errors/ClusterAllFailedError.js\");\nconst Redis_1 = __webpack_require__(/*! ../Redis */ \"(rsc)/./node_modules/ioredis/built/Redis.js\");\nconst ScanStream_1 = __webpack_require__(/*! ../ScanStream */ \"(rsc)/./node_modules/ioredis/built/ScanStream.js\");\nconst transaction_1 = __webpack_require__(/*! ../transaction */ \"(rsc)/./node_modules/ioredis/built/transaction.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst applyMixin_1 = __webpack_require__(/*! ../utils/applyMixin */ \"(rsc)/./node_modules/ioredis/built/utils/applyMixin.js\");\nconst Commander_1 = __webpack_require__(/*! ../utils/Commander */ \"(rsc)/./node_modules/ioredis/built/utils/Commander.js\");\nconst ClusterOptions_1 = __webpack_require__(/*! ./ClusterOptions */ \"(rsc)/./node_modules/ioredis/built/cluster/ClusterOptions.js\");\nconst ClusterSubscriber_1 = __webpack_require__(/*! ./ClusterSubscriber */ \"(rsc)/./node_modules/ioredis/built/cluster/ClusterSubscriber.js\");\nconst ConnectionPool_1 = __webpack_require__(/*! ./ConnectionPool */ \"(rsc)/./node_modules/ioredis/built/cluster/ConnectionPool.js\");\nconst DelayQueue_1 = __webpack_require__(/*! ./DelayQueue */ \"(rsc)/./node_modules/ioredis/built/cluster/DelayQueue.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/ioredis/built/cluster/util.js\");\nconst Deque = __webpack_require__(/*! denque */ \"(rsc)/./node_modules/denque/index.js\");\nconst ClusterSubscriberGroup_1 = __webpack_require__(/*! ./ClusterSubscriberGroup */ \"(rsc)/./node_modules/ioredis/built/cluster/ClusterSubscriberGroup.js\");\nconst debug = (0, utils_1.Debug)(\"cluster\");\nconst REJECT_OVERWRITTEN_COMMANDS = new WeakSet();\n/**\n * Client for the official Redis Cluster\n */ class Cluster extends Commander_1.default {\n    /**\n     * Creates an instance of Cluster.\n     */ //TODO: Add an option that enables or disables sharded PubSub\n    constructor(startupNodes, options = {}){\n        super();\n        this.slots = [];\n        /**\n         * @ignore\n         */ this._groupsIds = {};\n        /**\n         * @ignore\n         */ this._groupsBySlot = Array(16384);\n        /**\n         * @ignore\n         */ this.isCluster = true;\n        this.retryAttempts = 0;\n        this.delayQueue = new DelayQueue_1.default();\n        this.offlineQueue = new Deque();\n        this.isRefreshing = false;\n        this._refreshSlotsCacheCallbacks = [];\n        this._autoPipelines = new Map();\n        this._runningAutoPipelines = new Set();\n        this._readyDelayedCallbacks = [];\n        /**\n         * Every time Cluster#connect() is called, this value will be\n         * auto-incrementing. The purpose of this value is used for\n         * discarding previous connect attampts when creating a new\n         * connection.\n         */ this.connectionEpoch = 0;\n        events_1.EventEmitter.call(this);\n        this.startupNodes = startupNodes;\n        this.options = (0, utils_1.defaults)({}, options, ClusterOptions_1.DEFAULT_CLUSTER_OPTIONS, this.options);\n        if (this.options.shardedSubscribers == true) this.shardedSubscribers = new ClusterSubscriberGroup_1.default(this);\n        if (this.options.redisOptions && this.options.redisOptions.keyPrefix && !this.options.keyPrefix) {\n            this.options.keyPrefix = this.options.redisOptions.keyPrefix;\n        }\n        // validate options\n        if (typeof this.options.scaleReads !== \"function\" && [\n            \"all\",\n            \"master\",\n            \"slave\"\n        ].indexOf(this.options.scaleReads) === -1) {\n            throw new Error('Invalid option scaleReads \"' + this.options.scaleReads + '\". Expected \"all\", \"master\", \"slave\" or a custom function');\n        }\n        this.connectionPool = new ConnectionPool_1.default(this.options.redisOptions);\n        this.connectionPool.on(\"-node\", (redis, key)=>{\n            this.emit(\"-node\", redis);\n        });\n        this.connectionPool.on(\"+node\", (redis)=>{\n            this.emit(\"+node\", redis);\n        });\n        this.connectionPool.on(\"drain\", ()=>{\n            this.setStatus(\"close\");\n        });\n        this.connectionPool.on(\"nodeError\", (error, key)=>{\n            this.emit(\"node error\", error, key);\n        });\n        this.subscriber = new ClusterSubscriber_1.default(this.connectionPool, this);\n        if (this.options.scripts) {\n            Object.entries(this.options.scripts).forEach(([name, definition])=>{\n                this.defineCommand(name, definition);\n            });\n        }\n        if (this.options.lazyConnect) {\n            this.setStatus(\"wait\");\n        } else {\n            this.connect().catch((err)=>{\n                debug(\"connecting failed: %s\", err);\n            });\n        }\n    }\n    /**\n     * Connect to a cluster\n     */ connect() {\n        return new Promise((resolve, reject)=>{\n            if (this.status === \"connecting\" || this.status === \"connect\" || this.status === \"ready\") {\n                reject(new Error(\"Redis is already connecting/connected\"));\n                return;\n            }\n            const epoch = ++this.connectionEpoch;\n            this.setStatus(\"connecting\");\n            this.resolveStartupNodeHostnames().then((nodes)=>{\n                if (this.connectionEpoch !== epoch) {\n                    debug(\"discard connecting after resolving startup nodes because epoch not match: %d != %d\", epoch, this.connectionEpoch);\n                    reject(new redis_errors_1.RedisError(\"Connection is discarded because a new connection is made\"));\n                    return;\n                }\n                if (this.status !== \"connecting\") {\n                    debug(\"discard connecting after resolving startup nodes because the status changed to %s\", this.status);\n                    reject(new redis_errors_1.RedisError(\"Connection is aborted\"));\n                    return;\n                }\n                this.connectionPool.reset(nodes);\n                const readyHandler = ()=>{\n                    this.setStatus(\"ready\");\n                    this.retryAttempts = 0;\n                    this.executeOfflineCommands();\n                    this.resetNodesRefreshInterval();\n                    resolve();\n                };\n                let closeListener = undefined;\n                const refreshListener = ()=>{\n                    this.invokeReadyDelayedCallbacks(undefined);\n                    this.removeListener(\"close\", closeListener);\n                    this.manuallyClosing = false;\n                    this.setStatus(\"connect\");\n                    if (this.options.enableReadyCheck) {\n                        this.readyCheck((err, fail)=>{\n                            if (err || fail) {\n                                debug(\"Ready check failed (%s). Reconnecting...\", err || fail);\n                                if (this.status === \"connect\") {\n                                    this.disconnect(true);\n                                }\n                            } else {\n                                readyHandler();\n                            }\n                        });\n                    } else {\n                        readyHandler();\n                    }\n                };\n                closeListener = ()=>{\n                    const error = new Error(\"None of startup nodes is available\");\n                    this.removeListener(\"refresh\", refreshListener);\n                    this.invokeReadyDelayedCallbacks(error);\n                    reject(error);\n                };\n                this.once(\"refresh\", refreshListener);\n                this.once(\"close\", closeListener);\n                this.once(\"close\", this.handleCloseEvent.bind(this));\n                this.refreshSlotsCache((err)=>{\n                    if (err && err.message === ClusterAllFailedError_1.default.defaultMessage) {\n                        Redis_1.default.prototype.silentEmit.call(this, \"error\", err);\n                        this.connectionPool.reset([]);\n                    }\n                });\n                this.subscriber.start();\n                if (this.options.shardedSubscribers) {\n                    this.shardedSubscribers.start();\n                }\n            }).catch((err)=>{\n                this.setStatus(\"close\");\n                this.handleCloseEvent(err);\n                this.invokeReadyDelayedCallbacks(err);\n                reject(err);\n            });\n        });\n    }\n    /**\n     * Disconnect from every node in the cluster.\n     */ disconnect(reconnect = false) {\n        const status = this.status;\n        this.setStatus(\"disconnecting\");\n        if (!reconnect) {\n            this.manuallyClosing = true;\n        }\n        if (this.reconnectTimeout && !reconnect) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n            debug(\"Canceled reconnecting attempts\");\n        }\n        this.clearNodesRefreshInterval();\n        this.subscriber.stop();\n        if (this.options.shardedSubscribers) {\n            this.shardedSubscribers.stop();\n        }\n        if (status === \"wait\") {\n            this.setStatus(\"close\");\n            this.handleCloseEvent();\n        } else {\n            this.connectionPool.reset([]);\n        }\n    }\n    /**\n     * Quit the cluster gracefully.\n     */ quit(callback) {\n        const status = this.status;\n        this.setStatus(\"disconnecting\");\n        this.manuallyClosing = true;\n        if (this.reconnectTimeout) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n        }\n        this.clearNodesRefreshInterval();\n        this.subscriber.stop();\n        if (this.options.shardedSubscribers) {\n            this.shardedSubscribers.stop();\n        }\n        if (status === \"wait\") {\n            const ret = (0, standard_as_callback_1.default)(Promise.resolve(\"OK\"), callback);\n            // use setImmediate to make sure \"close\" event\n            // being emitted after quit() is returned\n            setImmediate((function() {\n                this.setStatus(\"close\");\n                this.handleCloseEvent();\n            }).bind(this));\n            return ret;\n        }\n        return (0, standard_as_callback_1.default)(Promise.all(this.nodes().map((node)=>node.quit().catch((err)=>{\n                // Ignore the error caused by disconnecting since\n                // we're disconnecting...\n                if (err.message === utils_1.CONNECTION_CLOSED_ERROR_MSG) {\n                    return \"OK\";\n                }\n                throw err;\n            }))).then(()=>\"OK\"), callback);\n    }\n    /**\n     * Create a new instance with the same startup nodes and options as the current one.\n     *\n     * @example\n     * ```js\n     * var cluster = new Redis.Cluster([{ host: \"127.0.0.1\", port: \"30001\" }]);\n     * var anotherCluster = cluster.duplicate();\n     * ```\n     */ duplicate(overrideStartupNodes = [], overrideOptions = {}) {\n        const startupNodes = overrideStartupNodes.length > 0 ? overrideStartupNodes : this.startupNodes.slice(0);\n        const options = Object.assign({}, this.options, overrideOptions);\n        return new Cluster(startupNodes, options);\n    }\n    /**\n     * Get nodes with the specified role\n     */ nodes(role = \"all\") {\n        if (role !== \"all\" && role !== \"master\" && role !== \"slave\") {\n            throw new Error('Invalid role \"' + role + '\". Expected \"all\", \"master\" or \"slave\"');\n        }\n        return this.connectionPool.getNodes(role);\n    }\n    /**\n     * This is needed in order not to install a listener for each auto pipeline\n     *\n     * @ignore\n     */ delayUntilReady(callback) {\n        this._readyDelayedCallbacks.push(callback);\n    }\n    /**\n     * Get the number of commands queued in automatic pipelines.\n     *\n     * This is not available (and returns 0) until the cluster is connected and slots information have been received.\n     */ get autoPipelineQueueSize() {\n        let queued = 0;\n        for (const pipeline of this._autoPipelines.values()){\n            queued += pipeline.length;\n        }\n        return queued;\n    }\n    /**\n     * Refresh the slot cache\n     *\n     * @ignore\n     */ refreshSlotsCache(callback) {\n        if (callback) {\n            this._refreshSlotsCacheCallbacks.push(callback);\n        }\n        if (this.isRefreshing) {\n            return;\n        }\n        this.isRefreshing = true;\n        const _this = this;\n        const wrapper = (error)=>{\n            this.isRefreshing = false;\n            for (const callback of this._refreshSlotsCacheCallbacks){\n                callback(error);\n            }\n            this._refreshSlotsCacheCallbacks = [];\n        };\n        const nodes = (0, utils_1.shuffle)(this.connectionPool.getNodes());\n        let lastNodeError = null;\n        function tryNode(index) {\n            if (index === nodes.length) {\n                const error = new ClusterAllFailedError_1.default(ClusterAllFailedError_1.default.defaultMessage, lastNodeError);\n                return wrapper(error);\n            }\n            const node = nodes[index];\n            const key = `${node.options.host}:${node.options.port}`;\n            debug(\"getting slot cache from %s\", key);\n            _this.getInfoFromNode(node, function(err) {\n                switch(_this.status){\n                    case \"close\":\n                    case \"end\":\n                        return wrapper(new Error(\"Cluster is disconnected.\"));\n                    case \"disconnecting\":\n                        return wrapper(new Error(\"Cluster is disconnecting.\"));\n                }\n                if (err) {\n                    _this.emit(\"node error\", err, key);\n                    lastNodeError = err;\n                    tryNode(index + 1);\n                } else {\n                    _this.emit(\"refresh\");\n                    wrapper();\n                }\n            });\n        }\n        tryNode(0);\n    }\n    /**\n     * @ignore\n     */ sendCommand(command, stream, node) {\n        if (this.status === \"wait\") {\n            this.connect().catch(utils_1.noop);\n        }\n        if (this.status === \"end\") {\n            command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n            return command.promise;\n        }\n        let to = this.options.scaleReads;\n        if (to !== \"master\") {\n            const isCommandReadOnly = command.isReadOnly || (0, commands_1.exists)(command.name) && (0, commands_1.hasFlag)(command.name, \"readonly\");\n            if (!isCommandReadOnly) {\n                to = \"master\";\n            }\n        }\n        let targetSlot = node ? node.slot : command.getSlot();\n        const ttl = {};\n        const _this = this;\n        if (!node && !REJECT_OVERWRITTEN_COMMANDS.has(command)) {\n            REJECT_OVERWRITTEN_COMMANDS.add(command);\n            const reject = command.reject;\n            command.reject = function(err) {\n                const partialTry = tryConnection.bind(null, true);\n                _this.handleError(err, ttl, {\n                    moved: function(slot, key) {\n                        debug(\"command %s is moved to %s\", command.name, key);\n                        targetSlot = Number(slot);\n                        if (_this.slots[slot]) {\n                            _this.slots[slot][0] = key;\n                        } else {\n                            _this.slots[slot] = [\n                                key\n                            ];\n                        }\n                        _this._groupsBySlot[slot] = _this._groupsIds[_this.slots[slot].join(\";\")];\n                        _this.connectionPool.findOrCreate(_this.natMapper(key));\n                        tryConnection();\n                        debug(\"refreshing slot caches... (triggered by MOVED error)\");\n                        _this.refreshSlotsCache();\n                    },\n                    ask: function(slot, key) {\n                        debug(\"command %s is required to ask %s:%s\", command.name, key);\n                        const mapped = _this.natMapper(key);\n                        _this.connectionPool.findOrCreate(mapped);\n                        tryConnection(false, `${mapped.host}:${mapped.port}`);\n                    },\n                    tryagain: partialTry,\n                    clusterDown: partialTry,\n                    connectionClosed: partialTry,\n                    maxRedirections: function(redirectionError) {\n                        reject.call(command, redirectionError);\n                    },\n                    defaults: function() {\n                        reject.call(command, err);\n                    }\n                });\n            };\n        }\n        tryConnection();\n        function tryConnection(random, asking) {\n            if (_this.status === \"end\") {\n                command.reject(new redis_errors_1.AbortError(\"Cluster is ended.\"));\n                return;\n            }\n            let redis;\n            if (_this.status === \"ready\" || command.name === \"cluster\") {\n                if (node && node.redis) {\n                    redis = node.redis;\n                } else if (Command_1.default.checkFlag(\"ENTER_SUBSCRIBER_MODE\", command.name) || Command_1.default.checkFlag(\"EXIT_SUBSCRIBER_MODE\", command.name)) {\n                    if (_this.options.shardedSubscribers == true && (command.name == \"ssubscribe\" || command.name == \"sunsubscribe\")) {\n                        const sub = _this.shardedSubscribers.getResponsibleSubscriber(targetSlot);\n                        let status = -1;\n                        if (command.name == \"ssubscribe\") status = _this.shardedSubscribers.addChannels(command.getKeys());\n                        if (command.name == \"sunsubscribe\") status = _this.shardedSubscribers.removeChannels(command.getKeys());\n                        if (status !== -1) {\n                            redis = sub.getInstance();\n                        } else {\n                            command.reject(new redis_errors_1.AbortError(\"Can't add or remove the given channels. Are they in the same slot?\"));\n                        }\n                    } else {\n                        redis = _this.subscriber.getInstance();\n                    }\n                    if (!redis) {\n                        command.reject(new redis_errors_1.AbortError(\"No subscriber for the cluster\"));\n                        return;\n                    }\n                } else {\n                    if (!random) {\n                        if (typeof targetSlot === \"number\" && _this.slots[targetSlot]) {\n                            const nodeKeys = _this.slots[targetSlot];\n                            if (typeof to === \"function\") {\n                                const nodes = nodeKeys.map(function(key) {\n                                    return _this.connectionPool.getInstanceByKey(key);\n                                });\n                                redis = to(nodes, command);\n                                if (Array.isArray(redis)) {\n                                    redis = (0, utils_1.sample)(redis);\n                                }\n                                if (!redis) {\n                                    redis = nodes[0];\n                                }\n                            } else {\n                                let key;\n                                if (to === \"all\") {\n                                    key = (0, utils_1.sample)(nodeKeys);\n                                } else if (to === \"slave\" && nodeKeys.length > 1) {\n                                    key = (0, utils_1.sample)(nodeKeys, 1);\n                                } else {\n                                    key = nodeKeys[0];\n                                }\n                                redis = _this.connectionPool.getInstanceByKey(key);\n                            }\n                        }\n                        if (asking) {\n                            redis = _this.connectionPool.getInstanceByKey(asking);\n                            redis.asking();\n                        }\n                    }\n                    if (!redis) {\n                        redis = (typeof to === \"function\" ? null : _this.connectionPool.getSampleInstance(to)) || _this.connectionPool.getSampleInstance(\"all\");\n                    }\n                }\n                if (node && !node.redis) {\n                    node.redis = redis;\n                }\n            }\n            if (redis) {\n                redis.sendCommand(command, stream);\n            } else if (_this.options.enableOfflineQueue) {\n                _this.offlineQueue.push({\n                    command: command,\n                    stream: stream,\n                    node: node\n                });\n            } else {\n                command.reject(new Error(\"Cluster isn't ready and enableOfflineQueue options is false\"));\n            }\n        }\n        return command.promise;\n    }\n    sscanStream(key, options) {\n        return this.createScanStream(\"sscan\", {\n            key,\n            options\n        });\n    }\n    sscanBufferStream(key, options) {\n        return this.createScanStream(\"sscanBuffer\", {\n            key,\n            options\n        });\n    }\n    hscanStream(key, options) {\n        return this.createScanStream(\"hscan\", {\n            key,\n            options\n        });\n    }\n    hscanBufferStream(key, options) {\n        return this.createScanStream(\"hscanBuffer\", {\n            key,\n            options\n        });\n    }\n    zscanStream(key, options) {\n        return this.createScanStream(\"zscan\", {\n            key,\n            options\n        });\n    }\n    zscanBufferStream(key, options) {\n        return this.createScanStream(\"zscanBuffer\", {\n            key,\n            options\n        });\n    }\n    /**\n     * @ignore\n     */ handleError(error, ttl, handlers) {\n        if (typeof ttl.value === \"undefined\") {\n            ttl.value = this.options.maxRedirections;\n        } else {\n            ttl.value -= 1;\n        }\n        if (ttl.value <= 0) {\n            handlers.maxRedirections(new Error(\"Too many Cluster redirections. Last error: \" + error));\n            return;\n        }\n        const errv = error.message.split(\" \");\n        if (errv[0] === \"MOVED\") {\n            const timeout = this.options.retryDelayOnMoved;\n            if (timeout && typeof timeout === \"number\") {\n                this.delayQueue.push(\"moved\", handlers.moved.bind(null, errv[1], errv[2]), {\n                    timeout\n                });\n            } else {\n                handlers.moved(errv[1], errv[2]);\n            }\n        } else if (errv[0] === \"ASK\") {\n            handlers.ask(errv[1], errv[2]);\n        } else if (errv[0] === \"TRYAGAIN\") {\n            this.delayQueue.push(\"tryagain\", handlers.tryagain, {\n                timeout: this.options.retryDelayOnTryAgain\n            });\n        } else if (errv[0] === \"CLUSTERDOWN\" && this.options.retryDelayOnClusterDown > 0) {\n            this.delayQueue.push(\"clusterdown\", handlers.connectionClosed, {\n                timeout: this.options.retryDelayOnClusterDown,\n                callback: this.refreshSlotsCache.bind(this)\n            });\n        } else if (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG && this.options.retryDelayOnFailover > 0 && this.status === \"ready\") {\n            this.delayQueue.push(\"failover\", handlers.connectionClosed, {\n                timeout: this.options.retryDelayOnFailover,\n                callback: this.refreshSlotsCache.bind(this)\n            });\n        } else {\n            handlers.defaults();\n        }\n    }\n    resetOfflineQueue() {\n        this.offlineQueue = new Deque();\n    }\n    clearNodesRefreshInterval() {\n        if (this.slotsTimer) {\n            clearTimeout(this.slotsTimer);\n            this.slotsTimer = null;\n        }\n    }\n    resetNodesRefreshInterval() {\n        if (this.slotsTimer || !this.options.slotsRefreshInterval) {\n            return;\n        }\n        const nextRound = ()=>{\n            this.slotsTimer = setTimeout(()=>{\n                debug('refreshing slot caches... (triggered by \"slotsRefreshInterval\" option)');\n                this.refreshSlotsCache(()=>{\n                    nextRound();\n                });\n            }, this.options.slotsRefreshInterval);\n        };\n        nextRound();\n    }\n    /**\n     * Change cluster instance's status\n     */ setStatus(status) {\n        debug(\"status: %s -> %s\", this.status || \"[empty]\", status);\n        this.status = status;\n        process.nextTick(()=>{\n            this.emit(status);\n        });\n    }\n    /**\n     * Called when closed to check whether a reconnection should be made\n     */ handleCloseEvent(reason) {\n        if (reason) {\n            debug(\"closed because %s\", reason);\n        }\n        let retryDelay;\n        if (!this.manuallyClosing && typeof this.options.clusterRetryStrategy === \"function\") {\n            retryDelay = this.options.clusterRetryStrategy.call(this, ++this.retryAttempts, reason);\n        }\n        if (typeof retryDelay === \"number\") {\n            this.setStatus(\"reconnecting\");\n            this.reconnectTimeout = setTimeout(()=>{\n                this.reconnectTimeout = null;\n                debug(\"Cluster is disconnected. Retrying after %dms\", retryDelay);\n                this.connect().catch(function(err) {\n                    debug(\"Got error %s when reconnecting. Ignoring...\", err);\n                });\n            }, retryDelay);\n        } else {\n            this.setStatus(\"end\");\n            this.flushQueue(new Error(\"None of startup nodes is available\"));\n        }\n    }\n    /**\n     * Flush offline queue with error.\n     */ flushQueue(error) {\n        let item;\n        while(item = this.offlineQueue.shift()){\n            item.command.reject(error);\n        }\n    }\n    executeOfflineCommands() {\n        if (this.offlineQueue.length) {\n            debug(\"send %d commands in offline queue\", this.offlineQueue.length);\n            const offlineQueue = this.offlineQueue;\n            this.resetOfflineQueue();\n            let item;\n            while(item = offlineQueue.shift()){\n                this.sendCommand(item.command, item.stream, item.node);\n            }\n        }\n    }\n    natMapper(nodeKey) {\n        const key = typeof nodeKey === \"string\" ? nodeKey : `${nodeKey.host}:${nodeKey.port}`;\n        let mapped = null;\n        if (this.options.natMap && typeof this.options.natMap === \"function\") {\n            mapped = this.options.natMap(key);\n        } else if (this.options.natMap && typeof this.options.natMap === \"object\") {\n            mapped = this.options.natMap[key];\n        }\n        if (mapped) {\n            debug(\"NAT mapping %s -> %O\", key, mapped);\n            return Object.assign({}, mapped);\n        }\n        return typeof nodeKey === \"string\" ? (0, util_1.nodeKeyToRedisOptions)(nodeKey) : nodeKey;\n    }\n    getInfoFromNode(redis, callback) {\n        if (!redis) {\n            return callback(new Error(\"Node is disconnected\"));\n        }\n        // Use a duplication of the connection to avoid\n        // timeouts when the connection is in the blocking\n        // mode (e.g. waiting for BLPOP).\n        const duplicatedConnection = redis.duplicate({\n            enableOfflineQueue: true,\n            enableReadyCheck: false,\n            retryStrategy: null,\n            connectionName: (0, util_1.getConnectionName)(\"refresher\", this.options.redisOptions && this.options.redisOptions.connectionName)\n        });\n        // Ignore error events since we will handle\n        // exceptions for the CLUSTER SLOTS command.\n        duplicatedConnection.on(\"error\", utils_1.noop);\n        duplicatedConnection.cluster(\"SLOTS\", (0, utils_1.timeout)((err, result)=>{\n            duplicatedConnection.disconnect();\n            if (err) {\n                debug(\"error encountered running CLUSTER.SLOTS: %s\", err);\n                return callback(err);\n            }\n            if (this.status === \"disconnecting\" || this.status === \"close\" || this.status === \"end\") {\n                debug(\"ignore CLUSTER.SLOTS results (count: %d) since cluster status is %s\", result.length, this.status);\n                callback();\n                return;\n            }\n            const nodes = [];\n            debug(\"cluster slots result count: %d\", result.length);\n            for(let i = 0; i < result.length; ++i){\n                const items = result[i];\n                const slotRangeStart = items[0];\n                const slotRangeEnd = items[1];\n                const keys = [];\n                for(let j = 2; j < items.length; j++){\n                    if (!items[j][0]) {\n                        continue;\n                    }\n                    const node = this.natMapper({\n                        host: items[j][0],\n                        port: items[j][1]\n                    });\n                    node.readOnly = j !== 2;\n                    nodes.push(node);\n                    keys.push(node.host + \":\" + node.port);\n                }\n                debug(\"cluster slots result [%d]: slots %d~%d served by %s\", i, slotRangeStart, slotRangeEnd, keys);\n                for(let slot = slotRangeStart; slot <= slotRangeEnd; slot++){\n                    this.slots[slot] = keys;\n                }\n            }\n            // Assign to each node keys a numeric value to make autopipeline comparison faster.\n            this._groupsIds = Object.create(null);\n            let j = 0;\n            for(let i = 0; i < 16384; i++){\n                const target = (this.slots[i] || []).join(\";\");\n                if (!target.length) {\n                    this._groupsBySlot[i] = undefined;\n                    continue;\n                }\n                if (!this._groupsIds[target]) {\n                    this._groupsIds[target] = ++j;\n                }\n                this._groupsBySlot[i] = this._groupsIds[target];\n            }\n            this.connectionPool.reset(nodes);\n            callback();\n        }, this.options.slotsRefreshTimeout));\n    }\n    invokeReadyDelayedCallbacks(err) {\n        for (const c of this._readyDelayedCallbacks){\n            process.nextTick(c, err);\n        }\n        this._readyDelayedCallbacks = [];\n    }\n    /**\n     * Check whether Cluster is able to process commands\n     */ readyCheck(callback) {\n        this.cluster(\"INFO\", (err, res)=>{\n            if (err) {\n                return callback(err);\n            }\n            if (typeof res !== \"string\") {\n                return callback();\n            }\n            let state;\n            const lines = res.split(\"\\r\\n\");\n            for(let i = 0; i < lines.length; ++i){\n                const parts = lines[i].split(\":\");\n                if (parts[0] === \"cluster_state\") {\n                    state = parts[1];\n                    break;\n                }\n            }\n            if (state === \"fail\") {\n                debug(\"cluster state not ok (%s)\", state);\n                callback(null, state);\n            } else {\n                callback();\n            }\n        });\n    }\n    resolveSrv(hostname) {\n        return new Promise((resolve, reject)=>{\n            this.options.resolveSrv(hostname, (err, records)=>{\n                if (err) {\n                    return reject(err);\n                }\n                const self = this, groupedRecords = (0, util_1.groupSrvRecords)(records), sortedKeys = Object.keys(groupedRecords).sort((a, b)=>parseInt(a) - parseInt(b));\n                function tryFirstOne(err) {\n                    if (!sortedKeys.length) {\n                        return reject(err);\n                    }\n                    const key = sortedKeys[0], group = groupedRecords[key], record = (0, util_1.weightSrvRecords)(group);\n                    if (!group.records.length) {\n                        sortedKeys.shift();\n                    }\n                    self.dnsLookup(record.name).then((host)=>resolve({\n                            host,\n                            port: record.port\n                        }), tryFirstOne);\n                }\n                tryFirstOne();\n            });\n        });\n    }\n    dnsLookup(hostname) {\n        return new Promise((resolve, reject)=>{\n            this.options.dnsLookup(hostname, (err, address)=>{\n                if (err) {\n                    debug(\"failed to resolve hostname %s to IP: %s\", hostname, err.message);\n                    reject(err);\n                } else {\n                    debug(\"resolved hostname %s to IP %s\", hostname, address);\n                    resolve(address);\n                }\n            });\n        });\n    }\n    /**\n     * Normalize startup nodes, and resolving hostnames to IPs.\n     *\n     * This process happens every time when #connect() is called since\n     * #startupNodes and DNS records may chanage.\n     */ async resolveStartupNodeHostnames() {\n        if (!Array.isArray(this.startupNodes) || this.startupNodes.length === 0) {\n            throw new Error(\"`startupNodes` should contain at least one node.\");\n        }\n        const startupNodes = (0, util_1.normalizeNodeOptions)(this.startupNodes);\n        const hostnames = (0, util_1.getUniqueHostnamesFromOptions)(startupNodes);\n        if (hostnames.length === 0) {\n            return startupNodes;\n        }\n        const configs = await Promise.all(hostnames.map((this.options.useSRVRecords ? this.resolveSrv : this.dnsLookup).bind(this)));\n        const hostnameToConfig = (0, utils_1.zipMap)(hostnames, configs);\n        return startupNodes.map((node)=>{\n            const config = hostnameToConfig.get(node.host);\n            if (!config) {\n                return node;\n            }\n            if (this.options.useSRVRecords) {\n                return Object.assign({}, node, config);\n            }\n            return Object.assign({}, node, {\n                host: config\n            });\n        });\n    }\n    createScanStream(command, { key, options = {} }) {\n        return new ScanStream_1.default({\n            objectMode: true,\n            key: key,\n            redis: this,\n            command: command,\n            ...options\n        });\n    }\n}\n(0, applyMixin_1.default)(Cluster, events_1.EventEmitter);\n(0, transaction_1.addTransactionSupport)(Cluster.prototype);\nexports[\"default\"] = Cluster;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLGFBQWFDLG1CQUFPQSxDQUFDLGdGQUFtQjtBQUM5QyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqQyxNQUFNRSxpQkFBaUJGLG1CQUFPQSxDQUFDLGdFQUFjO0FBQzdDLE1BQU1HLHlCQUF5QkgsbUJBQU9BLENBQUMsc0ZBQXNCO0FBQzdELE1BQU1JLFlBQVlKLG1CQUFPQSxDQUFDLGlFQUFZO0FBQ3RDLE1BQU1LLDBCQUEwQkwsbUJBQU9BLENBQUMsMkdBQWlDO0FBQ3pFLE1BQU1NLFVBQVVOLG1CQUFPQSxDQUFDLDZEQUFVO0FBQ2xDLE1BQU1PLGVBQWVQLG1CQUFPQSxDQUFDLHVFQUFlO0FBQzVDLE1BQU1RLGdCQUFnQlIsbUJBQU9BLENBQUMseUVBQWdCO0FBQzlDLE1BQU1TLFVBQVVULG1CQUFPQSxDQUFDLG1FQUFVO0FBQ2xDLE1BQU1VLGVBQWVWLG1CQUFPQSxDQUFDLG1GQUFxQjtBQUNsRCxNQUFNVyxjQUFjWCxtQkFBT0EsQ0FBQyxpRkFBb0I7QUFDaEQsTUFBTVksbUJBQW1CWixtQkFBT0EsQ0FBQyxzRkFBa0I7QUFDbkQsTUFBTWEsc0JBQXNCYixtQkFBT0EsQ0FBQyw0RkFBcUI7QUFDekQsTUFBTWMsbUJBQW1CZCxtQkFBT0EsQ0FBQyxzRkFBa0I7QUFDbkQsTUFBTWUsZUFBZWYsbUJBQU9BLENBQUMsOEVBQWM7QUFDM0MsTUFBTWdCLFNBQVNoQixtQkFBT0EsQ0FBQyxrRUFBUTtBQUMvQixNQUFNaUIsUUFBUWpCLG1CQUFPQSxDQUFDLG9EQUFRO0FBQzlCLE1BQU1rQiwyQkFBMkJsQixtQkFBT0EsQ0FBQyxzR0FBMEI7QUFDbkUsTUFBTW1CLFFBQVEsQ0FBQyxHQUFHVixRQUFRVyxLQUFLLEVBQUU7QUFDakMsTUFB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O1FBQ2Q7SUFDSjtBQUNKO0FBQ0MsSUFBR2pCLGFBQWFjLE9BQU8sRUFBRUQsU0FBU3RCLFNBQVMyQyxZQUFZO0FBQ3ZELElBQUdwQyxjQUFja1EscUJBQXFCLEVBQUVuUCxRQUFROEUsU0FBUztBQUMxRHhHLGtCQUFlLEdBQUcwQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2NsdXN0ZXIvaW5kZXguanM/MDY0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbW1hbmRzXzEgPSByZXF1aXJlKFwiQGlvcmVkaXMvY29tbWFuZHNcIik7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCByZWRpc19lcnJvcnNfMSA9IHJlcXVpcmUoXCJyZWRpcy1lcnJvcnNcIik7XG5jb25zdCBzdGFuZGFyZF9hc19jYWxsYmFja18xID0gcmVxdWlyZShcInN0YW5kYXJkLWFzLWNhbGxiYWNrXCIpO1xuY29uc3QgQ29tbWFuZF8xID0gcmVxdWlyZShcIi4uL0NvbW1hbmRcIik7XG5jb25zdCBDbHVzdGVyQWxsRmFpbGVkRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnMvQ2x1c3RlckFsbEZhaWxlZEVycm9yXCIpO1xuY29uc3QgUmVkaXNfMSA9IHJlcXVpcmUoXCIuLi9SZWRpc1wiKTtcbmNvbnN0IFNjYW5TdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi9TY2FuU3RyZWFtXCIpO1xuY29uc3QgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvblwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBhcHBseU1peGluXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvYXBwbHlNaXhpblwiKTtcbmNvbnN0IENvbW1hbmRlcl8xID0gcmVxdWlyZShcIi4uL3V0aWxzL0NvbW1hbmRlclwiKTtcbmNvbnN0IENsdXN0ZXJPcHRpb25zXzEgPSByZXF1aXJlKFwiLi9DbHVzdGVyT3B0aW9uc1wiKTtcbmNvbnN0IENsdXN0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKFwiLi9DbHVzdGVyU3Vic2NyaWJlclwiKTtcbmNvbnN0IENvbm5lY3Rpb25Qb29sXzEgPSByZXF1aXJlKFwiLi9Db25uZWN0aW9uUG9vbFwiKTtcbmNvbnN0IERlbGF5UXVldWVfMSA9IHJlcXVpcmUoXCIuL0RlbGF5UXVldWVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgRGVxdWUgPSByZXF1aXJlKFwiZGVucXVlXCIpO1xuY29uc3QgQ2x1c3RlclN1YnNjcmliZXJHcm91cF8xID0gcmVxdWlyZShcIi4vQ2x1c3RlclN1YnNjcmliZXJHcm91cFwiKTtcbmNvbnN0IGRlYnVnID0gKDAsIHV0aWxzXzEuRGVidWcpKFwiY2x1c3RlclwiKTtcbmNvbnN0IFJFSkVDVF9PVkVSV1JJVFRFTl9DT01NQU5EUyA9IG5ldyBXZWFrU2V0KCk7XG4vKipcbiAqIENsaWVudCBmb3IgdGhlIG9mZmljaWFsIFJlZGlzIENsdXN0ZXJcbiAqL1xuY2xhc3MgQ2x1c3RlciBleHRlbmRzIENvbW1hbmRlcl8xLmRlZmF1bHQge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQ2x1c3Rlci5cbiAgICAgKi9cbiAgICAvL1RPRE86IEFkZCBhbiBvcHRpb24gdGhhdCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXJkZWQgUHViU3ViXG4gICAgY29uc3RydWN0b3Ioc3RhcnR1cE5vZGVzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zbG90cyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGlnbm9yZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZ3JvdXBzSWRzID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaWdub3JlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ncm91cHNCeVNsb3QgPSBBcnJheSgxNjM4NCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaWdub3JlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzQ2x1c3RlciA9IHRydWU7XG4gICAgICAgIHRoaXMucmV0cnlBdHRlbXB0cyA9IDA7XG4gICAgICAgIHRoaXMuZGVsYXlRdWV1ZSA9IG5ldyBEZWxheVF1ZXVlXzEuZGVmYXVsdCgpO1xuICAgICAgICB0aGlzLm9mZmxpbmVRdWV1ZSA9IG5ldyBEZXF1ZSgpO1xuICAgICAgICB0aGlzLmlzUmVmcmVzaGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZWZyZXNoU2xvdHNDYWNoZUNhbGxiYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLl9hdXRvUGlwZWxpbmVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9ydW5uaW5nQXV0b1BpcGVsaW5lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5fcmVhZHlEZWxheWVkQ2FsbGJhY2tzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVyeSB0aW1lIENsdXN0ZXIjY29ubmVjdCgpIGlzIGNhbGxlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlXG4gICAgICAgICAqIGF1dG8taW5jcmVtZW50aW5nLiBUaGUgcHVycG9zZSBvZiB0aGlzIHZhbHVlIGlzIHVzZWQgZm9yXG4gICAgICAgICAqIGRpc2NhcmRpbmcgcHJldmlvdXMgY29ubmVjdCBhdHRhbXB0cyB3aGVuIGNyZWF0aW5nIGEgbmV3XG4gICAgICAgICAqIGNvbm5lY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25FcG9jaCA9IDA7XG4gICAgICAgIGV2ZW50c18xLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnN0YXJ0dXBOb2RlcyA9IHN0YXJ0dXBOb2RlcztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gKDAsIHV0aWxzXzEuZGVmYXVsdHMpKHt9LCBvcHRpb25zLCBDbHVzdGVyT3B0aW9uc18xLkRFRkFVTFRfQ0xVU1RFUl9PUFRJT05TLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXJkZWRTdWJzY3JpYmVycyA9PSB0cnVlKVxuICAgICAgICAgICAgdGhpcy5zaGFyZGVkU3Vic2NyaWJlcnMgPSBuZXcgQ2x1c3RlclN1YnNjcmliZXJHcm91cF8xLmRlZmF1bHQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVkaXNPcHRpb25zICYmXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMucmVkaXNPcHRpb25zLmtleVByZWZpeCAmJlxuICAgICAgICAgICAgIXRoaXMub3B0aW9ucy5rZXlQcmVmaXgpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5rZXlQcmVmaXggPSB0aGlzLm9wdGlvbnMucmVkaXNPcHRpb25zLmtleVByZWZpeDtcbiAgICAgICAgfVxuICAgICAgICAvLyB2YWxpZGF0ZSBvcHRpb25zXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnNjYWxlUmVhZHMgIT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgW1wiYWxsXCIsIFwibWFzdGVyXCIsIFwic2xhdmVcIl0uaW5kZXhPZih0aGlzLm9wdGlvbnMuc2NhbGVSZWFkcykgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3B0aW9uIHNjYWxlUmVhZHMgXCInICtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2NhbGVSZWFkcyArXG4gICAgICAgICAgICAgICAgJ1wiLiBFeHBlY3RlZCBcImFsbFwiLCBcIm1hc3RlclwiLCBcInNsYXZlXCIgb3IgYSBjdXN0b20gZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb29sID0gbmV3IENvbm5lY3Rpb25Qb29sXzEuZGVmYXVsdCh0aGlzLm9wdGlvbnMucmVkaXNPcHRpb25zKTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9vbC5vbihcIi1ub2RlXCIsIChyZWRpcywga2V5KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCItbm9kZVwiLCByZWRpcyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb29sLm9uKFwiK25vZGVcIiwgKHJlZGlzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCIrbm9kZVwiLCByZWRpcyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb29sLm9uKFwiZHJhaW5cIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJjbG9zZVwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvb2wub24oXCJub2RlRXJyb3JcIiwgKGVycm9yLCBrZXkpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcIm5vZGUgZXJyb3JcIiwgZXJyb3IsIGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN1YnNjcmliZXIgPSBuZXcgQ2x1c3RlclN1YnNjcmliZXJfMS5kZWZhdWx0KHRoaXMuY29ubmVjdGlvblBvb2wsIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNjcmlwdHMpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMub3B0aW9ucy5zY3JpcHRzKS5mb3JFYWNoKChbbmFtZSwgZGVmaW5pdGlvbl0pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmluZUNvbW1hbmQobmFtZSwgZGVmaW5pdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxhenlDb25uZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhcIndhaXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3QoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJjb25uZWN0aW5nIGZhaWxlZDogJXNcIiwgZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbm5lY3QgdG8gYSBjbHVzdGVyXG4gICAgICovXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJjb25uZWN0aW5nXCIgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9PT0gXCJjb25uZWN0XCIgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9PT0gXCJyZWFkeVwiKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlJlZGlzIGlzIGFscmVhZHkgY29ubmVjdGluZy9jb25uZWN0ZWRcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVwb2NoID0gKyt0aGlzLmNvbm5lY3Rpb25FcG9jaDtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKFwiY29ubmVjdGluZ1wiKTtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZVN0YXJ0dXBOb2RlSG9zdG5hbWVzKClcbiAgICAgICAgICAgICAgICAudGhlbigobm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uRXBvY2ggIT09IGVwb2NoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiZGlzY2FyZCBjb25uZWN0aW5nIGFmdGVyIHJlc29sdmluZyBzdGFydHVwIG5vZGVzIGJlY2F1c2UgZXBvY2ggbm90IG1hdGNoOiAlZCAhPSAlZFwiLCBlcG9jaCwgdGhpcy5jb25uZWN0aW9uRXBvY2gpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IHJlZGlzX2Vycm9yc18xLlJlZGlzRXJyb3IoXCJDb25uZWN0aW9uIGlzIGRpc2NhcmRlZCBiZWNhdXNlIGEgbmV3IGNvbm5lY3Rpb24gaXMgbWFkZVwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBcImNvbm5lY3RpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImRpc2NhcmQgY29ubmVjdGluZyBhZnRlciByZXNvbHZpbmcgc3RhcnR1cCBub2RlcyBiZWNhdXNlIHRoZSBzdGF0dXMgY2hhbmdlZCB0byAlc1wiLCB0aGlzLnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgcmVkaXNfZXJyb3JzXzEuUmVkaXNFcnJvcihcIkNvbm5lY3Rpb24gaXMgYWJvcnRlZFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9vbC5yZXNldChub2Rlcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVhZHlIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhcInJlYWR5XCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJldHJ5QXR0ZW1wdHMgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4ZWN1dGVPZmZsaW5lQ29tbWFuZHMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldE5vZGVzUmVmcmVzaEludGVydmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGxldCBjbG9zZUxpc3RlbmVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZnJlc2hMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZva2VSZWFkeURlbGF5ZWRDYWxsYmFja3ModW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIGNsb3NlTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hbnVhbGx5Q2xvc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhcImNvbm5lY3RcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlUmVhZHlDaGVjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkeUNoZWNrKChlcnIsIGZhaWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyIHx8IGZhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJSZWFkeSBjaGVjayBmYWlsZWQgKCVzKS4gUmVjb25uZWN0aW5nLi4uXCIsIGVyciB8fCBmYWlsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcImNvbm5lY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkeUhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWR5SGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjbG9zZUxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcIk5vbmUgb2Ygc3RhcnR1cCBub2RlcyBpcyBhdmFpbGFibGVcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoXCJyZWZyZXNoXCIsIHJlZnJlc2hMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW52b2tlUmVhZHlEZWxheWVkQ2FsbGJhY2tzKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMub25jZShcInJlZnJlc2hcIiwgcmVmcmVzaExpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJjbG9zZVwiLCBjbG9zZUxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJjbG9zZVwiLCB0aGlzLmhhbmRsZUNsb3NlRXZlbnQuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoU2xvdHNDYWNoZSgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UgPT09IENsdXN0ZXJBbGxGYWlsZWRFcnJvcl8xLmRlZmF1bHQuZGVmYXVsdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlZGlzXzEuZGVmYXVsdC5wcm90b3R5cGUuc2lsZW50RW1pdC5jYWxsKHRoaXMsIFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvblBvb2wucmVzZXQoW10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFyZGVkU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGFyZGVkU3Vic2NyaWJlcnMuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJjbG9zZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNsb3NlRXZlbnQoZXJyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmludm9rZVJlYWR5RGVsYXllZENhbGxiYWNrcyhlcnIpO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0IGZyb20gZXZlcnkgbm9kZSBpbiB0aGUgY2x1c3Rlci5cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KHJlY29ubmVjdCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcImRpc2Nvbm5lY3RpbmdcIik7XG4gICAgICAgIGlmICghcmVjb25uZWN0KSB7XG4gICAgICAgICAgICB0aGlzLm1hbnVhbGx5Q2xvc2luZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjb25uZWN0VGltZW91dCAmJiAhcmVjb25uZWN0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBkZWJ1ZyhcIkNhbmNlbGVkIHJlY29ubmVjdGluZyBhdHRlbXB0c1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyTm9kZXNSZWZyZXNoSW50ZXJ2YWwoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFyZGVkU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2hhcmRlZFN1YnNjcmliZXJzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzID09PSBcIndhaXRcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJjbG9zZVwiKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xvc2VFdmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9vbC5yZXNldChbXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVpdCB0aGUgY2x1c3RlciBncmFjZWZ1bGx5LlxuICAgICAqL1xuICAgIHF1aXQoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwiZGlzY29ubmVjdGluZ1wiKTtcbiAgICAgICAgdGhpcy5tYW51YWxseUNsb3NpbmcgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhck5vZGVzUmVmcmVzaEludGVydmFsKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcmRlZFN1YnNjcmliZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnNoYXJkZWRTdWJzY3JpYmVycy5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gXCJ3YWl0XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9ICgwLCBzdGFuZGFyZF9hc19jYWxsYmFja18xLmRlZmF1bHQpKFByb21pc2UucmVzb2x2ZShcIk9LXCIpLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAvLyB1c2Ugc2V0SW1tZWRpYXRlIHRvIG1ha2Ugc3VyZSBcImNsb3NlXCIgZXZlbnRcbiAgICAgICAgICAgIC8vIGJlaW5nIGVtaXR0ZWQgYWZ0ZXIgcXVpdCgpIGlzIHJldHVybmVkXG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKFwiY2xvc2VcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDbG9zZUV2ZW50KCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEuZGVmYXVsdCkoUHJvbWlzZS5hbGwodGhpcy5ub2RlcygpLm1hcCgobm9kZSkgPT4gbm9kZS5xdWl0KCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgLy8gSWdub3JlIHRoZSBlcnJvciBjYXVzZWQgYnkgZGlzY29ubmVjdGluZyBzaW5jZVxuICAgICAgICAgICAgLy8gd2UncmUgZGlzY29ubmVjdGluZy4uLlxuICAgICAgICAgICAgaWYgKGVyci5tZXNzYWdlID09PSB1dGlsc18xLkNPTk5FQ1RJT05fQ0xPU0VEX0VSUk9SX01TRykge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIk9LXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pKSkudGhlbigoKSA9PiBcIk9LXCIpLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSB3aXRoIHRoZSBzYW1lIHN0YXJ0dXAgbm9kZXMgYW5kIG9wdGlvbnMgYXMgdGhlIGN1cnJlbnQgb25lLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIHZhciBjbHVzdGVyID0gbmV3IFJlZGlzLkNsdXN0ZXIoW3sgaG9zdDogXCIxMjcuMC4wLjFcIiwgcG9ydDogXCIzMDAwMVwiIH1dKTtcbiAgICAgKiB2YXIgYW5vdGhlckNsdXN0ZXIgPSBjbHVzdGVyLmR1cGxpY2F0ZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGR1cGxpY2F0ZShvdmVycmlkZVN0YXJ0dXBOb2RlcyA9IFtdLCBvdmVycmlkZU9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBzdGFydHVwTm9kZXMgPSBvdmVycmlkZVN0YXJ0dXBOb2Rlcy5sZW5ndGggPiAwXG4gICAgICAgICAgICA/IG92ZXJyaWRlU3RhcnR1cE5vZGVzXG4gICAgICAgICAgICA6IHRoaXMuc3RhcnR1cE5vZGVzLnNsaWNlKDApO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLCBvdmVycmlkZU9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbmV3IENsdXN0ZXIoc3RhcnR1cE5vZGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IG5vZGVzIHdpdGggdGhlIHNwZWNpZmllZCByb2xlXG4gICAgICovXG4gICAgbm9kZXMocm9sZSA9IFwiYWxsXCIpIHtcbiAgICAgICAgaWYgKHJvbGUgIT09IFwiYWxsXCIgJiYgcm9sZSAhPT0gXCJtYXN0ZXJcIiAmJiByb2xlICE9PSBcInNsYXZlXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByb2xlIFwiJyArIHJvbGUgKyAnXCIuIEV4cGVjdGVkIFwiYWxsXCIsIFwibWFzdGVyXCIgb3IgXCJzbGF2ZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvblBvb2wuZ2V0Tm9kZXMocm9sZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgbmVlZGVkIGluIG9yZGVyIG5vdCB0byBpbnN0YWxsIGEgbGlzdGVuZXIgZm9yIGVhY2ggYXV0byBwaXBlbGluZVxuICAgICAqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIGRlbGF5VW50aWxSZWFkeShjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9yZWFkeURlbGF5ZWRDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIGNvbW1hbmRzIHF1ZXVlZCBpbiBhdXRvbWF0aWMgcGlwZWxpbmVzLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBub3QgYXZhaWxhYmxlIChhbmQgcmV0dXJucyAwKSB1bnRpbCB0aGUgY2x1c3RlciBpcyBjb25uZWN0ZWQgYW5kIHNsb3RzIGluZm9ybWF0aW9uIGhhdmUgYmVlbiByZWNlaXZlZC5cbiAgICAgKi9cbiAgICBnZXQgYXV0b1BpcGVsaW5lUXVldWVTaXplKCkge1xuICAgICAgICBsZXQgcXVldWVkID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBwaXBlbGluZSBvZiB0aGlzLl9hdXRvUGlwZWxpbmVzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBxdWV1ZWQgKz0gcGlwZWxpbmUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdWV1ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZnJlc2ggdGhlIHNsb3QgY2FjaGVcbiAgICAgKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICByZWZyZXNoU2xvdHNDYWNoZShjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hTbG90c0NhY2hlQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzUmVmcmVzaGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNSZWZyZXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzUmVmcmVzaGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiB0aGlzLl9yZWZyZXNoU2xvdHNDYWNoZUNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hTbG90c0NhY2hlQ2FsbGJhY2tzID0gW107XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG5vZGVzID0gKDAsIHV0aWxzXzEuc2h1ZmZsZSkodGhpcy5jb25uZWN0aW9uUG9vbC5nZXROb2RlcygpKTtcbiAgICAgICAgbGV0IGxhc3ROb2RlRXJyb3IgPSBudWxsO1xuICAgICAgICBmdW5jdGlvbiB0cnlOb2RlKGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IENsdXN0ZXJBbGxGYWlsZWRFcnJvcl8xLmRlZmF1bHQoQ2x1c3RlckFsbEZhaWxlZEVycm9yXzEuZGVmYXVsdC5kZWZhdWx0TWVzc2FnZSwgbGFzdE5vZGVFcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXIoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGAke25vZGUub3B0aW9ucy5ob3N0fToke25vZGUub3B0aW9ucy5wb3J0fWA7XG4gICAgICAgICAgICBkZWJ1ZyhcImdldHRpbmcgc2xvdCBjYWNoZSBmcm9tICVzXCIsIGtleSk7XG4gICAgICAgICAgICBfdGhpcy5nZXRJbmZvRnJvbU5vZGUobm9kZSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX3RoaXMuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjbG9zZVwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlcihuZXcgRXJyb3IoXCJDbHVzdGVyIGlzIGRpc2Nvbm5lY3RlZC5cIikpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGlzY29ubmVjdGluZ1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXIobmV3IEVycm9yKFwiQ2x1c3RlciBpcyBkaXNjb25uZWN0aW5nLlwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcIm5vZGUgZXJyb3JcIiwgZXJyLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0Tm9kZUVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICB0cnlOb2RlKGluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwicmVmcmVzaFwiKTtcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRyeU5vZGUoMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBzZW5kQ29tbWFuZChjb21tYW5kLCBzdHJlYW0sIG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcIndhaXRcIikge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCkuY2F0Y2godXRpbHNfMS5ub29wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwiZW5kXCIpIHtcbiAgICAgICAgICAgIGNvbW1hbmQucmVqZWN0KG5ldyBFcnJvcih1dGlsc18xLkNPTk5FQ1RJT05fQ0xPU0VEX0VSUk9SX01TRykpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmQucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG8gPSB0aGlzLm9wdGlvbnMuc2NhbGVSZWFkcztcbiAgICAgICAgaWYgKHRvICE9PSBcIm1hc3RlclwiKSB7XG4gICAgICAgICAgICBjb25zdCBpc0NvbW1hbmRSZWFkT25seSA9IGNvbW1hbmQuaXNSZWFkT25seSB8fFxuICAgICAgICAgICAgICAgICgoMCwgY29tbWFuZHNfMS5leGlzdHMpKGNvbW1hbmQubmFtZSkgJiYgKDAsIGNvbW1hbmRzXzEuaGFzRmxhZykoY29tbWFuZC5uYW1lLCBcInJlYWRvbmx5XCIpKTtcbiAgICAgICAgICAgIGlmICghaXNDb21tYW5kUmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICB0byA9IFwibWFzdGVyXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRhcmdldFNsb3QgPSBub2RlID8gbm9kZS5zbG90IDogY29tbWFuZC5nZXRTbG90KCk7XG4gICAgICAgIGNvbnN0IHR0bCA9IHt9O1xuICAgICAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghbm9kZSAmJiAhUkVKRUNUX09WRVJXUklUVEVOX0NPTU1BTkRTLmhhcyhjb21tYW5kKSkge1xuICAgICAgICAgICAgUkVKRUNUX09WRVJXUklUVEVOX0NPTU1BTkRTLmFkZChjb21tYW5kKTtcbiAgICAgICAgICAgIGNvbnN0IHJlamVjdCA9IGNvbW1hbmQucmVqZWN0O1xuICAgICAgICAgICAgY29tbWFuZC5yZWplY3QgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydGlhbFRyeSA9IHRyeUNvbm5lY3Rpb24uYmluZChudWxsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVFcnJvcihlcnIsIHR0bCwge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlZDogZnVuY3Rpb24gKHNsb3QsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJjb21tYW5kICVzIGlzIG1vdmVkIHRvICVzXCIsIGNvbW1hbmQubmFtZSwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFNsb3QgPSBOdW1iZXIoc2xvdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc2xvdHNbc2xvdF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zbG90c1tzbG90XVswXSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNsb3RzW3Nsb3RdID0gW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZ3JvdXBzQnlTbG90W3Nsb3RdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZ3JvdXBzSWRzW190aGlzLnNsb3RzW3Nsb3RdLmpvaW4oXCI7XCIpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbm5lY3Rpb25Qb29sLmZpbmRPckNyZWF0ZShfdGhpcy5uYXRNYXBwZXIoa2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnlDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcInJlZnJlc2hpbmcgc2xvdCBjYWNoZXMuLi4gKHRyaWdnZXJlZCBieSBNT1ZFRCBlcnJvcilcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWZyZXNoU2xvdHNDYWNoZSgpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhc2s6IGZ1bmN0aW9uIChzbG90LCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiY29tbWFuZCAlcyBpcyByZXF1aXJlZCB0byBhc2sgJXM6JXNcIiwgY29tbWFuZC5uYW1lLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFwcGVkID0gX3RoaXMubmF0TWFwcGVyKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb25uZWN0aW9uUG9vbC5maW5kT3JDcmVhdGUobWFwcGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeUNvbm5lY3Rpb24oZmFsc2UsIGAke21hcHBlZC5ob3N0fToke21hcHBlZC5wb3J0fWApO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0cnlhZ2FpbjogcGFydGlhbFRyeSxcbiAgICAgICAgICAgICAgICAgICAgY2x1c3RlckRvd246IHBhcnRpYWxUcnksXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25DbG9zZWQ6IHBhcnRpYWxUcnksXG4gICAgICAgICAgICAgICAgICAgIG1heFJlZGlyZWN0aW9uczogZnVuY3Rpb24gKHJlZGlyZWN0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdC5jYWxsKGNvbW1hbmQsIHJlZGlyZWN0aW9uRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0LmNhbGwoY29tbWFuZCwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdHJ5Q29ubmVjdGlvbigpO1xuICAgICAgICBmdW5jdGlvbiB0cnlDb25uZWN0aW9uKHJhbmRvbSwgYXNraW5nKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdHVzID09PSBcImVuZFwiKSB7XG4gICAgICAgICAgICAgICAgY29tbWFuZC5yZWplY3QobmV3IHJlZGlzX2Vycm9yc18xLkFib3J0RXJyb3IoXCJDbHVzdGVyIGlzIGVuZGVkLlwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlZGlzO1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXR1cyA9PT0gXCJyZWFkeVwiIHx8IGNvbW1hbmQubmFtZSA9PT0gXCJjbHVzdGVyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSAmJiBub2RlLnJlZGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZGlzID0gbm9kZS5yZWRpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoQ29tbWFuZF8xLmRlZmF1bHQuY2hlY2tGbGFnKFwiRU5URVJfU1VCU0NSSUJFUl9NT0RFXCIsIGNvbW1hbmQubmFtZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgQ29tbWFuZF8xLmRlZmF1bHQuY2hlY2tGbGFnKFwiRVhJVF9TVUJTQ1JJQkVSX01PREVcIiwgY29tbWFuZC5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5zaGFyZGVkU3Vic2NyaWJlcnMgPT0gdHJ1ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbW1hbmQubmFtZSA9PSBcInNzdWJzY3JpYmVcIiB8fCBjb21tYW5kLm5hbWUgPT0gXCJzdW5zdWJzY3JpYmVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1YiA9IF90aGlzLnNoYXJkZWRTdWJzY3JpYmVycy5nZXRSZXNwb25zaWJsZVN1YnNjcmliZXIodGFyZ2V0U2xvdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhdHVzID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWFuZC5uYW1lID09IFwic3N1YnNjcmliZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IF90aGlzLnNoYXJkZWRTdWJzY3JpYmVycy5hZGRDaGFubmVscyhjb21tYW5kLmdldEtleXMoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWFuZC5uYW1lID09IFwic3Vuc3Vic2NyaWJlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gX3RoaXMuc2hhcmRlZFN1YnNjcmliZXJzLnJlbW92ZUNoYW5uZWxzKGNvbW1hbmQuZ2V0S2V5cygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXMgPSBzdWIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQucmVqZWN0KG5ldyByZWRpc19lcnJvcnNfMS5BYm9ydEVycm9yKFwiQ2FuJ3QgYWRkIG9yIHJlbW92ZSB0aGUgZ2l2ZW4gY2hhbm5lbHMuIEFyZSB0aGV5IGluIHRoZSBzYW1lIHNsb3Q/XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZGlzID0gX3RoaXMuc3Vic2NyaWJlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVkaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQucmVqZWN0KG5ldyByZWRpc19lcnJvcnNfMS5BYm9ydEVycm9yKFwiTm8gc3Vic2NyaWJlciBmb3IgdGhlIGNsdXN0ZXJcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJhbmRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRTbG90ID09PSBcIm51bWJlclwiICYmIF90aGlzLnNsb3RzW3RhcmdldFNsb3RdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZUtleXMgPSBfdGhpcy5zbG90c1t0YXJnZXRTbG90XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBub2RlS2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvbm5lY3Rpb25Qb29sLmdldEluc3RhbmNlQnlLZXkoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZGlzID0gdG8obm9kZXMsIGNvbW1hbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWRpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZGlzID0gKDAsIHV0aWxzXzEuc2FtcGxlKShyZWRpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWRpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXMgPSBub2Rlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvID09PSBcImFsbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSAoMCwgdXRpbHNfMS5zYW1wbGUpKG5vZGVLZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0byA9PT0gXCJzbGF2ZVwiICYmIG5vZGVLZXlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9ICgwLCB1dGlsc18xLnNhbXBsZSkobm9kZUtleXMsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gbm9kZUtleXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXMgPSBfdGhpcy5jb25uZWN0aW9uUG9vbC5nZXRJbnN0YW5jZUJ5S2V5KGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFza2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZGlzID0gX3RoaXMuY29ubmVjdGlvblBvb2wuZ2V0SW5zdGFuY2VCeUtleShhc2tpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZGlzLmFza2luZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVkaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZGlzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHRvID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogX3RoaXMuY29ubmVjdGlvblBvb2wuZ2V0U2FtcGxlSW5zdGFuY2UodG8pKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb25uZWN0aW9uUG9vbC5nZXRTYW1wbGVJbnN0YW5jZShcImFsbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9kZSAmJiAhbm9kZS5yZWRpcykge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnJlZGlzID0gcmVkaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlZGlzKSB7XG4gICAgICAgICAgICAgICAgcmVkaXMuc2VuZENvbW1hbmQoY29tbWFuZCwgc3RyZWFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLm9wdGlvbnMuZW5hYmxlT2ZmbGluZVF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub2ZmbGluZVF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBjb21tYW5kLFxuICAgICAgICAgICAgICAgICAgICBzdHJlYW06IHN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbW1hbmQucmVqZWN0KG5ldyBFcnJvcihcIkNsdXN0ZXIgaXNuJ3QgcmVhZHkgYW5kIGVuYWJsZU9mZmxpbmVRdWV1ZSBvcHRpb25zIGlzIGZhbHNlXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tbWFuZC5wcm9taXNlO1xuICAgIH1cbiAgICBzc2NhblN0cmVhbShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcInNzY2FuXCIsIHsga2V5LCBvcHRpb25zIH0pO1xuICAgIH1cbiAgICBzc2NhbkJ1ZmZlclN0cmVhbShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcInNzY2FuQnVmZmVyXCIsIHsga2V5LCBvcHRpb25zIH0pO1xuICAgIH1cbiAgICBoc2NhblN0cmVhbShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcImhzY2FuXCIsIHsga2V5LCBvcHRpb25zIH0pO1xuICAgIH1cbiAgICBoc2NhbkJ1ZmZlclN0cmVhbShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcImhzY2FuQnVmZmVyXCIsIHsga2V5LCBvcHRpb25zIH0pO1xuICAgIH1cbiAgICB6c2NhblN0cmVhbShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcInpzY2FuXCIsIHsga2V5LCBvcHRpb25zIH0pO1xuICAgIH1cbiAgICB6c2NhbkJ1ZmZlclN0cmVhbShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcInpzY2FuQnVmZmVyXCIsIHsga2V5LCBvcHRpb25zIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgaGFuZGxlRXJyb3IoZXJyb3IsIHR0bCwgaGFuZGxlcnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0dGwudmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHR0bC52YWx1ZSA9IHRoaXMub3B0aW9ucy5tYXhSZWRpcmVjdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0dGwudmFsdWUgLT0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHRsLnZhbHVlIDw9IDApIHtcbiAgICAgICAgICAgIGhhbmRsZXJzLm1heFJlZGlyZWN0aW9ucyhuZXcgRXJyb3IoXCJUb28gbWFueSBDbHVzdGVyIHJlZGlyZWN0aW9ucy4gTGFzdCBlcnJvcjogXCIgKyBlcnJvcikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycnYgPSBlcnJvci5tZXNzYWdlLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgaWYgKGVycnZbMF0gPT09IFwiTU9WRURcIikge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMub3B0aW9ucy5yZXRyeURlbGF5T25Nb3ZlZDtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICYmIHR5cGVvZiB0aW1lb3V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxheVF1ZXVlLnB1c2goXCJtb3ZlZFwiLCBoYW5kbGVycy5tb3ZlZC5iaW5kKG51bGwsIGVycnZbMV0sIGVycnZbMl0pLCB7IHRpbWVvdXQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVycy5tb3ZlZChlcnJ2WzFdLCBlcnJ2WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlcnJ2WzBdID09PSBcIkFTS1wiKSB7XG4gICAgICAgICAgICBoYW5kbGVycy5hc2soZXJydlsxXSwgZXJydlsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXJydlswXSA9PT0gXCJUUllBR0FJTlwiKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGF5UXVldWUucHVzaChcInRyeWFnYWluXCIsIGhhbmRsZXJzLnRyeWFnYWluLCB7XG4gICAgICAgICAgICAgICAgdGltZW91dDogdGhpcy5vcHRpb25zLnJldHJ5RGVsYXlPblRyeUFnYWluLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXJydlswXSA9PT0gXCJDTFVTVEVSRE9XTlwiICYmXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMucmV0cnlEZWxheU9uQ2x1c3RlckRvd24gPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGF5UXVldWUucHVzaChcImNsdXN0ZXJkb3duXCIsIGhhbmRsZXJzLmNvbm5lY3Rpb25DbG9zZWQsIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aGlzLm9wdGlvbnMucmV0cnlEZWxheU9uQ2x1c3RlckRvd24sXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IHRoaXMucmVmcmVzaFNsb3RzQ2FjaGUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVycm9yLm1lc3NhZ2UgPT09IHV0aWxzXzEuQ09OTkVDVElPTl9DTE9TRURfRVJST1JfTVNHICYmXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMucmV0cnlEZWxheU9uRmFpbG92ZXIgPiAwICYmXG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9PT0gXCJyZWFkeVwiKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGF5UXVldWUucHVzaChcImZhaWxvdmVyXCIsIGhhbmRsZXJzLmNvbm5lY3Rpb25DbG9zZWQsIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aGlzLm9wdGlvbnMucmV0cnlEZWxheU9uRmFpbG92ZXIsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IHRoaXMucmVmcmVzaFNsb3RzQ2FjaGUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlcnMuZGVmYXVsdHMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldE9mZmxpbmVRdWV1ZSgpIHtcbiAgICAgICAgdGhpcy5vZmZsaW5lUXVldWUgPSBuZXcgRGVxdWUoKTtcbiAgICB9XG4gICAgY2xlYXJOb2Rlc1JlZnJlc2hJbnRlcnZhbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2xvdHNUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2xvdHNUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnNsb3RzVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc2V0Tm9kZXNSZWZyZXNoSW50ZXJ2YWwoKSB7XG4gICAgICAgIGlmICh0aGlzLnNsb3RzVGltZXIgfHwgIXRoaXMub3B0aW9ucy5zbG90c1JlZnJlc2hJbnRlcnZhbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHRSb3VuZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2xvdHNUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdyZWZyZXNoaW5nIHNsb3QgY2FjaGVzLi4uICh0cmlnZ2VyZWQgYnkgXCJzbG90c1JlZnJlc2hJbnRlcnZhbFwiIG9wdGlvbiknKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hTbG90c0NhY2hlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFJvdW5kKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB0aGlzLm9wdGlvbnMuc2xvdHNSZWZyZXNoSW50ZXJ2YWwpO1xuICAgICAgICB9O1xuICAgICAgICBuZXh0Um91bmQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlIGNsdXN0ZXIgaW5zdGFuY2UncyBzdGF0dXNcbiAgICAgKi9cbiAgICBzZXRTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgIGRlYnVnKFwic3RhdHVzOiAlcyAtPiAlc1wiLCB0aGlzLnN0YXR1cyB8fCBcIltlbXB0eV1cIiwgc3RhdHVzKTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KHN0YXR1cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBjbG9zZWQgdG8gY2hlY2sgd2hldGhlciBhIHJlY29ubmVjdGlvbiBzaG91bGQgYmUgbWFkZVxuICAgICAqL1xuICAgIGhhbmRsZUNsb3NlRXZlbnQocmVhc29uKSB7XG4gICAgICAgIGlmIChyZWFzb24pIHtcbiAgICAgICAgICAgIGRlYnVnKFwiY2xvc2VkIGJlY2F1c2UgJXNcIiwgcmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmV0cnlEZWxheTtcbiAgICAgICAgaWYgKCF0aGlzLm1hbnVhbGx5Q2xvc2luZyAmJlxuICAgICAgICAgICAgdHlwZW9mIHRoaXMub3B0aW9ucy5jbHVzdGVyUmV0cnlTdHJhdGVneSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXRyeURlbGF5ID0gdGhpcy5vcHRpb25zLmNsdXN0ZXJSZXRyeVN0cmF0ZWd5LmNhbGwodGhpcywgKyt0aGlzLnJldHJ5QXR0ZW1wdHMsIHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZXRyeURlbGF5ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhcInJlY29ubmVjdGluZ1wiKTtcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJDbHVzdGVyIGlzIGRpc2Nvbm5lY3RlZC4gUmV0cnlpbmcgYWZ0ZXIgJWRtc1wiLCByZXRyeURlbGF5KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3QoKS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiR290IGVycm9yICVzIHdoZW4gcmVjb25uZWN0aW5nLiBJZ25vcmluZy4uLlwiLCBlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgcmV0cnlEZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhcImVuZFwiKTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hRdWV1ZShuZXcgRXJyb3IoXCJOb25lIG9mIHN0YXJ0dXAgbm9kZXMgaXMgYXZhaWxhYmxlXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGbHVzaCBvZmZsaW5lIHF1ZXVlIHdpdGggZXJyb3IuXG4gICAgICovXG4gICAgZmx1c2hRdWV1ZShlcnJvcikge1xuICAgICAgICBsZXQgaXRlbTtcbiAgICAgICAgd2hpbGUgKChpdGVtID0gdGhpcy5vZmZsaW5lUXVldWUuc2hpZnQoKSkpIHtcbiAgICAgICAgICAgIGl0ZW0uY29tbWFuZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4ZWN1dGVPZmZsaW5lQ29tbWFuZHMoKSB7XG4gICAgICAgIGlmICh0aGlzLm9mZmxpbmVRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlYnVnKFwic2VuZCAlZCBjb21tYW5kcyBpbiBvZmZsaW5lIHF1ZXVlXCIsIHRoaXMub2ZmbGluZVF1ZXVlLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBvZmZsaW5lUXVldWUgPSB0aGlzLm9mZmxpbmVRdWV1ZTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRPZmZsaW5lUXVldWUoKTtcbiAgICAgICAgICAgIGxldCBpdGVtO1xuICAgICAgICAgICAgd2hpbGUgKChpdGVtID0gb2ZmbGluZVF1ZXVlLnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kQ29tbWFuZChpdGVtLmNvbW1hbmQsIGl0ZW0uc3RyZWFtLCBpdGVtLm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG5hdE1hcHBlcihub2RlS2V5KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHR5cGVvZiBub2RlS2V5ID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IG5vZGVLZXlcbiAgICAgICAgICAgIDogYCR7bm9kZUtleS5ob3N0fToke25vZGVLZXkucG9ydH1gO1xuICAgICAgICBsZXQgbWFwcGVkID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5uYXRNYXAgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy5uYXRNYXAgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbWFwcGVkID0gdGhpcy5vcHRpb25zLm5hdE1hcChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9ucy5uYXRNYXAgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy5uYXRNYXAgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIG1hcHBlZCA9IHRoaXMub3B0aW9ucy5uYXRNYXBba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFwcGVkKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcIk5BVCBtYXBwaW5nICVzIC0+ICVPXCIsIGtleSwgbWFwcGVkKTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBtYXBwZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlb2Ygbm9kZUtleSA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgPyAoMCwgdXRpbF8xLm5vZGVLZXlUb1JlZGlzT3B0aW9ucykobm9kZUtleSlcbiAgICAgICAgICAgIDogbm9kZUtleTtcbiAgICB9XG4gICAgZ2V0SW5mb0Zyb21Ob2RlKHJlZGlzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXJlZGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKFwiTm9kZSBpcyBkaXNjb25uZWN0ZWRcIikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSBhIGR1cGxpY2F0aW9uIG9mIHRoZSBjb25uZWN0aW9uIHRvIGF2b2lkXG4gICAgICAgIC8vIHRpbWVvdXRzIHdoZW4gdGhlIGNvbm5lY3Rpb24gaXMgaW4gdGhlIGJsb2NraW5nXG4gICAgICAgIC8vIG1vZGUgKGUuZy4gd2FpdGluZyBmb3IgQkxQT1ApLlxuICAgICAgICBjb25zdCBkdXBsaWNhdGVkQ29ubmVjdGlvbiA9IHJlZGlzLmR1cGxpY2F0ZSh7XG4gICAgICAgICAgICBlbmFibGVPZmZsaW5lUXVldWU6IHRydWUsXG4gICAgICAgICAgICBlbmFibGVSZWFkeUNoZWNrOiBmYWxzZSxcbiAgICAgICAgICAgIHJldHJ5U3RyYXRlZ3k6IG51bGwsXG4gICAgICAgICAgICBjb25uZWN0aW9uTmFtZTogKDAsIHV0aWxfMS5nZXRDb25uZWN0aW9uTmFtZSkoXCJyZWZyZXNoZXJcIiwgdGhpcy5vcHRpb25zLnJlZGlzT3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMucmVkaXNPcHRpb25zLmNvbm5lY3Rpb25OYW1lKSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElnbm9yZSBlcnJvciBldmVudHMgc2luY2Ugd2Ugd2lsbCBoYW5kbGVcbiAgICAgICAgLy8gZXhjZXB0aW9ucyBmb3IgdGhlIENMVVNURVIgU0xPVFMgY29tbWFuZC5cbiAgICAgICAgZHVwbGljYXRlZENvbm5lY3Rpb24ub24oXCJlcnJvclwiLCB1dGlsc18xLm5vb3ApO1xuICAgICAgICBkdXBsaWNhdGVkQ29ubmVjdGlvbi5jbHVzdGVyKFwiU0xPVFNcIiwgKDAsIHV0aWxzXzEudGltZW91dCkoKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBkdXBsaWNhdGVkQ29ubmVjdGlvbi5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJlcnJvciBlbmNvdW50ZXJlZCBydW5uaW5nIENMVVNURVIuU0xPVFM6ICVzXCIsIGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwiZGlzY29ubmVjdGluZ1wiIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPT09IFwiY2xvc2VcIiB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID09PSBcImVuZFwiKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJpZ25vcmUgQ0xVU1RFUi5TTE9UUyByZXN1bHRzIChjb3VudDogJWQpIHNpbmNlIGNsdXN0ZXIgc3RhdHVzIGlzICVzXCIsIHJlc3VsdC5sZW5ndGgsIHRoaXMuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgICAgICAgICBkZWJ1ZyhcImNsdXN0ZXIgc2xvdHMgcmVzdWx0IGNvdW50OiAlZFwiLCByZXN1bHQubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSByZXN1bHRbaV07XG4gICAgICAgICAgICAgICAgY29uc3Qgc2xvdFJhbmdlU3RhcnQgPSBpdGVtc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzbG90UmFuZ2VFbmQgPSBpdGVtc1sxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDI7IGogPCBpdGVtcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW1zW2pdWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5uYXRNYXBwZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogaXRlbXNbal1bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiBpdGVtc1tqXVsxXSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucmVhZE9ubHkgPSBqICE9PSAyO1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2gobm9kZS5ob3N0ICsgXCI6XCIgKyBub2RlLnBvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImNsdXN0ZXIgc2xvdHMgcmVzdWx0IFslZF06IHNsb3RzICVkfiVkIHNlcnZlZCBieSAlc1wiLCBpLCBzbG90UmFuZ2VTdGFydCwgc2xvdFJhbmdlRW5kLCBrZXlzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzbG90ID0gc2xvdFJhbmdlU3RhcnQ7IHNsb3QgPD0gc2xvdFJhbmdlRW5kOyBzbG90KyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zbG90c1tzbG90XSA9IGtleXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXNzaWduIHRvIGVhY2ggbm9kZSBrZXlzIGEgbnVtZXJpYyB2YWx1ZSB0byBtYWtlIGF1dG9waXBlbGluZSBjb21wYXJpc29uIGZhc3Rlci5cbiAgICAgICAgICAgIHRoaXMuX2dyb3Vwc0lkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBsZXQgaiA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2Mzg0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAodGhpcy5zbG90c1tpXSB8fCBbXSkuam9pbihcIjtcIik7XG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyb3Vwc0J5U2xvdFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZ3JvdXBzSWRzW3RhcmdldF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JvdXBzSWRzW3RhcmdldF0gPSArK2o7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2dyb3Vwc0J5U2xvdFtpXSA9IHRoaXMuX2dyb3Vwc0lkc1t0YXJnZXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9vbC5yZXNldChub2Rlcyk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9LCB0aGlzLm9wdGlvbnMuc2xvdHNSZWZyZXNoVGltZW91dCkpO1xuICAgIH1cbiAgICBpbnZva2VSZWFkeURlbGF5ZWRDYWxsYmFja3MoZXJyKSB7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiB0aGlzLl9yZWFkeURlbGF5ZWRDYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soYywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZWFkeURlbGF5ZWRDYWxsYmFja3MgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciBDbHVzdGVyIGlzIGFibGUgdG8gcHJvY2VzcyBjb21tYW5kc1xuICAgICAqL1xuICAgIHJlYWR5Q2hlY2soY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jbHVzdGVyKFwiSU5GT1wiLCAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IHJlcy5zcGxpdChcIlxcclxcblwiKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmVzW2ldLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgICAgICAgICBpZiAocGFydHNbMF0gPT09IFwiY2x1c3Rlcl9zdGF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gcGFydHNbMV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gXCJmYWlsXCIpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImNsdXN0ZXIgc3RhdGUgbm90IG9rICglcylcIiwgc3RhdGUpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXNvbHZlU3J2KGhvc3RuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMucmVzb2x2ZVNydihob3N0bmFtZSwgKGVyciwgcmVjb3JkcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzZWxmID0gdGhpcywgZ3JvdXBlZFJlY29yZHMgPSAoMCwgdXRpbF8xLmdyb3VwU3J2UmVjb3JkcykocmVjb3JkcyksIHNvcnRlZEtleXMgPSBPYmplY3Qua2V5cyhncm91cGVkUmVjb3Jkcykuc29ydCgoYSwgYikgPT4gcGFyc2VJbnQoYSkgLSBwYXJzZUludChiKSk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdHJ5Rmlyc3RPbmUoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc29ydGVkS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBzb3J0ZWRLZXlzWzBdLCBncm91cCA9IGdyb3VwZWRSZWNvcmRzW2tleV0sIHJlY29yZCA9ICgwLCB1dGlsXzEud2VpZ2h0U3J2UmVjb3JkcykoZ3JvdXApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdyb3VwLnJlY29yZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0ZWRLZXlzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kbnNMb29rdXAocmVjb3JkLm5hbWUpLnRoZW4oKGhvc3QpID0+IHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQ6IHJlY29yZC5wb3J0LFxuICAgICAgICAgICAgICAgICAgICB9KSwgdHJ5Rmlyc3RPbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnlGaXJzdE9uZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkbnNMb29rdXAoaG9zdG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5kbnNMb29rdXAoaG9zdG5hbWUsIChlcnIsIGFkZHJlc3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiZmFpbGVkIHRvIHJlc29sdmUgaG9zdG5hbWUgJXMgdG8gSVA6ICVzXCIsIGhvc3RuYW1lLCBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJyZXNvbHZlZCBob3N0bmFtZSAlcyB0byBJUCAlc1wiLCBob3N0bmFtZSwgYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgc3RhcnR1cCBub2RlcywgYW5kIHJlc29sdmluZyBob3N0bmFtZXMgdG8gSVBzLlxuICAgICAqXG4gICAgICogVGhpcyBwcm9jZXNzIGhhcHBlbnMgZXZlcnkgdGltZSB3aGVuICNjb25uZWN0KCkgaXMgY2FsbGVkIHNpbmNlXG4gICAgICogI3N0YXJ0dXBOb2RlcyBhbmQgRE5TIHJlY29yZHMgbWF5IGNoYW5hZ2UuXG4gICAgICovXG4gICAgYXN5bmMgcmVzb2x2ZVN0YXJ0dXBOb2RlSG9zdG5hbWVzKCkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5zdGFydHVwTm9kZXMpIHx8IHRoaXMuc3RhcnR1cE5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYHN0YXJ0dXBOb2Rlc2Agc2hvdWxkIGNvbnRhaW4gYXQgbGVhc3Qgb25lIG5vZGUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0dXBOb2RlcyA9ICgwLCB1dGlsXzEubm9ybWFsaXplTm9kZU9wdGlvbnMpKHRoaXMuc3RhcnR1cE5vZGVzKTtcbiAgICAgICAgY29uc3QgaG9zdG5hbWVzID0gKDAsIHV0aWxfMS5nZXRVbmlxdWVIb3N0bmFtZXNGcm9tT3B0aW9ucykoc3RhcnR1cE5vZGVzKTtcbiAgICAgICAgaWYgKGhvc3RuYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydHVwTm9kZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlncyA9IGF3YWl0IFByb21pc2UuYWxsKGhvc3RuYW1lcy5tYXAoKHRoaXMub3B0aW9ucy51c2VTUlZSZWNvcmRzID8gdGhpcy5yZXNvbHZlU3J2IDogdGhpcy5kbnNMb29rdXApLmJpbmQodGhpcykpKTtcbiAgICAgICAgY29uc3QgaG9zdG5hbWVUb0NvbmZpZyA9ICgwLCB1dGlsc18xLnppcE1hcCkoaG9zdG5hbWVzLCBjb25maWdzKTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0dXBOb2Rlcy5tYXAoKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IGhvc3RuYW1lVG9Db25maWcuZ2V0KG5vZGUuaG9zdCk7XG4gICAgICAgICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51c2VTUlZSZWNvcmRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG5vZGUsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbm9kZSwgeyBob3N0OiBjb25maWcgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVTY2FuU3RyZWFtKGNvbW1hbmQsIHsga2V5LCBvcHRpb25zID0ge30gfSkge1xuICAgICAgICByZXR1cm4gbmV3IFNjYW5TdHJlYW1fMS5kZWZhdWx0KHtcbiAgICAgICAgICAgIG9iamVjdE1vZGU6IHRydWUsXG4gICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgIHJlZGlzOiB0aGlzLFxuICAgICAgICAgICAgY29tbWFuZDogY29tbWFuZCxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbigwLCBhcHBseU1peGluXzEuZGVmYXVsdCkoQ2x1c3RlciwgZXZlbnRzXzEuRXZlbnRFbWl0dGVyKTtcbigwLCB0cmFuc2FjdGlvbl8xLmFkZFRyYW5zYWN0aW9uU3VwcG9ydCkoQ2x1c3Rlci5wcm90b3R5cGUpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2x1c3RlcjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNvbW1hbmRzXzEiLCJyZXF1aXJlIiwiZXZlbnRzXzEiLCJyZWRpc19lcnJvcnNfMSIsInN0YW5kYXJkX2FzX2NhbGxiYWNrXzEiLCJDb21tYW5kXzEiLCJDbHVzdGVyQWxsRmFpbGVkRXJyb3JfMSIsIlJlZGlzXzEiLCJTY2FuU3RyZWFtXzEiLCJ0cmFuc2FjdGlvbl8xIiwidXRpbHNfMSIsImFwcGx5TWl4aW5fMSIsIkNvbW1hbmRlcl8xIiwiQ2x1c3Rlck9wdGlvbnNfMSIsIkNsdXN0ZXJTdWJzY3JpYmVyXzEiLCJDb25uZWN0aW9uUG9vbF8xIiwiRGVsYXlRdWV1ZV8xIiwidXRpbF8xIiwiRGVxdWUiLCJDbHVzdGVyU3Vic2NyaWJlckdyb3VwXzEiLCJkZWJ1ZyIsIkRlYnVnIiwiUkVKRUNUX09WRVJXUklUVEVOX0NPTU1BTkRTIiwiV2Vha1NldCIsIkNsdXN0ZXIiLCJkZWZhdWx0IiwiY29uc3RydWN0b3IiLCJzdGFydHVwTm9kZXMiLCJvcHRpb25zIiwic2xvdHMiLCJfZ3JvdXBzSWRzIiwiX2dyb3Vwc0J5U2xvdCIsIkFycmF5IiwiaXNDbHVzdGVyIiwicmV0cnlBdHRlbXB0cyIsImRlbGF5UXVldWUiLCJvZmZsaW5lUXVldWUiLCJpc1JlZnJlc2hpbmciLCJfcmVmcmVzaFNsb3RzQ2FjaGVDYWxsYmFja3MiLCJfYXV0b1BpcGVsaW5lcyIsIk1hcCIsIl9ydW5uaW5nQXV0b1BpcGVsaW5lcyIsIlNldCIsIl9yZWFkeURlbGF5ZWRDYWxsYmFja3MiLCJjb25uZWN0aW9uRXBvY2giLCJFdmVudEVtaXR0ZXIiLCJjYWxsIiwiZGVmYXVsdHMiLCJERUZBVUxUX0NMVVNURVJfT1BUSU9OUyIsInNoYXJkZWRTdWJzY3JpYmVycyIsInJlZGlzT3B0aW9ucyIsImtleVByZWZpeCIsInNjYWxlUmVhZHMiLCJpbmRleE9mIiwiRXJyb3IiLCJjb25uZWN0aW9uUG9vbCIsIm9uIiwicmVkaXMiLCJrZXkiLCJlbWl0Iiwic2V0U3RhdHVzIiwiZXJyb3IiLCJzdWJzY3JpYmVyIiwic2NyaXB0cyIsImVudHJpZXMiLCJmb3JFYWNoIiwibmFtZSIsImRlZmluaXRpb24iLCJkZWZpbmVDb21tYW5kIiwibGF6eUNvbm5lY3QiLCJjb25uZWN0IiwiY2F0Y2giLCJlcnIiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInN0YXR1cyIsImVwb2NoIiwicmVzb2x2ZVN0YXJ0dXBOb2RlSG9zdG5hbWVzIiwidGhlbiIsIm5vZGVzIiwiUmVkaXNFcnJvciIsInJlc2V0IiwicmVhZHlIYW5kbGVyIiwiZXhlY3V0ZU9mZmxpbmVDb21tYW5kcyIsInJlc2V0Tm9kZXNSZWZyZXNoSW50ZXJ2YWwiLCJjbG9zZUxpc3RlbmVyIiwidW5kZWZpbmVkIiwicmVmcmVzaExpc3RlbmVyIiwiaW52b2tlUmVhZHlEZWxheWVkQ2FsbGJhY2tzIiwicmVtb3ZlTGlzdGVuZXIiLCJtYW51YWxseUNsb3NpbmciLCJlbmFibGVSZWFkeUNoZWNrIiwicmVhZHlDaGVjayIsImZhaWwiLCJkaXNjb25uZWN0Iiwib25jZSIsImhhbmRsZUNsb3NlRXZlbnQiLCJiaW5kIiwicmVmcmVzaFNsb3RzQ2FjaGUiLCJtZXNzYWdlIiwiZGVmYXVsdE1lc3NhZ2UiLCJwcm90b3R5cGUiLCJzaWxlbnRFbWl0Iiwic3RhcnQiLCJyZWNvbm5lY3QiLCJyZWNvbm5lY3RUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiY2xlYXJOb2Rlc1JlZnJlc2hJbnRlcnZhbCIsInN0b3AiLCJxdWl0IiwiY2FsbGJhY2siLCJyZXQiLCJzZXRJbW1lZGlhdGUiLCJhbGwiLCJtYXAiLCJub2RlIiwiQ09OTkVDVElPTl9DTE9TRURfRVJST1JfTVNHIiwiZHVwbGljYXRlIiwib3ZlcnJpZGVTdGFydHVwTm9kZXMiLCJvdmVycmlkZU9wdGlvbnMiLCJsZW5ndGgiLCJzbGljZSIsImFzc2lnbiIsInJvbGUiLCJnZXROb2RlcyIsImRlbGF5VW50aWxSZWFkeSIsInB1c2giLCJhdXRvUGlwZWxpbmVRdWV1ZVNpemUiLCJxdWV1ZWQiLCJwaXBlbGluZSIsInZhbHVlcyIsIl90aGlzIiwid3JhcHBlciIsInNodWZmbGUiLCJsYXN0Tm9kZUVycm9yIiwidHJ5Tm9kZSIsImluZGV4IiwiaG9zdCIsInBvcnQiLCJnZXRJbmZvRnJvbU5vZGUiLCJzZW5kQ29tbWFuZCIsImNvbW1hbmQiLCJzdHJlYW0iLCJub29wIiwicHJvbWlzZSIsInRvIiwiaXNDb21tYW5kUmVhZE9ubHkiLCJpc1JlYWRPbmx5IiwiZXhpc3RzIiwiaGFzRmxhZyIsInRhcmdldFNsb3QiLCJzbG90IiwiZ2V0U2xvdCIsInR0bCIsImhhcyIsImFkZCIsInBhcnRpYWxUcnkiLCJ0cnlDb25uZWN0aW9uIiwiaGFuZGxlRXJyb3IiLCJtb3ZlZCIsIk51bWJlciIsImpvaW4iLCJmaW5kT3JDcmVhdGUiLCJuYXRNYXBwZXIiLCJhc2siLCJtYXBwZWQiLCJ0cnlhZ2FpbiIsImNsdXN0ZXJEb3duIiwiY29ubmVjdGlvbkNsb3NlZCIsIm1heFJlZGlyZWN0aW9ucyIsInJlZGlyZWN0aW9uRXJyb3IiLCJyYW5kb20iLCJhc2tpbmciLCJBYm9ydEVycm9yIiwiY2hlY2tGbGFnIiwic3ViIiwiZ2V0UmVzcG9uc2libGVTdWJzY3JpYmVyIiwiYWRkQ2hhbm5lbHMiLCJnZXRLZXlzIiwicmVtb3ZlQ2hhbm5lbHMiLCJnZXRJbnN0YW5jZSIsIm5vZGVLZXlzIiwiZ2V0SW5zdGFuY2VCeUtleSIsImlzQXJyYXkiLCJzYW1wbGUiLCJnZXRTYW1wbGVJbnN0YW5jZSIsImVuYWJsZU9mZmxpbmVRdWV1ZSIsInNzY2FuU3RyZWFtIiwiY3JlYXRlU2NhblN0cmVhbSIsInNzY2FuQnVmZmVyU3RyZWFtIiwiaHNjYW5TdHJlYW0iLCJoc2NhbkJ1ZmZlclN0cmVhbSIsInpzY2FuU3RyZWFtIiwienNjYW5CdWZmZXJTdHJlYW0iLCJoYW5kbGVycyIsImVycnYiLCJzcGxpdCIsInRpbWVvdXQiLCJyZXRyeURlbGF5T25Nb3ZlZCIsInJldHJ5RGVsYXlPblRyeUFnYWluIiwicmV0cnlEZWxheU9uQ2x1c3RlckRvd24iLCJyZXRyeURlbGF5T25GYWlsb3ZlciIsInJlc2V0T2ZmbGluZVF1ZXVlIiwic2xvdHNUaW1lciIsInNsb3RzUmVmcmVzaEludGVydmFsIiwibmV4dFJvdW5kIiwic2V0VGltZW91dCIsInByb2Nlc3MiLCJuZXh0VGljayIsInJlYXNvbiIsInJldHJ5RGVsYXkiLCJjbHVzdGVyUmV0cnlTdHJhdGVneSIsImZsdXNoUXVldWUiLCJpdGVtIiwic2hpZnQiLCJub2RlS2V5IiwibmF0TWFwIiwibm9kZUtleVRvUmVkaXNPcHRpb25zIiwiZHVwbGljYXRlZENvbm5lY3Rpb24iLCJyZXRyeVN0cmF0ZWd5IiwiY29ubmVjdGlvbk5hbWUiLCJnZXRDb25uZWN0aW9uTmFtZSIsImNsdXN0ZXIiLCJyZXN1bHQiLCJpIiwiaXRlbXMiLCJzbG90UmFuZ2VTdGFydCIsInNsb3RSYW5nZUVuZCIsImtleXMiLCJqIiwicmVhZE9ubHkiLCJjcmVhdGUiLCJ0YXJnZXQiLCJzbG90c1JlZnJlc2hUaW1lb3V0IiwiYyIsInJlcyIsInN0YXRlIiwibGluZXMiLCJwYXJ0cyIsInJlc29sdmVTcnYiLCJob3N0bmFtZSIsInJlY29yZHMiLCJzZWxmIiwiZ3JvdXBlZFJlY29yZHMiLCJncm91cFNydlJlY29yZHMiLCJzb3J0ZWRLZXlzIiwic29ydCIsImEiLCJiIiwicGFyc2VJbnQiLCJ0cnlGaXJzdE9uZSIsImdyb3VwIiwicmVjb3JkIiwid2VpZ2h0U3J2UmVjb3JkcyIsImRuc0xvb2t1cCIsImFkZHJlc3MiLCJub3JtYWxpemVOb2RlT3B0aW9ucyIsImhvc3RuYW1lcyIsImdldFVuaXF1ZUhvc3RuYW1lc0Zyb21PcHRpb25zIiwiY29uZmlncyIsInVzZVNSVlJlY29yZHMiLCJob3N0bmFtZVRvQ29uZmlnIiwiemlwTWFwIiwiY29uZmlnIiwiZ2V0Iiwib2JqZWN0TW9kZSIsImFkZFRyYW5zYWN0aW9uU3VwcG9ydCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/cluster/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/cluster/util.js":
/*!****************************************************!*\
  !*** ./node_modules/ioredis/built/cluster/util.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getConnectionName = exports.weightSrvRecords = exports.groupSrvRecords = exports.getUniqueHostnamesFromOptions = exports.normalizeNodeOptions = exports.nodeKeyToRedisOptions = exports.getNodeKey = void 0;\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nfunction getNodeKey(node) {\n    node.port = node.port || 6379;\n    node.host = node.host || \"127.0.0.1\";\n    return node.host + \":\" + node.port;\n}\nexports.getNodeKey = getNodeKey;\nfunction nodeKeyToRedisOptions(nodeKey) {\n    const portIndex = nodeKey.lastIndexOf(\":\");\n    if (portIndex === -1) {\n        throw new Error(`Invalid node key ${nodeKey}`);\n    }\n    return {\n        host: nodeKey.slice(0, portIndex),\n        port: Number(nodeKey.slice(portIndex + 1))\n    };\n}\nexports.nodeKeyToRedisOptions = nodeKeyToRedisOptions;\nfunction normalizeNodeOptions(nodes) {\n    return nodes.map((node)=>{\n        const options = {};\n        if (typeof node === \"object\") {\n            Object.assign(options, node);\n        } else if (typeof node === \"string\") {\n            Object.assign(options, (0, utils_1.parseURL)(node));\n        } else if (typeof node === \"number\") {\n            options.port = node;\n        } else {\n            throw new Error(\"Invalid argument \" + node);\n        }\n        if (typeof options.port === \"string\") {\n            options.port = parseInt(options.port, 10);\n        }\n        // Cluster mode only support db 0\n        delete options.db;\n        if (!options.port) {\n            options.port = 6379;\n        }\n        if (!options.host) {\n            options.host = \"127.0.0.1\";\n        }\n        return (0, utils_1.resolveTLSProfile)(options);\n    });\n}\nexports.normalizeNodeOptions = normalizeNodeOptions;\nfunction getUniqueHostnamesFromOptions(nodes) {\n    const uniqueHostsMap = {};\n    nodes.forEach((node)=>{\n        uniqueHostsMap[node.host] = true;\n    });\n    return Object.keys(uniqueHostsMap).filter((host)=>!(0, net_1.isIP)(host));\n}\nexports.getUniqueHostnamesFromOptions = getUniqueHostnamesFromOptions;\nfunction groupSrvRecords(records) {\n    const recordsByPriority = {};\n    for (const record of records){\n        if (!recordsByPriority.hasOwnProperty(record.priority)) {\n            recordsByPriority[record.priority] = {\n                totalWeight: record.weight,\n                records: [\n                    record\n                ]\n            };\n        } else {\n            recordsByPriority[record.priority].totalWeight += record.weight;\n            recordsByPriority[record.priority].records.push(record);\n        }\n    }\n    return recordsByPriority;\n}\nexports.groupSrvRecords = groupSrvRecords;\nfunction weightSrvRecords(recordsGroup) {\n    if (recordsGroup.records.length === 1) {\n        recordsGroup.totalWeight = 0;\n        return recordsGroup.records.shift();\n    }\n    // + `recordsGroup.records.length` to support `weight` 0\n    const random = Math.floor(Math.random() * (recordsGroup.totalWeight + recordsGroup.records.length));\n    let total = 0;\n    for (const [i, record] of recordsGroup.records.entries()){\n        total += 1 + record.weight;\n        if (total > random) {\n            recordsGroup.totalWeight -= record.weight;\n            recordsGroup.records.splice(i, 1);\n            return record;\n        }\n    }\n}\nexports.weightSrvRecords = weightSrvRecords;\nfunction getConnectionName(component, nodeConnectionName) {\n    const prefix = `ioredis-cluster(${component})`;\n    return nodeConnectionName ? `${prefix}:${nodeConnectionName}` : prefix;\n}\nexports.getConnectionName = getConnectionName;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHlCQUF5QixHQUFHQSx3QkFBd0IsR0FBR0EsdUJBQXVCLEdBQUdBLHFDQUFxQyxHQUFHQSw0QkFBNEIsR0FBR0EsNkJBQTZCLEdBQUdBLGtCQUFrQixHQUFHLEtBQUs7QUFDbE4sTUFBTVMsVUFBVUMsbUJBQU9BLENBQUMsbUVBQVU7QUFDbEMsTUFBTUMsUUFBUUQsbUJBQU9BLENBQUMsZ0JBQUs7QUFDM0IsU0FBU0YsV0FBV0ksSUFBSTtJQUNwQkEsS0FBS0MsSUFBSSxHQUFHRCxLQUFLQyxJQUFJLElBQUk7SUFDekJELEtBQUtFLElBQUksR0FBR0YsS0FBS0UsSUFBSSxJQUFJO0lBQ3pCLE9BQU9GLEtBQUtFLElBQUksR0FBRyxNQUFNRixLQUFLQyxJQUFJO0FBQ3RDO0FBQ0FiLGtCQUFrQixHQUFHUTtBQUNyQixTQUFTRCxzQkFBc0JRLE9BQU87SUFDbEMsTUFBTUMsWUFBWUQsUUFBUUUsV0FBVyxDQUFDO0lBQ3RDLElBQUlELGNBQWMsQ0FBQyxHQUFHO1FBQ2xCLE1BQU0sSUFBSUUsTUFBTSxDQUFDLGlCQUFpQixFQUFFSCxRQUFRLENBQUM7SUFDakQ7SUFDQSxPQUFPO1FBQ0hELE1BQU1DLFFBQVFJLEtBQUssQ0FBQyxHQUFHSDtRQUN2QkgsTUFBTU8sT0FBT0wsUUFBUUksS0FBSyxDQUFDSCxZQUFZO0lBQzNDO0FBQ0o7QUFDQWhCLDZCQUE2QixHQUFHTztBQUNoQyxTQUFTRCxxQkFBcUJlLEtBQUs7SUFDL0IsT0FBT0EsTUFBTUMsR0FBRyxDQUFDLENBQUNWO1FBQ2QsTUFBTVcsVUFBVSxDQUFDO1FBQ2pCLElBQUksT0FBT1gsU0FBUyxVQUFVO1lBQzFCZCxPQUFPMEIsTUFBTSxDQUFDRCxTQUFTWDtRQUMzQixPQUNLLElBQUksT0FBT0EsU0FBUyxV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QUNBdEQseUJBQXlCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY2x1c3Rlci91dGlsLmpzP2RiZmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldENvbm5lY3Rpb25OYW1lID0gZXhwb3J0cy53ZWlnaHRTcnZSZWNvcmRzID0gZXhwb3J0cy5ncm91cFNydlJlY29yZHMgPSBleHBvcnRzLmdldFVuaXF1ZUhvc3RuYW1lc0Zyb21PcHRpb25zID0gZXhwb3J0cy5ub3JtYWxpemVOb2RlT3B0aW9ucyA9IGV4cG9ydHMubm9kZUtleVRvUmVkaXNPcHRpb25zID0gZXhwb3J0cy5nZXROb2RlS2V5ID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IG5ldF8xID0gcmVxdWlyZShcIm5ldFwiKTtcbmZ1bmN0aW9uIGdldE5vZGVLZXkobm9kZSkge1xuICAgIG5vZGUucG9ydCA9IG5vZGUucG9ydCB8fCA2Mzc5O1xuICAgIG5vZGUuaG9zdCA9IG5vZGUuaG9zdCB8fCBcIjEyNy4wLjAuMVwiO1xuICAgIHJldHVybiBub2RlLmhvc3QgKyBcIjpcIiArIG5vZGUucG9ydDtcbn1cbmV4cG9ydHMuZ2V0Tm9kZUtleSA9IGdldE5vZGVLZXk7XG5mdW5jdGlvbiBub2RlS2V5VG9SZWRpc09wdGlvbnMobm9kZUtleSkge1xuICAgIGNvbnN0IHBvcnRJbmRleCA9IG5vZGVLZXkubGFzdEluZGV4T2YoXCI6XCIpO1xuICAgIGlmIChwb3J0SW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBub2RlIGtleSAke25vZGVLZXl9YCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGhvc3Q6IG5vZGVLZXkuc2xpY2UoMCwgcG9ydEluZGV4KSxcbiAgICAgICAgcG9ydDogTnVtYmVyKG5vZGVLZXkuc2xpY2UocG9ydEluZGV4ICsgMSkpLFxuICAgIH07XG59XG5leHBvcnRzLm5vZGVLZXlUb1JlZGlzT3B0aW9ucyA9IG5vZGVLZXlUb1JlZGlzT3B0aW9ucztcbmZ1bmN0aW9uIG5vcm1hbGl6ZU5vZGVPcHRpb25zKG5vZGVzKSB7XG4gICAgcmV0dXJuIG5vZGVzLm1hcCgobm9kZSkgPT4ge1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygbm9kZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCAoMCwgdXRpbHNfMS5wYXJzZVVSTCkobm9kZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBub2RlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBvcHRpb25zLnBvcnQgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudCBcIiArIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wb3J0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBvcHRpb25zLnBvcnQgPSBwYXJzZUludChvcHRpb25zLnBvcnQsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbHVzdGVyIG1vZGUgb25seSBzdXBwb3J0IGRiIDBcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGI7XG4gICAgICAgIGlmICghb3B0aW9ucy5wb3J0KSB7XG4gICAgICAgICAgICBvcHRpb25zLnBvcnQgPSA2Mzc5O1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy5ob3N0KSB7XG4gICAgICAgICAgICBvcHRpb25zLmhvc3QgPSBcIjEyNy4wLjAuMVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5yZXNvbHZlVExTUHJvZmlsZSkob3B0aW9ucyk7XG4gICAgfSk7XG59XG5leHBvcnRzLm5vcm1hbGl6ZU5vZGVPcHRpb25zID0gbm9ybWFsaXplTm9kZU9wdGlvbnM7XG5mdW5jdGlvbiBnZXRVbmlxdWVIb3N0bmFtZXNGcm9tT3B0aW9ucyhub2Rlcykge1xuICAgIGNvbnN0IHVuaXF1ZUhvc3RzTWFwID0ge307XG4gICAgbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICB1bmlxdWVIb3N0c01hcFtub2RlLmhvc3RdID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModW5pcXVlSG9zdHNNYXApLmZpbHRlcigoaG9zdCkgPT4gISgwLCBuZXRfMS5pc0lQKShob3N0KSk7XG59XG5leHBvcnRzLmdldFVuaXF1ZUhvc3RuYW1lc0Zyb21PcHRpb25zID0gZ2V0VW5pcXVlSG9zdG5hbWVzRnJvbU9wdGlvbnM7XG5mdW5jdGlvbiBncm91cFNydlJlY29yZHMocmVjb3Jkcykge1xuICAgIGNvbnN0IHJlY29yZHNCeVByaW9yaXR5ID0ge307XG4gICAgZm9yIChjb25zdCByZWNvcmQgb2YgcmVjb3Jkcykge1xuICAgICAgICBpZiAoIXJlY29yZHNCeVByaW9yaXR5Lmhhc093blByb3BlcnR5KHJlY29yZC5wcmlvcml0eSkpIHtcbiAgICAgICAgICAgIHJlY29yZHNCeVByaW9yaXR5W3JlY29yZC5wcmlvcml0eV0gPSB7XG4gICAgICAgICAgICAgICAgdG90YWxXZWlnaHQ6IHJlY29yZC53ZWlnaHQsXG4gICAgICAgICAgICAgICAgcmVjb3JkczogW3JlY29yZF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVjb3Jkc0J5UHJpb3JpdHlbcmVjb3JkLnByaW9yaXR5XS50b3RhbFdlaWdodCArPSByZWNvcmQud2VpZ2h0O1xuICAgICAgICAgICAgcmVjb3Jkc0J5UHJpb3JpdHlbcmVjb3JkLnByaW9yaXR5XS5yZWNvcmRzLnB1c2gocmVjb3JkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVjb3Jkc0J5UHJpb3JpdHk7XG59XG5leHBvcnRzLmdyb3VwU3J2UmVjb3JkcyA9IGdyb3VwU3J2UmVjb3JkcztcbmZ1bmN0aW9uIHdlaWdodFNydlJlY29yZHMocmVjb3Jkc0dyb3VwKSB7XG4gICAgaWYgKHJlY29yZHNHcm91cC5yZWNvcmRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZWNvcmRzR3JvdXAudG90YWxXZWlnaHQgPSAwO1xuICAgICAgICByZXR1cm4gcmVjb3Jkc0dyb3VwLnJlY29yZHMuc2hpZnQoKTtcbiAgICB9XG4gICAgLy8gKyBgcmVjb3Jkc0dyb3VwLnJlY29yZHMubGVuZ3RoYCB0byBzdXBwb3J0IGB3ZWlnaHRgIDBcbiAgICBjb25zdCByYW5kb20gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAocmVjb3Jkc0dyb3VwLnRvdGFsV2VpZ2h0ICsgcmVjb3Jkc0dyb3VwLnJlY29yZHMubGVuZ3RoKSk7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBmb3IgKGNvbnN0IFtpLCByZWNvcmRdIG9mIHJlY29yZHNHcm91cC5yZWNvcmRzLmVudHJpZXMoKSkge1xuICAgICAgICB0b3RhbCArPSAxICsgcmVjb3JkLndlaWdodDtcbiAgICAgICAgaWYgKHRvdGFsID4gcmFuZG9tKSB7XG4gICAgICAgICAgICByZWNvcmRzR3JvdXAudG90YWxXZWlnaHQgLT0gcmVjb3JkLndlaWdodDtcbiAgICAgICAgICAgIHJlY29yZHNHcm91cC5yZWNvcmRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLndlaWdodFNydlJlY29yZHMgPSB3ZWlnaHRTcnZSZWNvcmRzO1xuZnVuY3Rpb24gZ2V0Q29ubmVjdGlvbk5hbWUoY29tcG9uZW50LCBub2RlQ29ubmVjdGlvbk5hbWUpIHtcbiAgICBjb25zdCBwcmVmaXggPSBgaW9yZWRpcy1jbHVzdGVyKCR7Y29tcG9uZW50fSlgO1xuICAgIHJldHVybiBub2RlQ29ubmVjdGlvbk5hbWUgPyBgJHtwcmVmaXh9OiR7bm9kZUNvbm5lY3Rpb25OYW1lfWAgOiBwcmVmaXg7XG59XG5leHBvcnRzLmdldENvbm5lY3Rpb25OYW1lID0gZ2V0Q29ubmVjdGlvbk5hbWU7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRDb25uZWN0aW9uTmFtZSIsIndlaWdodFNydlJlY29yZHMiLCJncm91cFNydlJlY29yZHMiLCJnZXRVbmlxdWVIb3N0bmFtZXNGcm9tT3B0aW9ucyIsIm5vcm1hbGl6ZU5vZGVPcHRpb25zIiwibm9kZUtleVRvUmVkaXNPcHRpb25zIiwiZ2V0Tm9kZUtleSIsInV0aWxzXzEiLCJyZXF1aXJlIiwibmV0XzEiLCJub2RlIiwicG9ydCIsImhvc3QiLCJub2RlS2V5IiwicG9ydEluZGV4IiwibGFzdEluZGV4T2YiLCJFcnJvciIsInNsaWNlIiwiTnVtYmVyIiwibm9kZXMiLCJtYXAiLCJvcHRpb25zIiwiYXNzaWduIiwicGFyc2VVUkwiLCJwYXJzZUludCIsImRiIiwicmVzb2x2ZVRMU1Byb2ZpbGUiLCJ1bmlxdWVIb3N0c01hcCIsImZvckVhY2giLCJrZXlzIiwiZmlsdGVyIiwiaXNJUCIsInJlY29yZHMiLCJyZWNvcmRzQnlQcmlvcml0eSIsInJlY29yZCIsImhhc093blByb3BlcnR5IiwicHJpb3JpdHkiLCJ0b3RhbFdlaWdodCIsIndlaWdodCIsInB1c2giLCJyZWNvcmRzR3JvdXAiLCJsZW5ndGgiLCJzaGlmdCIsInJhbmRvbSIsIk1hdGgiLCJmbG9vciIsInRvdGFsIiwiaSIsImVudHJpZXMiLCJzcGxpY2UiLCJjb21wb25lbnQiLCJub2RlQ29ubmVjdGlvbk5hbWUiLCJwcmVmaXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/cluster/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/connectors/AbstractConnector.js":
/*!********************************************************************!*\
  !*** ./node_modules/ioredis/built/connectors/AbstractConnector.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst debug = (0, utils_1.Debug)(\"AbstractConnector\");\nclass AbstractConnector {\n    constructor(disconnectTimeout){\n        this.connecting = false;\n        this.disconnectTimeout = disconnectTimeout;\n    }\n    check(info) {\n        return true;\n    }\n    disconnect() {\n        this.connecting = false;\n        if (this.stream) {\n            const stream = this.stream; // Make sure callbacks refer to the same instance\n            const timeout = setTimeout(()=>{\n                debug(\"stream %s:%s still open, destroying it\", stream.remoteAddress, stream.remotePort);\n                stream.destroy();\n            }, this.disconnectTimeout);\n            stream.on(\"close\", ()=>clearTimeout(timeout));\n            stream.end();\n        }\n    }\n}\nexports[\"default\"] = AbstractConnector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jb25uZWN0b3JzL0Fic3RyYWN0Q29ubmVjdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFVBQVVDLG1CQUFPQSxDQUFDLG1FQUFVO0FBQ2xDLE1BQU1DLFFBQVEsQ0FBQyxHQUFHRixRQUFRRyxLQUFLLEVBQUU7QUFDakMsTUFBTUM7SUFDRkMsWUFBWUMsaUJBQWlCLENBQUU7UUFDM0IsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDRCxpQkFBaUIsR0FBR0E7SUFDN0I7SUFDQUUsTUFBTUMsSUFBSSxFQUFFO1FBQ1IsT0FBTztJQUNYO0lBQ0FDLGFBQWE7UUFDVCxJQUFJLENBQUNILFVBQVUsR0FBRztRQUNsQixJQUFJLElBQUksQ0FBQ0ksTUFBTSxFQUFFO1lBQ2IsTUFBTUEsU0FBUyxJQUFJLENBQUNBLE1BQU0sRUFBRSxpREFBaUQ7WUFDN0UsTUFBTUMsVUFBVUMsV0FBVztnQkFDdkJYLE1BQU0sMENBQTBDUyxPQUFPRyxhQUFhLEVBQUVILE9BQU9JLFVBQVU7Z0JBQ3ZGSixPQUFPSyxPQUFPO1lBQ2xCLEdBQUcsSUFBSSxDQUFDVixpQkFBaUI7WUFDekJLLE9BQU9NLEVBQUUsQ0FBQyxTQUFTLElBQU1DLGFBQWFOO1lBQ3RDRCxPQUFPUSxHQUFHO1FBQ2Q7SUFDSjtBQUNKO0FBQ0FyQixrQkFBZSxHQUFHTSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2Nvbm5lY3RvcnMvQWJzdHJhY3RDb25uZWN0b3IuanM/Mjc5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCB1dGlsc18xLkRlYnVnKShcIkFic3RyYWN0Q29ubmVjdG9yXCIpO1xuY2xhc3MgQWJzdHJhY3RDb25uZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGRpc2Nvbm5lY3RUaW1lb3V0KSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RUaW1lb3V0ID0gZGlzY29ubmVjdFRpbWVvdXQ7XG4gICAgfVxuICAgIGNoZWNrKGluZm8pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5zdHJlYW0pIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuc3RyZWFtOyAvLyBNYWtlIHN1cmUgY2FsbGJhY2tzIHJlZmVyIHRvIHRoZSBzYW1lIGluc3RhbmNlXG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJzdHJlYW0gJXM6JXMgc3RpbGwgb3BlbiwgZGVzdHJveWluZyBpdFwiLCBzdHJlYW0ucmVtb3RlQWRkcmVzcywgc3RyZWFtLnJlbW90ZVBvcnQpO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9LCB0aGlzLmRpc2Nvbm5lY3RUaW1lb3V0KTtcbiAgICAgICAgICAgIHN0cmVhbS5vbihcImNsb3NlXCIsICgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0KSk7XG4gICAgICAgICAgICBzdHJlYW0uZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBBYnN0cmFjdENvbm5lY3RvcjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInV0aWxzXzEiLCJyZXF1aXJlIiwiZGVidWciLCJEZWJ1ZyIsIkFic3RyYWN0Q29ubmVjdG9yIiwiY29uc3RydWN0b3IiLCJkaXNjb25uZWN0VGltZW91dCIsImNvbm5lY3RpbmciLCJjaGVjayIsImluZm8iLCJkaXNjb25uZWN0Iiwic3RyZWFtIiwidGltZW91dCIsInNldFRpbWVvdXQiLCJyZW1vdGVBZGRyZXNzIiwicmVtb3RlUG9ydCIsImRlc3Ryb3kiLCJvbiIsImNsZWFyVGltZW91dCIsImVuZCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/connectors/AbstractConnector.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/FailoverDetector.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ioredis/built/connectors/SentinelConnector/FailoverDetector.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FailoverDetector = void 0;\nconst utils_1 = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst debug = (0, utils_1.Debug)(\"FailoverDetector\");\nconst CHANNEL_NAME = \"+switch-master\";\nclass FailoverDetector {\n    // sentinels can't be used for regular commands after this\n    constructor(connector, sentinels){\n        this.isDisconnected = false;\n        this.connector = connector;\n        this.sentinels = sentinels;\n    }\n    cleanup() {\n        this.isDisconnected = true;\n        for (const sentinel of this.sentinels){\n            sentinel.client.disconnect();\n        }\n    }\n    async subscribe() {\n        debug(\"Starting FailoverDetector\");\n        const promises = [];\n        for (const sentinel of this.sentinels){\n            const promise = sentinel.client.subscribe(CHANNEL_NAME).catch((err)=>{\n                debug(\"Failed to subscribe to failover messages on sentinel %s:%s (%s)\", sentinel.address.host || \"127.0.0.1\", sentinel.address.port || 26739, err.message);\n            });\n            promises.push(promise);\n            sentinel.client.on(\"message\", (channel)=>{\n                if (!this.isDisconnected && channel === CHANNEL_NAME) {\n                    this.disconnect();\n                }\n            });\n        }\n        await Promise.all(promises);\n    }\n    disconnect() {\n        // Avoid disconnecting more than once per failover.\n        // A new FailoverDetector will be created after reconnecting.\n        this.isDisconnected = true;\n        debug(\"Failover detected, disconnecting\");\n        // Will call this.cleanup()\n        this.connector.disconnect();\n    }\n}\nexports.FailoverDetector = FailoverDetector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jb25uZWN0b3JzL1NlbnRpbmVsQ29ubmVjdG9yL0ZhaWxvdmVyRGV0ZWN0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHdCQUF3QixHQUFHLEtBQUs7QUFDaEMsTUFBTUcsVUFBVUMsbUJBQU9BLENBQUMsc0VBQWE7QUFDckMsTUFBTUMsUUFBUSxDQUFDLEdBQUdGLFFBQVFHLEtBQUssRUFBRTtBQUNqQyxNQUFNQyxlQUFlO0FBQ3JCLE1BQU1MO0lBQ0YsMERBQTBEO0lBQzFETSxZQUFZQyxTQUFTLEVBQUVDLFNBQVMsQ0FBRTtRQUM5QixJQUFJLENBQUNDLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNGLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO0lBQ3JCO0lBQ0FFLFVBQVU7UUFDTixJQUFJLENBQUNELGNBQWMsR0FBRztRQUN0QixLQUFLLE1BQU1FLFlBQVksSUFBSSxDQUFDSCxTQUFTLENBQUU7WUFDbkNHLFNBQVNDLE1BQU0sQ0FBQ0MsVUFBVTtRQUM5QjtJQUNKO0lBQ0EsTUFBTUMsWUFBWTtRQUNkWCxNQUFNO1FBQ04sTUFBTVksV0FBVyxFQUFFO1FBQ25CLEtBQUssTUFBTUosWUFBWSxJQUFJLENBQUNILFNBQVMsQ0FBRTtZQUNuQyxNQUFNUSxVQUFVTCxTQUFTQyxNQUFNLENBQUNFLFNBQVMsQ0FBQ1QsY0FBY1ksS0FBSyxDQUFDLENBQUNDO2dCQUMzRGYsTUFBTSxtRUFBbUVRLFNBQVNRLE9BQU8sQ0FBQ0MsSUFBSSxJQUFJLGFBQWFULFNBQVNRLE9BQU8sQ0FBQ0UsSUFBSSxJQUFJLE9BQU9ILElBQUlJLE9BQU87WUFDOUo7WUFDQVAsU0FBU1EsSUFBSSxDQUFDUDtZQUNkTCxTQUFTQyxNQUFNLENBQUNZLEVBQUUsQ0FBQyxXQUFXLENBQUNDO2dCQUMzQixJQUFJLENBQUMsSUFBSSxDQUFDaEIsY0FBYyxJQUFJZ0IsWUFBWXBCLGNBQWM7b0JBQ2xELElBQUksQ0FBQ1EsVUFBVTtnQkFDbkI7WUFDSjtRQUNKO1FBQ0EsTUFBTWEsUUFBUUMsR0FBRyxDQUFDWjtJQUN0QjtJQUNBRixhQUFhO1FBQ1QsbURBQW1EO1FBQ25ELDZEQUE2RDtRQUM3RCxJQUFJLENBQUNKLGNBQWMsR0FBRztRQUN0Qk4sTUFBTTtRQUNOLDJCQUEyQjtRQUMzQixJQUFJLENBQUNJLFNBQVMsQ0FBQ00sVUFBVTtJQUM3QjtBQUNKO0FBQ0FmLHdCQUF3QixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2Nvbm5lY3RvcnMvU2VudGluZWxDb25uZWN0b3IvRmFpbG92ZXJEZXRlY3Rvci5qcz9lMTRiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GYWlsb3ZlckRldGVjdG9yID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIHV0aWxzXzEuRGVidWcpKFwiRmFpbG92ZXJEZXRlY3RvclwiKTtcbmNvbnN0IENIQU5ORUxfTkFNRSA9IFwiK3N3aXRjaC1tYXN0ZXJcIjtcbmNsYXNzIEZhaWxvdmVyRGV0ZWN0b3Ige1xuICAgIC8vIHNlbnRpbmVscyBjYW4ndCBiZSB1c2VkIGZvciByZWd1bGFyIGNvbW1hbmRzIGFmdGVyIHRoaXNcbiAgICBjb25zdHJ1Y3Rvcihjb25uZWN0b3IsIHNlbnRpbmVscykge1xuICAgICAgICB0aGlzLmlzRGlzY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29ubmVjdG9yID0gY29ubmVjdG9yO1xuICAgICAgICB0aGlzLnNlbnRpbmVscyA9IHNlbnRpbmVscztcbiAgICB9XG4gICAgY2xlYW51cCgpIHtcbiAgICAgICAgdGhpcy5pc0Rpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIGZvciAoY29uc3Qgc2VudGluZWwgb2YgdGhpcy5zZW50aW5lbHMpIHtcbiAgICAgICAgICAgIHNlbnRpbmVsLmNsaWVudC5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc3Vic2NyaWJlKCkge1xuICAgICAgICBkZWJ1ZyhcIlN0YXJ0aW5nIEZhaWxvdmVyRGV0ZWN0b3JcIik7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgc2VudGluZWwgb2YgdGhpcy5zZW50aW5lbHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBzZW50aW5lbC5jbGllbnQuc3Vic2NyaWJlKENIQU5ORUxfTkFNRSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiRmFpbGVkIHRvIHN1YnNjcmliZSB0byBmYWlsb3ZlciBtZXNzYWdlcyBvbiBzZW50aW5lbCAlczolcyAoJXMpXCIsIHNlbnRpbmVsLmFkZHJlc3MuaG9zdCB8fCBcIjEyNy4wLjAuMVwiLCBzZW50aW5lbC5hZGRyZXNzLnBvcnQgfHwgMjY3MzksIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgICAgIHNlbnRpbmVsLmNsaWVudC5vbihcIm1lc3NhZ2VcIiwgKGNoYW5uZWwpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNEaXNjb25uZWN0ZWQgJiYgY2hhbm5lbCA9PT0gQ0hBTk5FTF9OQU1FKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgLy8gQXZvaWQgZGlzY29ubmVjdGluZyBtb3JlIHRoYW4gb25jZSBwZXIgZmFpbG92ZXIuXG4gICAgICAgIC8vIEEgbmV3IEZhaWxvdmVyRGV0ZWN0b3Igd2lsbCBiZSBjcmVhdGVkIGFmdGVyIHJlY29ubmVjdGluZy5cbiAgICAgICAgdGhpcy5pc0Rpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIGRlYnVnKFwiRmFpbG92ZXIgZGV0ZWN0ZWQsIGRpc2Nvbm5lY3RpbmdcIik7XG4gICAgICAgIC8vIFdpbGwgY2FsbCB0aGlzLmNsZWFudXAoKVxuICAgICAgICB0aGlzLmNvbm5lY3Rvci5kaXNjb25uZWN0KCk7XG4gICAgfVxufVxuZXhwb3J0cy5GYWlsb3ZlckRldGVjdG9yID0gRmFpbG92ZXJEZXRlY3RvcjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkZhaWxvdmVyRGV0ZWN0b3IiLCJ1dGlsc18xIiwicmVxdWlyZSIsImRlYnVnIiwiRGVidWciLCJDSEFOTkVMX05BTUUiLCJjb25zdHJ1Y3RvciIsImNvbm5lY3RvciIsInNlbnRpbmVscyIsImlzRGlzY29ubmVjdGVkIiwiY2xlYW51cCIsInNlbnRpbmVsIiwiY2xpZW50IiwiZGlzY29ubmVjdCIsInN1YnNjcmliZSIsInByb21pc2VzIiwicHJvbWlzZSIsImNhdGNoIiwiZXJyIiwiYWRkcmVzcyIsImhvc3QiLCJwb3J0IiwibWVzc2FnZSIsInB1c2giLCJvbiIsImNoYW5uZWwiLCJQcm9taXNlIiwiYWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/FailoverDetector.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/SentinelIterator.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ioredis/built/connectors/SentinelConnector/SentinelIterator.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction isSentinelEql(a, b) {\n    return (a.host || \"127.0.0.1\") === (b.host || \"127.0.0.1\") && (a.port || 26379) === (b.port || 26379);\n}\nclass SentinelIterator {\n    constructor(sentinels){\n        this.cursor = 0;\n        this.sentinels = sentinels.slice(0);\n    }\n    next() {\n        const done = this.cursor >= this.sentinels.length;\n        return {\n            done,\n            value: done ? undefined : this.sentinels[this.cursor++]\n        };\n    }\n    reset(moveCurrentEndpointToFirst) {\n        if (moveCurrentEndpointToFirst && this.sentinels.length > 1 && this.cursor !== 1) {\n            this.sentinels.unshift(...this.sentinels.splice(this.cursor - 1));\n        }\n        this.cursor = 0;\n    }\n    add(sentinel) {\n        for(let i = 0; i < this.sentinels.length; i++){\n            if (isSentinelEql(sentinel, this.sentinels[i])) {\n                return false;\n            }\n        }\n        this.sentinels.push(sentinel);\n        return true;\n    }\n    toString() {\n        return `${JSON.stringify(this.sentinels)} @${this.cursor}`;\n    }\n}\nexports[\"default\"] = SentinelIterator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jb25uZWN0b3JzL1NlbnRpbmVsQ29ubmVjdG9yL1NlbnRpbmVsSXRlcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsU0FBU0MsY0FBY0MsQ0FBQyxFQUFFQyxDQUFDO0lBQ3ZCLE9BQVEsQ0FBQ0QsRUFBRUUsSUFBSSxJQUFJLFdBQVUsTUFBUUQsQ0FBQUEsRUFBRUMsSUFBSSxJQUFJLFdBQVUsS0FDckQsQ0FBQ0YsRUFBRUcsSUFBSSxJQUFJLEtBQUksTUFBUUYsQ0FBQUEsRUFBRUUsSUFBSSxJQUFJLEtBQUk7QUFDN0M7QUFDQSxNQUFNQztJQUNGQyxZQUFZQyxTQUFTLENBQUU7UUFDbkIsSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNELFNBQVMsR0FBR0EsVUFBVUUsS0FBSyxDQUFDO0lBQ3JDO0lBQ0FDLE9BQU87UUFDSCxNQUFNQyxPQUFPLElBQUksQ0FBQ0gsTUFBTSxJQUFJLElBQUksQ0FBQ0QsU0FBUyxDQUFDSyxNQUFNO1FBQ2pELE9BQU87WUFBRUQ7WUFBTVosT0FBT1ksT0FBT0UsWUFBWSxJQUFJLENBQUNOLFNBQVMsQ0FBQyxJQUFJLENBQUNDLE1BQU0sR0FBRztRQUFDO0lBQzNFO0lBQ0FNLE1BQU1DLDBCQUEwQixFQUFFO1FBQzlCLElBQUlBLDhCQUNBLElBQUksQ0FBQ1IsU0FBUyxDQUFDSyxNQUFNLEdBQUcsS0FDeEIsSUFBSSxDQUFDSixNQUFNLEtBQUssR0FBRztZQUNuQixJQUFJLENBQUNELFNBQVMsQ0FBQ1MsT0FBTyxJQUFJLElBQUksQ0FBQ1QsU0FBUyxDQUFDVSxNQUFNLENBQUMsSUFBSSxDQUFDVCxNQUFNLEdBQUc7UUFDbEU7UUFDQSxJQUFJLENBQUNBLE1BQU0sR0FBRztJQUNsQjtJQUNBVSxJQUFJQyxRQUFRLEVBQUU7UUFDVixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNiLFNBQVMsQ0FBQ0ssTUFBTSxFQUFFUSxJQUFLO1lBQzVDLElBQUlwQixjQUFjbUIsVUFBVSxJQUFJLENBQUNaLFNBQVMsQ0FBQ2EsRUFBRSxHQUFHO2dCQUM1QyxPQUFPO1lBQ1g7UUFDSjtRQUNBLElBQUksQ0FBQ2IsU0FBUyxDQUFDYyxJQUFJLENBQUNGO1FBQ3BCLE9BQU87SUFDWDtJQUNBRyxXQUFXO1FBQ1AsT0FBTyxDQUFDLEVBQUVDLEtBQUtDLFNBQVMsQ0FBQyxJQUFJLENBQUNqQixTQUFTLEVBQUUsRUFBRSxFQUFFLElBQUksQ0FBQ0MsTUFBTSxDQUFDLENBQUM7SUFDOUQ7QUFDSjtBQUNBVixrQkFBZSxHQUFHTyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2Nvbm5lY3RvcnMvU2VudGluZWxDb25uZWN0b3IvU2VudGluZWxJdGVyYXRvci5qcz9kMjFjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gaXNTZW50aW5lbEVxbChhLCBiKSB7XG4gICAgcmV0dXJuICgoYS5ob3N0IHx8IFwiMTI3LjAuMC4xXCIpID09PSAoYi5ob3N0IHx8IFwiMTI3LjAuMC4xXCIpICYmXG4gICAgICAgIChhLnBvcnQgfHwgMjYzNzkpID09PSAoYi5wb3J0IHx8IDI2Mzc5KSk7XG59XG5jbGFzcyBTZW50aW5lbEl0ZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihzZW50aW5lbHMpIHtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSAwO1xuICAgICAgICB0aGlzLnNlbnRpbmVscyA9IHNlbnRpbmVscy5zbGljZSgwKTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgZG9uZSA9IHRoaXMuY3Vyc29yID49IHRoaXMuc2VudGluZWxzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHsgZG9uZSwgdmFsdWU6IGRvbmUgPyB1bmRlZmluZWQgOiB0aGlzLnNlbnRpbmVsc1t0aGlzLmN1cnNvcisrXSB9O1xuICAgIH1cbiAgICByZXNldChtb3ZlQ3VycmVudEVuZHBvaW50VG9GaXJzdCkge1xuICAgICAgICBpZiAobW92ZUN1cnJlbnRFbmRwb2ludFRvRmlyc3QgJiZcbiAgICAgICAgICAgIHRoaXMuc2VudGluZWxzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yICE9PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnNlbnRpbmVscy51bnNoaWZ0KC4uLnRoaXMuc2VudGluZWxzLnNwbGljZSh0aGlzLmN1cnNvciAtIDEpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnNvciA9IDA7XG4gICAgfVxuICAgIGFkZChzZW50aW5lbCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VudGluZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXNTZW50aW5lbEVxbChzZW50aW5lbCwgdGhpcy5zZW50aW5lbHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VudGluZWxzLnB1c2goc2VudGluZWwpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgJHtKU09OLnN0cmluZ2lmeSh0aGlzLnNlbnRpbmVscyl9IEAke3RoaXMuY3Vyc29yfWA7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gU2VudGluZWxJdGVyYXRvcjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImlzU2VudGluZWxFcWwiLCJhIiwiYiIsImhvc3QiLCJwb3J0IiwiU2VudGluZWxJdGVyYXRvciIsImNvbnN0cnVjdG9yIiwic2VudGluZWxzIiwiY3Vyc29yIiwic2xpY2UiLCJuZXh0IiwiZG9uZSIsImxlbmd0aCIsInVuZGVmaW5lZCIsInJlc2V0IiwibW92ZUN1cnJlbnRFbmRwb2ludFRvRmlyc3QiLCJ1bnNoaWZ0Iiwic3BsaWNlIiwiYWRkIiwic2VudGluZWwiLCJpIiwicHVzaCIsInRvU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/SentinelIterator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ioredis/built/connectors/SentinelConnector/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SentinelIterator = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst utils_1 = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst SentinelIterator_1 = __webpack_require__(/*! ./SentinelIterator */ \"(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/SentinelIterator.js\");\nexports.SentinelIterator = SentinelIterator_1.default;\nconst AbstractConnector_1 = __webpack_require__(/*! ../AbstractConnector */ \"(rsc)/./node_modules/ioredis/built/connectors/AbstractConnector.js\");\nconst Redis_1 = __webpack_require__(/*! ../../Redis */ \"(rsc)/./node_modules/ioredis/built/Redis.js\");\nconst FailoverDetector_1 = __webpack_require__(/*! ./FailoverDetector */ \"(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/FailoverDetector.js\");\nconst debug = (0, utils_1.Debug)(\"SentinelConnector\");\nclass SentinelConnector extends AbstractConnector_1.default {\n    constructor(options){\n        super(options.disconnectTimeout);\n        this.options = options;\n        this.emitter = null;\n        this.failoverDetector = null;\n        if (!this.options.sentinels.length) {\n            throw new Error(\"Requires at least one sentinel to connect to.\");\n        }\n        if (!this.options.name) {\n            throw new Error(\"Requires the name of master.\");\n        }\n        this.sentinelIterator = new SentinelIterator_1.default(this.options.sentinels);\n    }\n    check(info) {\n        const roleMatches = !info.role || this.options.role === info.role;\n        if (!roleMatches) {\n            debug(\"role invalid, expected %s, but got %s\", this.options.role, info.role);\n            // Start from the next item.\n            // Note that `reset` will move the cursor to the previous element,\n            // so we advance two steps here.\n            this.sentinelIterator.next();\n            this.sentinelIterator.next();\n            this.sentinelIterator.reset(true);\n        }\n        return roleMatches;\n    }\n    disconnect() {\n        super.disconnect();\n        if (this.failoverDetector) {\n            this.failoverDetector.cleanup();\n        }\n    }\n    connect(eventEmitter) {\n        this.connecting = true;\n        this.retryAttempts = 0;\n        let lastError;\n        const connectToNext = async ()=>{\n            const endpoint = this.sentinelIterator.next();\n            if (endpoint.done) {\n                this.sentinelIterator.reset(false);\n                const retryDelay = typeof this.options.sentinelRetryStrategy === \"function\" ? this.options.sentinelRetryStrategy(++this.retryAttempts) : null;\n                let errorMsg = typeof retryDelay !== \"number\" ? \"All sentinels are unreachable and retry is disabled.\" : `All sentinels are unreachable. Retrying from scratch after ${retryDelay}ms.`;\n                if (lastError) {\n                    errorMsg += ` Last error: ${lastError.message}`;\n                }\n                debug(errorMsg);\n                const error = new Error(errorMsg);\n                if (typeof retryDelay === \"number\") {\n                    eventEmitter(\"error\", error);\n                    await new Promise((resolve)=>setTimeout(resolve, retryDelay));\n                    return connectToNext();\n                } else {\n                    throw error;\n                }\n            }\n            let resolved = null;\n            let err = null;\n            try {\n                resolved = await this.resolve(endpoint.value);\n            } catch (error) {\n                err = error;\n            }\n            if (!this.connecting) {\n                throw new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG);\n            }\n            const endpointAddress = endpoint.value.host + \":\" + endpoint.value.port;\n            if (resolved) {\n                debug(\"resolved: %s:%s from sentinel %s\", resolved.host, resolved.port, endpointAddress);\n                if (this.options.enableTLSForSentinelMode && this.options.tls) {\n                    Object.assign(resolved, this.options.tls);\n                    this.stream = (0, tls_1.connect)(resolved);\n                    this.stream.once(\"secureConnect\", this.initFailoverDetector.bind(this));\n                } else {\n                    this.stream = (0, net_1.createConnection)(resolved);\n                    this.stream.once(\"connect\", this.initFailoverDetector.bind(this));\n                }\n                this.stream.once(\"error\", (err)=>{\n                    this.firstError = err;\n                });\n                return this.stream;\n            } else {\n                const errorMsg = err ? \"failed to connect to sentinel \" + endpointAddress + \" because \" + err.message : \"connected to sentinel \" + endpointAddress + \" successfully, but got an invalid reply: \" + resolved;\n                debug(errorMsg);\n                eventEmitter(\"sentinelError\", new Error(errorMsg));\n                if (err) {\n                    lastError = err;\n                }\n                return connectToNext();\n            }\n        };\n        return connectToNext();\n    }\n    async updateSentinels(client) {\n        if (!this.options.updateSentinels) {\n            return;\n        }\n        const result = await client.sentinel(\"sentinels\", this.options.name);\n        if (!Array.isArray(result)) {\n            return;\n        }\n        result.map(utils_1.packObject).forEach((sentinel)=>{\n            const flags = sentinel.flags ? sentinel.flags.split(\",\") : [];\n            if (flags.indexOf(\"disconnected\") === -1 && sentinel.ip && sentinel.port) {\n                const endpoint = this.sentinelNatResolve(addressResponseToAddress(sentinel));\n                if (this.sentinelIterator.add(endpoint)) {\n                    debug(\"adding sentinel %s:%s\", endpoint.host, endpoint.port);\n                }\n            }\n        });\n        debug(\"Updated internal sentinels: %s\", this.sentinelIterator);\n    }\n    async resolveMaster(client) {\n        const result = await client.sentinel(\"get-master-addr-by-name\", this.options.name);\n        await this.updateSentinels(client);\n        return this.sentinelNatResolve(Array.isArray(result) ? {\n            host: result[0],\n            port: Number(result[1])\n        } : null);\n    }\n    async resolveSlave(client) {\n        const result = await client.sentinel(\"slaves\", this.options.name);\n        if (!Array.isArray(result)) {\n            return null;\n        }\n        const availableSlaves = result.map(utils_1.packObject).filter((slave)=>slave.flags && !slave.flags.match(/(disconnected|s_down|o_down)/));\n        return this.sentinelNatResolve(selectPreferredSentinel(availableSlaves, this.options.preferredSlaves));\n    }\n    sentinelNatResolve(item) {\n        if (!item || !this.options.natMap) return item;\n        const key = `${item.host}:${item.port}`;\n        let result = item;\n        if (typeof this.options.natMap === \"function\") {\n            result = this.options.natMap(key) || item;\n        } else if (typeof this.options.natMap === \"object\") {\n            result = this.options.natMap[key] || item;\n        }\n        return result;\n    }\n    connectToSentinel(endpoint, options) {\n        const redis = new Redis_1.default({\n            port: endpoint.port || 26379,\n            host: endpoint.host,\n            username: this.options.sentinelUsername || null,\n            password: this.options.sentinelPassword || null,\n            family: endpoint.family || // @ts-expect-error\n            (\"path\" in this.options && this.options.path ? undefined : this.options.family),\n            tls: this.options.sentinelTLS,\n            retryStrategy: null,\n            enableReadyCheck: false,\n            connectTimeout: this.options.connectTimeout,\n            commandTimeout: this.options.sentinelCommandTimeout,\n            ...options\n        });\n        // @ts-expect-error\n        return redis;\n    }\n    async resolve(endpoint) {\n        const client = this.connectToSentinel(endpoint);\n        // ignore the errors since resolve* methods will handle them\n        client.on(\"error\", noop);\n        try {\n            if (this.options.role === \"slave\") {\n                return await this.resolveSlave(client);\n            } else {\n                return await this.resolveMaster(client);\n            }\n        } finally{\n            client.disconnect();\n        }\n    }\n    async initFailoverDetector() {\n        var _a;\n        if (!this.options.failoverDetector) {\n            return;\n        }\n        // Move the current sentinel to the first position\n        this.sentinelIterator.reset(true);\n        const sentinels = [];\n        // In case of a large amount of sentinels, limit the number of concurrent connections\n        while(sentinels.length < this.options.sentinelMaxConnections){\n            const { done, value } = this.sentinelIterator.next();\n            if (done) {\n                break;\n            }\n            const client = this.connectToSentinel(value, {\n                lazyConnect: true,\n                retryStrategy: this.options.sentinelReconnectStrategy\n            });\n            client.on(\"reconnecting\", ()=>{\n                var _a;\n                // Tests listen to this event\n                (_a = this.emitter) === null || _a === void 0 ? void 0 : _a.emit(\"sentinelReconnecting\");\n            });\n            sentinels.push({\n                address: value,\n                client\n            });\n        }\n        this.sentinelIterator.reset(false);\n        if (this.failoverDetector) {\n            // Clean up previous detector\n            this.failoverDetector.cleanup();\n        }\n        this.failoverDetector = new FailoverDetector_1.FailoverDetector(this, sentinels);\n        await this.failoverDetector.subscribe();\n        // Tests listen to this event\n        (_a = this.emitter) === null || _a === void 0 ? void 0 : _a.emit(\"failoverSubscribed\");\n    }\n}\nexports[\"default\"] = SentinelConnector;\nfunction selectPreferredSentinel(availableSlaves, preferredSlaves) {\n    if (availableSlaves.length === 0) {\n        return null;\n    }\n    let selectedSlave;\n    if (typeof preferredSlaves === \"function\") {\n        selectedSlave = preferredSlaves(availableSlaves);\n    } else if (preferredSlaves !== null && typeof preferredSlaves === \"object\") {\n        const preferredSlavesArray = Array.isArray(preferredSlaves) ? preferredSlaves : [\n            preferredSlaves\n        ];\n        // sort by priority\n        preferredSlavesArray.sort((a, b)=>{\n            // default the priority to 1\n            if (!a.prio) {\n                a.prio = 1;\n            }\n            if (!b.prio) {\n                b.prio = 1;\n            }\n            // lowest priority first\n            if (a.prio < b.prio) {\n                return -1;\n            }\n            if (a.prio > b.prio) {\n                return 1;\n            }\n            return 0;\n        });\n        // loop over preferred slaves and return the first match\n        for(let p = 0; p < preferredSlavesArray.length; p++){\n            for(let a = 0; a < availableSlaves.length; a++){\n                const slave = availableSlaves[a];\n                if (slave.ip === preferredSlavesArray[p].ip) {\n                    if (slave.port === preferredSlavesArray[p].port) {\n                        selectedSlave = slave;\n                        break;\n                    }\n                }\n            }\n            if (selectedSlave) {\n                break;\n            }\n        }\n    }\n    // if none of the preferred slaves are available, a random available slave is returned\n    if (!selectedSlave) {\n        selectedSlave = (0, utils_1.sample)(availableSlaves);\n    }\n    return addressResponseToAddress(selectedSlave);\n}\nfunction addressResponseToAddress(input) {\n    return {\n        host: input.ip,\n        port: Number(input.port)\n    };\n}\nfunction noop() {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jb25uZWN0b3JzL1NlbnRpbmVsQ29ubmVjdG9yL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx3QkFBd0IsR0FBRyxLQUFLO0FBQ2hDLE1BQU1HLFFBQVFDLG1CQUFPQSxDQUFDLGdCQUFLO0FBQzNCLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLHNFQUFhO0FBQ3JDLE1BQU1FLFFBQVFGLG1CQUFPQSxDQUFDLGdCQUFLO0FBQzNCLE1BQU1HLHFCQUFxQkgsbUJBQU9BLENBQUMsK0dBQW9CO0FBQ3ZESix3QkFBd0IsR0FBR08sbUJBQW1CQyxPQUFPO0FBQ3JELE1BQU1DLHNCQUFzQkwsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzFELE1BQU1NLFVBQVVOLG1CQUFPQSxDQUFDLGdFQUFhO0FBQ3JDLE1BQU1PLHFCQUFxQlAsbUJBQU9BLENBQUMsK0dBQW9CO0FBQ3ZELE1BQU1RLFFBQVEsQ0FBQyxHQUFHUCxRQUFRUSxLQUFLLEVBQUU7QUFDakMsTUFBTUMsMEJBQTBCTCxvQkFBb0JELE9BQU87SUFDdkRPLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUNBLFFBQVFDLGlCQUFpQjtRQUMvQixJQUFJLENBQUNELE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNFLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDLElBQUksQ0FBQ0gsT0FBTyxDQUFDSSxTQUFTLENBQUNDLE1BQU0sRUFBRTtZQUNoQyxNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDTixPQUFPLENBQUNPLElBQUksRUFBRTtZQUNwQixNQUFNLElBQUlELE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUNFLGdCQUFnQixHQUFHLElBQUlqQixtQkFBbUJDLE9BQU8sQ0FBQyxJQUFJ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d2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2Nvbm5lY3RvcnMvU2VudGluZWxDb25uZWN0b3IvaW5kZXguanM/YTlmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2VudGluZWxJdGVyYXRvciA9IHZvaWQgMDtcbmNvbnN0IG5ldF8xID0gcmVxdWlyZShcIm5ldFwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG5jb25zdCB0bHNfMSA9IHJlcXVpcmUoXCJ0bHNcIik7XG5jb25zdCBTZW50aW5lbEl0ZXJhdG9yXzEgPSByZXF1aXJlKFwiLi9TZW50aW5lbEl0ZXJhdG9yXCIpO1xuZXhwb3J0cy5TZW50aW5lbEl0ZXJhdG9yID0gU2VudGluZWxJdGVyYXRvcl8xLmRlZmF1bHQ7XG5jb25zdCBBYnN0cmFjdENvbm5lY3Rvcl8xID0gcmVxdWlyZShcIi4uL0Fic3RyYWN0Q29ubmVjdG9yXCIpO1xuY29uc3QgUmVkaXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9SZWRpc1wiKTtcbmNvbnN0IEZhaWxvdmVyRGV0ZWN0b3JfMSA9IHJlcXVpcmUoXCIuL0ZhaWxvdmVyRGV0ZWN0b3JcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCB1dGlsc18xLkRlYnVnKShcIlNlbnRpbmVsQ29ubmVjdG9yXCIpO1xuY2xhc3MgU2VudGluZWxDb25uZWN0b3IgZXh0ZW5kcyBBYnN0cmFjdENvbm5lY3Rvcl8xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5kaXNjb25uZWN0VGltZW91dCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuZmFpbG92ZXJEZXRlY3RvciA9IG51bGw7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnNlbnRpbmVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlcXVpcmVzIGF0IGxlYXN0IG9uZSBzZW50aW5lbCB0byBjb25uZWN0IHRvLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXF1aXJlcyB0aGUgbmFtZSBvZiBtYXN0ZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VudGluZWxJdGVyYXRvciA9IG5ldyBTZW50aW5lbEl0ZXJhdG9yXzEuZGVmYXVsdCh0aGlzLm9wdGlvbnMuc2VudGluZWxzKTtcbiAgICB9XG4gICAgY2hlY2soaW5mbykge1xuICAgICAgICBjb25zdCByb2xlTWF0Y2hlcyA9ICFpbmZvLnJvbGUgfHwgdGhpcy5vcHRpb25zLnJvbGUgPT09IGluZm8ucm9sZTtcbiAgICAgICAgaWYgKCFyb2xlTWF0Y2hlcykge1xuICAgICAgICAgICAgZGVidWcoXCJyb2xlIGludmFsaWQsIGV4cGVjdGVkICVzLCBidXQgZ290ICVzXCIsIHRoaXMub3B0aW9ucy5yb2xlLCBpbmZvLnJvbGUpO1xuICAgICAgICAgICAgLy8gU3RhcnQgZnJvbSB0aGUgbmV4dCBpdGVtLlxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IGByZXNldGAgd2lsbCBtb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIHByZXZpb3VzIGVsZW1lbnQsXG4gICAgICAgICAgICAvLyBzbyB3ZSBhZHZhbmNlIHR3byBzdGVwcyBoZXJlLlxuICAgICAgICAgICAgdGhpcy5zZW50aW5lbEl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIHRoaXMuc2VudGluZWxJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICB0aGlzLnNlbnRpbmVsSXRlcmF0b3IucmVzZXQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvbGVNYXRjaGVzO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICBzdXBlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIGlmICh0aGlzLmZhaWxvdmVyRGV0ZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuZmFpbG92ZXJEZXRlY3Rvci5jbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29ubmVjdChldmVudEVtaXR0ZXIpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXRyeUF0dGVtcHRzID0gMDtcbiAgICAgICAgbGV0IGxhc3RFcnJvcjtcbiAgICAgICAgY29uc3QgY29ubmVjdFRvTmV4dCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5zZW50aW5lbEl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChlbmRwb2ludC5kb25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW50aW5lbEl0ZXJhdG9yLnJlc2V0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXRyeURlbGF5ID0gdHlwZW9mIHRoaXMub3B0aW9ucy5zZW50aW5lbFJldHJ5U3RyYXRlZ3kgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMub3B0aW9ucy5zZW50aW5lbFJldHJ5U3RyYXRlZ3koKyt0aGlzLnJldHJ5QXR0ZW1wdHMpXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgZXJyb3JNc2cgPSB0eXBlb2YgcmV0cnlEZWxheSAhPT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgICAgICAgICA/IFwiQWxsIHNlbnRpbmVscyBhcmUgdW5yZWFjaGFibGUgYW5kIHJldHJ5IGlzIGRpc2FibGVkLlwiXG4gICAgICAgICAgICAgICAgICAgIDogYEFsbCBzZW50aW5lbHMgYXJlIHVucmVhY2hhYmxlLiBSZXRyeWluZyBmcm9tIHNjcmF0Y2ggYWZ0ZXIgJHtyZXRyeURlbGF5fW1zLmA7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1zZyArPSBgIExhc3QgZXJyb3I6ICR7bGFzdEVycm9yLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVidWcoZXJyb3JNc2cpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGVycm9yTXNnKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJldHJ5RGVsYXkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRFbWl0dGVyKFwiZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCByZXRyeURlbGF5KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0VG9OZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGVyciA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkID0gYXdhaXQgdGhpcy5yZXNvbHZlKGVuZHBvaW50LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGVyciA9IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbHNfMS5DT05ORUNUSU9OX0NMT1NFRF9FUlJPUl9NU0cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZW5kcG9pbnRBZGRyZXNzID0gZW5kcG9pbnQudmFsdWUuaG9zdCArIFwiOlwiICsgZW5kcG9pbnQudmFsdWUucG9ydDtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwicmVzb2x2ZWQ6ICVzOiVzIGZyb20gc2VudGluZWwgJXNcIiwgcmVzb2x2ZWQuaG9zdCwgcmVzb2x2ZWQucG9ydCwgZW5kcG9pbnRBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZVRMU0ZvclNlbnRpbmVsTW9kZSAmJiB0aGlzLm9wdGlvbnMudGxzKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzb2x2ZWQsIHRoaXMub3B0aW9ucy50bHMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbSA9ICgwLCB0bHNfMS5jb25uZWN0KShyZXNvbHZlZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLm9uY2UoXCJzZWN1cmVDb25uZWN0XCIsIHRoaXMuaW5pdEZhaWxvdmVyRGV0ZWN0b3IuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbSA9ICgwLCBuZXRfMS5jcmVhdGVDb25uZWN0aW9uKShyZXNvbHZlZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLm9uY2UoXCJjb25uZWN0XCIsIHRoaXMuaW5pdEZhaWxvdmVyRGV0ZWN0b3IuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLm9uY2UoXCJlcnJvclwiLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RFcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1zZyA9IGVyclxuICAgICAgICAgICAgICAgICAgICA/IFwiZmFpbGVkIHRvIGNvbm5lY3QgdG8gc2VudGluZWwgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnRBZGRyZXNzICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIGJlY2F1c2UgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgOiBcImNvbm5lY3RlZCB0byBzZW50aW5lbCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludEFkZHJlc3MgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIgc3VjY2Vzc2Z1bGx5LCBidXQgZ290IGFuIGludmFsaWQgcmVwbHk6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkO1xuICAgICAgICAgICAgICAgIGRlYnVnKGVycm9yTXNnKTtcbiAgICAgICAgICAgICAgICBldmVudEVtaXR0ZXIoXCJzZW50aW5lbEVycm9yXCIsIG5ldyBFcnJvcihlcnJvck1zZykpO1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdFRvTmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY29ubmVjdFRvTmV4dCgpO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVTZW50aW5lbHMoY2xpZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnVwZGF0ZVNlbnRpbmVscykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNsaWVudC5zZW50aW5lbChcInNlbnRpbmVsc1wiLCB0aGlzLm9wdGlvbnMubmFtZSk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICAubWFwKHV0aWxzXzEucGFja09iamVjdClcbiAgICAgICAgICAgIC5mb3JFYWNoKChzZW50aW5lbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmxhZ3MgPSBzZW50aW5lbC5mbGFncyA/IHNlbnRpbmVsLmZsYWdzLnNwbGl0KFwiLFwiKSA6IFtdO1xuICAgICAgICAgICAgaWYgKGZsYWdzLmluZGV4T2YoXCJkaXNjb25uZWN0ZWRcIikgPT09IC0xICYmXG4gICAgICAgICAgICAgICAgc2VudGluZWwuaXAgJiZcbiAgICAgICAgICAgICAgICBzZW50aW5lbC5wb3J0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLnNlbnRpbmVsTmF0UmVzb2x2ZShhZGRyZXNzUmVzcG9uc2VUb0FkZHJlc3Moc2VudGluZWwpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZW50aW5lbEl0ZXJhdG9yLmFkZChlbmRwb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJhZGRpbmcgc2VudGluZWwgJXM6JXNcIiwgZW5kcG9pbnQuaG9zdCwgZW5kcG9pbnQucG9ydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZGVidWcoXCJVcGRhdGVkIGludGVybmFsIHNlbnRpbmVsczogJXNcIiwgdGhpcy5zZW50aW5lbEl0ZXJhdG9yKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzb2x2ZU1hc3RlcihjbGllbnQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2xpZW50LnNlbnRpbmVsKFwiZ2V0LW1hc3Rlci1hZGRyLWJ5LW5hbWVcIiwgdGhpcy5vcHRpb25zLm5hbWUpO1xuICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZVNlbnRpbmVscyhjbGllbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZW50aW5lbE5hdFJlc29sdmUoQXJyYXkuaXNBcnJheShyZXN1bHQpXG4gICAgICAgICAgICA/IHsgaG9zdDogcmVzdWx0WzBdLCBwb3J0OiBOdW1iZXIocmVzdWx0WzFdKSB9XG4gICAgICAgICAgICA6IG51bGwpO1xuICAgIH1cbiAgICBhc3luYyByZXNvbHZlU2xhdmUoY2xpZW50KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNsaWVudC5zZW50aW5lbChcInNsYXZlc1wiLCB0aGlzLm9wdGlvbnMubmFtZSk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdmFpbGFibGVTbGF2ZXMgPSByZXN1bHRcbiAgICAgICAgICAgIC5tYXAodXRpbHNfMS5wYWNrT2JqZWN0KVxuICAgICAgICAgICAgLmZpbHRlcigoc2xhdmUpID0+IHNsYXZlLmZsYWdzICYmICFzbGF2ZS5mbGFncy5tYXRjaCgvKGRpc2Nvbm5lY3RlZHxzX2Rvd258b19kb3duKS8pKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VudGluZWxOYXRSZXNvbHZlKHNlbGVjdFByZWZlcnJlZFNlbnRpbmVsKGF2YWlsYWJsZVNsYXZlcywgdGhpcy5vcHRpb25zLnByZWZlcnJlZFNsYXZlcykpO1xuICAgIH1cbiAgICBzZW50aW5lbE5hdFJlc29sdmUoaXRlbSkge1xuICAgICAgICBpZiAoIWl0ZW0gfHwgIXRoaXMub3B0aW9ucy5uYXRNYXApXG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgY29uc3Qga2V5ID0gYCR7aXRlbS5ob3N0fToke2l0ZW0ucG9ydH1gO1xuICAgICAgICBsZXQgcmVzdWx0ID0gaXRlbTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMubmF0TWFwID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMub3B0aW9ucy5uYXRNYXAoa2V5KSB8fCBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMubmF0TWFwID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLm9wdGlvbnMubmF0TWFwW2tleV0gfHwgaXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjb25uZWN0VG9TZW50aW5lbChlbmRwb2ludCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCByZWRpcyA9IG5ldyBSZWRpc18xLmRlZmF1bHQoe1xuICAgICAgICAgICAgcG9ydDogZW5kcG9pbnQucG9ydCB8fCAyNjM3OSxcbiAgICAgICAgICAgIGhvc3Q6IGVuZHBvaW50Lmhvc3QsXG4gICAgICAgICAgICB1c2VybmFtZTogdGhpcy5vcHRpb25zLnNlbnRpbmVsVXNlcm5hbWUgfHwgbnVsbCxcbiAgICAgICAgICAgIHBhc3N3b3JkOiB0aGlzLm9wdGlvbnMuc2VudGluZWxQYXNzd29yZCB8fCBudWxsLFxuICAgICAgICAgICAgZmFtaWx5OiBlbmRwb2ludC5mYW1pbHkgfHxcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgKFwicGF0aFwiIGluIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMucGF0aFxuICAgICAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA6IC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5mYW1pbHkpLFxuICAgICAgICAgICAgdGxzOiB0aGlzLm9wdGlvbnMuc2VudGluZWxUTFMsXG4gICAgICAgICAgICByZXRyeVN0cmF0ZWd5OiBudWxsLFxuICAgICAgICAgICAgZW5hYmxlUmVhZHlDaGVjazogZmFsc2UsXG4gICAgICAgICAgICBjb25uZWN0VGltZW91dDogdGhpcy5vcHRpb25zLmNvbm5lY3RUaW1lb3V0LFxuICAgICAgICAgICAgY29tbWFuZFRpbWVvdXQ6IHRoaXMub3B0aW9ucy5zZW50aW5lbENvbW1hbmRUaW1lb3V0LFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgcmV0dXJuIHJlZGlzO1xuICAgIH1cbiAgICBhc3luYyByZXNvbHZlKGVuZHBvaW50KSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY29ubmVjdFRvU2VudGluZWwoZW5kcG9pbnQpO1xuICAgICAgICAvLyBpZ25vcmUgdGhlIGVycm9ycyBzaW5jZSByZXNvbHZlKiBtZXRob2RzIHdpbGwgaGFuZGxlIHRoZW1cbiAgICAgICAgY2xpZW50Lm9uKFwiZXJyb3JcIiwgbm9vcCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJvbGUgPT09IFwic2xhdmVcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnJlc29sdmVTbGF2ZShjbGllbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucmVzb2x2ZU1hc3RlcihjbGllbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgY2xpZW50LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBpbml0RmFpbG92ZXJEZXRlY3RvcigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5mYWlsb3ZlckRldGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTW92ZSB0aGUgY3VycmVudCBzZW50aW5lbCB0byB0aGUgZmlyc3QgcG9zaXRpb25cbiAgICAgICAgdGhpcy5zZW50aW5lbEl0ZXJhdG9yLnJlc2V0KHRydWUpO1xuICAgICAgICBjb25zdCBzZW50aW5lbHMgPSBbXTtcbiAgICAgICAgLy8gSW4gY2FzZSBvZiBhIGxhcmdlIGFtb3VudCBvZiBzZW50aW5lbHMsIGxpbWl0IHRoZSBudW1iZXIgb2YgY29uY3VycmVudCBjb25uZWN0aW9uc1xuICAgICAgICB3aGlsZSAoc2VudGluZWxzLmxlbmd0aCA8IHRoaXMub3B0aW9ucy5zZW50aW5lbE1heENvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSB0aGlzLnNlbnRpbmVsSXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY29ubmVjdFRvU2VudGluZWwodmFsdWUsIHtcbiAgICAgICAgICAgICAgICBsYXp5Q29ubmVjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICByZXRyeVN0cmF0ZWd5OiB0aGlzLm9wdGlvbnMuc2VudGluZWxSZWNvbm5lY3RTdHJhdGVneSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2xpZW50Lm9uKFwicmVjb25uZWN0aW5nXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgLy8gVGVzdHMgbGlzdGVuIHRvIHRoaXMgZXZlbnRcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmVtaXR0ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbWl0KFwic2VudGluZWxSZWNvbm5lY3RpbmdcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbnRpbmVscy5wdXNoKHsgYWRkcmVzczogdmFsdWUsIGNsaWVudCB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbnRpbmVsSXRlcmF0b3IucmVzZXQoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5mYWlsb3ZlckRldGVjdG9yKSB7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBwcmV2aW91cyBkZXRlY3RvclxuICAgICAgICAgICAgdGhpcy5mYWlsb3ZlckRldGVjdG9yLmNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZhaWxvdmVyRGV0ZWN0b3IgPSBuZXcgRmFpbG92ZXJEZXRlY3Rvcl8xLkZhaWxvdmVyRGV0ZWN0b3IodGhpcywgc2VudGluZWxzKTtcbiAgICAgICAgYXdhaXQgdGhpcy5mYWlsb3ZlckRldGVjdG9yLnN1YnNjcmliZSgpO1xuICAgICAgICAvLyBUZXN0cyBsaXN0ZW4gdG8gdGhpcyBldmVudFxuICAgICAgICAoX2EgPSB0aGlzLmVtaXR0ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbWl0KFwiZmFpbG92ZXJTdWJzY3JpYmVkXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFNlbnRpbmVsQ29ubmVjdG9yO1xuZnVuY3Rpb24gc2VsZWN0UHJlZmVycmVkU2VudGluZWwoYXZhaWxhYmxlU2xhdmVzLCBwcmVmZXJyZWRTbGF2ZXMpIHtcbiAgICBpZiAoYXZhaWxhYmxlU2xhdmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IHNlbGVjdGVkU2xhdmU7XG4gICAgaWYgKHR5cGVvZiBwcmVmZXJyZWRTbGF2ZXMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBzZWxlY3RlZFNsYXZlID0gcHJlZmVycmVkU2xhdmVzKGF2YWlsYWJsZVNsYXZlcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByZWZlcnJlZFNsYXZlcyAhPT0gbnVsbCAmJiB0eXBlb2YgcHJlZmVycmVkU2xhdmVzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNvbnN0IHByZWZlcnJlZFNsYXZlc0FycmF5ID0gQXJyYXkuaXNBcnJheShwcmVmZXJyZWRTbGF2ZXMpXG4gICAgICAgICAgICA/IHByZWZlcnJlZFNsYXZlc1xuICAgICAgICAgICAgOiBbcHJlZmVycmVkU2xhdmVzXTtcbiAgICAgICAgLy8gc29ydCBieSBwcmlvcml0eVxuICAgICAgICBwcmVmZXJyZWRTbGF2ZXNBcnJheS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAvLyBkZWZhdWx0IHRoZSBwcmlvcml0eSB0byAxXG4gICAgICAgICAgICBpZiAoIWEucHJpbykge1xuICAgICAgICAgICAgICAgIGEucHJpbyA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWIucHJpbykge1xuICAgICAgICAgICAgICAgIGIucHJpbyA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsb3dlc3QgcHJpb3JpdHkgZmlyc3RcbiAgICAgICAgICAgIGlmIChhLnByaW8gPCBiLnByaW8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYS5wcmlvID4gYi5wcmlvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGxvb3Agb3ZlciBwcmVmZXJyZWQgc2xhdmVzIGFuZCByZXR1cm4gdGhlIGZpcnN0IG1hdGNoXG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgcHJlZmVycmVkU2xhdmVzQXJyYXkubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGEgPSAwOyBhIDwgYXZhaWxhYmxlU2xhdmVzLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2xhdmUgPSBhdmFpbGFibGVTbGF2ZXNbYV07XG4gICAgICAgICAgICAgICAgaWYgKHNsYXZlLmlwID09PSBwcmVmZXJyZWRTbGF2ZXNBcnJheVtwXS5pcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2xhdmUucG9ydCA9PT0gcHJlZmVycmVkU2xhdmVzQXJyYXlbcF0ucG9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRTbGF2ZSA9IHNsYXZlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRTbGF2ZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGlmIG5vbmUgb2YgdGhlIHByZWZlcnJlZCBzbGF2ZXMgYXJlIGF2YWlsYWJsZSwgYSByYW5kb20gYXZhaWxhYmxlIHNsYXZlIGlzIHJldHVybmVkXG4gICAgaWYgKCFzZWxlY3RlZFNsYXZlKSB7XG4gICAgICAgIHNlbGVjdGVkU2xhdmUgPSAoMCwgdXRpbHNfMS5zYW1wbGUpKGF2YWlsYWJsZVNsYXZlcyk7XG4gICAgfVxuICAgIHJldHVybiBhZGRyZXNzUmVzcG9uc2VUb0FkZHJlc3Moc2VsZWN0ZWRTbGF2ZSk7XG59XG5mdW5jdGlvbiBhZGRyZXNzUmVzcG9uc2VUb0FkZHJlc3MoaW5wdXQpIHtcbiAgICByZXR1cm4geyBob3N0OiBpbnB1dC5pcCwgcG9ydDogTnVtYmVyKGlucHV0LnBvcnQpIH07XG59XG5mdW5jdGlvbiBub29wKCkgeyB9XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTZW50aW5lbEl0ZXJhdG9yIiwibmV0XzEiLCJyZXF1aXJlIiwidXRpbHNfMSIsInRsc18xIiwiU2VudGluZWxJdGVyYXRvcl8xIiwiZGVmYXVsdCIsIkFic3RyYWN0Q29ubmVjdG9yXzEiLCJSZWRpc18xIiwiRmFpbG92ZXJEZXRlY3Rvcl8xIiwiZGVidWciLCJEZWJ1ZyIsIlNlbnRpbmVsQ29ubmVjdG9yIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiZGlzY29ubmVjdFRpbWVvdXQiLCJlbWl0dGVyIiwiZmFpbG92ZXJEZXRlY3RvciIsInNlbnRpbmVscyIsImxlbmd0aCIsIkVycm9yIiwibmFtZSIsInNlbnRpbmVsSXRlcmF0b3IiLCJjaGVjayIsImluZm8iLCJyb2xlTWF0Y2hlcyIsInJvbGUiLCJuZXh0IiwicmVzZXQiLCJkaXNjb25uZWN0IiwiY2xlYW51cCIsImNvbm5lY3QiLCJldmVudEVtaXR0ZXIiLCJjb25uZWN0aW5nIiwicmV0cnlBdHRlbXB0cyIsImxhc3RFcnJvciIsImNvbm5lY3RUb05leHQiLCJlbmRwb2ludCIsImRvbmUiLCJyZXRyeURlbGF5Iiwic2VudGluZWxSZXRyeVN0cmF0ZWd5IiwiZXJyb3JNc2ciLCJtZXNzYWdlIiwiZXJyb3IiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJyZXNvbHZlZCIsImVyciIsIkNPTk5FQ1RJT05fQ0xPU0VEX0VSUk9SX01TRyIsImVuZHBvaW50QWRkcmVzcyIsImhvc3QiLCJwb3J0IiwiZW5hYmxlVExTRm9yU2VudGluZWxNb2RlIiwidGxzIiwiYXNzaWduIiwic3RyZWFtIiwib25jZSIsImluaXRGYWlsb3ZlckRldGVjdG9yIiwiYmluZCIsImNyZWF0ZUNvbm5lY3Rpb24iLCJmaXJzdEVycm9yIiwidXBkYXRlU2VudGluZWxzIiwiY2xpZW50IiwicmVzdWx0Iiwic2VudGluZWwiLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJwYWNrT2JqZWN0IiwiZm9yRWFjaCIsImZsYWdzIiwic3BsaXQiLCJpbmRleE9mIiwiaXAiLCJzZW50aW5lbE5hdFJlc29sdmUiLCJhZGRyZXNzUmVzcG9uc2VUb0FkZHJlc3MiLCJhZGQiLCJyZXNvbHZlTWFzdGVyIiwiTnVtYmVyIiwicmVzb2x2ZVNsYXZlIiwiYXZhaWxhYmxlU2xhdmVzIiwiZmlsdGVyIiwic2xhdmUiLCJtYXRjaCIsInNlbGVjdFByZWZlcnJlZFNlbnRpbmVsIiwicHJlZmVycmVkU2xhdmVzIiwiaXRlbSIsIm5hdE1hcCIsImtleSIsImNvbm5lY3RUb1NlbnRpbmVsIiwicmVkaXMiLCJ1c2VybmFtZSIsInNlbnRpbmVsVXNlcm5hbWUiLCJwYXNzd29yZCIsInNlbnRpbmVsUGFzc3dvcmQiLCJmYW1pbHkiLCJwYXRoIiwidW5kZWZpbmVkIiwic2VudGluZWxUTFMiLCJyZXRyeVN0cmF0ZWd5IiwiZW5hYmxlUmVhZHlDaGVjayIsImNvbm5lY3RUaW1lb3V0IiwiY29tbWFuZFRpbWVvdXQiLCJzZW50aW5lbENvbW1hbmRUaW1lb3V0Iiwib24iLCJub29wIiwiX2EiLCJzZW50aW5lbE1heENvbm5lY3Rpb25zIiwibGF6eUNvbm5lY3QiLCJzZW50aW5lbFJlY29ubmVjdFN0cmF0ZWd5IiwiZW1pdCIsInB1c2giLCJhZGRyZXNzIiwiRmFpbG92ZXJEZXRlY3RvciIsInN1YnNjcmliZSIsInNlbGVjdGVkU2xhdmUiLCJwcmVmZXJyZWRTbGF2ZXNBcnJheSIsInNvcnQiLCJhIiwiYiIsInByaW8iLCJwIiwic2FtcGxlIiwiaW5wdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/connectors/StandaloneConnector.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ioredis/built/connectors/StandaloneConnector.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst AbstractConnector_1 = __webpack_require__(/*! ./AbstractConnector */ \"(rsc)/./node_modules/ioredis/built/connectors/AbstractConnector.js\");\nclass StandaloneConnector extends AbstractConnector_1.default {\n    constructor(options){\n        super(options.disconnectTimeout);\n        this.options = options;\n    }\n    connect(_) {\n        const { options } = this;\n        this.connecting = true;\n        let connectionOptions;\n        if (\"path\" in options && options.path) {\n            connectionOptions = {\n                path: options.path\n            };\n        } else {\n            connectionOptions = {};\n            if (\"port\" in options && options.port != null) {\n                connectionOptions.port = options.port;\n            }\n            if (\"host\" in options && options.host != null) {\n                connectionOptions.host = options.host;\n            }\n            if (\"family\" in options && options.family != null) {\n                connectionOptions.family = options.family;\n            }\n        }\n        if (options.tls) {\n            Object.assign(connectionOptions, options.tls);\n        }\n        // TODO:\n        // We use native Promise here since other Promise\n        // implementation may use different schedulers that\n        // cause issue when the stream is resolved in the\n        // next tick.\n        // Should use the provided promise in the next major\n        // version and do not connect before resolved.\n        return new Promise((resolve, reject)=>{\n            process.nextTick(()=>{\n                if (!this.connecting) {\n                    reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n                    return;\n                }\n                try {\n                    if (options.tls) {\n                        this.stream = (0, tls_1.connect)(connectionOptions);\n                    } else {\n                        this.stream = (0, net_1.createConnection)(connectionOptions);\n                    }\n                } catch (err) {\n                    reject(err);\n                    return;\n                }\n                this.stream.once(\"error\", (err)=>{\n                    this.firstError = err;\n                });\n                resolve(this.stream);\n            });\n        });\n    }\n}\nexports[\"default\"] = StandaloneConnector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jb25uZWN0b3JzL1N0YW5kYWxvbmVDb25uZWN0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsUUFBUUMsbUJBQU9BLENBQUMsZ0JBQUs7QUFDM0IsTUFBTUMsUUFBUUQsbUJBQU9BLENBQUMsZ0JBQUs7QUFDM0IsTUFBTUUsVUFBVUYsbUJBQU9BLENBQUMsbUVBQVU7QUFDbEMsTUFBTUcsc0JBQXNCSCxtQkFBT0EsQ0FBQywrRkFBcUI7QUFDekQsTUFBTUksNEJBQTRCRCxvQkFBb0JFLE9BQU87SUFDekRDLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUNBLFFBQVFDLGlCQUFpQjtRQUMvQixJQUFJLENBQUNELE9BQU8sR0FBR0E7SUFDbkI7SUFDQUUsUUFBUUMsQ0FBQyxFQUFFO1FBQ1AsTUFBTSxFQUFFSCxPQUFPLEVBQUUsR0FBRyxJQUFJO1FBQ3hCLElBQUksQ0FBQ0ksVUFBVSxHQUFHO1FBQ2xCLElBQUlDO1FBQ0osSUFBSSxVQUFVTCxXQUFXQSxRQUFRTSxJQUFJLEVBQUU7WUFDbkNELG9CQUFvQjtnQkFDaEJDLE1BQU1OLFFBQVFNLElBQUk7WUFDdEI7UUFDSixPQUNLO1lBQ0RELG9CQUFvQixDQUFDO1lBQ3JCLElBQUksVUFBVUwsV0FBV0EsUUFBUU8sSUFBSSxJQUFJLE1BQU07Z0JBQzNDRixrQkFBa0JFLElBQUksR0FBR1AsUUFBUU8sSUFBSTtZQUN6QztZQUNBLElBQUksVUFBVVAsV0FBV0EsUUFBUVEsSUFBSSxJQUFJLE1BQU07Z0JBQzNDSCxrQkFBa0JHLElBQUksR0FBR1IsUUFBUVEsSUFBSTtZQUN6QztZQUNBLElBQUksWUFBWVIsV0FBV0EsUUFBUVMsTUFBTSxJQUFJLE1BQU07Z0JBQy9DSixrQkFBa0JJLE1BQU0sR0FBR1QsUUFBUVMsTUFBTTtZQUM3QztRQUNKO1FBQ0EsSUFBSVQsUUFBUVUsR0FBRyxFQUFFO1lBQ2J0QixPQUFPdUIsTUFBTSxDQUFDTixtQkFBbUJMLFFBQVFVLEdBQUc7UUFDaEQ7UUFDQSxRQUFRO1FBQ1IsaURBQWlEO1FBQ2pELG1EQUFtRDtRQUNuRCxpREFBaUQ7UUFDakQsYUFBYTtRQUNiLG9EQUFvRDtRQUNwRCw4Q0FBOEM7UUFDOUMsT0FBTyxJQUFJRSxRQUFRLENBQUNDLFNBQVNDO1lBQ3pCQyxRQUFRQyxRQUFRLENBQUM7Z0JBQ2IsSUFBSSxDQUFDLElBQUksQ0FBQ1osVUFBVSxFQUFFO29CQUNsQlUsT0FBTyxJQUFJRyxNQUFNdEIsUUFBUXVCLDJCQUEyQjtvQkFDcEQ7Z0JBQ0o7Z0JBQ0EsSUFBSTtvQkFDQSxJQUFJbEIsUUFBUVUsR0FBRyxFQUFFO3dCQUNiLElBQUksQ0FBQ1MsTUFBTSxHQUFHLENBQUMsR0FBR3pCLE1BQU1RLE9BQU8sRUFBRUc7b0JBQ3JDLE9BQ0s7d0JBQ0QsSUFBSSxDQUFDYyxNQUFNLEdBQUcsQ0FBQyxHQUFHM0IsTUFBTTRCLGdCQUFnQixFQUFFZjtvQkFDOUM7Z0JBQ0osRUFDQSxPQUFPZ0IsS0FBSztvQkFDUlAsT0FBT087b0JBQ1A7Z0JBQ0o7Z0JBQ0EsSUFBSSxDQUFDRixNQUFNLENBQUNHLElBQUksQ0FBQyxTQUFTLENBQUNEO29CQUN2QixJQUFJLENBQUNFLFVBQVUsR0FBR0Y7Z0JBQ3RCO2dCQUNBUixRQUFRLElBQUksQ0FBQ00sTUFBTTtZQUN2QjtRQUNKO0lBQ0o7QUFDSjtBQUNBN0Isa0JBQWUsR0FBR08iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jb25uZWN0b3JzL1N0YW5kYWxvbmVDb25uZWN0b3IuanM/MGVjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IG5ldF8xID0gcmVxdWlyZShcIm5ldFwiKTtcbmNvbnN0IHRsc18xID0gcmVxdWlyZShcInRsc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBBYnN0cmFjdENvbm5lY3Rvcl8xID0gcmVxdWlyZShcIi4vQWJzdHJhY3RDb25uZWN0b3JcIik7XG5jbGFzcyBTdGFuZGFsb25lQ29ubmVjdG9yIGV4dGVuZHMgQWJzdHJhY3RDb25uZWN0b3JfMS5kZWZhdWx0IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMuZGlzY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBjb25uZWN0KF8pIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmNvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICBsZXQgY29ubmVjdGlvbk9wdGlvbnM7XG4gICAgICAgIGlmIChcInBhdGhcIiBpbiBvcHRpb25zICYmIG9wdGlvbnMucGF0aCkge1xuICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgcGF0aDogb3B0aW9ucy5wYXRoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zID0ge307XG4gICAgICAgICAgICBpZiAoXCJwb3J0XCIgaW4gb3B0aW9ucyAmJiBvcHRpb25zLnBvcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLnBvcnQgPSBvcHRpb25zLnBvcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJob3N0XCIgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmhvc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLmhvc3QgPSBvcHRpb25zLmhvc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJmYW1pbHlcIiBpbiBvcHRpb25zICYmIG9wdGlvbnMuZmFtaWx5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5mYW1pbHkgPSBvcHRpb25zLmZhbWlseTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy50bHMpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY29ubmVjdGlvbk9wdGlvbnMsIG9wdGlvbnMudGxzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOlxuICAgICAgICAvLyBXZSB1c2UgbmF0aXZlIFByb21pc2UgaGVyZSBzaW5jZSBvdGhlciBQcm9taXNlXG4gICAgICAgIC8vIGltcGxlbWVudGF0aW9uIG1heSB1c2UgZGlmZmVyZW50IHNjaGVkdWxlcnMgdGhhdFxuICAgICAgICAvLyBjYXVzZSBpc3N1ZSB3aGVuIHRoZSBzdHJlYW0gaXMgcmVzb2x2ZWQgaW4gdGhlXG4gICAgICAgIC8vIG5leHQgdGljay5cbiAgICAgICAgLy8gU2hvdWxkIHVzZSB0aGUgcHJvdmlkZWQgcHJvbWlzZSBpbiB0aGUgbmV4dCBtYWpvclxuICAgICAgICAvLyB2ZXJzaW9uIGFuZCBkbyBub3QgY29ubmVjdCBiZWZvcmUgcmVzb2x2ZWQuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKHV0aWxzXzEuQ09OTkVDVElPTl9DTE9TRURfRVJST1JfTVNHKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudGxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbSA9ICgwLCB0bHNfMS5jb25uZWN0KShjb25uZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbSA9ICgwLCBuZXRfMS5jcmVhdGVDb25uZWN0aW9uKShjb25uZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5vbmNlKFwiZXJyb3JcIiwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcnN0RXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnN0cmVhbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gU3RhbmRhbG9uZUNvbm5lY3RvcjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm5ldF8xIiwicmVxdWlyZSIsInRsc18xIiwidXRpbHNfMSIsIkFic3RyYWN0Q29ubmVjdG9yXzEiLCJTdGFuZGFsb25lQ29ubmVjdG9yIiwiZGVmYXVsdCIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImRpc2Nvbm5lY3RUaW1lb3V0IiwiY29ubmVjdCIsIl8iLCJjb25uZWN0aW5nIiwiY29ubmVjdGlvbk9wdGlvbnMiLCJwYXRoIiwicG9ydCIsImhvc3QiLCJmYW1pbHkiLCJ0bHMiLCJhc3NpZ24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInByb2Nlc3MiLCJuZXh0VGljayIsIkVycm9yIiwiQ09OTkVDVElPTl9DTE9TRURfRVJST1JfTVNHIiwic3RyZWFtIiwiY3JlYXRlQ29ubmVjdGlvbiIsImVyciIsIm9uY2UiLCJmaXJzdEVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/connectors/StandaloneConnector.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/connectors/index.js":
/*!********************************************************!*\
  !*** ./node_modules/ioredis/built/connectors/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SentinelConnector = exports.StandaloneConnector = void 0;\nconst StandaloneConnector_1 = __webpack_require__(/*! ./StandaloneConnector */ \"(rsc)/./node_modules/ioredis/built/connectors/StandaloneConnector.js\");\nexports.StandaloneConnector = StandaloneConnector_1.default;\nconst SentinelConnector_1 = __webpack_require__(/*! ./SentinelConnector */ \"(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/index.js\");\nexports.SentinelConnector = SentinelConnector_1.default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jb25uZWN0b3JzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx5QkFBeUIsR0FBR0EsMkJBQTJCLEdBQUcsS0FBSztBQUMvRCxNQUFNSSx3QkFBd0JDLG1CQUFPQSxDQUFDLG1HQUF1QjtBQUM3REwsMkJBQTJCLEdBQUdJLHNCQUFzQkUsT0FBTztBQUMzRCxNQUFNQyxzQkFBc0JGLG1CQUFPQSxDQUFDLHFHQUFxQjtBQUN6REwseUJBQXlCLEdBQUdPLG9CQUFvQkQsT0FBTyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2Nvbm5lY3RvcnMvaW5kZXguanM/MDJmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2VudGluZWxDb25uZWN0b3IgPSBleHBvcnRzLlN0YW5kYWxvbmVDb25uZWN0b3IgPSB2b2lkIDA7XG5jb25zdCBTdGFuZGFsb25lQ29ubmVjdG9yXzEgPSByZXF1aXJlKFwiLi9TdGFuZGFsb25lQ29ubmVjdG9yXCIpO1xuZXhwb3J0cy5TdGFuZGFsb25lQ29ubmVjdG9yID0gU3RhbmRhbG9uZUNvbm5lY3Rvcl8xLmRlZmF1bHQ7XG5jb25zdCBTZW50aW5lbENvbm5lY3Rvcl8xID0gcmVxdWlyZShcIi4vU2VudGluZWxDb25uZWN0b3JcIik7XG5leHBvcnRzLlNlbnRpbmVsQ29ubmVjdG9yID0gU2VudGluZWxDb25uZWN0b3JfMS5kZWZhdWx0O1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU2VudGluZWxDb25uZWN0b3IiLCJTdGFuZGFsb25lQ29ubmVjdG9yIiwiU3RhbmRhbG9uZUNvbm5lY3Rvcl8xIiwicmVxdWlyZSIsImRlZmF1bHQiLCJTZW50aW5lbENvbm5lY3Rvcl8xIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/connectors/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/constants/TLSProfiles.js":
/*!*************************************************************!*\
  !*** ./node_modules/ioredis/built/constants/TLSProfiles.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n/**\n * TLS settings for Redis Cloud. Updated on 2022-08-19.\n */ const RedisCloudCA = `-----BEGIN CERTIFICATE-----\nMIIDTzCCAjegAwIBAgIJAKSVpiDswLcwMA0GCSqGSIb3DQEBBQUAMD4xFjAUBgNV\nBAoMDUdhcmFudGlhIERhdGExJDAiBgNVBAMMG1NTTCBDZXJ0aWZpY2F0aW9uIEF1\ndGhvcml0eTAeFw0xMzEwMDExMjE0NTVaFw0yMzA5MjkxMjE0NTVaMD4xFjAUBgNV\nBAoMDUdhcmFudGlhIERhdGExJDAiBgNVBAMMG1NTTCBDZXJ0aWZpY2F0aW9uIEF1\ndGhvcml0eTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALZqkh/DczWP\nJnxnHLQ7QL0T4B4CDKWBKCcisriGbA6ZePWVNo4hfKQC6JrzfR+081NeD6VcWUiz\nrmd+jtPhIY4c+WVQYm5PKaN6DT1imYdxQw7aqO5j2KUCEh/cznpLxeSHoTxlR34E\nQwF28Wl3eg2vc5ct8LjU3eozWVk3gb7alx9mSA2SgmuX5lEQawl++rSjsBStemY2\nBDwOpAMXIrdEyP/cVn8mkvi/BDs5M5G+09j0gfhyCzRWMQ7Hn71u1eolRxwVxgi3\nTMn+/vTaFSqxKjgck6zuAYjBRPaHe7qLxHNr1So/Mc9nPy+3wHebFwbIcnUojwbp\n4nctkWbjb2cCAwEAAaNQME4wHQYDVR0OBBYEFP1whtcrydmW3ZJeuSoKZIKjze3w\nMB8GA1UdIwQYMBaAFP1whtcrydmW3ZJeuSoKZIKjze3wMAwGA1UdEwQFMAMBAf8w\nDQYJKoZIhvcNAQEFBQADggEBAG2erXhwRAa7+ZOBs0B6X57Hwyd1R4kfmXcs0rta\nlbPpvgULSiB+TCbf3EbhJnHGyvdCY1tvlffLjdA7HJ0PCOn+YYLBA0pTU/dyvrN6\nSu8NuS5yubnt9mb13nDGYo1rnt0YRfxN+8DM3fXIVr038A30UlPX2Ou1ExFJT0MZ\nuFKY6ZvLdI6/1cbgmguMlAhM+DhKyV6Sr5699LM3zqeI816pZmlREETYkGr91q7k\nBpXJu/dtHaGxg1ZGu6w/PCsYGUcECWENYD4VQPd8N32JjOfu6vEgoEAwfPP+3oGp\nZ4m3ewACcWOAenqflb+cQYC4PsF7qbXDmRaWrbKntOlZ3n0=\n-----END CERTIFICATE-----\n-----BEGIN CERTIFICATE-----\nMIIGMTCCBBmgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwajELMAkGA1UEBhMCVVMx\nCzAJBgNVBAgMAkNBMQswCQYDVQQHDAJDQTESMBAGA1UECgwJUmVkaXNMYWJzMS0w\nKwYDVQQDDCRSZWRpc0xhYnMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwHhcN\nMTgwMjI1MTUzNzM3WhcNMjgwMjIzMTUzNzM3WjBfMQswCQYDVQQGEwJVUzELMAkG\nA1UECAwCQ0ExEjAQBgNVBAoMCVJlZGlzTGFiczEvMC0GA1UEAwwmUkNQIEludGVy\nbWVkaWF0ZSBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUA\nA4ICDwAwggIKAoICAQDf9dqbxc8Bq7Ctq9rWcxrGNKKHivqLAFpPq02yLPx6fsOv\nTq7GsDChAYBBc4v7Y2Ap9RD5Vs3dIhEANcnolf27QwrG9RMnnvzk8pCvp1o6zSU4\nVuOE1W66/O1/7e2rVxyrnTcP7UgK43zNIXu7+tiAqWsO92uSnuMoGPGpeaUm1jym\nhjWKtkAwDFSqvHY+XL5qDVBEjeUe+WHkYUg40cAXjusAqgm2hZt29c2wnVrxW25W\nP0meNlzHGFdA2AC5z54iRiqj57dTfBTkHoBczQxcyw6hhzxZQ4e5I5zOKjXXEhZN\nr0tA3YC14CTabKRus/JmZieyZzRgEy2oti64tmLYTqSlAD78pRL40VNoaSYetXLw\nhhNsXCHgWaY6d5bLOc/aIQMAV5oLvZQKvuXAF1IDmhPA+bZbpWipp0zagf1P1H3s\nUzsMdn2KM0ejzgotbtNlj5TcrVwpmvE3ktvUAuA+hi3FkVx1US+2Gsp5x4YOzJ7u\nP1WPk6ShF0JgnJH2ILdj6kttTWwFzH17keSFICWDfH/+kM+k7Y1v3EXMQXE7y0T9\nMjvJskz6d/nv+sQhY04xt64xFMGTnZjlJMzfQNi7zWFLTZnDD0lPowq7l3YiPoTT\nt5Xky83lu0KZsZBo0WlWaDG00gLVdtRgVbcuSWxpi5BdLb1kRab66JptWjxwXQID\nAQABo4HrMIHoMDoGA1UdHwQzMDEwL6AtoCuGKWh0dHBzOi8vcmwtY2Etc2VydmVy\nLnJlZGlzbGFicy5jb20vdjEvY3JsMEYGCCsGAQUFBwEBBDowODA2BggrBgEFBQcw\nAYYqaHR0cHM6Ly9ybC1jYS1zZXJ2ZXIucmVkaXNsYWJzLmNvbS92MS9vY3NwMB0G\nA1UdDgQWBBQHar5OKvQUpP2qWt6mckzToeCOHDAfBgNVHSMEGDAWgBQi42wH6hM4\nL2sujEvLM0/u8lRXTzASBgNVHRMBAf8ECDAGAQH/AgEAMA4GA1UdDwEB/wQEAwIB\nhjANBgkqhkiG9w0BAQsFAAOCAgEAirEn/iTsAKyhd+pu2W3Z5NjCko4NPU0EYUbr\nAP7+POK2rzjIrJO3nFYQ/LLuC7KCXG+2qwan2SAOGmqWst13Y+WHp44Kae0kaChW\nvcYLXXSoGQGC8QuFSNUdaeg3RbMDYFT04dOkqufeWVccoHVxyTSg9eD8LZuHn5jw\n7QDLiEECBmIJHk5Eeo2TAZrx4Yx6ufSUX5HeVjlAzqwtAqdt99uCJ/EL8bgpWbe+\nXoSpvUv0SEC1I1dCAhCKAvRlIOA6VBcmzg5Am12KzkqTul12/VEFIgzqu0Zy2Jbc\nAUPrYVu/+tOGXQaijy7YgwH8P8n3s7ZeUa1VABJHcxrxYduDDJBLZi+MjheUDaZ1\njQRHYevI2tlqeSBqdPKG4zBY5lS0GiAlmuze5oENt0P3XboHoZPHiqcK3VECgTVh\n/BkJcuudETSJcZDmQ8YfoKfBzRQNg2sv/hwvUv73Ss51Sco8GEt2lD8uEdib1Q6z\nzDT5lXJowSzOD5ZA9OGDjnSRL+2riNtKWKEqvtEG3VBJoBzu9GoxbAc7wIZLxmli\niF5a/Zf5X+UXD3s4TMmy6C4QZJpAA2egsSQCnraWO2ULhh7iXMysSkF/nzVfZn43\niqpaB8++9a37hWq14ZmOv0TJIDz//b2+KC4VFXWQ5W5QC6whsjT+OlG4p5ZYG0jo\n616pxqo=\n-----END CERTIFICATE-----\n-----BEGIN CERTIFICATE-----\n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\n-----END CERTIFICATE-----\n\n-----BEGIN CERTIFICATE-----\nMIIEjzCCA3egAwIBAgIQe55B/ALCKJDZtdNT8kD6hTANBgkqhkiG9w0BAQsFADBM\nMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEGA1UEChMKR2xv\nYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjAeFw0yMjAxMjYxMjAwMDBaFw0y\nNTAxMjYwMDAwMDBaMFgxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWdu\nIG52LXNhMS4wLAYDVQQDEyVHbG9iYWxTaWduIEF0bGFzIFIzIE9WIFRMUyBDQSAy\nMDIyIFEyMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmGmg1LW9b7Lf\n8zDD83yBDTEkt+FOxKJZqF4veWc5KZsQj9HfnUS2e5nj/E+JImlGPsQuoiosLuXD\nBVBNAMcUFa11buFMGMeEMwiTmCXoXRrXQmH0qjpOfKgYc5gHG3BsRGaRrf7VR4eg\nofNMG9wUBw4/g/TT7+bQJdA4NfE7Y4d5gEryZiBGB/swaX6Jp/8MF4TgUmOWmalK\ndZCKyb4sPGQFRTtElk67F7vU+wdGcrcOx1tDcIB0ncjLPMnaFicagl+daWGsKqTh\ncounQb6QJtYHa91KvCfKWocMxQ7OIbB5UARLPmC4CJ1/f8YFm35ebfzAeULYdGXu\njE9CLor0OwIDAQABo4IBXzCCAVswDgYDVR0PAQH/BAQDAgGGMB0GA1UdJQQWMBQG\nCCsGAQUFBwMBBggrBgEFBQcDAjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQW\nBBSH5Zq7a7B/t95GfJWkDBpA8HHqdjAfBgNVHSMEGDAWgBSP8Et/qC5FJK5NUPpj\nmove4t0bvDB7BggrBgEFBQcBAQRvMG0wLgYIKwYBBQUHMAGGImh0dHA6Ly9vY3Nw\nMi5nbG9iYWxzaWduLmNvbS9yb290cjMwOwYIKwYBBQUHMAKGL2h0dHA6Ly9zZWN1\ncmUuZ2xvYmFsc2lnbi5jb20vY2FjZXJ0L3Jvb3QtcjMuY3J0MDYGA1UdHwQvMC0w\nK6ApoCeGJWh0dHA6Ly9jcmwuZ2xvYmFsc2lnbi5jb20vcm9vdC1yMy5jcmwwIQYD\nVR0gBBowGDAIBgZngQwBAgIwDAYKKwYBBAGgMgoBAjANBgkqhkiG9w0BAQsFAAOC\nAQEAKRic9/f+nmhQU/wz04APZLjgG5OgsuUOyUEZjKVhNGDwxGTvKhyXGGAMW2B/\n3bRi+aElpXwoxu3pL6fkElbX3B0BeS5LoDtxkyiVEBMZ8m+sXbocwlPyxrPbX6mY\n0rVIvnuUeBH8X0L5IwfpNVvKnBIilTbcebfHyXkPezGwz7E1yhUULjJFm2bt0SdX\ny+4X/WeiiYIv+fTVgZZgl+/2MKIsu/qdBJc3f3TvJ8nz+Eax1zgZmww+RSQWeOj3\n15Iw6Z5FX+NwzY/Ab+9PosR5UosSeq+9HhtaxZttXG1nVh+avYPGYddWmiMT90J5\nZgKnO/Fx2hBgTxhOTMYaD312kg==\n-----END CERTIFICATE-----\n\n-----BEGIN CERTIFICATE-----\nMIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\nA1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\nZ24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\nMTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\nA1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\nRgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\ngHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\nKPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\nQQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\nXriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\nDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\nLkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\nRUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\njjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\n6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\nmcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\nMx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\nWD9f\n-----END CERTIFICATE-----`;\nconst TLSProfiles = {\n    RedisCloudFixed: {\n        ca: RedisCloudCA\n    },\n    RedisCloudFlexible: {\n        ca: RedisCloudCA\n    }\n};\nexports[\"default\"] = TLSProfiles;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jb25zdGFudHMvVExTUHJvZmlsZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0Q7O0NBRUMsR0FDRCxNQUFNQyxlQUFlLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5QkEwSUcsQ0FBQztBQUMxQixNQUFNQyxjQUFjO0lBQ2hCQyxpQkFBaUI7UUFBRUMsSUFBSUg7SUFBYTtJQUNwQ0ksb0JBQW9CO1FBQUVELElBQUlIO0lBQWE7QUFDM0M7QUFDQUYsa0JBQWUsR0FBR0ciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jb25zdGFudHMvVExTUHJvZmlsZXMuanM/ODE1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogVExTIHNldHRpbmdzIGZvciBSZWRpcyBDbG91ZC4gVXBkYXRlZCBvbiAyMDIyLTA4LTE5LlxuICovXG5jb25zdCBSZWRpc0Nsb3VkQ0EgPSBgLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tXG5NSUlEVHpDQ0FqZWdBd0lCQWdJSkFLU1ZwaURzd0xjd01BMEdDU3FHU0liM0RRRUJCUVVBTUQ0eEZqQVVCZ05WXG5CQW9NRFVkaGNtRnVkR2xoSUVSaGRHRXhKREFpQmdOVkJBTU1HMU5UVENCRFpYSjBhV1pwWTJGMGFXOXVJRUYxXG5kR2h2Y21sMGVUQWVGdzB4TXpFd01ERXhNakUwTlRWYUZ3MHlNekE1TWpreE1qRTBOVFZhTUQ0eEZqQVVCZ05WXG5CQW9NRFVkaGNtRnVkR2xoSUVSaGRHRXhKREFpQmdOVkJBTU1HMU5UVENCRFpYSjBhV1pwWTJGMGFXOXVJRUYxXG5kR2h2Y21sMGVUQ0NBU0l3RFFZSktvWklodmNOQVFFQkJRQURnZ0VQQURDQ0FRb0NnZ0VCQUxacWtoL0RjeldQXG5KbnhuSExRN1FMMFQ0QjRDREtXQktDY2lzcmlHYkE2WmVQV1ZObzRoZktRQzZKcnpmUiswODFOZUQ2VmNXVWl6XG5ybWQranRQaElZNGMrV1ZRWW01UEthTjZEVDFpbVlkeFF3N2FxTzVqMktVQ0VoL2N6bnBMeGVTSG9UeGxSMzRFXG5Rd0YyOFdsM2VnMnZjNWN0OExqVTNlb3pXVmszZ2I3YWx4OW1TQTJTZ211WDVsRVFhd2wrK3JTanNCU3RlbVkyXG5CRHdPcEFNWElyZEV5UC9jVm44bWt2aS9CRHM1TTVHKzA5ajBnZmh5Q3pSV01RN0huNzF1MWVvbFJ4d1Z4Z2kzXG5UTW4rL3ZUYUZTcXhLamdjazZ6dUFZakJSUGFIZTdxTHhITnIxU28vTWM5blB5KzN3SGViRndiSWNuVW9qd2JwXG40bmN0a1diamIyY0NBd0VBQWFOUU1FNHdIUVlEVlIwT0JCWUVGUDF3aHRjcnlkbVczWkpldVNvS1pJS2p6ZTN3XG5NQjhHQTFVZEl3UVlNQmFBRlAxd2h0Y3J5ZG1XM1pKZXVTb0taSUtqemUzd01Bd0dBMVVkRXdRRk1BTUJBZjh3XG5EUVlKS29aSWh2Y05BUUVGQlFBRGdnRUJBRzJlclhod1JBYTcrWk9CczBCNlg1N0h3eWQxUjRrZm1YY3MwcnRhXG5sYlBwdmdVTFNpQitUQ2JmM0ViaEpuSEd5dmRDWTF0dmxmZkxqZEE3SEowUENPbitZWUxCQTBwVFUvZHl2ck42XG5TdThOdVM1eXVibnQ5bWIxM25ER1lvMXJudDBZUmZ4Tis4RE0zZlhJVnIwMzhBMzBVbFBYMk91MUV4RkpUME1aXG51RktZNlp2TGRJNi8xY2JnbWd1TWxBaE0rRGhLeVY2U3I1Njk5TE0zenFlSTgxNnBabWxSRUVUWWtHcjkxcTdrXG5CcFhKdS9kdEhhR3hnMVpHdTZ3L1BDc1lHVWNFQ1dFTllENFZRUGQ4TjMySmpPZnU2dkVnb0VBd2ZQUCszb0dwXG5aNG0zZXdBQ2NXT0FlbnFmbGIrY1FZQzRQc0Y3cWJYRG1SYVdyYktudE9sWjNuMD1cbi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS1cbi0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLVxuTUlJR01UQ0NCQm1nQXdJQkFnSUNFQUF3RFFZSktvWklodmNOQVFFTEJRQXdhakVMTUFrR0ExVUVCaE1DVlZNeFxuQ3pBSkJnTlZCQWdNQWtOQk1Rc3dDUVlEVlFRSERBSkRRVEVTTUJBR0ExVUVDZ3dKVW1Wa2FYTk1ZV0p6TVMwd1xuS3dZRFZRUUREQ1JTWldScGMweGhZbk1nVW05dmRDQkRaWEowYVdacFkyRjBaU0JCZFhSb2IzSnBkSGt3SGhjTlxuTVRnd01qSTFNVFV6TnpNM1doY05Namd3TWpJek1UVXpOek0zV2pCZk1Rc3dDUVlEVlFRR0V3SlZVekVMTUFrR1xuQTFVRUNBd0NRMEV4RWpBUUJnTlZCQW9NQ1ZKbFpHbHpUR0ZpY3pFdk1DMEdBMVVFQXd3bVVrTlFJRWx1ZEdWeVxuYldWa2FXRjBaU0JEWlhKMGFXWnBZMkYwWlNCQmRYUm9iM0pwZEhrd2dnSWlNQTBHQ1NxR1NJYjNEUUVCQVFVQVxuQTRJQ0R3QXdnZ0lLQW9JQ0FRRGY5ZHFieGM4QnE3Q3RxOXJXY3hyR05LS0hpdnFMQUZwUHEwMnlMUHg2ZnNPdlxuVHE3R3NEQ2hBWUJCYzR2N1kyQXA5UkQ1VnMzZEloRUFOY25vbGYyN1F3ckc5Uk1ubnZ6azhwQ3ZwMW82elNVNFxuVnVPRTFXNjYvTzEvN2UyclZ4eXJuVGNQN1VnSzQzek5JWHU3K3RpQXFXc085MnVTbnVNb0dQR3BlYVVtMWp5bVxuaGpXS3RrQXdERlNxdkhZK1hMNXFEVkJFamVVZStXSGtZVWc0MGNBWGp1c0FxZ20yaFp0MjljMnduVnJ4VzI1V1xuUDBtZU5sekhHRmRBMkFDNXo1NGlSaXFqNTdkVGZCVGtIb0JjelF4Y3l3NmhoenhaUTRlNUk1ek9LalhYRWhaTlxucjB0QTNZQzE0Q1RhYktSdXMvSm1aaWV5WnpSZ0V5Mm90aTY0dG1MWVRxU2xBRDc4cFJMNDBWTm9hU1lldFhMd1xuaGhOc1hDSGdXYVk2ZDViTE9jL2FJUU1BVjVvTHZaUUt2dVhBRjFJRG1oUEErYlpicFdpcHAwemFnZjFQMUgzc1xuVXpzTWRuMktNMGVqemdvdGJ0TmxqNVRjclZ3cG12RTNrdHZVQXVBK2hpM0ZrVngxVVMrMkdzcDV4NFlPeko3dVxuUDFXUGs2U2hGMEpnbkpIMklMZGo2a3R0VFd3RnpIMTdrZVNGSUNXRGZILytrTStrN1kxdjNFWE1RWEU3eTBUOVxuTWp2SnNrejZkL252K3NRaFkwNHh0NjR4Rk1HVG5aamxKTXpmUU5pN3pXRkxUWm5ERDBsUG93cTdsM1lpUG9UVFxudDVYa3k4M2x1MEtac1pCbzBXbFdhREcwMGdMVmR0UmdWYmN1U1d4cGk1QmRMYjFrUmFiNjZKcHRXanh3WFFJRFxuQVFBQm80SHJNSUhvTURvR0ExVWRId1F6TURFd0w2QXRvQ3VHS1doMGRIQnpPaTh2Y213dFkyRXRjMlZ5ZG1WeVxuTG5KbFpHbHpiR0ZpY3k1amIyMHZkakV2WTNKc01FWUdDQ3NHQVFVRkJ3RUJCRG93T0RBMkJnZ3JCZ0VGQlFjd1xuQVlZcWFIUjBjSE02THk5eWJDMWpZUzF6WlhKMlpYSXVjbVZrYVhOc1lXSnpMbU52YlM5Mk1TOXZZM053TUIwR1xuQTFVZERnUVdCQlFIYXI1T0t2UVVwUDJxV3Q2bWNrelRvZUNPSERBZkJnTlZIU01FR0RBV2dCUWk0MndINmhNNFxuTDJzdWpFdkxNMC91OGxSWFR6QVNCZ05WSFJNQkFmOEVDREFHQVFIL0FnRUFNQTRHQTFVZER3RUIvd1FFQXdJQlxuaGpBTkJna3Foa2lHOXcwQkFRc0ZBQU9DQWdFQWlyRW4vaVRzQUt5aGQrcHUyVzNaNU5qQ2tvNE5QVTBFWVViclxuQVA3K1BPSzJyempJckpPM25GWVEvTEx1QzdLQ1hHKzJxd2FuMlNBT0dtcVdzdDEzWStXSHA0NEthZTBrYUNoV1xudmNZTFhYU29HUUdDOFF1RlNOVWRhZWczUmJNRFlGVDA0ZE9rcXVmZVdWY2NvSFZ4eVRTZzllRDhMWnVIbjVqd1xuN1FETGlFRUNCbUlKSGs1RWVvMlRBWnJ4NFl4NnVmU1VYNUhlVmpsQXpxd3RBcWR0OTl1Q0ovRUw4YmdwV2JlK1xuWG9TcHZVdjBTRUMxSTFkQ0FoQ0tBdlJsSU9BNlZCY216ZzVBbTEyS3prcVR1bDEyL1ZFRklnenF1MFp5MkpiY1xuQVVQcllWdS8rdE9HWFFhaWp5N1lnd0g4UDhuM3M3WmVVYTFWQUJKSGN4cnhZZHVEREpCTFppK01qaGVVRGFaMVxualFSSFlldkkydGxxZVNCcWRQS0c0ekJZNWxTMEdpQWxtdXplNW9FTnQwUDNYYm9Ib1pQSGlxY0szVkVDZ1RWaFxuL0JrSmN1dWRFVFNKY1pEbVE4WWZvS2ZCelJRTmcyc3YvaHd2VXY3M1NzNTFTY284R0V0MmxEOHVFZGliMVE2elxuekRUNWxYSm93U3pPRDVaQTlPR0RqblNSTCsycmlOdEtXS0VxdnRFRzNWQkpvQnp1OUdveGJBYzd3SVpMeG1saVxuaUY1YS9aZjVYK1VYRDNzNFRNbXk2QzRRWkpwQUEyZWdzU1FDbnJhV08yVUxoaDdpWE15c1NrRi9uelZmWm40M1xuaXFwYUI4Kys5YTM3aFdxMTRabU92MFRKSUR6Ly9iMitLQzRWRlhXUTVXNVFDNndoc2pUK09sRzRwNVpZRzBqb1xuNjE2cHhxbz1cbi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS1cbi0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLVxuTUlJRnVqQ0NBNktnQXdJQkFnSUpBSjFhVFQxbHUyU2NNQTBHQ1NxR1NJYjNEUUVCQ3dVQU1Hb3hDekFKQmdOVlxuQkFZVEFsVlRNUXN3Q1FZRFZRUUlEQUpEUVRFTE1Ba0dBMVVFQnd3Q1EwRXhFakFRQmdOVkJBb01DVkpsWkdselxuVEdGaWN6RXRNQ3NHQTFVRUF3d2tVbVZrYVhOTVlXSnpJRkp2YjNRZ1EyVnlkR2xtYVdOaGRHVWdRWFYwYUc5eVxuYVhSNU1CNFhEVEU0TURJeU5URTFNakEwTWxvWERUTTRNREl5TURFMU1qQTBNbG93YWpFTE1Ba0dBMVVFQmhNQ1xuVlZNeEN6QUpCZ05WQkFnTUFrTkJNUXN3Q1FZRFZRUUhEQUpEUVRFU01CQUdBMVVFQ2d3SlVtVmthWE5NWVdKelxuTVMwd0t3WURWUVFERENSU1pXUnBjMHhoWW5NZ1VtOXZkQ0JEWlhKMGFXWnBZMkYwWlNCQmRYUm9iM0pwZEhrd1xuZ2dJaU1BMEdDU3FHU0liM0RRRUJBUVVBQTRJQ0R3QXdnZ0lLQW9JQ0FRRExFalh5N1lyYk41V2FhdTVjZDZnMVxuRzVDMnRNbWVUcFowZHVGQVB4TlU0b0UzUkhTNWdHaW9rMzQ2ZlVYdVV4Ylo2UWt1emVOMi8yWitSbVJjSmhRWVxuRG0wWmdkRzR4NTlBbjFUSmZuektLb1dqOElTbW9IUy9UR05CZEZ6WFY3RllOTEJ1cVpvdXFlUEk2UmVDNlFobFxucHA0NWh1VjMyUTNhNklEcnJ2eDdXbzVaY3pFUWVGTmJDZUNPUVlORGRUbUN5RWtIcWMyQUdvOGVvSWxTVHV0VFxuVUxPQzdSNWd6SlZUUzBlMWhlc1E3am1xSGpiTytWUVMxTkFMNC81SzZjdVRFcVVsK1hoVmhQZExXQlhKUTVhZ1xuNTRxaFg0ditvakx6ZVUxUi9WYzZOak12VnRwdFdZNkppaHBncGxwck4wWWgyNTU2ZXdjWE1ldHVyY0tnWGZHSlxueGVZenNqelhlckVqclZvY1g1VjhCTnJnNjRObGlmelRNS05PT3Y0ZlZac3pxMVNJSFI4RjlST3JxaU9kaDhpQ1xuSnBVYkxwWEg5aFdDU0VPNlZSTUIyeEpvS3UzY2dsNjNrRjMwczc3eDd3TEZNRUhpd3NRUkt4b29FMVVoZ1M5S1xuMnNPNFRsUTFlV1V2RnZIU1RWRFFEbEdRNnp1NHFqYk9wYjNROGJRd29LK2FpMmFsa1hWUjRMdHhlOVFsZ1lLM1xuU3RzblBocnV6WkdBMHdiWGRwdzBibk0rWWRsRW01ZmZTVHBOSWZnSGVhYTdEdGI4MDFGdEE3MVpsSDdBNlRhSVxuU0lRdVVTVDlFS212N3hySnl4MFcxcEdvUE9MdzVUMDI5YVRqbklDU0xkdFY5Ykx3eXNyTGhJWUc1Ym5QcTc4QlxuY1MralpIRkd6RDdQVVZHUUQwMW5PUUlEQVFBQm8yTXdZVEFkQmdOVkhRNEVGZ1FVSXVOc0Irb1RPQzlyTG94TFxueXpOUDd2SlVWMDh3SHdZRFZSMGpCQmd3Rm9BVUl1TnNCK29UT0M5ckxveEx5ek5QN3ZKVVYwOHdEd1lEVlIwVFxuQVFIL0JBVXdBd0VCL3pBT0JnTlZIUThCQWY4RUJBTUNBWVl3RFFZSktvWklodmNOQVFFTEJRQURnZ0lCQUhmZ1xuejVwTU5VQUtkTXpLMWFTMUVEZEs5eUt6NHFpY0lMejVjelNMajFtQzdIS0RSeThjVkFEVXhFSUNpcysrQ3NDdVxucllPdnlDVmVyZ0hRTFJFY3hQcTRyYzVOcTF1ajZKNjY0OU5FZWg0V2F6T09qTDRaZlExalZ6bk1iR3krZkptM1xuM0hvZWx2NmpXUkc5aXFlSlpqYTcvMXM2WUM2Yld5bUkvT1kxZTR3VUtlTkhBbytWZ2VyN01sSFYrUnVhYmFYK1xuaFNKOGJKQU01OU5DTTdBZ01UUXBKQ25jcmNkTGVjZVluaUd5NVEvcXQyYjVtSmtRVmtJZHk0VFBHR0IrQVhESlxuRDBxM0kvSkRSa0RVRk5GZGVXMGpzN2ZIZHN2Q1I3TzN0Snk1eklnRVYvby9CQ2ttSlZ0dXdQWU9ydy95T2xLalxuVFkvVTdBVEF4OVZGRjYvdllFT01ZU21yWmxGWCs5OEw2bkp0d0RxZkxCNVZUbHRxWjRIL0tCeEdFM0lSU3Q5bFxuRlh5NDBVK0xuWHpoaFcrN1ZCQXZ5WVg4R0VYaEhrS1U4R3FrMXhpdHJxZkJYWTc0eEtneVVTVG9sRlNmRlZnalxubWNNL1g0SzQ1YmthK3Fwa2o3S2Z2LzhENGo2YVpla3doTjJseTZoaEMxU21ROHFqTWpwRy9tcldPU1NIWkZtZlxueWJ1OWlEMkFZSGVJT2tzaElsNnhZSWErK1EvMDAvdnM0Nkl6QWJReXJpT2kwWHhsU01NVnRQeDBRM2lzcCtqaVxubjhNcTllT3V4WU9FUTRvZjh0d1VrVURkNTI4aXdHdEVkd2YwUTAxVXlUODRTNjJOOEF5U2wxWkJLWEp6Nlc0RlxuVWhXZmEvSFFZT0FQRGRFak5nblZ3TEkyM2I4dDBUb3p5Q1d3N3E4aFxuLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLVxuXG4tLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLS1cbk1JSUVqekNDQTNlZ0F3SUJBZ0lRZTU1Qi9BTENLSkRadGROVDhrRDZoVEFOQmdrcWhraUc5dzBCQVFzRkFEQk1cbk1TQXdIZ1lEVlFRTEV4ZEhiRzlpWVd4VGFXZHVJRkp2YjNRZ1EwRWdMU0JTTXpFVE1CRUdBMVVFQ2hNS1IyeHZcblltRnNVMmxuYmpFVE1CRUdBMVVFQXhNS1IyeHZZbUZzVTJsbmJqQWVGdzB5TWpBeE1qWXhNakF3TURCYUZ3MHlcbk5UQXhNall3TURBd01EQmFNRmd4Q3pBSkJnTlZCQVlUQWtKRk1Sa3dGd1lEVlFRS0V4QkhiRzlpWVd4VGFXZHVcbklHNTJMWE5oTVM0d0xBWURWUVFERXlWSGJHOWlZV3hUYVdkdUlFRjBiR0Z6SUZJeklFOVdJRlJNVXlCRFFTQXlcbk1ESXlJRkV5TUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FROEFNSUlCQ2dLQ0FRRUFtR21nMUxXOWI3TGZcbjh6REQ4M3lCRFRFa3QrRk94S0pacUY0dmVXYzVLWnNRajlIZm5VUzJlNW5qL0UrSkltbEdQc1F1b2lvc0x1WERcbkJWQk5BTWNVRmExMWJ1Rk1HTWVFTXdpVG1DWG9YUnJYUW1IMHFqcE9mS2dZYzVnSEczQnNSR2FScmY3VlI0ZWdcbm9mTk1HOXdVQnc0L2cvVFQ3K2JRSmRBNE5mRTdZNGQ1Z0VyeVppQkdCL3N3YVg2SnAvOE1GNFRnVW1PV21hbEtcbmRaQ0t5YjRzUEdRRlJUdEVsazY3Rjd2VSt3ZEdjcmNPeDF0RGNJQjBuY2pMUE1uYUZpY2FnbCtkYVdHc0txVGhcbmNvdW5RYjZRSnRZSGE5MUt2Q2ZLV29jTXhRN09JYkI1VUFSTFBtQzRDSjEvZjhZRm0zNWViZnpBZVVMWWRHWHVcbmpFOUNMb3IwT3dJREFRQUJvNElCWHpDQ0FWc3dEZ1lEVlIwUEFRSC9CQVFEQWdHR01CMEdBMVVkSlFRV01CUUdcbkNDc0dBUVVGQndNQkJnZ3JCZ0VGQlFjREFqQVNCZ05WSFJNQkFmOEVDREFHQVFIL0FnRUFNQjBHQTFVZERnUVdcbkJCU0g1WnE3YTdCL3Q5NUdmSldrREJwQThISHFkakFmQmdOVkhTTUVHREFXZ0JTUDhFdC9xQzVGSks1TlVQcGpcbm1vdmU0dDBidkRCN0JnZ3JCZ0VGQlFjQkFRUnZNRzB3TGdZSUt3WUJCUVVITUFHR0ltaDBkSEE2THk5dlkzTndcbk1pNW5iRzlpWVd4emFXZHVMbU52YlM5eWIyOTBjak13T3dZSUt3WUJCUVVITUFLR0wyaDBkSEE2THk5elpXTjFcbmNtVXVaMnh2WW1Gc2MybG5iaTVqYjIwdlkyRmpaWEowTDNKdmIzUXRjak11WTNKME1EWUdBMVVkSHdRdk1DMHdcbks2QXBvQ2VHSldoMGRIQTZMeTlqY213dVoyeHZZbUZzYzJsbmJpNWpiMjB2Y205dmRDMXlNeTVqY213d0lRWURcblZSMGdCQm93R0RBSUJnWm5nUXdCQWdJd0RBWUtLd1lCQkFHZ01nb0JBakFOQmdrcWhraUc5dzBCQVFzRkFBT0NcbkFRRUFLUmljOS9mK25taFFVL3d6MDRBUFpMamdHNU9nc3VVT3lVRVpqS1ZoTkdEd3hHVHZLaHlYR0dBTVcyQi9cbjNiUmkrYUVscFh3b3h1M3BMNmZrRWxiWDNCMEJlUzVMb0R0eGt5aVZFQk1aOG0rc1hib2N3bFB5eHJQYlg2bVlcbjByVkl2bnVVZUJIOFgwTDVJd2ZwTlZ2S25CSWlsVGJjZWJmSHlYa1Blekd3ejdFMXloVVVMakpGbTJidDBTZFhcbnkrNFgvV2VpaVlJditmVFZnWlpnbCsvMk1LSXN1L3FkQkpjM2YzVHZKOG56K0VheDF6Z1ptd3crUlNRV2VPajNcbjE1SXc2WjVGWCtOd3pZL0FiKzlQb3NSNVVvc1NlcSs5SGh0YXhadHRYRzFuVmgrYXZZUEdZZGRXbWlNVDkwSjVcblpnS25PL0Z4MmhCZ1R4aE9UTVlhRDMxMmtnPT1cbi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS1cblxuLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tXG5NSUlEWHpDQ0FrZWdBd0lCQWdJTEJBQUFBQUFCSVZoVENLSXdEUVlKS29aSWh2Y05BUUVMQlFBd1RERWdNQjRHXG5BMVVFQ3hNWFIyeHZZbUZzVTJsbmJpQlNiMjkwSUVOQklDMGdVak14RXpBUkJnTlZCQW9UQ2tkc2IySmhiRk5wXG5aMjR4RXpBUkJnTlZCQU1UQ2tkc2IySmhiRk5wWjI0d0hoY05NRGt3TXpFNE1UQXdNREF3V2hjTk1qa3dNekU0XG5NVEF3TURBd1dqQk1NU0F3SGdZRFZRUUxFeGRIYkc5aVlXeFRhV2R1SUZKdmIzUWdRMEVnTFNCU016RVRNQkVHXG5BMVVFQ2hNS1IyeHZZbUZzVTJsbmJqRVRNQkVHQTFVRUF4TUtSMnh2WW1Gc1UybG5iakNDQVNJd0RRWUpLb1pJXG5odmNOQVFFQkJRQURnZ0VQQURDQ0FRb0NnZ0VCQU13bGRwQjVCbmdpRnZYQWc3YUV5aWllL1FWMkVjV3RpSEw4XG5SZ0pEeDdLS25RUmZKTXN1UytGZ2drYmhVcXNNZ1Vkd2JOMWswZXYxTEtNUGdqME1LNjZYMTdZVWhoQjV1enNUXG5nSGVNQ09GSjBtcGlMeDllK3BabzM0a25sVGlmQnRjK3ljc21XUTF6M3JESTZTWU9neFhHNzF1TDBnUmd5a21tXG5LUFpwTy9iTHlDaVI1WjJLWVZjM3JIUVUzSFRnT3U1eUx5NmMrOUM3di9VOUFPRUdNK2lDSzY1VHBqb1djNHpkXG5RUTRnT3NDMHA2SHBzaytRTGpKZzZWZkx1UVNTYUdqbE9DWmdkYktmZC8rUkZPK3VJRW44clVBVlNORUNNV0VaXG5YcmlYNzYxM3QyU2Flcjlmd1JQdm0yTDdEV3pnVkdrV3FRUGFidW1EazNGMnhtbUZnaGNDQXdFQUFhTkNNRUF3XG5EZ1lEVlIwUEFRSC9CQVFEQWdFR01BOEdBMVVkRXdFQi93UUZNQU1CQWY4d0hRWURWUjBPQkJZRUZJL3dTMytvXG5Ma1VrcmsxUSttT2FpOTdpM1J1OE1BMEdDU3FHU0liM0RRRUJDd1VBQTRJQkFRQkxRTnZBVUtyK3lBenY5NVpVXG5SVW03bGdBSlFheXpFNGFHS0Fjenltdm1kTG02QUMydXBBclQ5Zkh4RDRxL2MyZEtnOGRFZTNqZ3IyNXNid01wXG5qak01UmNPTzVMbFhiS3I4RXBic1U4WXQ1Q1JzdVpSais5eFRhR2RXUG9PNHp6VWh3OGxvL3M3YXdsT3F6SkNLXG42ZkJkUm95VjNYcFlLQm92SGQ3TkFEZEJqKzFFYmRkVEtKZCs4MmNFSGhYWGlwYTAwOTVNSjZSTUczTnpkdlFYXG5tY0lmZWc3akxRaXRDaHdzL3p5clZRNFBrWDQyNjhOWFNiN2hMaTE4WUl2RFFWRVRJNTNPOXpKcmxBR29tZWNzXG5NeDg2T3lYU2hrRE9PeXlHZU1saEx4UzY3dHRWYjkrRTdnVUpUYjBvMkhMTzAySlFaUjdya3BlRE1kbXp0Y3BIXG5XRDlmXG4tLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tYDtcbmNvbnN0IFRMU1Byb2ZpbGVzID0ge1xuICAgIFJlZGlzQ2xvdWRGaXhlZDogeyBjYTogUmVkaXNDbG91ZENBIH0sXG4gICAgUmVkaXNDbG91ZEZsZXhpYmxlOiB7IGNhOiBSZWRpc0Nsb3VkQ0EgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBUTFNQcm9maWxlcztcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlJlZGlzQ2xvdWRDQSIsIlRMU1Byb2ZpbGVzIiwiUmVkaXNDbG91ZEZpeGVkIiwiY2EiLCJSZWRpc0Nsb3VkRmxleGlibGUiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/constants/TLSProfiles.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/errors/ClusterAllFailedError.js":
/*!********************************************************************!*\
  !*** ./node_modules/ioredis/built/errors/ClusterAllFailedError.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst redis_errors_1 = __webpack_require__(/*! redis-errors */ \"(rsc)/./node_modules/redis-errors/index.js\");\nclass ClusterAllFailedError extends redis_errors_1.RedisError {\n    constructor(message, lastNodeError){\n        super(message);\n        this.lastNodeError = lastNodeError;\n        Error.captureStackTrace(this, this.constructor);\n    }\n    get name() {\n        return this.constructor.name;\n    }\n}\nexports[\"default\"] = ClusterAllFailedError;\nClusterAllFailedError.defaultMessage = \"Failed to refresh slots cache.\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9lcnJvcnMvQ2x1c3RlckFsbEZhaWxlZEVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLGlCQUFpQkMsbUJBQU9BLENBQUMsZ0VBQWM7QUFDN0MsTUFBTUMsOEJBQThCRixlQUFlRyxVQUFVO0lBQ3pEQyxZQUFZQyxPQUFPLEVBQUVDLGFBQWEsQ0FBRTtRQUNoQyxLQUFLLENBQUNEO1FBQ04sSUFBSSxDQUFDQyxhQUFhLEdBQUdBO1FBQ3JCQyxNQUFNQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDSixXQUFXO0lBQ2xEO0lBQ0EsSUFBSUssT0FBTztRQUNQLE9BQU8sSUFBSSxDQUFDTCxXQUFXLENBQUNLLElBQUk7SUFDaEM7QUFDSjtBQUNBWCxrQkFBZSxHQUFHSTtBQUNsQkEsc0JBQXNCUyxjQUFjLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9lcnJvcnMvQ2x1c3RlckFsbEZhaWxlZEVycm9yLmpzPzExYzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByZWRpc19lcnJvcnNfMSA9IHJlcXVpcmUoXCJyZWRpcy1lcnJvcnNcIik7XG5jbGFzcyBDbHVzdGVyQWxsRmFpbGVkRXJyb3IgZXh0ZW5kcyByZWRpc19lcnJvcnNfMS5SZWRpc0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBsYXN0Tm9kZUVycm9yKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmxhc3ROb2RlRXJyb3IgPSBsYXN0Tm9kZUVycm9yO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ2x1c3RlckFsbEZhaWxlZEVycm9yO1xuQ2x1c3RlckFsbEZhaWxlZEVycm9yLmRlZmF1bHRNZXNzYWdlID0gXCJGYWlsZWQgdG8gcmVmcmVzaCBzbG90cyBjYWNoZS5cIjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJlZGlzX2Vycm9yc18xIiwicmVxdWlyZSIsIkNsdXN0ZXJBbGxGYWlsZWRFcnJvciIsIlJlZGlzRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJsYXN0Tm9kZUVycm9yIiwiRXJyb3IiLCJjYXB0dXJlU3RhY2tUcmFjZSIsIm5hbWUiLCJkZWZhdWx0IiwiZGVmYXVsdE1lc3NhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/errors/ClusterAllFailedError.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/errors/MaxRetriesPerRequestError.js":
/*!************************************************************************!*\
  !*** ./node_modules/ioredis/built/errors/MaxRetriesPerRequestError.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst redis_errors_1 = __webpack_require__(/*! redis-errors */ \"(rsc)/./node_modules/redis-errors/index.js\");\nclass MaxRetriesPerRequestError extends redis_errors_1.AbortError {\n    constructor(maxRetriesPerRequest){\n        const message = `Reached the max retries per request limit (which is ${maxRetriesPerRequest}). Refer to \"maxRetriesPerRequest\" option for details.`;\n        super(message);\n        Error.captureStackTrace(this, this.constructor);\n    }\n    get name() {\n        return this.constructor.name;\n    }\n}\nexports[\"default\"] = MaxRetriesPerRequestError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9lcnJvcnMvTWF4UmV0cmllc1BlclJlcXVlc3RFcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyxpQkFBaUJDLG1CQUFPQSxDQUFDLGdFQUFjO0FBQzdDLE1BQU1DLGtDQUFrQ0YsZUFBZUcsVUFBVTtJQUM3REMsWUFBWUMsb0JBQW9CLENBQUU7UUFDOUIsTUFBTUMsVUFBVSxDQUFDLG9EQUFvRCxFQUFFRCxxQkFBcUIsc0RBQXNELENBQUM7UUFDbkosS0FBSyxDQUFDQztRQUNOQyxNQUFNQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDSixXQUFXO0lBQ2xEO0lBQ0EsSUFBSUssT0FBTztRQUNQLE9BQU8sSUFBSSxDQUFDTCxXQUFXLENBQUNLLElBQUk7SUFDaEM7QUFDSjtBQUNBWCxrQkFBZSxHQUFHSSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2Vycm9ycy9NYXhSZXRyaWVzUGVyUmVxdWVzdEVycm9yLmpzP2EyNTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByZWRpc19lcnJvcnNfMSA9IHJlcXVpcmUoXCJyZWRpcy1lcnJvcnNcIik7XG5jbGFzcyBNYXhSZXRyaWVzUGVyUmVxdWVzdEVycm9yIGV4dGVuZHMgcmVkaXNfZXJyb3JzXzEuQWJvcnRFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWF4UmV0cmllc1BlclJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBSZWFjaGVkIHRoZSBtYXggcmV0cmllcyBwZXIgcmVxdWVzdCBsaW1pdCAod2hpY2ggaXMgJHttYXhSZXRyaWVzUGVyUmVxdWVzdH0pLiBSZWZlciB0byBcIm1heFJldHJpZXNQZXJSZXF1ZXN0XCIgb3B0aW9uIGZvciBkZXRhaWxzLmA7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gTWF4UmV0cmllc1BlclJlcXVlc3RFcnJvcjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJlZGlzX2Vycm9yc18xIiwicmVxdWlyZSIsIk1heFJldHJpZXNQZXJSZXF1ZXN0RXJyb3IiLCJBYm9ydEVycm9yIiwiY29uc3RydWN0b3IiLCJtYXhSZXRyaWVzUGVyUmVxdWVzdCIsIm1lc3NhZ2UiLCJFcnJvciIsImNhcHR1cmVTdGFja1RyYWNlIiwibmFtZSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/errors/MaxRetriesPerRequestError.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/errors/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ioredis/built/errors/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.MaxRetriesPerRequestError = void 0;\nconst MaxRetriesPerRequestError_1 = __webpack_require__(/*! ./MaxRetriesPerRequestError */ \"(rsc)/./node_modules/ioredis/built/errors/MaxRetriesPerRequestError.js\");\nexports.MaxRetriesPerRequestError = MaxRetriesPerRequestError_1.default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9lcnJvcnMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGlDQUFpQyxHQUFHLEtBQUs7QUFDekMsTUFBTUcsOEJBQThCQyxtQkFBT0EsQ0FBQywyR0FBNkI7QUFDekVKLGlDQUFpQyxHQUFHRyw0QkFBNEJFLE9BQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9lcnJvcnMvaW5kZXguanM/M2RjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWF4UmV0cmllc1BlclJlcXVlc3RFcnJvciA9IHZvaWQgMDtcbmNvbnN0IE1heFJldHJpZXNQZXJSZXF1ZXN0RXJyb3JfMSA9IHJlcXVpcmUoXCIuL01heFJldHJpZXNQZXJSZXF1ZXN0RXJyb3JcIik7XG5leHBvcnRzLk1heFJldHJpZXNQZXJSZXF1ZXN0RXJyb3IgPSBNYXhSZXRyaWVzUGVyUmVxdWVzdEVycm9yXzEuZGVmYXVsdDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIk1heFJldHJpZXNQZXJSZXF1ZXN0RXJyb3IiLCJNYXhSZXRyaWVzUGVyUmVxdWVzdEVycm9yXzEiLCJyZXF1aXJlIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/errors/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/index.js":
/*!*********************************************!*\
  !*** ./node_modules/ioredis/built/index.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.print = exports.ReplyError = exports.SentinelIterator = exports.SentinelConnector = exports.AbstractConnector = exports.Pipeline = exports.ScanStream = exports.Command = exports.Cluster = exports.Redis = exports[\"default\"] = void 0;\nexports = module.exports = __webpack_require__(/*! ./Redis */ \"(rsc)/./node_modules/ioredis/built/Redis.js\")[\"default\"];\nvar Redis_1 = __webpack_require__(/*! ./Redis */ \"(rsc)/./node_modules/ioredis/built/Redis.js\");\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return Redis_1.default;\n    }\n}));\nvar Redis_2 = __webpack_require__(/*! ./Redis */ \"(rsc)/./node_modules/ioredis/built/Redis.js\");\nObject.defineProperty(exports, \"Redis\", ({\n    enumerable: true,\n    get: function() {\n        return Redis_2.default;\n    }\n}));\nvar cluster_1 = __webpack_require__(/*! ./cluster */ \"(rsc)/./node_modules/ioredis/built/cluster/index.js\");\nObject.defineProperty(exports, \"Cluster\", ({\n    enumerable: true,\n    get: function() {\n        return cluster_1.default;\n    }\n}));\n/**\n * @ignore\n */ var Command_1 = __webpack_require__(/*! ./Command */ \"(rsc)/./node_modules/ioredis/built/Command.js\");\nObject.defineProperty(exports, \"Command\", ({\n    enumerable: true,\n    get: function() {\n        return Command_1.default;\n    }\n}));\n/**\n * @ignore\n */ var ScanStream_1 = __webpack_require__(/*! ./ScanStream */ \"(rsc)/./node_modules/ioredis/built/ScanStream.js\");\nObject.defineProperty(exports, \"ScanStream\", ({\n    enumerable: true,\n    get: function() {\n        return ScanStream_1.default;\n    }\n}));\n/**\n * @ignore\n */ var Pipeline_1 = __webpack_require__(/*! ./Pipeline */ \"(rsc)/./node_modules/ioredis/built/Pipeline.js\");\nObject.defineProperty(exports, \"Pipeline\", ({\n    enumerable: true,\n    get: function() {\n        return Pipeline_1.default;\n    }\n}));\n/**\n * @ignore\n */ var AbstractConnector_1 = __webpack_require__(/*! ./connectors/AbstractConnector */ \"(rsc)/./node_modules/ioredis/built/connectors/AbstractConnector.js\");\nObject.defineProperty(exports, \"AbstractConnector\", ({\n    enumerable: true,\n    get: function() {\n        return AbstractConnector_1.default;\n    }\n}));\n/**\n * @ignore\n */ var SentinelConnector_1 = __webpack_require__(/*! ./connectors/SentinelConnector */ \"(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/index.js\");\nObject.defineProperty(exports, \"SentinelConnector\", ({\n    enumerable: true,\n    get: function() {\n        return SentinelConnector_1.default;\n    }\n}));\nObject.defineProperty(exports, \"SentinelIterator\", ({\n    enumerable: true,\n    get: function() {\n        return SentinelConnector_1.SentinelIterator;\n    }\n}));\n// No TS typings\nexports.ReplyError = __webpack_require__(/*! redis-errors */ \"(rsc)/./node_modules/redis-errors/index.js\").ReplyError;\n/**\n * @ignore\n */ Object.defineProperty(exports, \"Promise\", ({\n    get () {\n        console.warn(\"ioredis v5 does not support plugging third-party Promise library anymore. Native Promise will be used.\");\n        return Promise;\n    },\n    set (_lib) {\n        console.warn(\"ioredis v5 does not support plugging third-party Promise library anymore. Native Promise will be used.\");\n    }\n}));\n/**\n * @ignore\n */ function print(err, reply) {\n    if (err) {\n        console.log(\"Error: \" + err);\n    } else {\n        console.log(\"Reply: \" + reply);\n    }\n}\nexports.print = print;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsYUFBYSxHQUFHQSxrQkFBa0IsR0FBR0Esd0JBQXdCLEdBQUdBLHlCQUF5QixHQUFHQSx5QkFBeUIsR0FBR0EsZ0JBQWdCLEdBQUdBLGtCQUFrQixHQUFHQSxlQUFlLEdBQUdBLGVBQWUsR0FBR0EsYUFBYSxHQUFHQSxrQkFBZSxHQUFHLEtBQUs7QUFDM09BLFVBQVVhLDZHQUEyQztBQUNyRCxJQUFJRSxVQUFVRCxtQkFBT0EsQ0FBQyw0REFBUztBQUMvQmhCLDJDQUEwQztJQUFFa0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0YsUUFBUUgsT0FBTztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzdHLElBQUlNLFVBQVVKLG1CQUFPQSxDQUFDLDREQUFTO0FBQy9CaEIseUNBQXdDO0lBQUVrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPQyxRQUFRTixPQUFPO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDM0csSUFBSU8sWUFBWUwsbUJBQU9BLENBQUMsc0VBQVc7QUFDbkNoQiwyQ0FBMEM7SUFBRWtCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9FLFVBQVVQLE9BQU87SUFBRTtBQUFFLENBQUMsRUFBQztBQUMvRzs7Q0FFQyxHQUNELElBQUlRLFlBQVlOLG1CQUFPQSxDQUFDLGdFQUFXO0FBQ25DaEIsMkNBQTBDO0lBQUVrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRyxVQUFVUixPQUFPO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDL0c7O0NBRUMsR0FDRCxJQUFJUyxlQUFlUCxtQkFBT0EsQ0FBQyxzRUFBYztBQUN6Q2hCLDhDQUE2QztJQUFFa0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0ksYUFBYVQsT0FBTztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3JIOztDQUVDLEdBQ0QsSUFBSVUsYUFBYVIsbUJBQU9BLENBQUMsa0VBQVk7QUFDckNoQiw0Q0FBMkM7SUFBRWtCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9LLFdBQVdWLE9BQU87SUFBRTtBQUFFLENBQUMsRUFBQztBQUNqSDs7Q0FFQyxHQUNELElBQUlXLHNCQUFzQlQsbUJBQU9BLENBQUMsMEdBQWdDO0FBQ2xFaEIscURBQW9EO0lBQUVrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPTSxvQkFBb0JYLE9BQU87SUFBRTtBQUFFLENBQUMsRUFBQztBQUNuSTs7Q0FFQyxHQUNELElBQUlZLHNCQUFzQlYsbUJBQU9BLENBQUMsZ0hBQWdDO0FBQ2xFaEIscURBQW9EO0lBQUVrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPTyxvQkFBb0JaLE9BQU87SUFBRTtBQUFFLENBQUMsRUFBQztBQUNuSWQsb0RBQW1EO0lBQUVrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPTyxvQkFBb0JwQixnQkFBZ0I7SUFBRTtBQUFFLENBQUMsRUFBQztBQUMzSSxnQkFBZ0I7QUFDaEJKLHFIQUF1RDtBQUN2RDs7Q0FFQyxHQUNERiwyQ0FBMEM7SUFDdENtQjtRQUNJUSxRQUFRQyxJQUFJLENBQUM7UUFDYixPQUFPQztJQUNYO0lBQ0FDLEtBQUlDLElBQUk7UUFDSkosUUFBUUMsSUFBSSxDQUFDO0lBQ2pCO0FBQ0osQ0FBQyxFQUFDO0FBQ0Y7O0NBRUMsR0FDRCxTQUFTeEIsTUFBTTRCLEdBQUcsRUFBRUMsS0FBSztJQUNyQixJQUFJRCxLQUFLO1FBQ0xMLFFBQVFPLEdBQUcsQ0FBQyxZQUFZRjtJQUM1QixPQUNLO1FBQ0RMLFFBQVFPLEdBQUcsQ0FBQyxZQUFZRDtJQUM1QjtBQUNKO0FBQ0EvQixhQUFhLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvaW5kZXguanM/MWUxNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucHJpbnQgPSBleHBvcnRzLlJlcGx5RXJyb3IgPSBleHBvcnRzLlNlbnRpbmVsSXRlcmF0b3IgPSBleHBvcnRzLlNlbnRpbmVsQ29ubmVjdG9yID0gZXhwb3J0cy5BYnN0cmFjdENvbm5lY3RvciA9IGV4cG9ydHMuUGlwZWxpbmUgPSBleHBvcnRzLlNjYW5TdHJlYW0gPSBleHBvcnRzLkNvbW1hbmQgPSBleHBvcnRzLkNsdXN0ZXIgPSBleHBvcnRzLlJlZGlzID0gZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vUmVkaXNcIikuZGVmYXVsdDtcbnZhciBSZWRpc18xID0gcmVxdWlyZShcIi4vUmVkaXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBSZWRpc18xLmRlZmF1bHQ7IH0gfSk7XG52YXIgUmVkaXNfMiA9IHJlcXVpcmUoXCIuL1JlZGlzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVkaXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJlZGlzXzIuZGVmYXVsdDsgfSB9KTtcbnZhciBjbHVzdGVyXzEgPSByZXF1aXJlKFwiLi9jbHVzdGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2x1c3RlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2x1c3Rlcl8xLmRlZmF1bHQ7IH0gfSk7XG4vKipcbiAqIEBpZ25vcmVcbiAqL1xudmFyIENvbW1hbmRfMSA9IHJlcXVpcmUoXCIuL0NvbW1hbmRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb21tYW5kXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDb21tYW5kXzEuZGVmYXVsdDsgfSB9KTtcbi8qKlxuICogQGlnbm9yZVxuICovXG52YXIgU2NhblN0cmVhbV8xID0gcmVxdWlyZShcIi4vU2NhblN0cmVhbVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNjYW5TdHJlYW1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFNjYW5TdHJlYW1fMS5kZWZhdWx0OyB9IH0pO1xuLyoqXG4gKiBAaWdub3JlXG4gKi9cbnZhciBQaXBlbGluZV8xID0gcmVxdWlyZShcIi4vUGlwZWxpbmVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQaXBlbGluZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUGlwZWxpbmVfMS5kZWZhdWx0OyB9IH0pO1xuLyoqXG4gKiBAaWdub3JlXG4gKi9cbnZhciBBYnN0cmFjdENvbm5lY3Rvcl8xID0gcmVxdWlyZShcIi4vY29ubmVjdG9ycy9BYnN0cmFjdENvbm5lY3RvclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFic3RyYWN0Q29ubmVjdG9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBBYnN0cmFjdENvbm5lY3Rvcl8xLmRlZmF1bHQ7IH0gfSk7XG4vKipcbiAqIEBpZ25vcmVcbiAqL1xudmFyIFNlbnRpbmVsQ29ubmVjdG9yXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0b3JzL1NlbnRpbmVsQ29ubmVjdG9yXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VudGluZWxDb25uZWN0b3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFNlbnRpbmVsQ29ubmVjdG9yXzEuZGVmYXVsdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlbnRpbmVsSXRlcmF0b3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFNlbnRpbmVsQ29ubmVjdG9yXzEuU2VudGluZWxJdGVyYXRvcjsgfSB9KTtcbi8vIE5vIFRTIHR5cGluZ3NcbmV4cG9ydHMuUmVwbHlFcnJvciA9IHJlcXVpcmUoXCJyZWRpcy1lcnJvcnNcIikuUmVwbHlFcnJvcjtcbi8qKlxuICogQGlnbm9yZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQcm9taXNlXCIsIHtcbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcImlvcmVkaXMgdjUgZG9lcyBub3Qgc3VwcG9ydCBwbHVnZ2luZyB0aGlyZC1wYXJ0eSBQcm9taXNlIGxpYnJhcnkgYW55bW9yZS4gTmF0aXZlIFByb21pc2Ugd2lsbCBiZSB1c2VkLlwiKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2U7XG4gICAgfSxcbiAgICBzZXQoX2xpYikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJpb3JlZGlzIHY1IGRvZXMgbm90IHN1cHBvcnQgcGx1Z2dpbmcgdGhpcmQtcGFydHkgUHJvbWlzZSBsaWJyYXJ5IGFueW1vcmUuIE5hdGl2ZSBQcm9taXNlIHdpbGwgYmUgdXNlZC5cIik7XG4gICAgfSxcbn0pO1xuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIHByaW50KGVyciwgcmVwbHkpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3I6IFwiICsgZXJyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiUmVwbHk6IFwiICsgcmVwbHkpO1xuICAgIH1cbn1cbmV4cG9ydHMucHJpbnQgPSBwcmludDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInByaW50IiwiUmVwbHlFcnJvciIsIlNlbnRpbmVsSXRlcmF0b3IiLCJTZW50aW5lbENvbm5lY3RvciIsIkFic3RyYWN0Q29ubmVjdG9yIiwiUGlwZWxpbmUiLCJTY2FuU3RyZWFtIiwiQ29tbWFuZCIsIkNsdXN0ZXIiLCJSZWRpcyIsImRlZmF1bHQiLCJtb2R1bGUiLCJyZXF1aXJlIiwiUmVkaXNfMSIsImVudW1lcmFibGUiLCJnZXQiLCJSZWRpc18yIiwiY2x1c3Rlcl8xIiwiQ29tbWFuZF8xIiwiU2NhblN0cmVhbV8xIiwiUGlwZWxpbmVfMSIsIkFic3RyYWN0Q29ubmVjdG9yXzEiLCJTZW50aW5lbENvbm5lY3Rvcl8xIiwiY29uc29sZSIsIndhcm4iLCJQcm9taXNlIiwic2V0IiwiX2xpYiIsImVyciIsInJlcGx5IiwibG9nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/redis/RedisOptions.js":
/*!**********************************************************!*\
  !*** ./node_modules/ioredis/built/redis/RedisOptions.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DEFAULT_REDIS_OPTIONS = void 0;\nexports.DEFAULT_REDIS_OPTIONS = {\n    // Connection\n    port: 6379,\n    host: \"localhost\",\n    family: 4,\n    connectTimeout: 10000,\n    disconnectTimeout: 2000,\n    retryStrategy: function(times) {\n        return Math.min(times * 50, 2000);\n    },\n    keepAlive: 0,\n    noDelay: true,\n    connectionName: null,\n    // Sentinel\n    sentinels: null,\n    name: null,\n    role: \"master\",\n    sentinelRetryStrategy: function(times) {\n        return Math.min(times * 10, 1000);\n    },\n    sentinelReconnectStrategy: function() {\n        // This strategy only applies when sentinels are used for detecting\n        // a failover, not during initial master resolution.\n        // The deployment can still function when some of the sentinels are down\n        // for a long period of time, so we may not want to attempt reconnection\n        // very often. Therefore the default interval is fairly long (1 minute).\n        return 60000;\n    },\n    natMap: null,\n    enableTLSForSentinelMode: false,\n    updateSentinels: true,\n    failoverDetector: false,\n    // Status\n    username: null,\n    password: null,\n    db: 0,\n    // Others\n    enableOfflineQueue: true,\n    enableReadyCheck: true,\n    autoResubscribe: true,\n    autoResendUnfulfilledCommands: true,\n    lazyConnect: false,\n    keyPrefix: \"\",\n    reconnectOnError: null,\n    readOnly: false,\n    stringNumbers: false,\n    maxRetriesPerRequest: 20,\n    maxLoadingRetryTime: 10000,\n    enableAutoPipelining: false,\n    autoPipeliningIgnoredCommands: [],\n    sentinelMaxConnections: 10\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9yZWRpcy9SZWRpc09wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHLEtBQUs7QUFDckNBLDZCQUE2QixHQUFHO0lBQzVCLGFBQWE7SUFDYkcsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLFFBQVE7SUFDUkMsZ0JBQWdCO0lBQ2hCQyxtQkFBbUI7SUFDbkJDLGVBQWUsU0FBVUMsS0FBSztRQUMxQixPQUFPQyxLQUFLQyxHQUFHLENBQUNGLFFBQVEsSUFBSTtJQUNoQztJQUNBRyxXQUFXO0lBQ1hDLFNBQVM7SUFDVEMsZ0JBQWdCO0lBQ2hCLFdBQVc7SUFDWEMsV0FBVztJQUNYQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsdUJBQXVCLFNBQVVULEtBQUs7UUFDbEMsT0FBT0MsS0FBS0MsR0FBRyxDQUFDRixRQUFRLElBQUk7SUFDaEM7SUFDQVUsMkJBQTJCO1FBQ3ZCLG1FQUFtRTtRQUNuRSxvREFBb0Q7UUFDcEQsd0VBQXdFO1FBQ3hFLHdFQUF3RTtRQUN4RSx3RUFBd0U7UUFDeEUsT0FBTztJQUNYO0lBQ0FDLFFBQVE7SUFDUkMsMEJBQTBCO0lBQzFCQyxpQkFBaUI7SUFDakJDLGtCQUFrQjtJQUNsQixTQUFTO0lBQ1RDLFVBQVU7SUFDVkMsVUFBVTtJQUNWQyxJQUFJO0lBQ0osU0FBUztJQUNUQyxvQkFBb0I7SUFDcEJDLGtCQUFrQjtJQUNsQkMsaUJBQWlCO0lBQ2pCQywrQkFBK0I7SUFDL0JDLGFBQWE7SUFDYkMsV0FBVztJQUNYQyxrQkFBa0I7SUFDbEJDLFVBQVU7SUFDVkMsZUFBZTtJQUNmQyxzQkFBc0I7SUFDdEJDLHFCQUFxQjtJQUNyQkMsc0JBQXNCO0lBQ3RCQywrQkFBK0IsRUFBRTtJQUNqQ0Msd0JBQXdCO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvcmVkaXMvUmVkaXNPcHRpb25zLmpzPzMzY2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRFRkFVTFRfUkVESVNfT1BUSU9OUyA9IHZvaWQgMDtcbmV4cG9ydHMuREVGQVVMVF9SRURJU19PUFRJT05TID0ge1xuICAgIC8vIENvbm5lY3Rpb25cbiAgICBwb3J0OiA2Mzc5LFxuICAgIGhvc3Q6IFwibG9jYWxob3N0XCIsXG4gICAgZmFtaWx5OiA0LFxuICAgIGNvbm5lY3RUaW1lb3V0OiAxMDAwMCxcbiAgICBkaXNjb25uZWN0VGltZW91dDogMjAwMCxcbiAgICByZXRyeVN0cmF0ZWd5OiBmdW5jdGlvbiAodGltZXMpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHRpbWVzICogNTAsIDIwMDApO1xuICAgIH0sXG4gICAga2VlcEFsaXZlOiAwLFxuICAgIG5vRGVsYXk6IHRydWUsXG4gICAgY29ubmVjdGlvbk5hbWU6IG51bGwsXG4gICAgLy8gU2VudGluZWxcbiAgICBzZW50aW5lbHM6IG51bGwsXG4gICAgbmFtZTogbnVsbCxcbiAgICByb2xlOiBcIm1hc3RlclwiLFxuICAgIHNlbnRpbmVsUmV0cnlTdHJhdGVneTogZnVuY3Rpb24gKHRpbWVzKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbih0aW1lcyAqIDEwLCAxMDAwKTtcbiAgICB9LFxuICAgIHNlbnRpbmVsUmVjb25uZWN0U3RyYXRlZ3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVGhpcyBzdHJhdGVneSBvbmx5IGFwcGxpZXMgd2hlbiBzZW50aW5lbHMgYXJlIHVzZWQgZm9yIGRldGVjdGluZ1xuICAgICAgICAvLyBhIGZhaWxvdmVyLCBub3QgZHVyaW5nIGluaXRpYWwgbWFzdGVyIHJlc29sdXRpb24uXG4gICAgICAgIC8vIFRoZSBkZXBsb3ltZW50IGNhbiBzdGlsbCBmdW5jdGlvbiB3aGVuIHNvbWUgb2YgdGhlIHNlbnRpbmVscyBhcmUgZG93blxuICAgICAgICAvLyBmb3IgYSBsb25nIHBlcmlvZCBvZiB0aW1lLCBzbyB3ZSBtYXkgbm90IHdhbnQgdG8gYXR0ZW1wdCByZWNvbm5lY3Rpb25cbiAgICAgICAgLy8gdmVyeSBvZnRlbi4gVGhlcmVmb3JlIHRoZSBkZWZhdWx0IGludGVydmFsIGlzIGZhaXJseSBsb25nICgxIG1pbnV0ZSkuXG4gICAgICAgIHJldHVybiA2MDAwMDtcbiAgICB9LFxuICAgIG5hdE1hcDogbnVsbCxcbiAgICBlbmFibGVUTFNGb3JTZW50aW5lbE1vZGU6IGZhbHNlLFxuICAgIHVwZGF0ZVNlbnRpbmVsczogdHJ1ZSxcbiAgICBmYWlsb3ZlckRldGVjdG9yOiBmYWxzZSxcbiAgICAvLyBTdGF0dXNcbiAgICB1c2VybmFtZTogbnVsbCxcbiAgICBwYXNzd29yZDogbnVsbCxcbiAgICBkYjogMCxcbiAgICAvLyBPdGhlcnNcbiAgICBlbmFibGVPZmZsaW5lUXVldWU6IHRydWUsXG4gICAgZW5hYmxlUmVhZHlDaGVjazogdHJ1ZSxcbiAgICBhdXRvUmVzdWJzY3JpYmU6IHRydWUsXG4gICAgYXV0b1Jlc2VuZFVuZnVsZmlsbGVkQ29tbWFuZHM6IHRydWUsXG4gICAgbGF6eUNvbm5lY3Q6IGZhbHNlLFxuICAgIGtleVByZWZpeDogXCJcIixcbiAgICByZWNvbm5lY3RPbkVycm9yOiBudWxsLFxuICAgIHJlYWRPbmx5OiBmYWxzZSxcbiAgICBzdHJpbmdOdW1iZXJzOiBmYWxzZSxcbiAgICBtYXhSZXRyaWVzUGVyUmVxdWVzdDogMjAsXG4gICAgbWF4TG9hZGluZ1JldHJ5VGltZTogMTAwMDAsXG4gICAgZW5hYmxlQXV0b1BpcGVsaW5pbmc6IGZhbHNlLFxuICAgIGF1dG9QaXBlbGluaW5nSWdub3JlZENvbW1hbmRzOiBbXSxcbiAgICBzZW50aW5lbE1heENvbm5lY3Rpb25zOiAxMCxcbn07XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJERUZBVUxUX1JFRElTX09QVElPTlMiLCJwb3J0IiwiaG9zdCIsImZhbWlseSIsImNvbm5lY3RUaW1lb3V0IiwiZGlzY29ubmVjdFRpbWVvdXQiLCJyZXRyeVN0cmF0ZWd5IiwidGltZXMiLCJNYXRoIiwibWluIiwia2VlcEFsaXZlIiwibm9EZWxheSIsImNvbm5lY3Rpb25OYW1lIiwic2VudGluZWxzIiwibmFtZSIsInJvbGUiLCJzZW50aW5lbFJldHJ5U3RyYXRlZ3kiLCJzZW50aW5lbFJlY29ubmVjdFN0cmF0ZWd5IiwibmF0TWFwIiwiZW5hYmxlVExTRm9yU2VudGluZWxNb2RlIiwidXBkYXRlU2VudGluZWxzIiwiZmFpbG92ZXJEZXRlY3RvciIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJkYiIsImVuYWJsZU9mZmxpbmVRdWV1ZSIsImVuYWJsZVJlYWR5Q2hlY2siLCJhdXRvUmVzdWJzY3JpYmUiLCJhdXRvUmVzZW5kVW5mdWxmaWxsZWRDb21tYW5kcyIsImxhenlDb25uZWN0Iiwia2V5UHJlZml4IiwicmVjb25uZWN0T25FcnJvciIsInJlYWRPbmx5Iiwic3RyaW5nTnVtYmVycyIsIm1heFJldHJpZXNQZXJSZXF1ZXN0IiwibWF4TG9hZGluZ1JldHJ5VGltZSIsImVuYWJsZUF1dG9QaXBlbGluaW5nIiwiYXV0b1BpcGVsaW5pbmdJZ25vcmVkQ29tbWFuZHMiLCJzZW50aW5lbE1heENvbm5lY3Rpb25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/redis/RedisOptions.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/redis/event_handler.js":
/*!***********************************************************!*\
  !*** ./node_modules/ioredis/built/redis/event_handler.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.readyHandler = exports.errorHandler = exports.closeHandler = exports.connectHandler = void 0;\nconst redis_errors_1 = __webpack_require__(/*! redis-errors */ \"(rsc)/./node_modules/redis-errors/index.js\");\nconst Command_1 = __webpack_require__(/*! ../Command */ \"(rsc)/./node_modules/ioredis/built/Command.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/ioredis/built/errors/index.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst DataHandler_1 = __webpack_require__(/*! ../DataHandler */ \"(rsc)/./node_modules/ioredis/built/DataHandler.js\");\nconst debug = (0, utils_1.Debug)(\"connection\");\nfunction connectHandler(self) {\n    return function() {\n        self.setStatus(\"connect\");\n        self.resetCommandQueue();\n        // AUTH command should be processed before any other commands\n        let flushed = false;\n        const { connectionEpoch } = self;\n        if (self.condition.auth) {\n            self.auth(self.condition.auth, function(err) {\n                if (connectionEpoch !== self.connectionEpoch) {\n                    return;\n                }\n                if (err) {\n                    if (err.message.indexOf(\"no password is set\") !== -1) {\n                        console.warn(\"[WARN] Redis server does not require a password, but a password was supplied.\");\n                    } else if (err.message.indexOf(\"without any password configured for the default user\") !== -1) {\n                        console.warn(\"[WARN] This Redis server's `default` user does not require a password, but a password was supplied\");\n                    } else if (err.message.indexOf(\"wrong number of arguments for 'auth' command\") !== -1) {\n                        console.warn(`[ERROR] The server returned \"wrong number of arguments for 'auth' command\". You are probably passing both username and password to Redis version 5 or below. You should only pass the 'password' option for Redis version 5 and under.`);\n                    } else {\n                        flushed = true;\n                        self.recoverFromFatalError(err, err);\n                    }\n                }\n            });\n        }\n        if (self.condition.select) {\n            self.select(self.condition.select).catch((err)=>{\n                // If the node is in cluster mode, select is disallowed.\n                // In this case, reconnect won't help.\n                self.silentEmit(\"error\", err);\n            });\n        }\n        if (!self.options.enableReadyCheck) {\n            exports.readyHandler(self)();\n        }\n        /*\n          No need to keep the reference of DataHandler here\n          because we don't need to do the cleanup.\n          `Stream#end()` will remove all listeners for us.\n        */ new DataHandler_1.default(self, {\n            stringNumbers: self.options.stringNumbers\n        });\n        if (self.options.enableReadyCheck) {\n            self._readyCheck(function(err, info) {\n                if (connectionEpoch !== self.connectionEpoch) {\n                    return;\n                }\n                if (err) {\n                    if (!flushed) {\n                        self.recoverFromFatalError(new Error(\"Ready check failed: \" + err.message), err);\n                    }\n                } else {\n                    if (self.connector.check(info)) {\n                        exports.readyHandler(self)();\n                    } else {\n                        self.disconnect(true);\n                    }\n                }\n            });\n        }\n    };\n}\nexports.connectHandler = connectHandler;\nfunction abortError(command) {\n    const err = new redis_errors_1.AbortError(\"Command aborted due to connection close\");\n    err.command = {\n        name: command.name,\n        args: command.args\n    };\n    return err;\n}\n// If a contiguous set of pipeline commands starts from index zero then they\n// can be safely reattempted. If however we have a chain of pipelined commands\n// starting at index 1 or more it means we received a partial response before\n// the connection close and those pipelined commands must be aborted. For\n// example, if the queue looks like this: [2, 3, 4, 0, 1, 2] then after\n// aborting and purging we'll have a queue that looks like this: [0, 1, 2]\nfunction abortIncompletePipelines(commandQueue) {\n    var _a;\n    let expectedIndex = 0;\n    for(let i = 0; i < commandQueue.length;){\n        const command = (_a = commandQueue.peekAt(i)) === null || _a === void 0 ? void 0 : _a.command;\n        const pipelineIndex = command.pipelineIndex;\n        if (pipelineIndex === undefined || pipelineIndex === 0) {\n            expectedIndex = 0;\n        }\n        if (pipelineIndex !== undefined && pipelineIndex !== expectedIndex++) {\n            commandQueue.remove(i, 1);\n            command.reject(abortError(command));\n            continue;\n        }\n        i++;\n    }\n}\n// If only a partial transaction result was received before connection close,\n// we have to abort any transaction fragments that may have ended up in the\n// offline queue\nfunction abortTransactionFragments(commandQueue) {\n    var _a;\n    for(let i = 0; i < commandQueue.length;){\n        const command = (_a = commandQueue.peekAt(i)) === null || _a === void 0 ? void 0 : _a.command;\n        if (command.name === \"multi\") {\n            break;\n        }\n        if (command.name === \"exec\") {\n            commandQueue.remove(i, 1);\n            command.reject(abortError(command));\n            break;\n        }\n        if (command.inTransaction) {\n            commandQueue.remove(i, 1);\n            command.reject(abortError(command));\n        } else {\n            i++;\n        }\n    }\n}\nfunction closeHandler(self) {\n    return function() {\n        const prevStatus = self.status;\n        self.setStatus(\"close\");\n        if (self.commandQueue.length) {\n            abortIncompletePipelines(self.commandQueue);\n        }\n        if (self.offlineQueue.length) {\n            abortTransactionFragments(self.offlineQueue);\n        }\n        if (prevStatus === \"ready\") {\n            if (!self.prevCondition) {\n                self.prevCondition = self.condition;\n            }\n            if (self.commandQueue.length) {\n                self.prevCommandQueue = self.commandQueue;\n            }\n        }\n        if (self.manuallyClosing) {\n            self.manuallyClosing = false;\n            debug(\"skip reconnecting since the connection is manually closed.\");\n            return close();\n        }\n        if (typeof self.options.retryStrategy !== \"function\") {\n            debug(\"skip reconnecting because `retryStrategy` is not a function\");\n            return close();\n        }\n        const retryDelay = self.options.retryStrategy(++self.retryAttempts);\n        if (typeof retryDelay !== \"number\") {\n            debug(\"skip reconnecting because `retryStrategy` doesn't return a number\");\n            return close();\n        }\n        debug(\"reconnect in %sms\", retryDelay);\n        self.setStatus(\"reconnecting\", retryDelay);\n        self.reconnectTimeout = setTimeout(function() {\n            self.reconnectTimeout = null;\n            self.connect().catch(utils_1.noop);\n        }, retryDelay);\n        const { maxRetriesPerRequest } = self.options;\n        if (typeof maxRetriesPerRequest === \"number\") {\n            if (maxRetriesPerRequest < 0) {\n                debug(\"maxRetriesPerRequest is negative, ignoring...\");\n            } else {\n                const remainder = self.retryAttempts % (maxRetriesPerRequest + 1);\n                if (remainder === 0) {\n                    debug(\"reach maxRetriesPerRequest limitation, flushing command queue...\");\n                    self.flushQueue(new errors_1.MaxRetriesPerRequestError(maxRetriesPerRequest));\n                }\n            }\n        }\n    };\n    function close() {\n        self.setStatus(\"end\");\n        self.flushQueue(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n    }\n}\nexports.closeHandler = closeHandler;\nfunction errorHandler(self) {\n    return function(error) {\n        debug(\"error: %s\", error);\n        self.silentEmit(\"error\", error);\n    };\n}\nexports.errorHandler = errorHandler;\nfunction readyHandler(self) {\n    return function() {\n        self.setStatus(\"ready\");\n        self.retryAttempts = 0;\n        if (self.options.monitor) {\n            self.call(\"monitor\").then(()=>self.setStatus(\"monitoring\"), (error)=>self.emit(\"error\", error));\n            const { sendCommand } = self;\n            self.sendCommand = function(command) {\n                if (Command_1.default.checkFlag(\"VALID_IN_MONITOR_MODE\", command.name)) {\n                    return sendCommand.call(self, command);\n                }\n                command.reject(new Error(\"Connection is in monitoring mode, can't process commands.\"));\n                return command.promise;\n            };\n            self.once(\"close\", function() {\n                delete self.sendCommand;\n            });\n            return;\n        }\n        const finalSelect = self.prevCondition ? self.prevCondition.select : self.condition.select;\n        if (self.options.connectionName) {\n            debug(\"set the connection name [%s]\", self.options.connectionName);\n            self.client(\"setname\", self.options.connectionName).catch(utils_1.noop);\n        }\n        if (self.options.readOnly) {\n            debug(\"set the connection to readonly mode\");\n            self.readonly().catch(utils_1.noop);\n        }\n        if (self.prevCondition) {\n            const condition = self.prevCondition;\n            self.prevCondition = null;\n            if (condition.subscriber && self.options.autoResubscribe) {\n                // We re-select the previous db first since\n                // `SELECT` command is not valid in sub mode.\n                if (self.condition.select !== finalSelect) {\n                    debug(\"connect to db [%d]\", finalSelect);\n                    self.select(finalSelect);\n                }\n                const subscribeChannels = condition.subscriber.channels(\"subscribe\");\n                if (subscribeChannels.length) {\n                    debug(\"subscribe %d channels\", subscribeChannels.length);\n                    self.subscribe(subscribeChannels);\n                }\n                const psubscribeChannels = condition.subscriber.channels(\"psubscribe\");\n                if (psubscribeChannels.length) {\n                    debug(\"psubscribe %d channels\", psubscribeChannels.length);\n                    self.psubscribe(psubscribeChannels);\n                }\n                const ssubscribeChannels = condition.subscriber.channels(\"ssubscribe\");\n                if (ssubscribeChannels.length) {\n                    debug(\"ssubscribe %d channels\", ssubscribeChannels.length);\n                    self.ssubscribe(ssubscribeChannels);\n                }\n            }\n        }\n        if (self.prevCommandQueue) {\n            if (self.options.autoResendUnfulfilledCommands) {\n                debug(\"resend %d unfulfilled commands\", self.prevCommandQueue.length);\n                while(self.prevCommandQueue.length > 0){\n                    const item = self.prevCommandQueue.shift();\n                    if (item.select !== self.condition.select && item.command.name !== \"select\") {\n                        self.select(item.select);\n                    }\n                    self.sendCommand(item.command, item.stream);\n                }\n            } else {\n                self.prevCommandQueue = null;\n            }\n        }\n        if (self.offlineQueue.length) {\n            debug(\"send %d commands in offline queue\", self.offlineQueue.length);\n            const offlineQueue = self.offlineQueue;\n            self.resetOfflineQueue();\n            while(offlineQueue.length > 0){\n                const item = offlineQueue.shift();\n                if (item.select !== self.condition.select && item.command.name !== \"select\") {\n                    self.select(item.select);\n                }\n                self.sendCommand(item.command, item.stream);\n            }\n        }\n        if (self.condition.select !== finalSelect) {\n            debug(\"connect to db [%d]\", finalSelect);\n            self.select(finalSelect);\n        }\n    };\n}\nexports.readyHandler = readyHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9yZWRpcy9ldmVudF9oYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxvQkFBb0IsR0FBR0Esb0JBQW9CLEdBQUdBLG9CQUFvQixHQUFHQSxzQkFBc0IsR0FBRyxLQUFLO0FBQ25HLE1BQU1NLGlCQUFpQkMsbUJBQU9BLENBQUMsZ0VBQWM7QUFDN0MsTUFBTUMsWUFBWUQsbUJBQU9BLENBQUMsaUVBQVk7QUFDdEMsTUFBTUUsV0FBV0YsbUJBQU9BLENBQUMscUVBQVc7QUFDcEMsTUFBTUcsVUFBVUgsbUJBQU9BLENBQUMsbUVBQVU7QUFDbEMsTUFBTUksZ0JBQWdCSixtQkFBT0EsQ0FBQyx5RUFBZ0I7QUFDOUMsTUFBTUssUUFBUSxDQUFDLEdBQUdGLFFBQVFHLEtBQUssRUFBRTtBQUNqQyxTQUFTUixlQUFlUyxJQUFJO0lBQ3hCLE9BQU87UUFDSEEsS0FBS0MsU0FBUyxDQUFDO1FBQ2ZELEtBQUtFLGlCQUFpQjtRQUN0Qiw2REFBNkQ7UUFDN0QsSUFBSUMsVUFBVTtRQUNkLE1BQU0sRUFBRUMsZUFBZSxFQUFFLEdBQUdKO1FBQzVCLElBQUlBLEtBQUtLLFNBQVMsQ0FBQ0MsSUFBSSxFQUFFO1lBQ3JCTixLQUFLTSxJQUFJLENBQUNOLEtBQUtLLFNBQVMsQ0FBQ0MsSUFBSSxFQUFFLFNBQVVDLEdBQUc7Z0JBQ3hDLElBQUlILG9CQUFvQkosS0FBS0ksZUFBZSxFQUFFO29CQUMxQztnQkFDSjtnQkFDQSxJQUFJRyxLQUFLO29CQUNMLElBQUlBLElBQUlDLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDLDBCQUEwQixDQUFDLEdBQUc7d0JBQ2xEQyxRQUFRQyxJQUFJLENBQUM7b0JBQ2pCLE9BQ0ssSUFBSUosSUFBSUMsT0FBTyxDQUFDQyxPQUFPLENBQUMsNERBQTRELENBQUMsR0FBRzt3QkFDekZDLFFBQVFDLElBQUksQ0FBQztv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SztvQkFDeEMsSUFBSUQsS0FBSzFFLE1BQU0sS0FBS2IsS0FBS0ssU0FBUyxDQUFDUSxNQUFNLElBQ3JDMEUsS0FBSzVELE9BQU8sQ0FBQ0UsSUFBSSxLQUFLLFVBQVU7d0JBQ2hDN0IsS0FBS2EsTUFBTSxDQUFDMEUsS0FBSzFFLE1BQU07b0JBQzNCO29CQUNBYixLQUFLb0UsV0FBVyxDQUFDbUIsS0FBSzVELE9BQU8sRUFBRTRELEtBQUtFLE1BQU07Z0JBQzlDO1lBQ0osT0FDSztnQkFDRHpGLEtBQUtnRCxnQkFBZ0IsR0FBRztZQUM1QjtRQUNKO1FBQ0EsSUFBSWhELEtBQUs4QyxZQUFZLENBQUNWLE1BQU0sRUFBRTtZQUMxQnRDLE1BQU0scUNBQXFDRSxLQUFLOEMsWUFBWSxDQUFDVixNQUFNO1lBQ25FLE1BQU1VLGVBQWU5QyxLQUFLOEMsWUFBWTtZQUN0QzlDLEtBQUswRixpQkFBaUI7WUFDdEIsTUFBTzVDLGFBQWFWLE1BQU0sR0FBRyxFQUFHO2dCQUM1QixNQUFNbUQsT0FBT3pDLGFBQWEwQyxLQUFLO2dCQUMvQixJQUFJRCxLQUFLMUUsTUFBTSxLQUFLYixLQUFLSyxTQUFTLENBQUNRLE1BQU0sSUFDckMwRSxLQUFLNUQsT0FBTyxDQUFDRSxJQUFJLEtBQUssVUFBVTtvQkFDaEM3QixLQUFLYSxNQUFNLENBQUMwRSxLQUFLMUUsTUFBTTtnQkFDM0I7Z0JBQ0FiLEtBQUtvRSxXQUFXLENBQUNtQixLQUFLNUQsT0FBTyxFQUFFNEQsS0FBS0UsTUFBTTtZQUM5QztRQUNKO1FBQ0EsSUFBSXpGLEtBQUtLLFNBQVMsQ0FBQ1EsTUFBTSxLQUFLMkQsYUFBYTtZQUN2QzFFLE1BQU0sc0JBQXNCMEU7WUFDNUJ4RSxLQUFLYSxNQUFNLENBQUMyRDtRQUNoQjtJQUNKO0FBQ0o7QUFDQXRGLG9CQUFvQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L3JlZGlzL2V2ZW50X2hhbmRsZXIuanM/ZjQ1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVhZHlIYW5kbGVyID0gZXhwb3J0cy5lcnJvckhhbmRsZXIgPSBleHBvcnRzLmNsb3NlSGFuZGxlciA9IGV4cG9ydHMuY29ubmVjdEhhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCByZWRpc19lcnJvcnNfMSA9IHJlcXVpcmUoXCJyZWRpcy1lcnJvcnNcIik7XG5jb25zdCBDb21tYW5kXzEgPSByZXF1aXJlKFwiLi4vQ29tbWFuZFwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBEYXRhSGFuZGxlcl8xID0gcmVxdWlyZShcIi4uL0RhdGFIYW5kbGVyXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgdXRpbHNfMS5EZWJ1ZykoXCJjb25uZWN0aW9uXCIpO1xuZnVuY3Rpb24gY29ubmVjdEhhbmRsZXIoc2VsZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuc2V0U3RhdHVzKFwiY29ubmVjdFwiKTtcbiAgICAgICAgc2VsZi5yZXNldENvbW1hbmRRdWV1ZSgpO1xuICAgICAgICAvLyBBVVRIIGNvbW1hbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCBiZWZvcmUgYW55IG90aGVyIGNvbW1hbmRzXG4gICAgICAgIGxldCBmbHVzaGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHsgY29ubmVjdGlvbkVwb2NoIH0gPSBzZWxmO1xuICAgICAgICBpZiAoc2VsZi5jb25kaXRpb24uYXV0aCkge1xuICAgICAgICAgICAgc2VsZi5hdXRoKHNlbGYuY29uZGl0aW9uLmF1dGgsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbkVwb2NoICE9PSBzZWxmLmNvbm5lY3Rpb25FcG9jaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoXCJubyBwYXNzd29yZCBpcyBzZXRcIikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbV0FSTl0gUmVkaXMgc2VydmVyIGRvZXMgbm90IHJlcXVpcmUgYSBwYXNzd29yZCwgYnV0IGEgcGFzc3dvcmQgd2FzIHN1cHBsaWVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnIubWVzc2FnZS5pbmRleE9mKFwid2l0aG91dCBhbnkgcGFzc3dvcmQgY29uZmlndXJlZCBmb3IgdGhlIGRlZmF1bHQgdXNlclwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltXQVJOXSBUaGlzIFJlZGlzIHNlcnZlcidzIGBkZWZhdWx0YCB1c2VyIGRvZXMgbm90IHJlcXVpcmUgYSBwYXNzd29yZCwgYnV0IGEgcGFzc3dvcmQgd2FzIHN1cHBsaWVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIGZvciAnYXV0aCcgY29tbWFuZFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW0VSUk9SXSBUaGUgc2VydmVyIHJldHVybmVkIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgJ2F1dGgnIGNvbW1hbmRcIi4gWW91IGFyZSBwcm9iYWJseSBwYXNzaW5nIGJvdGggdXNlcm5hbWUgYW5kIHBhc3N3b3JkIHRvIFJlZGlzIHZlcnNpb24gNSBvciBiZWxvdy4gWW91IHNob3VsZCBvbmx5IHBhc3MgdGhlICdwYXNzd29yZCcgb3B0aW9uIGZvciBSZWRpcyB2ZXJzaW9uIDUgYW5kIHVuZGVyLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmx1c2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlY292ZXJGcm9tRmF0YWxFcnJvcihlcnIsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5jb25kaXRpb24uc2VsZWN0KSB7XG4gICAgICAgICAgICBzZWxmLnNlbGVjdChzZWxmLmNvbmRpdGlvbi5zZWxlY3QpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbm9kZSBpcyBpbiBjbHVzdGVyIG1vZGUsIHNlbGVjdCBpcyBkaXNhbGxvd2VkLlxuICAgICAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSwgcmVjb25uZWN0IHdvbid0IGhlbHAuXG4gICAgICAgICAgICAgICAgc2VsZi5zaWxlbnRFbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2VsZi5vcHRpb25zLmVuYWJsZVJlYWR5Q2hlY2spIHtcbiAgICAgICAgICAgIGV4cG9ydHMucmVhZHlIYW5kbGVyKHNlbGYpKCk7XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICBObyBuZWVkIHRvIGtlZXAgdGhlIHJlZmVyZW5jZSBvZiBEYXRhSGFuZGxlciBoZXJlXG4gICAgICAgICAgYmVjYXVzZSB3ZSBkb24ndCBuZWVkIHRvIGRvIHRoZSBjbGVhbnVwLlxuICAgICAgICAgIGBTdHJlYW0jZW5kKClgIHdpbGwgcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIHVzLlxuICAgICAgICAqL1xuICAgICAgICBuZXcgRGF0YUhhbmRsZXJfMS5kZWZhdWx0KHNlbGYsIHtcbiAgICAgICAgICAgIHN0cmluZ051bWJlcnM6IHNlbGYub3B0aW9ucy5zdHJpbmdOdW1iZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5lbmFibGVSZWFkeUNoZWNrKSB7XG4gICAgICAgICAgICBzZWxmLl9yZWFkeUNoZWNrKGZ1bmN0aW9uIChlcnIsIGluZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbkVwb2NoICE9PSBzZWxmLmNvbm5lY3Rpb25FcG9jaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmbHVzaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlY292ZXJGcm9tRmF0YWxFcnJvcihuZXcgRXJyb3IoXCJSZWFkeSBjaGVjayBmYWlsZWQ6IFwiICsgZXJyLm1lc3NhZ2UpLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25uZWN0b3IuY2hlY2soaW5mbykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydHMucmVhZHlIYW5kbGVyKHNlbGYpKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRpc2Nvbm5lY3QodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnRzLmNvbm5lY3RIYW5kbGVyID0gY29ubmVjdEhhbmRsZXI7XG5mdW5jdGlvbiBhYm9ydEVycm9yKGNvbW1hbmQpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgcmVkaXNfZXJyb3JzXzEuQWJvcnRFcnJvcihcIkNvbW1hbmQgYWJvcnRlZCBkdWUgdG8gY29ubmVjdGlvbiBjbG9zZVwiKTtcbiAgICBlcnIuY29tbWFuZCA9IHtcbiAgICAgICAgbmFtZTogY29tbWFuZC5uYW1lLFxuICAgICAgICBhcmdzOiBjb21tYW5kLmFyZ3MsXG4gICAgfTtcbiAgICByZXR1cm4gZXJyO1xufVxuLy8gSWYgYSBjb250aWd1b3VzIHNldCBvZiBwaXBlbGluZSBjb21tYW5kcyBzdGFydHMgZnJvbSBpbmRleCB6ZXJvIHRoZW4gdGhleVxuLy8gY2FuIGJlIHNhZmVseSByZWF0dGVtcHRlZC4gSWYgaG93ZXZlciB3ZSBoYXZlIGEgY2hhaW4gb2YgcGlwZWxpbmVkIGNvbW1hbmRzXG4vLyBzdGFydGluZyBhdCBpbmRleCAxIG9yIG1vcmUgaXQgbWVhbnMgd2UgcmVjZWl2ZWQgYSBwYXJ0aWFsIHJlc3BvbnNlIGJlZm9yZVxuLy8gdGhlIGNvbm5lY3Rpb24gY2xvc2UgYW5kIHRob3NlIHBpcGVsaW5lZCBjb21tYW5kcyBtdXN0IGJlIGFib3J0ZWQuIEZvclxuLy8gZXhhbXBsZSwgaWYgdGhlIHF1ZXVlIGxvb2tzIGxpa2UgdGhpczogWzIsIDMsIDQsIDAsIDEsIDJdIHRoZW4gYWZ0ZXJcbi8vIGFib3J0aW5nIGFuZCBwdXJnaW5nIHdlJ2xsIGhhdmUgYSBxdWV1ZSB0aGF0IGxvb2tzIGxpa2UgdGhpczogWzAsIDEsIDJdXG5mdW5jdGlvbiBhYm9ydEluY29tcGxldGVQaXBlbGluZXMoY29tbWFuZFF1ZXVlKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBleHBlY3RlZEluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbW1hbmRRdWV1ZS5sZW5ndGg7KSB7XG4gICAgICAgIGNvbnN0IGNvbW1hbmQgPSAoX2EgPSBjb21tYW5kUXVldWUucGVla0F0KGkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29tbWFuZDtcbiAgICAgICAgY29uc3QgcGlwZWxpbmVJbmRleCA9IGNvbW1hbmQucGlwZWxpbmVJbmRleDtcbiAgICAgICAgaWYgKHBpcGVsaW5lSW5kZXggPT09IHVuZGVmaW5lZCB8fCBwaXBlbGluZUluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICBleHBlY3RlZEluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGlwZWxpbmVJbmRleCAhPT0gdW5kZWZpbmVkICYmIHBpcGVsaW5lSW5kZXggIT09IGV4cGVjdGVkSW5kZXgrKykge1xuICAgICAgICAgICAgY29tbWFuZFF1ZXVlLnJlbW92ZShpLCAxKTtcbiAgICAgICAgICAgIGNvbW1hbmQucmVqZWN0KGFib3J0RXJyb3IoY29tbWFuZCkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbn1cbi8vIElmIG9ubHkgYSBwYXJ0aWFsIHRyYW5zYWN0aW9uIHJlc3VsdCB3YXMgcmVjZWl2ZWQgYmVmb3JlIGNvbm5lY3Rpb24gY2xvc2UsXG4vLyB3ZSBoYXZlIHRvIGFib3J0IGFueSB0cmFuc2FjdGlvbiBmcmFnbWVudHMgdGhhdCBtYXkgaGF2ZSBlbmRlZCB1cCBpbiB0aGVcbi8vIG9mZmxpbmUgcXVldWVcbmZ1bmN0aW9uIGFib3J0VHJhbnNhY3Rpb25GcmFnbWVudHMoY29tbWFuZFF1ZXVlKSB7XG4gICAgdmFyIF9hO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tbWFuZFF1ZXVlLmxlbmd0aDspIHtcbiAgICAgICAgY29uc3QgY29tbWFuZCA9IChfYSA9IGNvbW1hbmRRdWV1ZS5wZWVrQXQoaSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb21tYW5kO1xuICAgICAgICBpZiAoY29tbWFuZC5uYW1lID09PSBcIm11bHRpXCIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21tYW5kLm5hbWUgPT09IFwiZXhlY1wiKSB7XG4gICAgICAgICAgICBjb21tYW5kUXVldWUucmVtb3ZlKGksIDEpO1xuICAgICAgICAgICAgY29tbWFuZC5yZWplY3QoYWJvcnRFcnJvcihjb21tYW5kKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWFuZC5pblRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICBjb21tYW5kUXVldWUucmVtb3ZlKGksIDEpO1xuICAgICAgICAgICAgY29tbWFuZC5yZWplY3QoYWJvcnRFcnJvcihjb21tYW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjbG9zZUhhbmRsZXIoc2VsZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHByZXZTdGF0dXMgPSBzZWxmLnN0YXR1cztcbiAgICAgICAgc2VsZi5zZXRTdGF0dXMoXCJjbG9zZVwiKTtcbiAgICAgICAgaWYgKHNlbGYuY29tbWFuZFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgYWJvcnRJbmNvbXBsZXRlUGlwZWxpbmVzKHNlbGYuY29tbWFuZFF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5vZmZsaW5lUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBhYm9ydFRyYW5zYWN0aW9uRnJhZ21lbnRzKHNlbGYub2ZmbGluZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldlN0YXR1cyA9PT0gXCJyZWFkeVwiKSB7XG4gICAgICAgICAgICBpZiAoIXNlbGYucHJldkNvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgIHNlbGYucHJldkNvbmRpdGlvbiA9IHNlbGYuY29uZGl0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY29tbWFuZFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNlbGYucHJldkNvbW1hbmRRdWV1ZSA9IHNlbGYuY29tbWFuZFF1ZXVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLm1hbnVhbGx5Q2xvc2luZykge1xuICAgICAgICAgICAgc2VsZi5tYW51YWxseUNsb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGRlYnVnKFwic2tpcCByZWNvbm5lY3Rpbmcgc2luY2UgdGhlIGNvbm5lY3Rpb24gaXMgbWFudWFsbHkgY2xvc2VkLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZi5vcHRpb25zLnJldHJ5U3RyYXRlZ3kgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZGVidWcoXCJza2lwIHJlY29ubmVjdGluZyBiZWNhdXNlIGByZXRyeVN0cmF0ZWd5YCBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgIHJldHVybiBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldHJ5RGVsYXkgPSBzZWxmLm9wdGlvbnMucmV0cnlTdHJhdGVneSgrK3NlbGYucmV0cnlBdHRlbXB0cyk7XG4gICAgICAgIGlmICh0eXBlb2YgcmV0cnlEZWxheSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgZGVidWcoXCJza2lwIHJlY29ubmVjdGluZyBiZWNhdXNlIGByZXRyeVN0cmF0ZWd5YCBkb2Vzbid0IHJldHVybiBhIG51bWJlclwiKTtcbiAgICAgICAgICAgIHJldHVybiBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKFwicmVjb25uZWN0IGluICVzbXNcIiwgcmV0cnlEZWxheSk7XG4gICAgICAgIHNlbGYuc2V0U3RhdHVzKFwicmVjb25uZWN0aW5nXCIsIHJldHJ5RGVsYXkpO1xuICAgICAgICBzZWxmLnJlY29ubmVjdFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYucmVjb25uZWN0VGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLmNvbm5lY3QoKS5jYXRjaCh1dGlsc18xLm5vb3ApO1xuICAgICAgICB9LCByZXRyeURlbGF5KTtcbiAgICAgICAgY29uc3QgeyBtYXhSZXRyaWVzUGVyUmVxdWVzdCB9ID0gc2VsZi5vcHRpb25zO1xuICAgICAgICBpZiAodHlwZW9mIG1heFJldHJpZXNQZXJSZXF1ZXN0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAobWF4UmV0cmllc1BlclJlcXVlc3QgPCAwKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJtYXhSZXRyaWVzUGVyUmVxdWVzdCBpcyBuZWdhdGl2ZSwgaWdub3JpbmcuLi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1haW5kZXIgPSBzZWxmLnJldHJ5QXR0ZW1wdHMgJSAobWF4UmV0cmllc1BlclJlcXVlc3QgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAocmVtYWluZGVyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwicmVhY2ggbWF4UmV0cmllc1BlclJlcXVlc3QgbGltaXRhdGlvbiwgZmx1c2hpbmcgY29tbWFuZCBxdWV1ZS4uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5mbHVzaFF1ZXVlKG5ldyBlcnJvcnNfMS5NYXhSZXRyaWVzUGVyUmVxdWVzdEVycm9yKG1heFJldHJpZXNQZXJSZXF1ZXN0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgc2VsZi5zZXRTdGF0dXMoXCJlbmRcIik7XG4gICAgICAgIHNlbGYuZmx1c2hRdWV1ZShuZXcgRXJyb3IodXRpbHNfMS5DT05ORUNUSU9OX0NMT1NFRF9FUlJPUl9NU0cpKTtcbiAgICB9XG59XG5leHBvcnRzLmNsb3NlSGFuZGxlciA9IGNsb3NlSGFuZGxlcjtcbmZ1bmN0aW9uIGVycm9ySGFuZGxlcihzZWxmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBkZWJ1ZyhcImVycm9yOiAlc1wiLCBlcnJvcik7XG4gICAgICAgIHNlbGYuc2lsZW50RW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICB9O1xufVxuZXhwb3J0cy5lcnJvckhhbmRsZXIgPSBlcnJvckhhbmRsZXI7XG5mdW5jdGlvbiByZWFkeUhhbmRsZXIoc2VsZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuc2V0U3RhdHVzKFwicmVhZHlcIik7XG4gICAgICAgIHNlbGYucmV0cnlBdHRlbXB0cyA9IDA7XG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMubW9uaXRvcikge1xuICAgICAgICAgICAgc2VsZi5jYWxsKFwibW9uaXRvclwiKS50aGVuKCgpID0+IHNlbGYuc2V0U3RhdHVzKFwibW9uaXRvcmluZ1wiKSwgKGVycm9yKSA9PiBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnJvcikpO1xuICAgICAgICAgICAgY29uc3QgeyBzZW5kQ29tbWFuZCB9ID0gc2VsZjtcbiAgICAgICAgICAgIHNlbGYuc2VuZENvbW1hbmQgPSBmdW5jdGlvbiAoY29tbWFuZCkge1xuICAgICAgICAgICAgICAgIGlmIChDb21tYW5kXzEuZGVmYXVsdC5jaGVja0ZsYWcoXCJWQUxJRF9JTl9NT05JVE9SX01PREVcIiwgY29tbWFuZC5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VuZENvbW1hbmQuY2FsbChzZWxmLCBjb21tYW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29tbWFuZC5yZWplY3QobmV3IEVycm9yKFwiQ29ubmVjdGlvbiBpcyBpbiBtb25pdG9yaW5nIG1vZGUsIGNhbid0IHByb2Nlc3MgY29tbWFuZHMuXCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZC5wcm9taXNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNlbGYub25jZShcImNsb3NlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgc2VsZi5zZW5kQ29tbWFuZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbmFsU2VsZWN0ID0gc2VsZi5wcmV2Q29uZGl0aW9uXG4gICAgICAgICAgICA/IHNlbGYucHJldkNvbmRpdGlvbi5zZWxlY3RcbiAgICAgICAgICAgIDogc2VsZi5jb25kaXRpb24uc2VsZWN0O1xuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmNvbm5lY3Rpb25OYW1lKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInNldCB0aGUgY29ubmVjdGlvbiBuYW1lIFslc11cIiwgc2VsZi5vcHRpb25zLmNvbm5lY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIHNlbGYuY2xpZW50KFwic2V0bmFtZVwiLCBzZWxmLm9wdGlvbnMuY29ubmVjdGlvbk5hbWUpLmNhdGNoKHV0aWxzXzEubm9vcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5yZWFkT25seSkge1xuICAgICAgICAgICAgZGVidWcoXCJzZXQgdGhlIGNvbm5lY3Rpb24gdG8gcmVhZG9ubHkgbW9kZVwiKTtcbiAgICAgICAgICAgIHNlbGYucmVhZG9ubHkoKS5jYXRjaCh1dGlsc18xLm5vb3ApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLnByZXZDb25kaXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IHNlbGYucHJldkNvbmRpdGlvbjtcbiAgICAgICAgICAgIHNlbGYucHJldkNvbmRpdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBpZiAoY29uZGl0aW9uLnN1YnNjcmliZXIgJiYgc2VsZi5vcHRpb25zLmF1dG9SZXN1YnNjcmliZSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHJlLXNlbGVjdCB0aGUgcHJldmlvdXMgZGIgZmlyc3Qgc2luY2VcbiAgICAgICAgICAgICAgICAvLyBgU0VMRUNUYCBjb21tYW5kIGlzIG5vdCB2YWxpZCBpbiBzdWIgbW9kZS5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25kaXRpb24uc2VsZWN0ICE9PSBmaW5hbFNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImNvbm5lY3QgdG8gZGIgWyVkXVwiLCBmaW5hbFNlbGVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0KGZpbmFsU2VsZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlQ2hhbm5lbHMgPSBjb25kaXRpb24uc3Vic2NyaWJlci5jaGFubmVscyhcInN1YnNjcmliZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlQ2hhbm5lbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwic3Vic2NyaWJlICVkIGNoYW5uZWxzXCIsIHN1YnNjcmliZUNoYW5uZWxzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc3Vic2NyaWJlKHN1YnNjcmliZUNoYW5uZWxzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHN1YnNjcmliZUNoYW5uZWxzID0gY29uZGl0aW9uLnN1YnNjcmliZXIuY2hhbm5lbHMoXCJwc3Vic2NyaWJlXCIpO1xuICAgICAgICAgICAgICAgIGlmIChwc3Vic2NyaWJlQ2hhbm5lbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwicHN1YnNjcmliZSAlZCBjaGFubmVsc1wiLCBwc3Vic2NyaWJlQ2hhbm5lbHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wc3Vic2NyaWJlKHBzdWJzY3JpYmVDaGFubmVscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNzdWJzY3JpYmVDaGFubmVscyA9IGNvbmRpdGlvbi5zdWJzY3JpYmVyLmNoYW5uZWxzKFwic3N1YnNjcmliZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoc3N1YnNjcmliZUNoYW5uZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcInNzdWJzY3JpYmUgJWQgY2hhbm5lbHNcIiwgc3N1YnNjcmliZUNoYW5uZWxzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc3N1YnNjcmliZShzc3Vic2NyaWJlQ2hhbm5lbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5wcmV2Q29tbWFuZFF1ZXVlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmF1dG9SZXNlbmRVbmZ1bGZpbGxlZENvbW1hbmRzKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJyZXNlbmQgJWQgdW5mdWxmaWxsZWQgY29tbWFuZHNcIiwgc2VsZi5wcmV2Q29tbWFuZFF1ZXVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNlbGYucHJldkNvbW1hbmRRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBzZWxmLnByZXZDb21tYW5kUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0ICE9PSBzZWxmLmNvbmRpdGlvbi5zZWxlY3QgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uY29tbWFuZC5uYW1lICE9PSBcInNlbGVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdChpdGVtLnNlbGVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZW5kQ29tbWFuZChpdGVtLmNvbW1hbmQsIGl0ZW0uc3RyZWFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLnByZXZDb21tYW5kUXVldWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLm9mZmxpbmVRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlYnVnKFwic2VuZCAlZCBjb21tYW5kcyBpbiBvZmZsaW5lIHF1ZXVlXCIsIHNlbGYub2ZmbGluZVF1ZXVlLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBvZmZsaW5lUXVldWUgPSBzZWxmLm9mZmxpbmVRdWV1ZTtcbiAgICAgICAgICAgIHNlbGYucmVzZXRPZmZsaW5lUXVldWUoKTtcbiAgICAgICAgICAgIHdoaWxlIChvZmZsaW5lUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBvZmZsaW5lUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5zZWxlY3QgIT09IHNlbGYuY29uZGl0aW9uLnNlbGVjdCAmJlxuICAgICAgICAgICAgICAgICAgICBpdGVtLmNvbW1hbmQubmFtZSAhPT0gXCJzZWxlY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdChpdGVtLnNlbGVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYuc2VuZENvbW1hbmQoaXRlbS5jb21tYW5kLCBpdGVtLnN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuY29uZGl0aW9uLnNlbGVjdCAhPT0gZmluYWxTZWxlY3QpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiY29ubmVjdCB0byBkYiBbJWRdXCIsIGZpbmFsU2VsZWN0KTtcbiAgICAgICAgICAgIHNlbGYuc2VsZWN0KGZpbmFsU2VsZWN0KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnRzLnJlYWR5SGFuZGxlciA9IHJlYWR5SGFuZGxlcjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJlYWR5SGFuZGxlciIsImVycm9ySGFuZGxlciIsImNsb3NlSGFuZGxlciIsImNvbm5lY3RIYW5kbGVyIiwicmVkaXNfZXJyb3JzXzEiLCJyZXF1aXJlIiwiQ29tbWFuZF8xIiwiZXJyb3JzXzEiLCJ1dGlsc18xIiwiRGF0YUhhbmRsZXJfMSIsImRlYnVnIiwiRGVidWciLCJzZWxmIiwic2V0U3RhdHVzIiwicmVzZXRDb21tYW5kUXVldWUiLCJmbHVzaGVkIiwiY29ubmVjdGlvbkVwb2NoIiwiY29uZGl0aW9uIiwiYXV0aCIsImVyciIsIm1lc3NhZ2UiLCJpbmRleE9mIiwiY29uc29sZSIsIndhcm4iLCJyZWNvdmVyRnJvbUZhdGFsRXJyb3IiLCJzZWxlY3QiLCJjYXRjaCIsInNpbGVudEVtaXQiLCJvcHRpb25zIiwiZW5hYmxlUmVhZHlDaGVjayIsImRlZmF1bHQiLCJzdHJpbmdOdW1iZXJzIiwiX3JlYWR5Q2hlY2siLCJpbmZvIiwiRXJyb3IiLCJjb25uZWN0b3IiLCJjaGVjayIsImRpc2Nvbm5lY3QiLCJhYm9ydEVycm9yIiwiY29tbWFuZCIsIkFib3J0RXJyb3IiLCJuYW1lIiwiYXJncyIsImFib3J0SW5jb21wbGV0ZVBpcGVsaW5lcyIsImNvbW1hbmRRdWV1ZSIsIl9hIiwiZXhwZWN0ZWRJbmRleCIsImkiLCJsZW5ndGgiLCJwZWVrQXQiLCJwaXBlbGluZUluZGV4IiwidW5kZWZpbmVkIiwicmVtb3ZlIiwicmVqZWN0IiwiYWJvcnRUcmFuc2FjdGlvbkZyYWdtZW50cyIsImluVHJhbnNhY3Rpb24iLCJwcmV2U3RhdHVzIiwic3RhdHVzIiwib2ZmbGluZVF1ZXVlIiwicHJldkNvbmRpdGlvbiIsInByZXZDb21tYW5kUXVldWUiLCJtYW51YWxseUNsb3NpbmciLCJjbG9zZSIsInJldHJ5U3RyYXRlZ3kiLCJyZXRyeURlbGF5IiwicmV0cnlBdHRlbXB0cyIsInJlY29ubmVjdFRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY29ubmVjdCIsIm5vb3AiLCJtYXhSZXRyaWVzUGVyUmVxdWVzdCIsInJlbWFpbmRlciIsImZsdXNoUXVldWUiLCJNYXhSZXRyaWVzUGVyUmVxdWVzdEVycm9yIiwiQ09OTkVDVElPTl9DTE9TRURfRVJST1JfTVNHIiwiZXJyb3IiLCJtb25pdG9yIiwiY2FsbCIsInRoZW4iLCJlbWl0Iiwic2VuZENvbW1hbmQiLCJjaGVja0ZsYWciLCJwcm9taXNlIiwib25jZSIsImZpbmFsU2VsZWN0IiwiY29ubmVjdGlvbk5hbWUiLCJjbGllbnQiLCJyZWFkT25seSIsInJlYWRvbmx5Iiwic3Vic2NyaWJlciIsImF1dG9SZXN1YnNjcmliZSIsInN1YnNjcmliZUNoYW5uZWxzIiwiY2hhbm5lbHMiLCJzdWJzY3JpYmUiLCJwc3Vic2NyaWJlQ2hhbm5lbHMiLCJwc3Vic2NyaWJlIiwic3N1YnNjcmliZUNoYW5uZWxzIiwic3N1YnNjcmliZSIsImF1dG9SZXNlbmRVbmZ1bGZpbGxlZENvbW1hbmRzIiwiaXRlbSIsInNoaWZ0Iiwic3RyZWFtIiwicmVzZXRPZmZsaW5lUXVldWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/redis/event_handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/transaction.js":
/*!***************************************************!*\
  !*** ./node_modules/ioredis/built/transaction.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addTransactionSupport = void 0;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/./node_modules/standard-as-callback/built/index.js\");\nconst Pipeline_1 = __webpack_require__(/*! ./Pipeline */ \"(rsc)/./node_modules/ioredis/built/Pipeline.js\");\nfunction addTransactionSupport(redis) {\n    redis.pipeline = function(commands) {\n        const pipeline = new Pipeline_1.default(this);\n        if (Array.isArray(commands)) {\n            pipeline.addBatch(commands);\n        }\n        return pipeline;\n    };\n    const { multi } = redis;\n    redis.multi = function(commands, options) {\n        if (typeof options === \"undefined\" && !Array.isArray(commands)) {\n            options = commands;\n            commands = null;\n        }\n        if (options && options.pipeline === false) {\n            return multi.call(this);\n        }\n        const pipeline = new Pipeline_1.default(this);\n        // @ts-expect-error\n        pipeline.multi();\n        if (Array.isArray(commands)) {\n            pipeline.addBatch(commands);\n        }\n        const exec = pipeline.exec;\n        pipeline.exec = function(callback) {\n            // Wait for the cluster to be connected, since we need nodes information before continuing\n            if (this.isCluster && !this.redis.slots.length) {\n                if (this.redis.status === \"wait\") this.redis.connect().catch(utils_1.noop);\n                return (0, standard_as_callback_1.default)(new Promise((resolve, reject)=>{\n                    this.redis.delayUntilReady((err)=>{\n                        if (err) {\n                            reject(err);\n                            return;\n                        }\n                        this.exec(pipeline).then(resolve, reject);\n                    });\n                }), callback);\n            }\n            if (this._transactions > 0) {\n                exec.call(pipeline);\n            }\n            // Returns directly when the pipeline\n            // has been called multiple times (retries).\n            if (this.nodeifiedPromise) {\n                return exec.call(pipeline);\n            }\n            const promise = exec.call(pipeline);\n            return (0, standard_as_callback_1.default)(promise.then(function(result) {\n                const execResult = result[result.length - 1];\n                if (typeof execResult === \"undefined\") {\n                    throw new Error(\"Pipeline cannot be used to send any commands when the `exec()` has been called on it.\");\n                }\n                if (execResult[0]) {\n                    execResult[0].previousErrors = [];\n                    for(let i = 0; i < result.length - 1; ++i){\n                        if (result[i][0]) {\n                            execResult[0].previousErrors.push(result[i][0]);\n                        }\n                    }\n                    throw execResult[0];\n                }\n                return (0, utils_1.wrapMultiResult)(execResult[1]);\n            }), callback);\n        };\n        // @ts-expect-error\n        const { execBuffer } = pipeline;\n        // @ts-expect-error\n        pipeline.execBuffer = function(callback) {\n            if (this._transactions > 0) {\n                execBuffer.call(pipeline);\n            }\n            return pipeline.exec(callback);\n        };\n        return pipeline;\n    };\n    const { exec } = redis;\n    redis.exec = function(callback) {\n        return (0, standard_as_callback_1.default)(exec.call(this).then(function(results) {\n            if (Array.isArray(results)) {\n                results = (0, utils_1.wrapMultiResult)(results);\n            }\n            return results;\n        }), callback);\n    };\n}\nexports.addTransactionSupport = addTransactionSupport;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC90cmFuc2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsNkJBQTZCLEdBQUcsS0FBSztBQUNyQyxNQUFNRyxVQUFVQyxtQkFBT0EsQ0FBQyxrRUFBUztBQUNqQyxNQUFNQyx5QkFBeUJELG1CQUFPQSxDQUFDLHNGQUFzQjtBQUM3RCxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQyxrRUFBWTtBQUN2QyxTQUFTRixzQkFBc0JLLEtBQUs7SUFDaENBLE1BQU1DLFFBQVEsR0FBRyxTQUFVQyxRQUFRO1FBQy9CLE1BQU1ELFdBQVcsSUFBSUYsV0FBV0ksT0FBTyxDQUFDLElBQUk7UUFDNUMsSUFBSUMsTUFBTUMsT0FBTyxDQUFDSCxXQUFXO1lBQ3pCRCxTQUFTSyxRQUFRLENBQUNKO1FBQ3RCO1FBQ0EsT0FBT0Q7SUFDWDtJQUNBLE1BQU0sRUFBRU0sS0FBSyxFQUFFLEdBQUdQO0lBQ2xCQSxNQUFNTyxLQUFLLEdBQUcsU0FBVUwsUUFBUSxFQUFFTSxPQUFPO1FBQ3JDLElBQUksT0FBT0EsWUFBWSxlQUFlLENBQUNKLE1BQU1DLE9BQU8sQ0FBQ0gsV0FBVztZQUM1RE0sVUFBVU47WUFDVkEsV0FBVztRQUNmO1FBQ0EsSUFBSU0sV0FBV0EsUUFBUVAsUUFBUSxLQUFLLE9BQU87WUFDdkMsT0FBT00sTUFBTUUsSUFBSSxDQUFDLElBQUk7UUFDMUI7UUFDQSxNQUFNUixXQUFXLElBQUlGLFdBQVdJLE9BQU8sQ0FBQyxJQUFJO1FBQzVDLG1CQUFtQjtRQUNuQkYsU0FBU00sS0FBSztRQUNkLElBQUlILE1BQU1DLE9BQU8sQ0FBQ0gsV0FBVztZQUN6QkQsU0FBU0ssUUFBUSxDQUFDSjtRQUN0QjtRQUNBLE1BQU1RLE9BQU9ULFNBQVNTLElBQUk7UUFDMUJULFNBQVNTLElBQUksR0FBRyxTQUFVQyxRQUFRO1lBQzlCLDBGQUEwRjtZQUMxRixJQUFJLElBQUksQ0FBQ0MsU0FBUyxJQUFJLENBQUMsSUFBSSxDQUFDWixLQUFLLENBQUNhLEtBQUssQ0FBQ0MsTUFBTSxFQUFFO2dCQUM1QyxJQUFJLElBQUksQ0FBQ2QsS0FBSyxDQUFDZSxNQUFNLEtBQUssUUFDdEIsSUFBSSxDQUFDZixLQUFLLENBQUNnQixPQUFPLEdBQUdDLEtBQUssQ0FBQ3JCLFFBQVFzQixJQUFJO2dCQUMzQyxPQUFPLENBQUMsR0FBR3BCLHVCQUF1QkssT0FBTyxFQUFFLElBQUlnQixRQUFRLENBQUNDLFNBQVNDO29CQUM3RCxJQUFJLENBQUNyQixLQUFLLENBQUNzQixlQUFlLENBQUMsQ0FBQ0M7d0JBQ3hCLElBQUlBLEtBQUs7NEJBQ0xGLE9BQU9FOzRCQUNQO3dCQUNKO3dCQUNBLElBQUksQ0FBQ2IsSUFBSSxDQUFDVCxVQUFVdUIsSUFBSSxDQUFDSixTQUFTQztvQkFDdEM7Z0JBQ0osSUFBSVY7WUFDUjtZQUNBLElBQUksSUFBSSxDQUFDYyxhQUFhLEdBQUcsR0FBRztnQkFDeEJmLEtBQUtELElBQUksQ0FBQ1I7WUFDZDtZQUNBLHFDQUFxQztZQUNyQyw0Q0FBNEM7WUFDNUMsSUFBSSxJQUFJLENBQUN5QixnQkFBZ0IsRUFBRTtnQkFDdkIsT0FBT2hCLEtBQUtELElBQUksQ0FBQ1I7WUFDckI7WUFDQSxNQUFNMEIsVUFBVWpCLEtBQUtELElBQUksQ0FBQ1I7WUFDMUIsT0FBTyxDQUFDLEdBQUdILHVCQUF1QkssT0FBTyxFQUFFd0IsUUFBUUgsSUFBSSxDQUFDLFNBQVVJLE1BQU07Z0JBQ3BFLE1BQU1DLGFBQWFELE1BQU0sQ0FBQ0EsT0FBT2QsTUFBTSxHQUFHLEVBQUU7Z0JBQzVDLElBQUksT0FBT2UsZUFBZSxhQUFhO29CQUNuQyxNQUFNLElBQUlDLE1BQU07Z0JBQ3BCO2dCQUNBLElBQUlELFVBQVUsQ0FBQyxFQUFFLEVBQUU7b0JBQ2ZBLFVBQVUsQ0FBQyxFQUFFLENBQUNFLGNBQWMsR0FBRyxFQUFFO29CQUNqQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUosT0FBT2QsTUFBTSxHQUFHLEdBQUcsRUFBRWtCLEVBQUc7d0JBQ3hDLElBQUlKLE1BQU0sQ0FBQ0ksRUFBRSxDQUFDLEVBQUUsRUFBRTs0QkFDZEgsVUFBVSxDQUFDLEVBQUUsQ0FBQ0UsY0FBYyxDQUFDRSxJQUFJLENBQUNMLE1BQU0sQ0FBQ0ksRUFBRSxDQUFDLEVBQUU7d0JBQ2xEO29CQUNKO29CQUNBLE1BQU1ILFVBQVUsQ0FBQyxFQUFFO2dCQUN2QjtnQkFDQSxPQUFPLENBQUMsR0FBR2pDLFFBQVFzQyxlQUFlLEVBQUVMLFVBQVUsQ0FBQyxFQUFFO1lBQ3JELElBQUlsQjtRQUNSO1FBQ0EsbUJBQW1CO1FBQ25CLE1BQU0sRUFBRXdCLFVBQVUsRUFBRSxHQUFHbEM7UUFDdkIsbUJBQW1CO1FBQ25CQSxTQUFTa0MsVUFBVSxHQUFHLFNBQVV4QixRQUFRO1lBQ3BDLElBQUksSUFBSSxDQUFDYyxhQUFhLEdBQUcsR0FBRztnQkFDeEJVLFdBQVcxQixJQUFJLENBQUNSO1lBQ3BCO1lBQ0EsT0FBT0EsU0FBU1MsSUFBSSxDQUFDQztRQUN6QjtRQUNBLE9BQU9WO0lBQ1g7SUFDQSxNQUFNLEVBQUVTLElBQUksRUFBRSxHQUFHVjtJQUNqQkEsTUFBTVUsSUFBSSxHQUFHLFNBQVVDLFFBQVE7UUFDM0IsT0FBTyxDQUFDLEdBQUdiLHVCQUF1QkssT0FBTyxFQUFFTyxLQUFLRCxJQUFJLENBQUMsSUFBSSxFQUFFZSxJQUFJLENBQUMsU0FBVVksT0FBTztZQUM3RSxJQUFJaEMsTUFBTUMsT0FBTyxDQUFDK0IsVUFBVTtnQkFDeEJBLFVBQVUsQ0FBQyxHQUFHeEMsUUFBUXNDLGVBQWUsRUFBRUU7WUFDM0M7WUFDQSxPQUFPQTtRQUNYLElBQUl6QjtJQUNSO0FBQ0o7QUFDQWxCLDZCQUE2QixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L3RyYW5zYWN0aW9uLmpzP2Y4MTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFkZFRyYW5zYWN0aW9uU3VwcG9ydCA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEgPSByZXF1aXJlKFwic3RhbmRhcmQtYXMtY2FsbGJhY2tcIik7XG5jb25zdCBQaXBlbGluZV8xID0gcmVxdWlyZShcIi4vUGlwZWxpbmVcIik7XG5mdW5jdGlvbiBhZGRUcmFuc2FjdGlvblN1cHBvcnQocmVkaXMpIHtcbiAgICByZWRpcy5waXBlbGluZSA9IGZ1bmN0aW9uIChjb21tYW5kcykge1xuICAgICAgICBjb25zdCBwaXBlbGluZSA9IG5ldyBQaXBlbGluZV8xLmRlZmF1bHQodGhpcyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbW1hbmRzKSkge1xuICAgICAgICAgICAgcGlwZWxpbmUuYWRkQmF0Y2goY29tbWFuZHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaXBlbGluZTtcbiAgICB9O1xuICAgIGNvbnN0IHsgbXVsdGkgfSA9IHJlZGlzO1xuICAgIHJlZGlzLm11bHRpID0gZnVuY3Rpb24gKGNvbW1hbmRzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJ1bmRlZmluZWRcIiAmJiAhQXJyYXkuaXNBcnJheShjb21tYW5kcykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBjb21tYW5kcztcbiAgICAgICAgICAgIGNvbW1hbmRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnBpcGVsaW5lID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIG11bHRpLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGlwZWxpbmUgPSBuZXcgUGlwZWxpbmVfMS5kZWZhdWx0KHRoaXMpO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHBpcGVsaW5lLm11bHRpKCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbW1hbmRzKSkge1xuICAgICAgICAgICAgcGlwZWxpbmUuYWRkQmF0Y2goY29tbWFuZHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4ZWMgPSBwaXBlbGluZS5leGVjO1xuICAgICAgICBwaXBlbGluZS5leGVjID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgY2x1c3RlciB0byBiZSBjb25uZWN0ZWQsIHNpbmNlIHdlIG5lZWQgbm9kZXMgaW5mb3JtYXRpb24gYmVmb3JlIGNvbnRpbnVpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ2x1c3RlciAmJiAhdGhpcy5yZWRpcy5zbG90cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWRpcy5zdGF0dXMgPT09IFwid2FpdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZGlzLmNvbm5lY3QoKS5jYXRjaCh1dGlsc18xLm5vb3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMS5kZWZhdWx0KShuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVkaXMuZGVsYXlVbnRpbFJlYWR5KChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4ZWMocGlwZWxpbmUpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbnMgPiAwKSB7XG4gICAgICAgICAgICAgICAgZXhlYy5jYWxsKHBpcGVsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJldHVybnMgZGlyZWN0bHkgd2hlbiB0aGUgcGlwZWxpbmVcbiAgICAgICAgICAgIC8vIGhhcyBiZWVuIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyAocmV0cmllcykuXG4gICAgICAgICAgICBpZiAodGhpcy5ub2RlaWZpZWRQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4ZWMuY2FsbChwaXBlbGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gZXhlYy5jYWxsKHBpcGVsaW5lKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMS5kZWZhdWx0KShwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4ZWNSZXN1bHQgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhlY1Jlc3VsdCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQaXBlbGluZSBjYW5ub3QgYmUgdXNlZCB0byBzZW5kIGFueSBjb21tYW5kcyB3aGVuIHRoZSBgZXhlYygpYCBoYXMgYmVlbiBjYWxsZWQgb24gaXQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXhlY1Jlc3VsdFswXSkge1xuICAgICAgICAgICAgICAgICAgICBleGVjUmVzdWx0WzBdLnByZXZpb3VzRXJyb3JzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdFtpXVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWNSZXN1bHRbMF0ucHJldmlvdXNFcnJvcnMucHVzaChyZXN1bHRbaV1bMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGV4ZWNSZXN1bHRbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS53cmFwTXVsdGlSZXN1bHQpKGV4ZWNSZXN1bHRbMV0pO1xuICAgICAgICAgICAgfSksIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB7IGV4ZWNCdWZmZXIgfSA9IHBpcGVsaW5lO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHBpcGVsaW5lLmV4ZWNCdWZmZXIgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbnMgPiAwKSB7XG4gICAgICAgICAgICAgICAgZXhlY0J1ZmZlci5jYWxsKHBpcGVsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwaXBlbGluZS5leGVjKGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBpcGVsaW5lO1xuICAgIH07XG4gICAgY29uc3QgeyBleGVjIH0gPSByZWRpcztcbiAgICByZWRpcy5leGVjID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiAoMCwgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMS5kZWZhdWx0KShleGVjLmNhbGwodGhpcykudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0cykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gKDAsIHV0aWxzXzEud3JhcE11bHRpUmVzdWx0KShyZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KSwgY2FsbGJhY2spO1xuICAgIH07XG59XG5leHBvcnRzLmFkZFRyYW5zYWN0aW9uU3VwcG9ydCA9IGFkZFRyYW5zYWN0aW9uU3VwcG9ydDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImFkZFRyYW5zYWN0aW9uU3VwcG9ydCIsInV0aWxzXzEiLCJyZXF1aXJlIiwic3RhbmRhcmRfYXNfY2FsbGJhY2tfMSIsIlBpcGVsaW5lXzEiLCJyZWRpcyIsInBpcGVsaW5lIiwiY29tbWFuZHMiLCJkZWZhdWx0IiwiQXJyYXkiLCJpc0FycmF5IiwiYWRkQmF0Y2giLCJtdWx0aSIsIm9wdGlvbnMiLCJjYWxsIiwiZXhlYyIsImNhbGxiYWNrIiwiaXNDbHVzdGVyIiwic2xvdHMiLCJsZW5ndGgiLCJzdGF0dXMiLCJjb25uZWN0IiwiY2F0Y2giLCJub29wIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJkZWxheVVudGlsUmVhZHkiLCJlcnIiLCJ0aGVuIiwiX3RyYW5zYWN0aW9ucyIsIm5vZGVpZmllZFByb21pc2UiLCJwcm9taXNlIiwicmVzdWx0IiwiZXhlY1Jlc3VsdCIsIkVycm9yIiwicHJldmlvdXNFcnJvcnMiLCJpIiwicHVzaCIsIndyYXBNdWx0aVJlc3VsdCIsImV4ZWNCdWZmZXIiLCJyZXN1bHRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/transaction.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/utils/Commander.js":
/*!*******************************************************!*\
  !*** ./node_modules/ioredis/built/utils/Commander.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst commands_1 = __webpack_require__(/*! @ioredis/commands */ \"(rsc)/./node_modules/@ioredis/commands/built/index.js\");\nconst autoPipelining_1 = __webpack_require__(/*! ../autoPipelining */ \"(rsc)/./node_modules/ioredis/built/autoPipelining.js\");\nconst Command_1 = __webpack_require__(/*! ../Command */ \"(rsc)/./node_modules/ioredis/built/Command.js\");\nconst Script_1 = __webpack_require__(/*! ../Script */ \"(rsc)/./node_modules/ioredis/built/Script.js\");\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nclass Commander {\n    constructor(){\n        this.options = {};\n        /**\n         * @ignore\n         */ this.scriptsSet = {};\n        /**\n         * @ignore\n         */ this.addedBuiltinSet = new Set();\n    }\n    /**\n     * Return supported builtin commands\n     */ getBuiltinCommands() {\n        return commands.slice(0);\n    }\n    /**\n     * Create a builtin command\n     */ createBuiltinCommand(commandName) {\n        return {\n            string: generateFunction(null, commandName, \"utf8\"),\n            buffer: generateFunction(null, commandName, null)\n        };\n    }\n    /**\n     * Create add builtin command\n     */ addBuiltinCommand(commandName) {\n        this.addedBuiltinSet.add(commandName);\n        this[commandName] = generateFunction(commandName, commandName, \"utf8\");\n        this[commandName + \"Buffer\"] = generateFunction(commandName + \"Buffer\", commandName, null);\n    }\n    /**\n     * Define a custom command using lua script\n     */ defineCommand(name, definition) {\n        const script = new Script_1.default(definition.lua, definition.numberOfKeys, this.options.keyPrefix, definition.readOnly);\n        this.scriptsSet[name] = script;\n        this[name] = generateScriptingFunction(name, name, script, \"utf8\");\n        this[name + \"Buffer\"] = generateScriptingFunction(name + \"Buffer\", name, script, null);\n    }\n    /**\n     * @ignore\n     */ sendCommand(command, stream, node) {\n        throw new Error('\"sendCommand\" is not implemented');\n    }\n}\nconst commands = commands_1.list.filter((command)=>command !== \"monitor\");\ncommands.push(\"sentinel\");\ncommands.forEach(function(commandName) {\n    Commander.prototype[commandName] = generateFunction(commandName, commandName, \"utf8\");\n    Commander.prototype[commandName + \"Buffer\"] = generateFunction(commandName + \"Buffer\", commandName, null);\n});\nCommander.prototype.call = generateFunction(\"call\", \"utf8\");\nCommander.prototype.callBuffer = generateFunction(\"callBuffer\", null);\n// @ts-expect-error\nCommander.prototype.send_command = Commander.prototype.call;\nfunction generateFunction(functionName, _commandName, _encoding) {\n    if (typeof _encoding === \"undefined\") {\n        _encoding = _commandName;\n        _commandName = null;\n    }\n    return function(...args) {\n        const commandName = _commandName || args.shift();\n        let callback = args[args.length - 1];\n        if (typeof callback === \"function\") {\n            args.pop();\n        } else {\n            callback = undefined;\n        }\n        const options = {\n            errorStack: this.options.showFriendlyErrorStack ? new Error() : undefined,\n            keyPrefix: this.options.keyPrefix,\n            replyEncoding: _encoding\n        };\n        // No auto pipeline, use regular command sending\n        if (!(0, autoPipelining_1.shouldUseAutoPipelining)(this, functionName, commandName)) {\n            return this.sendCommand(// @ts-expect-error\n            new Command_1.default(commandName, args, options, callback));\n        }\n        // Create a new pipeline and make sure it's scheduled\n        return (0, autoPipelining_1.executeWithAutoPipelining)(this, functionName, commandName, // @ts-expect-error\n        args, callback);\n    };\n}\nfunction generateScriptingFunction(functionName, commandName, script, encoding) {\n    return function(...args) {\n        const callback = typeof args[args.length - 1] === \"function\" ? args.pop() : undefined;\n        const options = {\n            replyEncoding: encoding\n        };\n        if (this.options.showFriendlyErrorStack) {\n            options.errorStack = new Error();\n        }\n        // No auto pipeline, use regular command sending\n        if (!(0, autoPipelining_1.shouldUseAutoPipelining)(this, functionName, commandName)) {\n            return script.execute(this, args, options, callback);\n        }\n        // Create a new pipeline and make sure it's scheduled\n        return (0, autoPipelining_1.executeWithAutoPipelining)(this, functionName, commandName, args, callback);\n    };\n}\nexports[\"default\"] = Commander;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC91dGlscy9Db21tYW5kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsYUFBYUMsbUJBQU9BLENBQUMsZ0ZBQW1CO0FBQzlDLE1BQU1DLG1CQUFtQkQsbUJBQU9BLENBQUMsK0VBQW1CO0FBQ3BELE1BQU1FLFlBQVlGLG1CQUFPQSxDQUFDLGlFQUFZO0FBQ3RDLE1BQU1HLFdBQVdILG1CQUFPQSxDQUFDLCtEQUFXO0FBQ3BDLDZEQUE2RDtBQUM3RCxNQUFNSTtJQUNGQyxhQUFjO1FBQ1YsSUFBSSxDQUFDQyxPQUFPLEdBQUcsQ0FBQztRQUNoQjs7U0FFQyxHQUNELElBQUksQ0FBQ0MsVUFBVSxHQUFHLENBQUM7UUFDbkI7O1NBRUMsR0FDRCxJQUFJLENBQUNDLGVBQWUsR0FBRyxJQUFJQztJQUMvQjtJQUNBOztLQUVDLEdBQ0RDLHFCQUFxQjtRQUNqQixPQUFPQyxTQUFTQyxLQUFLLENBQUM7SUFDMUI7SUFDQTs7S0FFQyxHQUNEQyxxQkFBcUJDLFdBQVcsRUFBRTtRQUM5QixPQUFPO1lBQ0hDLFFBQVFDLGlCQUFpQixNQUFNRixhQUFhO1lBQzVDRyxRQUFRRCxpQkFBaUIsTUFBTUYsYUFBYTtRQUNoRDtJQUNKO0lBQ0E7O0tBRUMsR0FDREksa0JBQWtCSixXQUFXLEVBQUU7UUFDM0IsSUFBSSxDQUFDTixlQUFlLENBQUNXLEdBQUcsQ0FBQ0w7UUFDekIsSUFBSSxDQUFDQSxZQUFZLEdBQUdFLGlCQUFpQkYsYUFBYUEsYUFBYTtRQUMvRCxJQUFJLENBQUNBLGNBQWMsU0FBUyxHQUFHRSxpQkFBaUJGLGNBQWMsVUFBVUEsYUFBYTtJQUN6RjtJQUNBOztLQUVDLEdBQ0RNLGNBQWNDLElBQUksRUFBRUMsVUFBVSxFQUFFO1FBQzVCLE1BQU1DLFNBQVMsSUFBSXBCLFNBQVNxQixPQUFPLENBQUNGLFdBQVdHLEdBQUcsRUFB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aUJzRCx1QkFBdUIsRUFBRSxJQUFJLEVBQUVaLGNBQWM3QixjQUFjO1lBQ2pGLE9BQU9TLE9BQU9tQyxPQUFPLENBQUMsSUFBSSxFQUFFWixNQUFNeEMsU0FBUzBDO1FBQy9DO1FBQ0EscURBQXFEO1FBQ3JELE9BQU8sQ0FBQyxHQUFHL0MsaUJBQWlCdUQseUJBQXlCLEVBQUUsSUFBSSxFQUFFYixjQUFjN0IsYUFBYWdDLE1BQU1FO0lBQ2xHO0FBQ0o7QUFDQW5ELGtCQUFlLEdBQUdPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvdXRpbHMvQ29tbWFuZGVyLmpzPzljOWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb21tYW5kc18xID0gcmVxdWlyZShcIkBpb3JlZGlzL2NvbW1hbmRzXCIpO1xuY29uc3QgYXV0b1BpcGVsaW5pbmdfMSA9IHJlcXVpcmUoXCIuLi9hdXRvUGlwZWxpbmluZ1wiKTtcbmNvbnN0IENvbW1hbmRfMSA9IHJlcXVpcmUoXCIuLi9Db21tYW5kXCIpO1xuY29uc3QgU2NyaXB0XzEgPSByZXF1aXJlKFwiLi4vU2NyaXB0XCIpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuY2xhc3MgQ29tbWFuZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaWdub3JlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjcmlwdHNTZXQgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpZ25vcmVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWRkZWRCdWlsdGluU2V0ID0gbmV3IFNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gc3VwcG9ydGVkIGJ1aWx0aW4gY29tbWFuZHNcbiAgICAgKi9cbiAgICBnZXRCdWlsdGluQ29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zbGljZSgwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgYnVpbHRpbiBjb21tYW5kXG4gICAgICovXG4gICAgY3JlYXRlQnVpbHRpbkNvbW1hbmQoY29tbWFuZE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0cmluZzogZ2VuZXJhdGVGdW5jdGlvbihudWxsLCBjb21tYW5kTmFtZSwgXCJ1dGY4XCIpLFxuICAgICAgICAgICAgYnVmZmVyOiBnZW5lcmF0ZUZ1bmN0aW9uKG51bGwsIGNvbW1hbmROYW1lLCBudWxsKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFkZCBidWlsdGluIGNvbW1hbmRcbiAgICAgKi9cbiAgICBhZGRCdWlsdGluQ29tbWFuZChjb21tYW5kTmFtZSkge1xuICAgICAgICB0aGlzLmFkZGVkQnVpbHRpblNldC5hZGQoY29tbWFuZE5hbWUpO1xuICAgICAgICB0aGlzW2NvbW1hbmROYW1lXSA9IGdlbmVyYXRlRnVuY3Rpb24oY29tbWFuZE5hbWUsIGNvbW1hbmROYW1lLCBcInV0ZjhcIik7XG4gICAgICAgIHRoaXNbY29tbWFuZE5hbWUgKyBcIkJ1ZmZlclwiXSA9IGdlbmVyYXRlRnVuY3Rpb24oY29tbWFuZE5hbWUgKyBcIkJ1ZmZlclwiLCBjb21tYW5kTmFtZSwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZSBhIGN1c3RvbSBjb21tYW5kIHVzaW5nIGx1YSBzY3JpcHRcbiAgICAgKi9cbiAgICBkZWZpbmVDb21tYW5kKG5hbWUsIGRlZmluaXRpb24pIHtcbiAgICAgICAgY29uc3Qgc2NyaXB0ID0gbmV3IFNjcmlwdF8xLmRlZmF1bHQoZGVmaW5pdGlvbi5sdWEsIGRlZmluaXRpb24ubnVtYmVyT2ZLZXlzLCB0aGlzLm9wdGlvbnMua2V5UHJlZml4LCBkZWZpbml0aW9uLnJlYWRPbmx5KTtcbiAgICAgICAgdGhpcy5zY3JpcHRzU2V0W25hbWVdID0gc2NyaXB0O1xuICAgICAgICB0aGlzW25hbWVdID0gZ2VuZXJhdGVTY3JpcHRpbmdGdW5jdGlvbihuYW1lLCBuYW1lLCBzY3JpcHQsIFwidXRmOFwiKTtcbiAgICAgICAgdGhpc1tuYW1lICsgXCJCdWZmZXJcIl0gPSBnZW5lcmF0ZVNjcmlwdGluZ0Z1bmN0aW9uKG5hbWUgKyBcIkJ1ZmZlclwiLCBuYW1lLCBzY3JpcHQsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgc2VuZENvbW1hbmQoY29tbWFuZCwgc3RyZWFtLCBub2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCJzZW5kQ29tbWFuZFwiIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbn1cbmNvbnN0IGNvbW1hbmRzID0gY29tbWFuZHNfMS5saXN0LmZpbHRlcigoY29tbWFuZCkgPT4gY29tbWFuZCAhPT0gXCJtb25pdG9yXCIpO1xuY29tbWFuZHMucHVzaChcInNlbnRpbmVsXCIpO1xuY29tbWFuZHMuZm9yRWFjaChmdW5jdGlvbiAoY29tbWFuZE5hbWUpIHtcbiAgICBDb21tYW5kZXIucHJvdG90eXBlW2NvbW1hbmROYW1lXSA9IGdlbmVyYXRlRnVuY3Rpb24oY29tbWFuZE5hbWUsIGNvbW1hbmROYW1lLCBcInV0ZjhcIik7XG4gICAgQ29tbWFuZGVyLnByb3RvdHlwZVtjb21tYW5kTmFtZSArIFwiQnVmZmVyXCJdID0gZ2VuZXJhdGVGdW5jdGlvbihjb21tYW5kTmFtZSArIFwiQnVmZmVyXCIsIGNvbW1hbmROYW1lLCBudWxsKTtcbn0pO1xuQ29tbWFuZGVyLnByb3RvdHlwZS5jYWxsID0gZ2VuZXJhdGVGdW5jdGlvbihcImNhbGxcIiwgXCJ1dGY4XCIpO1xuQ29tbWFuZGVyLnByb3RvdHlwZS5jYWxsQnVmZmVyID0gZ2VuZXJhdGVGdW5jdGlvbihcImNhbGxCdWZmZXJcIiwgbnVsbCk7XG4vLyBAdHMtZXhwZWN0LWVycm9yXG5Db21tYW5kZXIucHJvdG90eXBlLnNlbmRfY29tbWFuZCA9IENvbW1hbmRlci5wcm90b3R5cGUuY2FsbDtcbmZ1bmN0aW9uIGdlbmVyYXRlRnVuY3Rpb24oZnVuY3Rpb25OYW1lLCBfY29tbWFuZE5hbWUsIF9lbmNvZGluZykge1xuICAgIGlmICh0eXBlb2YgX2VuY29kaW5nID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIF9lbmNvZGluZyA9IF9jb21tYW5kTmFtZTtcbiAgICAgICAgX2NvbW1hbmROYW1lID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGNvbW1hbmROYW1lID0gKF9jb21tYW5kTmFtZSB8fCBhcmdzLnNoaWZ0KCkpO1xuICAgICAgICBsZXQgY2FsbGJhY2sgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgYXJncy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBlcnJvclN0YWNrOiB0aGlzLm9wdGlvbnMuc2hvd0ZyaWVuZGx5RXJyb3JTdGFjayA/IG5ldyBFcnJvcigpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAga2V5UHJlZml4OiB0aGlzLm9wdGlvbnMua2V5UHJlZml4LFxuICAgICAgICAgICAgcmVwbHlFbmNvZGluZzogX2VuY29kaW5nLFxuICAgICAgICB9O1xuICAgICAgICAvLyBObyBhdXRvIHBpcGVsaW5lLCB1c2UgcmVndWxhciBjb21tYW5kIHNlbmRpbmdcbiAgICAgICAgaWYgKCEoMCwgYXV0b1BpcGVsaW5pbmdfMS5zaG91bGRVc2VBdXRvUGlwZWxpbmluZykodGhpcywgZnVuY3Rpb25OYW1lLCBjb21tYW5kTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRDb21tYW5kKFxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgbmV3IENvbW1hbmRfMS5kZWZhdWx0KGNvbW1hbmROYW1lLCBhcmdzLCBvcHRpb25zLCBjYWxsYmFjaykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBwaXBlbGluZSBhbmQgbWFrZSBzdXJlIGl0J3Mgc2NoZWR1bGVkXG4gICAgICAgIHJldHVybiAoMCwgYXV0b1BpcGVsaW5pbmdfMS5leGVjdXRlV2l0aEF1dG9QaXBlbGluaW5nKSh0aGlzLCBmdW5jdGlvbk5hbWUsIGNvbW1hbmROYW1lLCBcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBhcmdzLCBjYWxsYmFjayk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlU2NyaXB0aW5nRnVuY3Rpb24oZnVuY3Rpb25OYW1lLCBjb21tYW5kTmFtZSwgc2NyaXB0LCBlbmNvZGluZykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09IFwiZnVuY3Rpb25cIiA/IGFyZ3MucG9wKCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICByZXBseUVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaG93RnJpZW5kbHlFcnJvclN0YWNrKSB7XG4gICAgICAgICAgICBvcHRpb25zLmVycm9yU3RhY2sgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBObyBhdXRvIHBpcGVsaW5lLCB1c2UgcmVndWxhciBjb21tYW5kIHNlbmRpbmdcbiAgICAgICAgaWYgKCEoMCwgYXV0b1BpcGVsaW5pbmdfMS5zaG91bGRVc2VBdXRvUGlwZWxpbmluZykodGhpcywgZnVuY3Rpb25OYW1lLCBjb21tYW5kTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzY3JpcHQuZXhlY3V0ZSh0aGlzLCBhcmdzLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHBpcGVsaW5lIGFuZCBtYWtlIHN1cmUgaXQncyBzY2hlZHVsZWRcbiAgICAgICAgcmV0dXJuICgwLCBhdXRvUGlwZWxpbmluZ18xLmV4ZWN1dGVXaXRoQXV0b1BpcGVsaW5pbmcpKHRoaXMsIGZ1bmN0aW9uTmFtZSwgY29tbWFuZE5hbWUsIGFyZ3MsIGNhbGxiYWNrKTtcbiAgICB9O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ29tbWFuZGVyO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY29tbWFuZHNfMSIsInJlcXVpcmUiLCJhdXRvUGlwZWxpbmluZ18xIiwiQ29tbWFuZF8xIiwiU2NyaXB0XzEiLCJDb21tYW5kZXIiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJzY3JpcHRzU2V0IiwiYWRkZWRCdWlsdGluU2V0IiwiU2V0IiwiZ2V0QnVpbHRpbkNvbW1hbmRzIiwiY29tbWFuZHMiLCJzbGljZSIsImNyZWF0ZUJ1aWx0aW5Db21tYW5kIiwiY29tbWFuZE5hbWUiLCJzdHJpbmciLCJnZW5lcmF0ZUZ1bmN0aW9uIiwiYnVmZmVyIiwiYWRkQnVpbHRpbkNvbW1hbmQiLCJhZGQiLCJkZWZpbmVDb21tYW5kIiwibmFtZSIsImRlZmluaXRpb24iLCJzY3JpcHQiLCJkZWZhdWx0IiwibHVhIiwibnVtYmVyT2ZLZXlzIiwia2V5UHJlZml4IiwicmVhZE9ubHkiLCJnZW5lcmF0ZVNjcmlwdGluZ0Z1bmN0aW9uIiwic2VuZENvbW1hbmQiLCJjb21tYW5kIiwic3RyZWFtIiwibm9kZSIsIkVycm9yIiwibGlzdCIsImZpbHRlciIsInB1c2giLCJmb3JFYWNoIiwicHJvdG90eXBlIiwiY2FsbCIsImNhbGxCdWZmZXIiLCJzZW5kX2NvbW1hbmQiLCJmdW5jdGlvbk5hbWUiLCJfY29tbWFuZE5hbWUiLCJfZW5jb2RpbmciLCJhcmdzIiwic2hpZnQiLCJjYWxsYmFjayIsImxlbmd0aCIsInBvcCIsInVuZGVmaW5lZCIsImVycm9yU3RhY2siLCJzaG93RnJpZW5kbHlFcnJvclN0YWNrIiwicmVwbHlFbmNvZGluZyIsInNob3VsZFVzZUF1dG9QaXBlbGluaW5nIiwiZXhlY3V0ZVdpdGhBdXRvUGlwZWxpbmluZyIsImVuY29kaW5nIiwiZXhlY3V0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/utils/Commander.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/utils/applyMixin.js":
/*!********************************************************!*\
  !*** ./node_modules/ioredis/built/utils/applyMixin.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction applyMixin(derivedConstructor, mixinConstructor) {\n    Object.getOwnPropertyNames(mixinConstructor.prototype).forEach((name)=>{\n        Object.defineProperty(derivedConstructor.prototype, name, Object.getOwnPropertyDescriptor(mixinConstructor.prototype, name));\n    });\n}\nexports[\"default\"] = applyMixin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC91dGlscy9hcHBseU1peGluLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELFNBQVNDLFdBQVdDLGtCQUFrQixFQUFFQyxnQkFBZ0I7SUFDcEROLE9BQU9PLG1CQUFtQixDQUFDRCxpQkFBaUJFLFNBQVMsRUFBRUMsT0FBTyxDQUFDLENBQUNDO1FBQzVEVixPQUFPQyxjQUFjLENBQUNJLG1CQUFtQkcsU0FBUyxFQUFFRSxNQUFNVixPQUFPVyx3QkFBd0IsQ0FBQ0wsaUJBQWlCRSxTQUFTLEVBQUVFO0lBQzFIO0FBQ0o7QUFDQVIsa0JBQWUsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC91dGlscy9hcHBseU1peGluLmpzPzg3YzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBhcHBseU1peGluKGRlcml2ZWRDb25zdHJ1Y3RvciwgbWl4aW5Db25zdHJ1Y3Rvcikge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG1peGluQ29uc3RydWN0b3IucHJvdG90eXBlKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXJpdmVkQ29uc3RydWN0b3IucHJvdG90eXBlLCBuYW1lLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG1peGluQ29uc3RydWN0b3IucHJvdG90eXBlLCBuYW1lKSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBhcHBseU1peGluO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYXBwbHlNaXhpbiIsImRlcml2ZWRDb25zdHJ1Y3RvciIsIm1peGluQ29uc3RydWN0b3IiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwicHJvdG90eXBlIiwiZm9yRWFjaCIsIm5hbWUiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/utils/applyMixin.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/utils/debug.js":
/*!***************************************************!*\
  !*** ./node_modules/ioredis/built/utils/debug.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.genRedactedString = exports.getStringValue = exports.MAX_ARGUMENT_LENGTH = void 0;\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\");\nconst MAX_ARGUMENT_LENGTH = 200;\nexports.MAX_ARGUMENT_LENGTH = MAX_ARGUMENT_LENGTH;\nconst NAMESPACE_PREFIX = \"ioredis\";\n/**\n * helper function that tried to get a string value for\n * arbitrary \"debug\" arg\n */ function getStringValue(v) {\n    if (v === null) {\n        return;\n    }\n    switch(typeof v){\n        case \"boolean\":\n            return;\n        case \"number\":\n            return;\n        case \"object\":\n            if (Buffer.isBuffer(v)) {\n                return v.toString(\"hex\");\n            }\n            if (Array.isArray(v)) {\n                return v.join(\",\");\n            }\n            try {\n                return JSON.stringify(v);\n            } catch (e) {\n                return;\n            }\n        case \"string\":\n            return v;\n    }\n}\nexports.getStringValue = getStringValue;\n/**\n * helper function that redacts a string representation of a \"debug\" arg\n */ function genRedactedString(str, maxLen) {\n    const { length } = str;\n    return length <= maxLen ? str : str.slice(0, maxLen) + ' ... <REDACTED full-length=\"' + length + '\">';\n}\nexports.genRedactedString = genRedactedString;\n/**\n * a wrapper for the `debug` module, used to generate\n * \"debug functions\" that trim the values in their output\n */ function genDebugFunction(namespace) {\n    const fn = (0, debug_1.default)(`${NAMESPACE_PREFIX}:${namespace}`);\n    function wrappedDebug(...args) {\n        if (!fn.enabled) {\n            return; // no-op\n        }\n        // we skip the first arg because that is the message\n        for(let i = 1; i < args.length; i++){\n            const str = getStringValue(args[i]);\n            if (typeof str === \"string\" && str.length > MAX_ARGUMENT_LENGTH) {\n                args[i] = genRedactedString(str, MAX_ARGUMENT_LENGTH);\n            }\n        }\n        return fn.apply(null, args);\n    }\n    Object.defineProperties(wrappedDebug, {\n        namespace: {\n            get () {\n                return fn.namespace;\n            }\n        },\n        enabled: {\n            get () {\n                return fn.enabled;\n            }\n        },\n        destroy: {\n            get () {\n                return fn.destroy;\n            }\n        },\n        log: {\n            get () {\n                return fn.log;\n            },\n            set (l) {\n                fn.log = l;\n            }\n        }\n    });\n    return wrappedDebug;\n}\nexports[\"default\"] = genDebugFunction;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC91dGlscy9kZWJ1Zy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQseUJBQXlCLEdBQUdBLHNCQUFzQixHQUFHQSwyQkFBMkIsR0FBRyxLQUFLO0FBQ3hGLE1BQU1LLFVBQVVDLG1CQUFPQSxDQUFDLHNEQUFPO0FBQy9CLE1BQU1GLHNCQUFzQjtBQUM1QkosMkJBQTJCLEdBQUdJO0FBQzlCLE1BQU1HLG1CQUFtQjtBQUN6Qjs7O0NBR0MsR0FDRCxTQUFTSixlQUFlSyxDQUFDO0lBQ3JCLElBQUlBLE1BQU0sTUFBTTtRQUNaO0lBQ0o7SUFDQSxPQUFRLE9BQU9BO1FBQ1gsS0FBSztZQUNEO1FBQ0osS0FBSztZQUNEO1FBQ0osS0FBSztZQUNELElBQUlDLE9BQU9DLFFBQVEsQ0FBQ0YsSUFBSTtnQkFDcEIsT0FBT0EsRUFBRUcsUUFBUSxDQUFDO1lBQ3RCO1lBQ0EsSUFBSUMsTUFBTUMsT0FBTyxDQUFDTCxJQUFJO2dCQUNsQixPQUFPQSxFQUFFTSxJQUFJLENBQUM7WUFDbEI7WUFDQSxJQUFJO2dCQUNBLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQ1I7WUFDMUIsRUFDQSxPQUFPUyxHQUFHO2dCQUNOO1lBQ0o7UUFDSixLQUFLO1lBQ0QsT0FBT1Q7SUFDZjtBQUNKO0FBQ0FSLHNCQUFzQixHQUFHRztBQUN6Qjs7Q0FFQyxHQUNELFNBQVNELGtCQUFrQmdCLEdBQUcsRUFBRUMsTUFBTTtJQUNsQyxNQUFNLEVBQUVDLE1BQU0sRUFBRSxHQUFHRjtJQUNuQixPQUFPRSxVQUFVRCxTQUNYRCxNQUNBQSxJQUFJRyxLQUFLLENBQUMsR0FBR0YsVUFBVSxpQ0FBaUNDLFNBQVM7QUFDM0U7QUFDQXBCLHlCQUF5QixHQUFHRTtBQUM1Qjs7O0NBR0MsR0FDRCxTQUFTb0IsaUJBQWlCQyxTQUFTO0lBQy9CLE1BQU1DLEtBQUssQ0FBQyxHQUFHbkIsUUFBUW9CLE9BQU8sRUFBRSxDQUFDLEVBQUVsQixpQkFBaUIsQ0FBQyxFQUFFZ0IsVUFBVSxDQUFDO0lBQ2xFLFNBQVNHLGFBQWEsR0FBR0MsSUFBSTtRQUN6QixJQUFJLENBQUNILEdBQUdJLE9BQU8sRUFBRTtZQUNiLFFBQVEsUUFBUTtRQUNwQjtRQUNBLG9EQUFvRDtRQUNwRCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsS0FBS1AsTUFBTSxFQUFFUyxJQUFLO1lBQ2xDLE1BQU1YLE1BQU1mLGVBQWV3QixJQUFJLENBQUNFLEVBQUU7WUFDbEMsSUFBSSxPQUFPWCxRQUFRLFlBQVlBLElBQUlFLE1BQU0sR0FBR2hCLHFCQUFxQjtnQkFDN0R1QixJQUFJLENBQUNFLEVBQUUsR0FBRzNCLGtCQUFrQmdCLEtBQUtkO1lBQ3JDO1FBQ0o7UUFDQSxPQUFPb0IsR0FBR00sS0FBSyxDQUFDLE1BQU1IO0lBQzFCO0lBQ0E3QixPQUFPaUMsZ0JBQWdCLENBQUNMLGNBQWM7UUFDbENILFdBQVc7WUFDUFM7Z0JBQ0ksT0FBT1IsR0FBR0QsU0FBUztZQUN2QjtRQUNKO1FBQ0FLLFNBQVM7WUFDTEk7Z0JBQ0ksT0FBT1IsR0FBR0ksT0FBTztZQUNyQjtRQUNKO1FBQ0FLLFNBQVM7WUFDTEQ7Z0JBQ0ksT0FBT1IsR0FBR1MsT0FBTztZQUNyQjtRQUNKO1FBQ0FDLEtBQUs7WUFDREY7Z0JBQ0ksT0FBT1IsR0FBR1UsR0FBRztZQUNqQjtZQUNBQyxLQUFJQyxDQUFDO2dCQUNEWixHQUFHVSxHQUFHLEdBQUdFO1lBQ2I7UUFDSjtJQUNKO0lBQ0EsT0FBT1Y7QUFDWDtBQUNBMUIsa0JBQWUsR0FBR3NCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvdXRpbHMvZGVidWcuanM/MDQ3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2VuUmVkYWN0ZWRTdHJpbmcgPSBleHBvcnRzLmdldFN0cmluZ1ZhbHVlID0gZXhwb3J0cy5NQVhfQVJHVU1FTlRfTEVOR1RIID0gdm9pZCAwO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IE1BWF9BUkdVTUVOVF9MRU5HVEggPSAyMDA7XG5leHBvcnRzLk1BWF9BUkdVTUVOVF9MRU5HVEggPSBNQVhfQVJHVU1FTlRfTEVOR1RIO1xuY29uc3QgTkFNRVNQQUNFX1BSRUZJWCA9IFwiaW9yZWRpc1wiO1xuLyoqXG4gKiBoZWxwZXIgZnVuY3Rpb24gdGhhdCB0cmllZCB0byBnZXQgYSBzdHJpbmcgdmFsdWUgZm9yXG4gKiBhcmJpdHJhcnkgXCJkZWJ1Z1wiIGFyZ1xuICovXG5mdW5jdGlvbiBnZXRTdHJpbmdWYWx1ZSh2KSB7XG4gICAgaWYgKHYgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2LnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdi5qb2luKFwiLFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0U3RyaW5nVmFsdWUgPSBnZXRTdHJpbmdWYWx1ZTtcbi8qKlxuICogaGVscGVyIGZ1bmN0aW9uIHRoYXQgcmVkYWN0cyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIFwiZGVidWdcIiBhcmdcbiAqL1xuZnVuY3Rpb24gZ2VuUmVkYWN0ZWRTdHJpbmcoc3RyLCBtYXhMZW4pIHtcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gc3RyO1xuICAgIHJldHVybiBsZW5ndGggPD0gbWF4TGVuXG4gICAgICAgID8gc3RyXG4gICAgICAgIDogc3RyLnNsaWNlKDAsIG1heExlbikgKyAnIC4uLiA8UkVEQUNURUQgZnVsbC1sZW5ndGg9XCInICsgbGVuZ3RoICsgJ1wiPic7XG59XG5leHBvcnRzLmdlblJlZGFjdGVkU3RyaW5nID0gZ2VuUmVkYWN0ZWRTdHJpbmc7XG4vKipcbiAqIGEgd3JhcHBlciBmb3IgdGhlIGBkZWJ1Z2AgbW9kdWxlLCB1c2VkIHRvIGdlbmVyYXRlXG4gKiBcImRlYnVnIGZ1bmN0aW9uc1wiIHRoYXQgdHJpbSB0aGUgdmFsdWVzIGluIHRoZWlyIG91dHB1dFxuICovXG5mdW5jdGlvbiBnZW5EZWJ1Z0Z1bmN0aW9uKG5hbWVzcGFjZSkge1xuICAgIGNvbnN0IGZuID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoYCR7TkFNRVNQQUNFX1BSRUZJWH06JHtuYW1lc3BhY2V9YCk7XG4gICAgZnVuY3Rpb24gd3JhcHBlZERlYnVnKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKCFmbi5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIG5vLW9wXG4gICAgICAgIH1cbiAgICAgICAgLy8gd2Ugc2tpcCB0aGUgZmlyc3QgYXJnIGJlY2F1c2UgdGhhdCBpcyB0aGUgbWVzc2FnZVxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHN0ciA9IGdldFN0cmluZ1ZhbHVlKGFyZ3NbaV0pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHIgPT09IFwic3RyaW5nXCIgJiYgc3RyLmxlbmd0aCA+IE1BWF9BUkdVTUVOVF9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICBhcmdzW2ldID0gZ2VuUmVkYWN0ZWRTdHJpbmcoc3RyLCBNQVhfQVJHVU1FTlRfTEVOR1RIKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHdyYXBwZWREZWJ1Zywge1xuICAgICAgICBuYW1lc3BhY2U6IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4ubmFtZXNwYWNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZW5hYmxlZDoge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5lbmFibGVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveToge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5kZXN0cm95O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgbG9nOiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmxvZztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQobCkge1xuICAgICAgICAgICAgICAgIGZuLmxvZyA9IGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiB3cmFwcGVkRGVidWc7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBnZW5EZWJ1Z0Z1bmN0aW9uO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2VuUmVkYWN0ZWRTdHJpbmciLCJnZXRTdHJpbmdWYWx1ZSIsIk1BWF9BUkdVTUVOVF9MRU5HVEgiLCJkZWJ1Z18xIiwicmVxdWlyZSIsIk5BTUVTUEFDRV9QUkVGSVgiLCJ2IiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJ0b1N0cmluZyIsIkFycmF5IiwiaXNBcnJheSIsImpvaW4iLCJKU09OIiwic3RyaW5naWZ5IiwiZSIsInN0ciIsIm1heExlbiIsImxlbmd0aCIsInNsaWNlIiwiZ2VuRGVidWdGdW5jdGlvbiIsIm5hbWVzcGFjZSIsImZuIiwiZGVmYXVsdCIsIndyYXBwZWREZWJ1ZyIsImFyZ3MiLCJlbmFibGVkIiwiaSIsImFwcGx5IiwiZGVmaW5lUHJvcGVydGllcyIsImdldCIsImRlc3Ryb3kiLCJsb2ciLCJzZXQiLCJsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/utils/debug.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/utils/index.js":
/*!***************************************************!*\
  !*** ./node_modules/ioredis/built/utils/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.noop = exports.defaults = exports.Debug = exports.zipMap = exports.CONNECTION_CLOSED_ERROR_MSG = exports.shuffle = exports.sample = exports.resolveTLSProfile = exports.parseURL = exports.optimizeErrorStack = exports.toArg = exports.convertMapToArray = exports.convertObjectToArray = exports.timeout = exports.packObject = exports.isInt = exports.wrapMultiResult = exports.convertBufferToString = void 0;\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst lodash_1 = __webpack_require__(/*! ./lodash */ \"(rsc)/./node_modules/ioredis/built/utils/lodash.js\");\nObject.defineProperty(exports, \"defaults\", ({\n    enumerable: true,\n    get: function() {\n        return lodash_1.defaults;\n    }\n}));\nObject.defineProperty(exports, \"noop\", ({\n    enumerable: true,\n    get: function() {\n        return lodash_1.noop;\n    }\n}));\nconst debug_1 = __webpack_require__(/*! ./debug */ \"(rsc)/./node_modules/ioredis/built/utils/debug.js\");\nexports.Debug = debug_1.default;\nconst TLSProfiles_1 = __webpack_require__(/*! ../constants/TLSProfiles */ \"(rsc)/./node_modules/ioredis/built/constants/TLSProfiles.js\");\n/**\n * Convert a buffer to string, supports buffer array\n *\n * @example\n * ```js\n * const input = [Buffer.from('foo'), [Buffer.from('bar')]]\n * const res = convertBufferToString(input, 'utf8')\n * expect(res).to.eql(['foo', ['bar']])\n * ```\n */ function convertBufferToString(value, encoding) {\n    if (value instanceof Buffer) {\n        return value.toString(encoding);\n    }\n    if (Array.isArray(value)) {\n        const length = value.length;\n        const res = Array(length);\n        for(let i = 0; i < length; ++i){\n            res[i] = value[i] instanceof Buffer && encoding === \"utf8\" ? value[i].toString() : convertBufferToString(value[i], encoding);\n        }\n        return res;\n    }\n    return value;\n}\nexports.convertBufferToString = convertBufferToString;\n/**\n * Convert a list of results to node-style\n *\n * @example\n * ```js\n * const input = ['a', 'b', new Error('c'), 'd']\n * const output = exports.wrapMultiResult(input)\n * expect(output).to.eql([[null, 'a'], [null, 'b'], [new Error('c')], [null, 'd'])\n * ```\n */ function wrapMultiResult(arr) {\n    // When using WATCH/EXEC transactions, the EXEC will return\n    // a null instead of an array\n    if (!arr) {\n        return null;\n    }\n    const result = [];\n    const length = arr.length;\n    for(let i = 0; i < length; ++i){\n        const item = arr[i];\n        if (item instanceof Error) {\n            result.push([\n                item\n            ]);\n        } else {\n            result.push([\n                null,\n                item\n            ]);\n        }\n    }\n    return result;\n}\nexports.wrapMultiResult = wrapMultiResult;\n/**\n * Detect if the argument is a int\n * @example\n * ```js\n * > isInt('123')\n * true\n * > isInt('123.3')\n * false\n * > isInt('1x')\n * false\n * > isInt(123)\n * true\n * > isInt(true)\n * false\n * ```\n */ function isInt(value) {\n    const x = parseFloat(value);\n    return !isNaN(value) && (x | 0) === x;\n}\nexports.isInt = isInt;\n/**\n * Pack an array to an Object\n *\n * @example\n * ```js\n * > packObject(['a', 'b', 'c', 'd'])\n * { a: 'b', c: 'd' }\n * ```\n */ function packObject(array) {\n    const result = {};\n    const length = array.length;\n    for(let i = 1; i < length; i += 2){\n        result[array[i - 1]] = array[i];\n    }\n    return result;\n}\nexports.packObject = packObject;\n/**\n * Return a callback with timeout\n */ function timeout(callback, timeout) {\n    let timer = null;\n    const run = function() {\n        if (timer) {\n            clearTimeout(timer);\n            timer = null;\n            callback.apply(this, arguments);\n        }\n    };\n    timer = setTimeout(run, timeout, new Error(\"timeout\"));\n    return run;\n}\nexports.timeout = timeout;\n/**\n * Convert an object to an array\n * @example\n * ```js\n * > convertObjectToArray({ a: '1' })\n * ['a', '1']\n * ```\n */ function convertObjectToArray(obj) {\n    const result = [];\n    const keys = Object.keys(obj); // Object.entries requires node 7+\n    for(let i = 0, l = keys.length; i < l; i++){\n        result.push(keys[i], obj[keys[i]]);\n    }\n    return result;\n}\nexports.convertObjectToArray = convertObjectToArray;\n/**\n * Convert a map to an array\n * @example\n * ```js\n * > convertMapToArray(new Map([[1, '2']]))\n * [1, '2']\n * ```\n */ function convertMapToArray(map) {\n    const result = [];\n    let pos = 0;\n    map.forEach(function(value, key) {\n        result[pos] = key;\n        result[pos + 1] = value;\n        pos += 2;\n    });\n    return result;\n}\nexports.convertMapToArray = convertMapToArray;\n/**\n * Convert a non-string arg to a string\n */ function toArg(arg) {\n    if (arg === null || typeof arg === \"undefined\") {\n        return \"\";\n    }\n    return String(arg);\n}\nexports.toArg = toArg;\n/**\n * Optimize error stack\n *\n * @param error actually error\n * @param friendlyStack the stack that more meaningful\n * @param filterPath only show stacks with the specified path\n */ function optimizeErrorStack(error, friendlyStack, filterPath) {\n    const stacks = friendlyStack.split(\"\\n\");\n    let lines = \"\";\n    let i;\n    for(i = 1; i < stacks.length; ++i){\n        if (stacks[i].indexOf(filterPath) === -1) {\n            break;\n        }\n    }\n    for(let j = i; j < stacks.length; ++j){\n        lines += \"\\n\" + stacks[j];\n    }\n    if (error.stack) {\n        const pos = error.stack.indexOf(\"\\n\");\n        error.stack = error.stack.slice(0, pos) + lines;\n    }\n    return error;\n}\nexports.optimizeErrorStack = optimizeErrorStack;\n/**\n * Parse the redis protocol url\n */ function parseURL(url) {\n    if (isInt(url)) {\n        return {\n            port: url\n        };\n    }\n    let parsed = (0, url_1.parse)(url, true, true);\n    if (!parsed.slashes && url[0] !== \"/\") {\n        url = \"//\" + url;\n        parsed = (0, url_1.parse)(url, true, true);\n    }\n    const options = parsed.query || {};\n    const result = {};\n    if (parsed.auth) {\n        const index = parsed.auth.indexOf(\":\");\n        result.username = index === -1 ? parsed.auth : parsed.auth.slice(0, index);\n        result.password = index === -1 ? \"\" : parsed.auth.slice(index + 1);\n    }\n    if (parsed.pathname) {\n        if (parsed.protocol === \"redis:\" || parsed.protocol === \"rediss:\") {\n            if (parsed.pathname.length > 1) {\n                result.db = parsed.pathname.slice(1);\n            }\n        } else {\n            result.path = parsed.pathname;\n        }\n    }\n    if (parsed.host) {\n        result.host = parsed.hostname;\n    }\n    if (parsed.port) {\n        result.port = parsed.port;\n    }\n    if (typeof options.family === \"string\") {\n        const intFamily = Number.parseInt(options.family, 10);\n        if (!Number.isNaN(intFamily)) {\n            result.family = intFamily;\n        }\n    }\n    (0, lodash_1.defaults)(result, options);\n    return result;\n}\nexports.parseURL = parseURL;\n/**\n * Resolve TLS profile shortcut in connection options\n */ function resolveTLSProfile(options) {\n    let tls = options === null || options === void 0 ? void 0 : options.tls;\n    if (typeof tls === \"string\") tls = {\n        profile: tls\n    };\n    const profile = TLSProfiles_1.default[tls === null || tls === void 0 ? void 0 : tls.profile];\n    if (profile) {\n        tls = Object.assign({}, profile, tls);\n        delete tls.profile;\n        options = Object.assign({}, options, {\n            tls\n        });\n    }\n    return options;\n}\nexports.resolveTLSProfile = resolveTLSProfile;\n/**\n * Get a random element from `array`\n */ function sample(array, from = 0) {\n    const length = array.length;\n    if (from >= length) {\n        return null;\n    }\n    return array[from + Math.floor(Math.random() * (length - from))];\n}\nexports.sample = sample;\n/**\n * Shuffle the array using the Fisher-Yates Shuffle.\n * This method will mutate the original array.\n */ function shuffle(array) {\n    let counter = array.length;\n    // While there are elements in the array\n    while(counter > 0){\n        // Pick a random index\n        const index = Math.floor(Math.random() * counter);\n        // Decrease counter by 1\n        counter--;\n        // And swap the last element with it\n        [array[counter], array[index]] = [\n            array[index],\n            array[counter]\n        ];\n    }\n    return array;\n}\nexports.shuffle = shuffle;\n/**\n * Error message for connection being disconnected\n */ exports.CONNECTION_CLOSED_ERROR_MSG = \"Connection is closed.\";\nfunction zipMap(keys, values) {\n    const map = new Map();\n    keys.forEach((key, index)=>{\n        map.set(key, values[index]);\n    });\n    return map;\n}\nexports.zipMap = zipMap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC91dGlscy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsWUFBWSxHQUFHQSxnQkFBZ0IsR0FBR0EsYUFBYSxHQUFHQSxjQUFjLEdBQUdBLG1DQUFtQyxHQUFHQSxlQUFlLEdBQUdBLGNBQWMsR0FBR0EseUJBQXlCLEdBQUdBLGdCQUFnQixHQUFHQSwwQkFBMEIsR0FBR0EsYUFBYSxHQUFHQSx5QkFBeUIsR0FBR0EsNEJBQTRCLEdBQUdBLGVBQWUsR0FBR0Esa0JBQWtCLEdBQUdBLGFBQWEsR0FBR0EsdUJBQXVCLEdBQUdBLDZCQUE2QixHQUFHLEtBQUs7QUFDelosTUFBTW9CLFFBQVFDLG1CQUFPQSxDQUFDLGdCQUFLO0FBQzNCLE1BQU1DLFdBQVdELG1CQUFPQSxDQUFDLG9FQUFVO0FBQ25DdkIsNENBQTJDO0lBQUV5QixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRixTQUFTbkIsUUFBUTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2hITCx3Q0FBdUM7SUFBRXlCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9GLFNBQVNwQixJQUFJO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDeEcsTUFBTXVCLFVBQVVKLG1CQUFPQSxDQUFDLGtFQUFTO0FBQ2pDckIsYUFBYSxHQUFHeUIsUUFBUUMsT0FBTztBQUMvQixNQUFNQyxnQkFBZ0JOLG1CQUFPQSxDQUFDLDZGQUEwQjtBQUN4RDs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTRixzQkFBc0JsQixLQUFLLEVBQUUyQixRQUFRO0lBQzFDLElBQUkzQixpQkFBaUI0QixRQUFRO1FBQ3pCLE9BQU81QixNQUFNNkIsUUFBUSxDQUFDRjtJQUMxQjtJQUNBLElBQUlHLE1BQU1DLE9BQU8sQ0FBQy9CLFFBQVE7UUFDdEIsTUFBTWdDLFNBQVNoQyxNQUFNZ0MsTUFBTTtRQUMzQixNQUFNQyxNQUFN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QUN4QyxNQUFPa0UsVUFBVSxFQUFHO1FBQ2hCLHNCQUFzQjtRQUN0QixNQUFNcEIsUUFBUWlCLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFLQztRQUN6Qyx3QkFBd0I7UUFDeEJBO1FBQ0Esb0NBQW9DO1FBQ3BDLENBQUN2RCxLQUFLLENBQUN1RCxRQUFRLEVBQUV2RCxLQUFLLENBQUNtQyxNQUFNLENBQUMsR0FBRztZQUFDbkMsS0FBSyxDQUFDbUMsTUFBTTtZQUFFbkMsS0FBSyxDQUFDdUQsUUFBUTtTQUFDO0lBQ25FO0lBQ0EsT0FBT3ZEO0FBQ1g7QUFDQTVDLGVBQWUsR0FBR087QUFDbEI7O0NBRUMsR0FDRFAsbUNBQW1DLEdBQUc7QUFDdEMsU0FBU0ssT0FBT2dELElBQUksRUFBRStDLE1BQU07SUFDeEIsTUFBTTdDLE1BQU0sSUFBSThDO0lBQ2hCaEQsS0FBS0ksT0FBTyxDQUFDLENBQUNDLEtBQUtxQjtRQUNmeEIsSUFBSStDLEdBQUcsQ0FBQzVDLEtBQUswQyxNQUFNLENBQUNyQixNQUFNO0lBQzlCO0lBQ0EsT0FBT3hCO0FBQ1g7QUFDQXZELGNBQWMsR0FBR0siLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC91dGlscy9pbmRleC5qcz85NTJkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ub29wID0gZXhwb3J0cy5kZWZhdWx0cyA9IGV4cG9ydHMuRGVidWcgPSBleHBvcnRzLnppcE1hcCA9IGV4cG9ydHMuQ09OTkVDVElPTl9DTE9TRURfRVJST1JfTVNHID0gZXhwb3J0cy5zaHVmZmxlID0gZXhwb3J0cy5zYW1wbGUgPSBleHBvcnRzLnJlc29sdmVUTFNQcm9maWxlID0gZXhwb3J0cy5wYXJzZVVSTCA9IGV4cG9ydHMub3B0aW1pemVFcnJvclN0YWNrID0gZXhwb3J0cy50b0FyZyA9IGV4cG9ydHMuY29udmVydE1hcFRvQXJyYXkgPSBleHBvcnRzLmNvbnZlcnRPYmplY3RUb0FycmF5ID0gZXhwb3J0cy50aW1lb3V0ID0gZXhwb3J0cy5wYWNrT2JqZWN0ID0gZXhwb3J0cy5pc0ludCA9IGV4cG9ydHMud3JhcE11bHRpUmVzdWx0ID0gZXhwb3J0cy5jb252ZXJ0QnVmZmVyVG9TdHJpbmcgPSB2b2lkIDA7XG5jb25zdCB1cmxfMSA9IHJlcXVpcmUoXCJ1cmxcIik7XG5jb25zdCBsb2Rhc2hfMSA9IHJlcXVpcmUoXCIuL2xvZGFzaFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2Rhc2hfMS5kZWZhdWx0czsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5vb3BcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvZGFzaF8xLm5vb3A7IH0gfSk7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcIi4vZGVidWdcIik7XG5leHBvcnRzLkRlYnVnID0gZGVidWdfMS5kZWZhdWx0O1xuY29uc3QgVExTUHJvZmlsZXNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHMvVExTUHJvZmlsZXNcIik7XG4vKipcbiAqIENvbnZlcnQgYSBidWZmZXIgdG8gc3RyaW5nLCBzdXBwb3J0cyBidWZmZXIgYXJyYXlcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGNvbnN0IGlucHV0ID0gW0J1ZmZlci5mcm9tKCdmb28nKSwgW0J1ZmZlci5mcm9tKCdiYXInKV1dXG4gKiBjb25zdCByZXMgPSBjb252ZXJ0QnVmZmVyVG9TdHJpbmcoaW5wdXQsICd1dGY4JylcbiAqIGV4cGVjdChyZXMpLnRvLmVxbChbJ2ZvbycsIFsnYmFyJ11dKVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRCdWZmZXJUb1N0cmluZyh2YWx1ZSwgZW5jb2RpbmcpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcmVzID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzW2ldID1cbiAgICAgICAgICAgICAgICB2YWx1ZVtpXSBpbnN0YW5jZW9mIEJ1ZmZlciAmJiBlbmNvZGluZyA9PT0gXCJ1dGY4XCJcbiAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZVtpXS50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgIDogY29udmVydEJ1ZmZlclRvU3RyaW5nKHZhbHVlW2ldLCBlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0cy5jb252ZXJ0QnVmZmVyVG9TdHJpbmcgPSBjb252ZXJ0QnVmZmVyVG9TdHJpbmc7XG4vKipcbiAqIENvbnZlcnQgYSBsaXN0IG9mIHJlc3VsdHMgdG8gbm9kZS1zdHlsZVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogY29uc3QgaW5wdXQgPSBbJ2EnLCAnYicsIG5ldyBFcnJvcignYycpLCAnZCddXG4gKiBjb25zdCBvdXRwdXQgPSBleHBvcnRzLndyYXBNdWx0aVJlc3VsdChpbnB1dClcbiAqIGV4cGVjdChvdXRwdXQpLnRvLmVxbChbW251bGwsICdhJ10sIFtudWxsLCAnYiddLCBbbmV3IEVycm9yKCdjJyldLCBbbnVsbCwgJ2QnXSlcbiAqIGBgYFxuICovXG5mdW5jdGlvbiB3cmFwTXVsdGlSZXN1bHQoYXJyKSB7XG4gICAgLy8gV2hlbiB1c2luZyBXQVRDSC9FWEVDIHRyYW5zYWN0aW9ucywgdGhlIEVYRUMgd2lsbCByZXR1cm5cbiAgICAvLyBhIG51bGwgaW5zdGVhZCBvZiBhbiBhcnJheVxuICAgIGlmICghYXJyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBsZW5ndGggPSBhcnIubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGFycltpXTtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW2l0ZW1dKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtudWxsLCBpdGVtXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMud3JhcE11bHRpUmVzdWx0ID0gd3JhcE11bHRpUmVzdWx0O1xuLyoqXG4gKiBEZXRlY3QgaWYgdGhlIGFyZ3VtZW50IGlzIGEgaW50XG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqID4gaXNJbnQoJzEyMycpXG4gKiB0cnVlXG4gKiA+IGlzSW50KCcxMjMuMycpXG4gKiBmYWxzZVxuICogPiBpc0ludCgnMXgnKVxuICogZmFsc2VcbiAqID4gaXNJbnQoMTIzKVxuICogdHJ1ZVxuICogPiBpc0ludCh0cnVlKVxuICogZmFsc2VcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBpc0ludCh2YWx1ZSkge1xuICAgIGNvbnN0IHggPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICByZXR1cm4gIWlzTmFOKHZhbHVlKSAmJiAoeCB8IDApID09PSB4O1xufVxuZXhwb3J0cy5pc0ludCA9IGlzSW50O1xuLyoqXG4gKiBQYWNrIGFuIGFycmF5IHRvIGFuIE9iamVjdFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogPiBwYWNrT2JqZWN0KFsnYScsICdiJywgJ2MnLCAnZCddKVxuICogeyBhOiAnYicsIGM6ICdkJyB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gcGFja09iamVjdChhcnJheSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHJlc3VsdFthcnJheVtpIC0gMV1dID0gYXJyYXlbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnBhY2tPYmplY3QgPSBwYWNrT2JqZWN0O1xuLyoqXG4gKiBSZXR1cm4gYSBjYWxsYmFjayB3aXRoIHRpbWVvdXRcbiAqL1xuZnVuY3Rpb24gdGltZW91dChjYWxsYmFjaywgdGltZW91dCkge1xuICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgY29uc3QgcnVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aW1lciA9IHNldFRpbWVvdXQocnVuLCB0aW1lb3V0LCBuZXcgRXJyb3IoXCJ0aW1lb3V0XCIpKTtcbiAgICByZXR1cm4gcnVuO1xufVxuZXhwb3J0cy50aW1lb3V0ID0gdGltZW91dDtcbi8qKlxuICogQ29udmVydCBhbiBvYmplY3QgdG8gYW4gYXJyYXlcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogPiBjb252ZXJ0T2JqZWN0VG9BcnJheSh7IGE6ICcxJyB9KVxuICogWydhJywgJzEnXVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRPYmplY3RUb0FycmF5KG9iaikge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopOyAvLyBPYmplY3QuZW50cmllcyByZXF1aXJlcyBub2RlIDcrXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5jb252ZXJ0T2JqZWN0VG9BcnJheSA9IGNvbnZlcnRPYmplY3RUb0FycmF5O1xuLyoqXG4gKiBDb252ZXJ0IGEgbWFwIHRvIGFuIGFycmF5XG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqID4gY29udmVydE1hcFRvQXJyYXkobmV3IE1hcChbWzEsICcyJ11dKSlcbiAqIFsxLCAnMiddXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gY29udmVydE1hcFRvQXJyYXkobWFwKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgbWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmVzdWx0W3Bvc10gPSBrZXk7XG4gICAgICAgIHJlc3VsdFtwb3MgKyAxXSA9IHZhbHVlO1xuICAgICAgICBwb3MgKz0gMjtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5jb252ZXJ0TWFwVG9BcnJheSA9IGNvbnZlcnRNYXBUb0FycmF5O1xuLyoqXG4gKiBDb252ZXJ0IGEgbm9uLXN0cmluZyBhcmcgdG8gYSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gdG9BcmcoYXJnKSB7XG4gICAgaWYgKGFyZyA9PT0gbnVsbCB8fCB0eXBlb2YgYXJnID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKGFyZyk7XG59XG5leHBvcnRzLnRvQXJnID0gdG9Bcmc7XG4vKipcbiAqIE9wdGltaXplIGVycm9yIHN0YWNrXG4gKlxuICogQHBhcmFtIGVycm9yIGFjdHVhbGx5IGVycm9yXG4gKiBAcGFyYW0gZnJpZW5kbHlTdGFjayB0aGUgc3RhY2sgdGhhdCBtb3JlIG1lYW5pbmdmdWxcbiAqIEBwYXJhbSBmaWx0ZXJQYXRoIG9ubHkgc2hvdyBzdGFja3Mgd2l0aCB0aGUgc3BlY2lmaWVkIHBhdGhcbiAqL1xuZnVuY3Rpb24gb3B0aW1pemVFcnJvclN0YWNrKGVycm9yLCBmcmllbmRseVN0YWNrLCBmaWx0ZXJQYXRoKSB7XG4gICAgY29uc3Qgc3RhY2tzID0gZnJpZW5kbHlTdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICBsZXQgbGluZXMgPSBcIlwiO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBzdGFja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHN0YWNrc1tpXS5pbmRleE9mKGZpbHRlclBhdGgpID09PSAtMSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IGk7IGogPCBzdGFja3MubGVuZ3RoOyArK2opIHtcbiAgICAgICAgbGluZXMgKz0gXCJcXG5cIiArIHN0YWNrc1tqXTtcbiAgICB9XG4gICAgaWYgKGVycm9yLnN0YWNrKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGVycm9yLnN0YWNrLmluZGV4T2YoXCJcXG5cIik7XG4gICAgICAgIGVycm9yLnN0YWNrID0gZXJyb3Iuc3RhY2suc2xpY2UoMCwgcG9zKSArIGxpbmVzO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG59XG5leHBvcnRzLm9wdGltaXplRXJyb3JTdGFjayA9IG9wdGltaXplRXJyb3JTdGFjaztcbi8qKlxuICogUGFyc2UgdGhlIHJlZGlzIHByb3RvY29sIHVybFxuICovXG5mdW5jdGlvbiBwYXJzZVVSTCh1cmwpIHtcbiAgICBpZiAoaXNJbnQodXJsKSkge1xuICAgICAgICByZXR1cm4geyBwb3J0OiB1cmwgfTtcbiAgICB9XG4gICAgbGV0IHBhcnNlZCA9ICgwLCB1cmxfMS5wYXJzZSkodXJsLCB0cnVlLCB0cnVlKTtcbiAgICBpZiAoIXBhcnNlZC5zbGFzaGVzICYmIHVybFswXSAhPT0gXCIvXCIpIHtcbiAgICAgICAgdXJsID0gXCIvL1wiICsgdXJsO1xuICAgICAgICBwYXJzZWQgPSAoMCwgdXJsXzEucGFyc2UpKHVybCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSBwYXJzZWQucXVlcnkgfHwge307XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgaWYgKHBhcnNlZC5hdXRoKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VkLmF1dGguaW5kZXhPZihcIjpcIik7XG4gICAgICAgIHJlc3VsdC51c2VybmFtZSA9IGluZGV4ID09PSAtMSA/IHBhcnNlZC5hdXRoIDogcGFyc2VkLmF1dGguc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICByZXN1bHQucGFzc3dvcmQgPSBpbmRleCA9PT0gLTEgPyBcIlwiIDogcGFyc2VkLmF1dGguc2xpY2UoaW5kZXggKyAxKTtcbiAgICB9XG4gICAgaWYgKHBhcnNlZC5wYXRobmFtZSkge1xuICAgICAgICBpZiAocGFyc2VkLnByb3RvY29sID09PSBcInJlZGlzOlwiIHx8IHBhcnNlZC5wcm90b2NvbCA9PT0gXCJyZWRpc3M6XCIpIHtcbiAgICAgICAgICAgIGlmIChwYXJzZWQucGF0aG5hbWUubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kYiA9IHBhcnNlZC5wYXRobmFtZS5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wYXRoID0gcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJzZWQuaG9zdCkge1xuICAgICAgICByZXN1bHQuaG9zdCA9IHBhcnNlZC5ob3N0bmFtZTtcbiAgICB9XG4gICAgaWYgKHBhcnNlZC5wb3J0KSB7XG4gICAgICAgIHJlc3VsdC5wb3J0ID0gcGFyc2VkLnBvcnQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mYW1pbHkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgaW50RmFtaWx5ID0gTnVtYmVyLnBhcnNlSW50KG9wdGlvbnMuZmFtaWx5LCAxMCk7XG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKGludEZhbWlseSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5mYW1pbHkgPSBpbnRGYW1pbHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKDAsIGxvZGFzaF8xLmRlZmF1bHRzKShyZXN1bHQsIG9wdGlvbnMpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnBhcnNlVVJMID0gcGFyc2VVUkw7XG4vKipcbiAqIFJlc29sdmUgVExTIHByb2ZpbGUgc2hvcnRjdXQgaW4gY29ubmVjdGlvbiBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVUTFNQcm9maWxlKG9wdGlvbnMpIHtcbiAgICBsZXQgdGxzID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRscztcbiAgICBpZiAodHlwZW9mIHRscyA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgdGxzID0geyBwcm9maWxlOiB0bHMgfTtcbiAgICBjb25zdCBwcm9maWxlID0gVExTUHJvZmlsZXNfMS5kZWZhdWx0W3RscyA9PT0gbnVsbCB8fCB0bHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRscy5wcm9maWxlXTtcbiAgICBpZiAocHJvZmlsZSkge1xuICAgICAgICB0bHMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9maWxlLCB0bHMpO1xuICAgICAgICBkZWxldGUgdGxzLnByb2ZpbGU7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IHRscyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5leHBvcnRzLnJlc29sdmVUTFNQcm9maWxlID0gcmVzb2x2ZVRMU1Byb2ZpbGU7XG4vKipcbiAqIEdldCBhIHJhbmRvbSBlbGVtZW50IGZyb20gYGFycmF5YFxuICovXG5mdW5jdGlvbiBzYW1wbGUoYXJyYXksIGZyb20gPSAwKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGlmIChmcm9tID49IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5W2Zyb20gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobGVuZ3RoIC0gZnJvbSkpXTtcbn1cbmV4cG9ydHMuc2FtcGxlID0gc2FtcGxlO1xuLyoqXG4gKiBTaHVmZmxlIHRoZSBhcnJheSB1c2luZyB0aGUgRmlzaGVyLVlhdGVzIFNodWZmbGUuXG4gKiBUaGlzIG1ldGhvZCB3aWxsIG11dGF0ZSB0aGUgb3JpZ2luYWwgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHNodWZmbGUoYXJyYXkpIHtcbiAgICBsZXQgY291bnRlciA9IGFycmF5Lmxlbmd0aDtcbiAgICAvLyBXaGlsZSB0aGVyZSBhcmUgZWxlbWVudHMgaW4gdGhlIGFycmF5XG4gICAgd2hpbGUgKGNvdW50ZXIgPiAwKSB7XG4gICAgICAgIC8vIFBpY2sgYSByYW5kb20gaW5kZXhcbiAgICAgICAgY29uc3QgaW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjb3VudGVyKTtcbiAgICAgICAgLy8gRGVjcmVhc2UgY291bnRlciBieSAxXG4gICAgICAgIGNvdW50ZXItLTtcbiAgICAgICAgLy8gQW5kIHN3YXAgdGhlIGxhc3QgZWxlbWVudCB3aXRoIGl0XG4gICAgICAgIFthcnJheVtjb3VudGVyXSwgYXJyYXlbaW5kZXhdXSA9IFthcnJheVtpbmRleF0sIGFycmF5W2NvdW50ZXJdXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZXhwb3J0cy5zaHVmZmxlID0gc2h1ZmZsZTtcbi8qKlxuICogRXJyb3IgbWVzc2FnZSBmb3IgY29ubmVjdGlvbiBiZWluZyBkaXNjb25uZWN0ZWRcbiAqL1xuZXhwb3J0cy5DT05ORUNUSU9OX0NMT1NFRF9FUlJPUl9NU0cgPSBcIkNvbm5lY3Rpb24gaXMgY2xvc2VkLlwiO1xuZnVuY3Rpb24gemlwTWFwKGtleXMsIHZhbHVlcykge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICBrZXlzLmZvckVhY2goKGtleSwgaW5kZXgpID0+IHtcbiAgICAgICAgbWFwLnNldChrZXksIHZhbHVlc1tpbmRleF0pO1xuICAgIH0pO1xuICAgIHJldHVybiBtYXA7XG59XG5leHBvcnRzLnppcE1hcCA9IHppcE1hcDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm5vb3AiLCJkZWZhdWx0cyIsIkRlYnVnIiwiemlwTWFwIiwiQ09OTkVDVElPTl9DTE9TRURfRVJST1JfTVNHIiwic2h1ZmZsZSIsInNhbXBsZSIsInJlc29sdmVUTFNQcm9maWxlIiwicGFyc2VVUkwiLCJvcHRpbWl6ZUVycm9yU3RhY2siLCJ0b0FyZyIsImNvbnZlcnRNYXBUb0FycmF5IiwiY29udmVydE9iamVjdFRvQXJyYXkiLCJ0aW1lb3V0IiwicGFja09iamVjdCIsImlzSW50Iiwid3JhcE11bHRpUmVzdWx0IiwiY29udmVydEJ1ZmZlclRvU3RyaW5nIiwidXJsXzEiLCJyZXF1aXJlIiwibG9kYXNoXzEiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVidWdfMSIsImRlZmF1bHQiLCJUTFNQcm9maWxlc18xIiwiZW5jb2RpbmciLCJCdWZmZXIiLCJ0b1N0cmluZyIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsInJlcyIsImkiLCJhcnIiLCJyZXN1bHQiLCJpdGVtIiwiRXJyb3IiLCJwdXNoIiwieCIsInBhcnNlRmxvYXQiLCJpc05hTiIsImFycmF5IiwiY2FsbGJhY2siLCJ0aW1lciIsInJ1biIsImNsZWFyVGltZW91dCIsImFwcGx5IiwiYXJndW1lbnRzIiwic2V0VGltZW91dCIsIm9iaiIsImtleXMiLCJsIiwibWFwIiwicG9zIiwiZm9yRWFjaCIsImtleSIsImFyZyIsIlN0cmluZyIsImVycm9yIiwiZnJpZW5kbHlTdGFjayIsImZpbHRlclBhdGgiLCJzdGFja3MiLCJzcGxpdCIsImxpbmVzIiwiaW5kZXhPZiIsImoiLCJzdGFjayIsInNsaWNlIiwidXJsIiwicG9ydCIsInBhcnNlZCIsInBhcnNlIiwic2xhc2hlcyIsIm9wdGlvbnMiLCJxdWVyeSIsImF1dGgiLCJpbmRleCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJwYXRobmFtZSIsInByb3RvY29sIiwiZGIiLCJwYXRoIiwiaG9zdCIsImhvc3RuYW1lIiwiZmFtaWx5IiwiaW50RmFtaWx5IiwiTnVtYmVyIiwicGFyc2VJbnQiLCJ0bHMiLCJwcm9maWxlIiwiYXNzaWduIiwiZnJvbSIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImNvdW50ZXIiLCJ2YWx1ZXMiLCJNYXAiLCJzZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/utils/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/utils/lodash.js":
/*!****************************************************!*\
  !*** ./node_modules/ioredis/built/utils/lodash.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isArguments = exports.defaults = exports.noop = void 0;\nconst defaults = __webpack_require__(/*! lodash.defaults */ \"(rsc)/./node_modules/lodash.defaults/index.js\");\nexports.defaults = defaults;\nconst isArguments = __webpack_require__(/*! lodash.isarguments */ \"(rsc)/./node_modules/lodash.isarguments/index.js\");\nexports.isArguments = isArguments;\nfunction noop() {}\nexports.noop = noop;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC91dGlscy9sb2Rhc2guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG1CQUFtQixHQUFHQSxnQkFBZ0IsR0FBR0EsWUFBWSxHQUFHLEtBQUs7QUFDN0QsTUFBTUcsV0FBV0UsbUJBQU9BLENBQUMsc0VBQWlCO0FBQzFDTCxnQkFBZ0IsR0FBR0c7QUFDbkIsTUFBTUQsY0FBY0csbUJBQU9BLENBQUMsNEVBQW9CO0FBQ2hETCxtQkFBbUIsR0FBR0U7QUFDdEIsU0FBU0UsUUFBUztBQUNsQkosWUFBWSxHQUFHSSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L3V0aWxzL2xvZGFzaC5qcz9iNmEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0FyZ3VtZW50cyA9IGV4cG9ydHMuZGVmYXVsdHMgPSBleHBvcnRzLm5vb3AgPSB2b2lkIDA7XG5jb25zdCBkZWZhdWx0cyA9IHJlcXVpcmUoXCJsb2Rhc2guZGVmYXVsdHNcIik7XG5leHBvcnRzLmRlZmF1bHRzID0gZGVmYXVsdHM7XG5jb25zdCBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoXCJsb2Rhc2guaXNhcmd1bWVudHNcIik7XG5leHBvcnRzLmlzQXJndW1lbnRzID0gaXNBcmd1bWVudHM7XG5mdW5jdGlvbiBub29wKCkgeyB9XG5leHBvcnRzLm5vb3AgPSBub29wO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaXNBcmd1bWVudHMiLCJkZWZhdWx0cyIsIm5vb3AiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/utils/lodash.js\n");

/***/ })

};
;