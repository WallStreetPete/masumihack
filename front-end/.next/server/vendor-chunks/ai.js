"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(rsc)/./node_modules/ai/dist/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/ai/dist/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError),\n/* harmony export */   APICallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError),\n/* harmony export */   AssistantResponse: () => (/* binding */ AssistantResponse),\n/* harmony export */   DownloadError: () => (/* binding */ DownloadError),\n/* harmony export */   EmptyResponseBodyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.EmptyResponseBodyError),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidDataContentError: () => (/* binding */ InvalidDataContentError),\n/* harmony export */   InvalidMessageRoleError: () => (/* binding */ InvalidMessageRoleError),\n/* harmony export */   InvalidPromptError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidResponseDataError),\n/* harmony export */   InvalidStreamPartError: () => (/* binding */ InvalidStreamPartError),\n/* harmony export */   InvalidToolArgumentsError: () => (/* binding */ InvalidToolArgumentsError),\n/* harmony export */   JSONParseError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError),\n/* harmony export */   LangChainAdapter: () => (/* binding */ langchain_adapter_exports),\n/* harmony export */   LlamaIndexAdapter: () => (/* binding */ llamaindex_adapter_exports),\n/* harmony export */   LoadAPIKeyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError),\n/* harmony export */   MCPClientError: () => (/* binding */ MCPClientError),\n/* harmony export */   MessageConversionError: () => (/* binding */ MessageConversionError),\n/* harmony export */   NoContentGeneratedError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoContentGeneratedError),\n/* harmony export */   NoImageGeneratedError: () => (/* binding */ NoImageGeneratedError),\n/* harmony export */   NoObjectGeneratedError: () => (/* binding */ NoObjectGeneratedError),\n/* harmony export */   NoOutputSpecifiedError: () => (/* binding */ NoOutputSpecifiedError),\n/* harmony export */   NoSuchModelError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchModelError),\n/* harmony export */   NoSuchProviderError: () => (/* binding */ NoSuchProviderError),\n/* harmony export */   NoSuchToolError: () => (/* binding */ NoSuchToolError),\n/* harmony export */   Output: () => (/* binding */ output_exports),\n/* harmony export */   RetryError: () => (/* binding */ RetryError),\n/* harmony export */   StreamData: () => (/* binding */ StreamData),\n/* harmony export */   ToolCallRepairError: () => (/* binding */ ToolCallRepairError),\n/* harmony export */   ToolExecutionError: () => (/* binding */ ToolExecutionError),\n/* harmony export */   TypeValidationError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError),\n/* harmony export */   appendClientMessage: () => (/* binding */ appendClientMessage),\n/* harmony export */   appendResponseMessages: () => (/* binding */ appendResponseMessages),\n/* harmony export */   convertToCoreMessages: () => (/* binding */ convertToCoreMessages),\n/* harmony export */   coreAssistantMessageSchema: () => (/* binding */ coreAssistantMessageSchema),\n/* harmony export */   coreMessageSchema: () => (/* binding */ coreMessageSchema),\n/* harmony export */   coreSystemMessageSchema: () => (/* binding */ coreSystemMessageSchema),\n/* harmony export */   coreToolMessageSchema: () => (/* binding */ coreToolMessageSchema),\n/* harmony export */   coreUserMessageSchema: () => (/* binding */ coreUserMessageSchema),\n/* harmony export */   cosineSimilarity: () => (/* binding */ cosineSimilarity),\n/* harmony export */   createDataStream: () => (/* binding */ createDataStream),\n/* harmony export */   createDataStreamResponse: () => (/* binding */ createDataStreamResponse),\n/* harmony export */   createIdGenerator: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator),\n/* harmony export */   createProviderRegistry: () => (/* binding */ createProviderRegistry),\n/* harmony export */   customProvider: () => (/* binding */ customProvider),\n/* harmony export */   defaultSettingsMiddleware: () => (/* binding */ defaultSettingsMiddleware),\n/* harmony export */   embed: () => (/* binding */ embed),\n/* harmony export */   embedMany: () => (/* binding */ embedMany),\n/* harmony export */   experimental_createMCPClient: () => (/* binding */ createMCPClient),\n/* harmony export */   experimental_createProviderRegistry: () => (/* binding */ experimental_createProviderRegistry),\n/* harmony export */   experimental_customProvider: () => (/* binding */ experimental_customProvider),\n/* harmony export */   experimental_generateImage: () => (/* binding */ generateImage),\n/* harmony export */   experimental_generateSpeech: () => (/* binding */ generateSpeech),\n/* harmony export */   experimental_transcribe: () => (/* binding */ transcribe),\n/* harmony export */   experimental_wrapLanguageModel: () => (/* binding */ experimental_wrapLanguageModel),\n/* harmony export */   extractReasoningMiddleware: () => (/* binding */ extractReasoningMiddleware),\n/* harmony export */   formatAssistantStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatAssistantStreamPart),\n/* harmony export */   formatDataStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart),\n/* harmony export */   generateId: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId),\n/* harmony export */   generateObject: () => (/* binding */ generateObject),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   jsonSchema: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.jsonSchema),\n/* harmony export */   parseAssistantStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.parseAssistantStreamPart),\n/* harmony export */   parseDataStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.parseDataStreamPart),\n/* harmony export */   pipeDataStreamToResponse: () => (/* binding */ pipeDataStreamToResponse),\n/* harmony export */   processDataStream: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.processDataStream),\n/* harmony export */   processTextStream: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.processTextStream),\n/* harmony export */   simulateReadableStream: () => (/* binding */ simulateReadableStream),\n/* harmony export */   simulateStreamingMiddleware: () => (/* binding */ simulateStreamingMiddleware),\n/* harmony export */   smoothStream: () => (/* binding */ smoothStream),\n/* harmony export */   streamObject: () => (/* binding */ streamObject),\n/* harmony export */   streamText: () => (/* binding */ streamText),\n/* harmony export */   tool: () => (/* binding */ tool),\n/* harmony export */   wrapLanguageModel: () => (/* binding */ wrapLanguageModel),\n/* harmony export */   zodSchema: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.zodSchema)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/ui-utils */ \"(rsc)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/next/dist/compiled/@opentelemetry/api/index.js\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.mjs\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all)=>{\n    for(var name17 in all)__defProp(target, name17, {\n        get: all[name17],\n        enumerable: true\n    });\n};\n// core/index.ts\n\n\n// core/data-stream/create-data-stream.ts\n\nfunction createDataStream({ execute, onError = ()=>\"An error occurred.\" }) {\n    let controller;\n    const ongoingStreamPromises = [];\n    const stream = new ReadableStream({\n        start (controllerArg) {\n            controller = controllerArg;\n        }\n    });\n    function safeEnqueue(data) {\n        try {\n            controller.enqueue(data);\n        } catch (error) {}\n    }\n    try {\n        const result = execute({\n            write (data) {\n                safeEnqueue(data);\n            },\n            writeData (data) {\n                safeEnqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"data\", [\n                    data\n                ]));\n            },\n            writeMessageAnnotation (annotation) {\n                safeEnqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"message_annotations\", [\n                    annotation\n                ]));\n            },\n            writeSource (source) {\n                safeEnqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"source\", source));\n            },\n            merge (streamArg) {\n                ongoingStreamPromises.push((async ()=>{\n                    const reader = streamArg.getReader();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) break;\n                        safeEnqueue(value);\n                    }\n                })().catch((error)=>{\n                    safeEnqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"error\", onError(error)));\n                }));\n            },\n            onError\n        });\n        if (result) {\n            ongoingStreamPromises.push(result.catch((error)=>{\n                safeEnqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"error\", onError(error)));\n            }));\n        }\n    } catch (error) {\n        safeEnqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"error\", onError(error)));\n    }\n    const waitForStreams = new Promise(async (resolve)=>{\n        while(ongoingStreamPromises.length > 0){\n            await ongoingStreamPromises.shift();\n        }\n        resolve();\n    });\n    waitForStreams.finally(()=>{\n        try {\n            controller.close();\n        } catch (error) {}\n    });\n    return stream;\n}\n// core/util/prepare-response-headers.ts\nfunction prepareResponseHeaders(headers, { contentType, dataStreamVersion }) {\n    const responseHeaders = new Headers(headers != null ? headers : {});\n    if (!responseHeaders.has(\"Content-Type\")) {\n        responseHeaders.set(\"Content-Type\", contentType);\n    }\n    if (dataStreamVersion !== void 0) {\n        responseHeaders.set(\"X-Vercel-AI-Data-Stream\", dataStreamVersion);\n    }\n    return responseHeaders;\n}\n// core/data-stream/create-data-stream-response.ts\nfunction createDataStreamResponse({ status, statusText, headers, execute, onError }) {\n    return new Response(createDataStream({\n        execute,\n        onError\n    }).pipeThrough(new TextEncoderStream()), {\n        status,\n        statusText,\n        headers: prepareResponseHeaders(headers, {\n            contentType: \"text/plain; charset=utf-8\",\n            dataStreamVersion: \"v1\"\n        })\n    });\n}\n// core/util/prepare-outgoing-http-headers.ts\nfunction prepareOutgoingHttpHeaders(headers, { contentType, dataStreamVersion }) {\n    const outgoingHeaders = {};\n    if (headers != null) {\n        for (const [key, value] of Object.entries(headers)){\n            outgoingHeaders[key] = value;\n        }\n    }\n    if (outgoingHeaders[\"Content-Type\"] == null) {\n        outgoingHeaders[\"Content-Type\"] = contentType;\n    }\n    if (dataStreamVersion !== void 0) {\n        outgoingHeaders[\"X-Vercel-AI-Data-Stream\"] = dataStreamVersion;\n    }\n    return outgoingHeaders;\n}\n// core/util/write-to-server-response.ts\nfunction writeToServerResponse({ response, status, statusText, headers, stream }) {\n    response.writeHead(status != null ? status : 200, statusText, headers);\n    const reader = stream.getReader();\n    const read = async ()=>{\n        try {\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) break;\n                response.write(value);\n            }\n        } catch (error) {\n            throw error;\n        } finally{\n            response.end();\n        }\n    };\n    read();\n}\n// core/data-stream/pipe-data-stream-to-response.ts\nfunction pipeDataStreamToResponse(response, { status, statusText, headers, execute, onError }) {\n    writeToServerResponse({\n        response,\n        status,\n        statusText,\n        headers: prepareOutgoingHttpHeaders(headers, {\n            contentType: \"text/plain; charset=utf-8\",\n            dataStreamVersion: \"v1\"\n        }),\n        stream: createDataStream({\n            execute,\n            onError\n        }).pipeThrough(new TextEncoderStream())\n    });\n}\n// errors/invalid-argument-error.ts\n\nvar name = \"AI_InvalidArgumentError\";\nvar marker = `vercel.ai.error.${name}`;\nvar symbol = Symbol.for(marker);\nvar _a;\nvar InvalidArgumentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor({ parameter, value, message }){\n        super({\n            name,\n            message: `Invalid argument for parameter ${parameter}: ${message}`\n        });\n        this[_a] = true;\n        this.parameter = parameter;\n        this.value = value;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker);\n    }\n};\n_a = symbol;\n// util/retry-with-exponential-backoff.ts\n\n\n// util/retry-error.ts\n\nvar name2 = \"AI_RetryError\";\nvar marker2 = `vercel.ai.error.${name2}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar RetryError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor({ message, reason, errors }){\n        super({\n            name: name2,\n            message\n        });\n        this[_a2] = true;\n        this.reason = reason;\n        this.errors = errors;\n        this.lastError = errors[errors.length - 1];\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker2);\n    }\n};\n_a2 = symbol2;\n// util/retry-with-exponential-backoff.ts\nvar retryWithExponentialBackoff = ({ maxRetries = 2, initialDelayInMs = 2e3, backoffFactor = 2 } = {})=>async (f)=>_retryWithExponentialBackoff(f, {\n            maxRetries,\n            delayInMs: initialDelayInMs,\n            backoffFactor\n        });\nasync function _retryWithExponentialBackoff(f, { maxRetries, delayInMs, backoffFactor }, errors = []) {\n    try {\n        return await f();\n    } catch (error) {\n        if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isAbortError)(error)) {\n            throw error;\n        }\n        if (maxRetries === 0) {\n            throw error;\n        }\n        const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage)(error);\n        const newErrors = [\n            ...errors,\n            error\n        ];\n        const tryNumber = newErrors.length;\n        if (tryNumber > maxRetries) {\n            throw new RetryError({\n                message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n                reason: \"maxRetriesExceeded\",\n                errors: newErrors\n            });\n        }\n        if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isInstance(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n            await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay)(delayInMs);\n            return _retryWithExponentialBackoff(f, {\n                maxRetries,\n                delayInMs: backoffFactor * delayInMs,\n                backoffFactor\n            }, newErrors);\n        }\n        if (tryNumber === 1) {\n            throw error;\n        }\n        throw new RetryError({\n            message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n            reason: \"errorNotRetryable\",\n            errors: newErrors\n        });\n    }\n}\n// core/prompt/prepare-retries.ts\nfunction prepareRetries({ maxRetries }) {\n    if (maxRetries != null) {\n        if (!Number.isInteger(maxRetries)) {\n            throw new InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be an integer\"\n            });\n        }\n        if (maxRetries < 0) {\n            throw new InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be >= 0\"\n            });\n        }\n    }\n    const maxRetriesResult = maxRetries != null ? maxRetries : 2;\n    return {\n        maxRetries: maxRetriesResult,\n        retry: retryWithExponentialBackoff({\n            maxRetries: maxRetriesResult\n        })\n    };\n}\n// core/telemetry/assemble-operation-name.ts\nfunction assembleOperationName({ operationId, telemetry }) {\n    return {\n        // standardized operation and resource name:\n        \"operation.name\": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : \"\"}`,\n        \"resource.name\": telemetry == null ? void 0 : telemetry.functionId,\n        // detailed, AI SDK specific data:\n        \"ai.operationId\": operationId,\n        \"ai.telemetry.functionId\": telemetry == null ? void 0 : telemetry.functionId\n    };\n}\n// core/telemetry/get-base-telemetry-attributes.ts\nfunction getBaseTelemetryAttributes({ model, settings, telemetry, headers }) {\n    var _a17;\n    return {\n        \"ai.model.provider\": model.provider,\n        \"ai.model.id\": model.modelId,\n        // settings:\n        ...Object.entries(settings).reduce((attributes, [key, value])=>{\n            attributes[`ai.settings.${key}`] = value;\n            return attributes;\n        }, {}),\n        // add metadata as attributes:\n        ...Object.entries((_a17 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a17 : {}).reduce((attributes, [key, value])=>{\n            attributes[`ai.telemetry.metadata.${key}`] = value;\n            return attributes;\n        }, {}),\n        // request headers\n        ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value])=>{\n            if (value !== void 0) {\n                attributes[`ai.request.headers.${key}`] = value;\n            }\n            return attributes;\n        }, {})\n    };\n}\n// core/telemetry/get-tracer.ts\n\n// core/telemetry/noop-tracer.ts\nvar noopTracer = {\n    startSpan () {\n        return noopSpan;\n    },\n    startActiveSpan (name17, arg1, arg2, arg3) {\n        if (typeof arg1 === \"function\") {\n            return arg1(noopSpan);\n        }\n        if (typeof arg2 === \"function\") {\n            return arg2(noopSpan);\n        }\n        if (typeof arg3 === \"function\") {\n            return arg3(noopSpan);\n        }\n    }\n};\nvar noopSpan = {\n    spanContext () {\n        return noopSpanContext;\n    },\n    setAttribute () {\n        return this;\n    },\n    setAttributes () {\n        return this;\n    },\n    addEvent () {\n        return this;\n    },\n    addLink () {\n        return this;\n    },\n    addLinks () {\n        return this;\n    },\n    setStatus () {\n        return this;\n    },\n    updateName () {\n        return this;\n    },\n    end () {\n        return this;\n    },\n    isRecording () {\n        return false;\n    },\n    recordException () {\n        return this;\n    }\n};\nvar noopSpanContext = {\n    traceId: \"\",\n    spanId: \"\",\n    traceFlags: 0\n};\n// core/telemetry/get-tracer.ts\nfunction getTracer({ isEnabled = false, tracer } = {}) {\n    if (!isEnabled) {\n        return noopTracer;\n    }\n    if (tracer) {\n        return tracer;\n    }\n    return _opentelemetry_api__WEBPACK_IMPORTED_MODULE_3__.trace.getTracer(\"ai\");\n}\n// core/telemetry/record-span.ts\n\nfunction recordSpan({ name: name17, tracer, attributes, fn, endWhenDone = true }) {\n    return tracer.startActiveSpan(name17, {\n        attributes\n    }, async (span)=>{\n        try {\n            const result = await fn(span);\n            if (endWhenDone) {\n                span.end();\n            }\n            return result;\n        } catch (error) {\n            try {\n                if (error instanceof Error) {\n                    span.recordException({\n                        name: error.name,\n                        message: error.message,\n                        stack: error.stack\n                    });\n                    span.setStatus({\n                        code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_3__.SpanStatusCode.ERROR,\n                        message: error.message\n                    });\n                } else {\n                    span.setStatus({\n                        code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_3__.SpanStatusCode.ERROR\n                    });\n                }\n            } finally{\n                span.end();\n            }\n            throw error;\n        }\n    });\n}\n// core/telemetry/select-telemetry-attributes.ts\nfunction selectTelemetryAttributes({ telemetry, attributes }) {\n    if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {\n        return {};\n    }\n    return Object.entries(attributes).reduce((attributes2, [key, value])=>{\n        if (value === void 0) {\n            return attributes2;\n        }\n        if (typeof value === \"object\" && \"input\" in value && typeof value.input === \"function\") {\n            if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {\n                return attributes2;\n            }\n            const result = value.input();\n            return result === void 0 ? attributes2 : {\n                ...attributes2,\n                [key]: result\n            };\n        }\n        if (typeof value === \"object\" && \"output\" in value && typeof value.output === \"function\") {\n            if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {\n                return attributes2;\n            }\n            const result = value.output();\n            return result === void 0 ? attributes2 : {\n                ...attributes2,\n                [key]: result\n            };\n        }\n        return {\n            ...attributes2,\n            [key]: value\n        };\n    }, {});\n}\n// core/embed/embed.ts\nasync function embed({ model, value, maxRetries: maxRetriesArg, abortSignal, headers, experimental_telemetry: telemetry }) {\n    const { maxRetries, retry } = prepareRetries({\n        maxRetries: maxRetriesArg\n    });\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    return recordSpan({\n        name: \"ai.embed\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.embed\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.value\": {\n                    input: ()=>JSON.stringify(value)\n                }\n            }\n        }),\n        tracer,\n        fn: async (span)=>{\n            const { embedding, usage, rawResponse } = await retry(()=>// nested spans to align with the embedMany telemetry data:\n                recordSpan({\n                    name: \"ai.embed.doEmbed\",\n                    attributes: selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                            ...assembleOperationName({\n                                operationId: \"ai.embed.doEmbed\",\n                                telemetry\n                            }),\n                            ...baseTelemetryAttributes,\n                            // specific settings that only make sense on the outer level:\n                            \"ai.values\": {\n                                input: ()=>[\n                                        JSON.stringify(value)\n                                    ]\n                            }\n                        }\n                    }),\n                    tracer,\n                    fn: async (doEmbedSpan)=>{\n                        var _a17;\n                        const modelResponse = await model.doEmbed({\n                            values: [\n                                value\n                            ],\n                            abortSignal,\n                            headers\n                        });\n                        const embedding2 = modelResponse.embeddings[0];\n                        const usage2 = (_a17 = modelResponse.usage) != null ? _a17 : {\n                            tokens: NaN\n                        };\n                        doEmbedSpan.setAttributes(selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                \"ai.embeddings\": {\n                                    output: ()=>modelResponse.embeddings.map((embedding3)=>JSON.stringify(embedding3))\n                                },\n                                \"ai.usage.tokens\": usage2.tokens\n                            }\n                        }));\n                        return {\n                            embedding: embedding2,\n                            usage: usage2,\n                            rawResponse: modelResponse.rawResponse\n                        };\n                    }\n                }));\n            span.setAttributes(selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    \"ai.embedding\": {\n                        output: ()=>JSON.stringify(embedding)\n                    },\n                    \"ai.usage.tokens\": usage.tokens\n                }\n            }));\n            return new DefaultEmbedResult({\n                value,\n                embedding,\n                usage,\n                rawResponse\n            });\n        }\n    });\n}\nvar DefaultEmbedResult = class {\n    constructor(options){\n        this.value = options.value;\n        this.embedding = options.embedding;\n        this.usage = options.usage;\n        this.rawResponse = options.rawResponse;\n    }\n};\n// core/util/split-array.ts\nfunction splitArray(array, chunkSize) {\n    if (chunkSize <= 0) {\n        throw new Error(\"chunkSize must be greater than 0\");\n    }\n    const result = [];\n    for(let i = 0; i < array.length; i += chunkSize){\n        result.push(array.slice(i, i + chunkSize));\n    }\n    return result;\n}\n// core/embed/embed-many.ts\nasync function embedMany({ model, values, maxRetries: maxRetriesArg, abortSignal, headers, experimental_telemetry: telemetry }) {\n    const { maxRetries, retry } = prepareRetries({\n        maxRetries: maxRetriesArg\n    });\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    return recordSpan({\n        name: \"ai.embedMany\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.embedMany\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": {\n                    input: ()=>values.map((value)=>JSON.stringify(value))\n                }\n            }\n        }),\n        tracer,\n        fn: async (span)=>{\n            const maxEmbeddingsPerCall = model.maxEmbeddingsPerCall;\n            if (maxEmbeddingsPerCall == null) {\n                const { embeddings: embeddings2, usage } = await retry(()=>{\n                    return recordSpan({\n                        name: \"ai.embedMany.doEmbed\",\n                        attributes: selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                ...assembleOperationName({\n                                    operationId: \"ai.embedMany.doEmbed\",\n                                    telemetry\n                                }),\n                                ...baseTelemetryAttributes,\n                                // specific settings that only make sense on the outer level:\n                                \"ai.values\": {\n                                    input: ()=>values.map((value)=>JSON.stringify(value))\n                                }\n                            }\n                        }),\n                        tracer,\n                        fn: async (doEmbedSpan)=>{\n                            var _a17;\n                            const modelResponse = await model.doEmbed({\n                                values,\n                                abortSignal,\n                                headers\n                            });\n                            const embeddings3 = modelResponse.embeddings;\n                            const usage2 = (_a17 = modelResponse.usage) != null ? _a17 : {\n                                tokens: NaN\n                            };\n                            doEmbedSpan.setAttributes(selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.embeddings\": {\n                                        output: ()=>embeddings3.map((embedding)=>JSON.stringify(embedding))\n                                    },\n                                    \"ai.usage.tokens\": usage2.tokens\n                                }\n                            }));\n                            return {\n                                embeddings: embeddings3,\n                                usage: usage2\n                            };\n                        }\n                    });\n                });\n                span.setAttributes(selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                        \"ai.embeddings\": {\n                            output: ()=>embeddings2.map((embedding)=>JSON.stringify(embedding))\n                        },\n                        \"ai.usage.tokens\": usage.tokens\n                    }\n                }));\n                return new DefaultEmbedManyResult({\n                    values,\n                    embeddings: embeddings2,\n                    usage\n                });\n            }\n            const valueChunks = splitArray(values, maxEmbeddingsPerCall);\n            const embeddings = [];\n            let tokens = 0;\n            for (const chunk of valueChunks){\n                const { embeddings: responseEmbeddings, usage } = await retry(()=>{\n                    return recordSpan({\n                        name: \"ai.embedMany.doEmbed\",\n                        attributes: selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                ...assembleOperationName({\n                                    operationId: \"ai.embedMany.doEmbed\",\n                                    telemetry\n                                }),\n                                ...baseTelemetryAttributes,\n                                // specific settings that only make sense on the outer level:\n                                \"ai.values\": {\n                                    input: ()=>chunk.map((value)=>JSON.stringify(value))\n                                }\n                            }\n                        }),\n                        tracer,\n                        fn: async (doEmbedSpan)=>{\n                            var _a17;\n                            const modelResponse = await model.doEmbed({\n                                values: chunk,\n                                abortSignal,\n                                headers\n                            });\n                            const embeddings2 = modelResponse.embeddings;\n                            const usage2 = (_a17 = modelResponse.usage) != null ? _a17 : {\n                                tokens: NaN\n                            };\n                            doEmbedSpan.setAttributes(selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.embeddings\": {\n                                        output: ()=>embeddings2.map((embedding)=>JSON.stringify(embedding))\n                                    },\n                                    \"ai.usage.tokens\": usage2.tokens\n                                }\n                            }));\n                            return {\n                                embeddings: embeddings2,\n                                usage: usage2\n                            };\n                        }\n                    });\n                });\n                embeddings.push(...responseEmbeddings);\n                tokens += usage.tokens;\n            }\n            span.setAttributes(selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    \"ai.embeddings\": {\n                        output: ()=>embeddings.map((embedding)=>JSON.stringify(embedding))\n                    },\n                    \"ai.usage.tokens\": tokens\n                }\n            }));\n            return new DefaultEmbedManyResult({\n                values,\n                embeddings,\n                usage: {\n                    tokens\n                }\n            });\n        }\n    });\n}\nvar DefaultEmbedManyResult = class {\n    constructor(options){\n        this.values = options.values;\n        this.embeddings = options.embeddings;\n        this.usage = options.usage;\n    }\n};\n// errors/no-image-generated-error.ts\n\nvar name3 = \"AI_NoImageGeneratedError\";\nvar marker3 = `vercel.ai.error.${name3}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar NoImageGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor({ message = \"No image generated.\", cause, responses }){\n        super({\n            name: name3,\n            message,\n            cause\n        });\n        this[_a3] = true;\n        this.responses = responses;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker3);\n    }\n};\n_a3 = symbol3;\n// core/generate-text/generated-file.ts\n\nvar DefaultGeneratedFile = class {\n    constructor({ data, mimeType }){\n        const isUint8Array = data instanceof Uint8Array;\n        this.base64Data = isUint8Array ? void 0 : data;\n        this.uint8ArrayData = isUint8Array ? data : void 0;\n        this.mimeType = mimeType;\n    }\n    // lazy conversion with caching to avoid unnecessary conversion overhead:\n    get base64() {\n        if (this.base64Data == null) {\n            this.base64Data = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(this.uint8ArrayData);\n        }\n        return this.base64Data;\n    }\n    // lazy conversion with caching to avoid unnecessary conversion overhead:\n    get uint8Array() {\n        if (this.uint8ArrayData == null) {\n            this.uint8ArrayData = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(this.base64Data);\n        }\n        return this.uint8ArrayData;\n    }\n};\nvar DefaultGeneratedFileWithType = class extends DefaultGeneratedFile {\n    constructor(options){\n        super(options);\n        this.type = \"file\";\n    }\n};\n// core/util/detect-mimetype.ts\n\nvar imageMimeTypeSignatures = [\n    {\n        mimeType: \"image/gif\",\n        bytesPrefix: [\n            71,\n            73,\n            70\n        ],\n        base64Prefix: \"R0lG\"\n    },\n    {\n        mimeType: \"image/png\",\n        bytesPrefix: [\n            137,\n            80,\n            78,\n            71\n        ],\n        base64Prefix: \"iVBORw\"\n    },\n    {\n        mimeType: \"image/jpeg\",\n        bytesPrefix: [\n            255,\n            216\n        ],\n        base64Prefix: \"/9j/\"\n    },\n    {\n        mimeType: \"image/webp\",\n        bytesPrefix: [\n            82,\n            73,\n            70,\n            70\n        ],\n        base64Prefix: \"UklGRg\"\n    },\n    {\n        mimeType: \"image/bmp\",\n        bytesPrefix: [\n            66,\n            77\n        ],\n        base64Prefix: \"Qk\"\n    },\n    {\n        mimeType: \"image/tiff\",\n        bytesPrefix: [\n            73,\n            73,\n            42,\n            0\n        ],\n        base64Prefix: \"SUkqAA\"\n    },\n    {\n        mimeType: \"image/tiff\",\n        bytesPrefix: [\n            77,\n            77,\n            0,\n            42\n        ],\n        base64Prefix: \"TU0AKg\"\n    },\n    {\n        mimeType: \"image/avif\",\n        bytesPrefix: [\n            0,\n            0,\n            0,\n            32,\n            102,\n            116,\n            121,\n            112,\n            97,\n            118,\n            105,\n            102\n        ],\n        base64Prefix: \"AAAAIGZ0eXBhdmlm\"\n    },\n    {\n        mimeType: \"image/heic\",\n        bytesPrefix: [\n            0,\n            0,\n            0,\n            32,\n            102,\n            116,\n            121,\n            112,\n            104,\n            101,\n            105,\n            99\n        ],\n        base64Prefix: \"AAAAIGZ0eXBoZWlj\"\n    }\n];\nvar audioMimeTypeSignatures = [\n    {\n        mimeType: \"audio/mpeg\",\n        bytesPrefix: [\n            255,\n            251\n        ],\n        base64Prefix: \"//s=\"\n    },\n    {\n        mimeType: \"audio/wav\",\n        bytesPrefix: [\n            82,\n            73,\n            70,\n            70\n        ],\n        base64Prefix: \"UklGR\"\n    },\n    {\n        mimeType: \"audio/ogg\",\n        bytesPrefix: [\n            79,\n            103,\n            103,\n            83\n        ],\n        base64Prefix: \"T2dnUw\"\n    },\n    {\n        mimeType: \"audio/flac\",\n        bytesPrefix: [\n            102,\n            76,\n            97,\n            67\n        ],\n        base64Prefix: \"ZkxhQw\"\n    },\n    {\n        mimeType: \"audio/aac\",\n        bytesPrefix: [\n            64,\n            21,\n            0,\n            0\n        ],\n        base64Prefix: \"QBUA\"\n    },\n    {\n        mimeType: \"audio/mp4\",\n        bytesPrefix: [\n            102,\n            116,\n            121,\n            112\n        ],\n        base64Prefix: \"ZnR5cA\"\n    }\n];\nvar stripID3 = (data)=>{\n    const bytes = typeof data === \"string\" ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(data) : data;\n    const id3Size = (bytes[6] & 127) << 21 | (bytes[7] & 127) << 14 | (bytes[8] & 127) << 7 | bytes[9] & 127;\n    return bytes.slice(id3Size + 10);\n};\nfunction stripID3TagsIfPresent(data) {\n    const hasId3 = typeof data === \"string\" && data.startsWith(\"SUQz\") || typeof data !== \"string\" && data.length > 10 && data[0] === 73 && // 'I'\n    data[1] === 68 && // 'D'\n    data[2] === 51;\n    return hasId3 ? stripID3(data) : data;\n}\nfunction detectMimeType({ data, signatures }) {\n    const processedData = stripID3TagsIfPresent(data);\n    for (const signature of signatures){\n        if (typeof processedData === \"string\" ? processedData.startsWith(signature.base64Prefix) : processedData.length >= signature.bytesPrefix.length && signature.bytesPrefix.every((byte, index)=>processedData[index] === byte)) {\n            return signature.mimeType;\n        }\n    }\n    return void 0;\n}\n// core/generate-image/generate-image.ts\nasync function generateImage({ model, prompt, n = 1, size, aspectRatio, seed, providerOptions, maxRetries: maxRetriesArg, abortSignal, headers }) {\n    var _a17;\n    const { retry } = prepareRetries({\n        maxRetries: maxRetriesArg\n    });\n    const maxImagesPerCall = (_a17 = model.maxImagesPerCall) != null ? _a17 : 1;\n    const callCount = Math.ceil(n / maxImagesPerCall);\n    const callImageCounts = Array.from({\n        length: callCount\n    }, (_, i)=>{\n        if (i < callCount - 1) {\n            return maxImagesPerCall;\n        }\n        const remainder = n % maxImagesPerCall;\n        return remainder === 0 ? maxImagesPerCall : remainder;\n    });\n    const results = await Promise.all(callImageCounts.map(async (callImageCount)=>retry(()=>model.doGenerate({\n                prompt,\n                n: callImageCount,\n                abortSignal,\n                headers,\n                size,\n                aspectRatio,\n                seed,\n                providerOptions: providerOptions != null ? providerOptions : {}\n            }))));\n    const images = [];\n    const warnings = [];\n    const responses = [];\n    for (const result of results){\n        images.push(...result.images.map((image)=>{\n            var _a18;\n            return new DefaultGeneratedFile({\n                data: image,\n                mimeType: (_a18 = detectMimeType({\n                    data: image,\n                    signatures: imageMimeTypeSignatures\n                })) != null ? _a18 : \"image/png\"\n            });\n        }));\n        warnings.push(...result.warnings);\n        responses.push(result.response);\n    }\n    if (!images.length) {\n        throw new NoImageGeneratedError({\n            responses\n        });\n    }\n    return new DefaultGenerateImageResult({\n        images,\n        warnings,\n        responses\n    });\n}\nvar DefaultGenerateImageResult = class {\n    constructor(options){\n        this.images = options.images;\n        this.warnings = options.warnings;\n        this.responses = options.responses;\n    }\n    get image() {\n        return this.images[0];\n    }\n};\n// core/generate-object/generate-object.ts\n\n\n// errors/no-object-generated-error.ts\n\nvar name4 = \"AI_NoObjectGeneratedError\";\nvar marker4 = `vercel.ai.error.${name4}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar NoObjectGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor({ message = \"No object generated.\", cause, text: text2, response, usage, finishReason }){\n        super({\n            name: name4,\n            message,\n            cause\n        });\n        this[_a4] = true;\n        this.text = text2;\n        this.response = response;\n        this.usage = usage;\n        this.finishReason = finishReason;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker4);\n    }\n};\n_a4 = symbol4;\n// util/download-error.ts\n\nvar name5 = \"AI_DownloadError\";\nvar marker5 = `vercel.ai.error.${name5}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar DownloadError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor({ url, statusCode, statusText, cause, message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}` }){\n        super({\n            name: name5,\n            message,\n            cause\n        });\n        this[_a5] = true;\n        this.url = url;\n        this.statusCode = statusCode;\n        this.statusText = statusText;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker5);\n    }\n};\n_a5 = symbol5;\n// util/download.ts\nasync function download({ url }) {\n    var _a17;\n    const urlText = url.toString();\n    try {\n        const response = await fetch(urlText);\n        if (!response.ok) {\n            throw new DownloadError({\n                url: urlText,\n                statusCode: response.status,\n                statusText: response.statusText\n            });\n        }\n        return {\n            data: new Uint8Array(await response.arrayBuffer()),\n            mimeType: (_a17 = response.headers.get(\"content-type\")) != null ? _a17 : void 0\n        };\n    } catch (error) {\n        if (DownloadError.isInstance(error)) {\n            throw error;\n        }\n        throw new DownloadError({\n            url: urlText,\n            cause: error\n        });\n    }\n}\n// core/prompt/data-content.ts\n\n// core/prompt/invalid-data-content-error.ts\n\nvar name6 = \"AI_InvalidDataContentError\";\nvar marker6 = `vercel.ai.error.${name6}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar InvalidDataContentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor({ content, cause, message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.` }){\n        super({\n            name: name6,\n            message,\n            cause\n        });\n        this[_a6] = true;\n        this.content = content;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker6);\n    }\n};\n_a6 = symbol6;\n// core/prompt/data-content.ts\n\nvar dataContentSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.instanceof(Uint8Array),\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.instanceof(ArrayBuffer),\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.custom(// Buffer might not be available in some environments such as CloudFlare:\n    (value)=>{\n        var _a17, _b;\n        return (_b = (_a17 = globalThis.Buffer) == null ? void 0 : _a17.isBuffer(value)) != null ? _b : false;\n    }, {\n        message: \"Must be a Buffer\"\n    })\n]);\nfunction convertDataContentToBase64String(content) {\n    if (typeof content === \"string\") {\n        return content;\n    }\n    if (content instanceof ArrayBuffer) {\n        return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(new Uint8Array(content));\n    }\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(content);\n}\nfunction convertDataContentToUint8Array(content) {\n    if (content instanceof Uint8Array) {\n        return content;\n    }\n    if (typeof content === \"string\") {\n        try {\n            return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(content);\n        } catch (error) {\n            throw new InvalidDataContentError({\n                message: \"Invalid data content. Content string is not a base64-encoded media.\",\n                content,\n                cause: error\n            });\n        }\n    }\n    if (content instanceof ArrayBuffer) {\n        return new Uint8Array(content);\n    }\n    throw new InvalidDataContentError({\n        content\n    });\n}\nfunction convertUint8ArrayToText(uint8Array) {\n    try {\n        return new TextDecoder().decode(uint8Array);\n    } catch (error) {\n        throw new Error(\"Error decoding Uint8Array to text\");\n    }\n}\n// core/prompt/invalid-message-role-error.ts\n\nvar name7 = \"AI_InvalidMessageRoleError\";\nvar marker7 = `vercel.ai.error.${name7}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar InvalidMessageRoleError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor({ role, message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".` }){\n        super({\n            name: name7,\n            message\n        });\n        this[_a7] = true;\n        this.role = role;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker7);\n    }\n};\n_a7 = symbol7;\n// core/prompt/split-data-url.ts\nfunction splitDataUrl(dataUrl) {\n    try {\n        const [header, base64Content] = dataUrl.split(\",\");\n        return {\n            mimeType: header.split(\";\")[0].split(\":\")[1],\n            base64Content\n        };\n    } catch (error) {\n        return {\n            mimeType: void 0,\n            base64Content: void 0\n        };\n    }\n}\n// core/prompt/convert-to-language-model-prompt.ts\nasync function convertToLanguageModelPrompt({ prompt, modelSupportsImageUrls = true, modelSupportsUrl = ()=>false, downloadImplementation = download }) {\n    const downloadedAssets = await downloadAssets(prompt.messages, downloadImplementation, modelSupportsImageUrls, modelSupportsUrl);\n    return [\n        ...prompt.system != null ? [\n            {\n                role: \"system\",\n                content: prompt.system\n            }\n        ] : [],\n        ...prompt.messages.map((message)=>convertToLanguageModelMessage(message, downloadedAssets))\n    ];\n}\nfunction convertToLanguageModelMessage(message, downloadedAssets) {\n    var _a17, _b, _c, _d, _e, _f;\n    const role = message.role;\n    switch(role){\n        case \"system\":\n            {\n                return {\n                    role: \"system\",\n                    content: message.content,\n                    providerMetadata: (_a17 = message.providerOptions) != null ? _a17 : message.experimental_providerMetadata\n                };\n            }\n        case \"user\":\n            {\n                if (typeof message.content === \"string\") {\n                    return {\n                        role: \"user\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: message.content\n                            }\n                        ],\n                        providerMetadata: (_b = message.providerOptions) != null ? _b : message.experimental_providerMetadata\n                    };\n                }\n                return {\n                    role: \"user\",\n                    content: message.content.map((part)=>convertPartToLanguageModelPart(part, downloadedAssets)).filter((part)=>part.type !== \"text\" || part.text !== \"\"),\n                    providerMetadata: (_c = message.providerOptions) != null ? _c : message.experimental_providerMetadata\n                };\n            }\n        case \"assistant\":\n            {\n                if (typeof message.content === \"string\") {\n                    return {\n                        role: \"assistant\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: message.content\n                            }\n                        ],\n                        providerMetadata: (_d = message.providerOptions) != null ? _d : message.experimental_providerMetadata\n                    };\n                }\n                return {\n                    role: \"assistant\",\n                    content: message.content.filter(// remove empty text parts:\n                    (part)=>part.type !== \"text\" || part.text !== \"\").map((part)=>{\n                        var _a18;\n                        const providerOptions = (_a18 = part.providerOptions) != null ? _a18 : part.experimental_providerMetadata;\n                        switch(part.type){\n                            case \"file\":\n                                {\n                                    return {\n                                        type: \"file\",\n                                        data: part.data instanceof URL ? part.data : convertDataContentToBase64String(part.data),\n                                        filename: part.filename,\n                                        mimeType: part.mimeType,\n                                        providerMetadata: providerOptions\n                                    };\n                                }\n                            case \"reasoning\":\n                                {\n                                    return {\n                                        type: \"reasoning\",\n                                        text: part.text,\n                                        signature: part.signature,\n                                        providerMetadata: providerOptions\n                                    };\n                                }\n                            case \"redacted-reasoning\":\n                                {\n                                    return {\n                                        type: \"redacted-reasoning\",\n                                        data: part.data,\n                                        providerMetadata: providerOptions\n                                    };\n                                }\n                            case \"text\":\n                                {\n                                    return {\n                                        type: \"text\",\n                                        text: part.text,\n                                        providerMetadata: providerOptions\n                                    };\n                                }\n                            case \"tool-call\":\n                                {\n                                    return {\n                                        type: \"tool-call\",\n                                        toolCallId: part.toolCallId,\n                                        toolName: part.toolName,\n                                        args: part.args,\n                                        providerMetadata: providerOptions\n                                    };\n                                }\n                        }\n                    }),\n                    providerMetadata: (_e = message.providerOptions) != null ? _e : message.experimental_providerMetadata\n                };\n            }\n        case \"tool\":\n            {\n                return {\n                    role: \"tool\",\n                    content: message.content.map((part)=>{\n                        var _a18;\n                        return {\n                            type: \"tool-result\",\n                            toolCallId: part.toolCallId,\n                            toolName: part.toolName,\n                            result: part.result,\n                            content: part.experimental_content,\n                            isError: part.isError,\n                            providerMetadata: (_a18 = part.providerOptions) != null ? _a18 : part.experimental_providerMetadata\n                        };\n                    }),\n                    providerMetadata: (_f = message.providerOptions) != null ? _f : message.experimental_providerMetadata\n                };\n            }\n        default:\n            {\n                const _exhaustiveCheck = role;\n                throw new InvalidMessageRoleError({\n                    role: _exhaustiveCheck\n                });\n            }\n    }\n}\nasync function downloadAssets(messages, downloadImplementation, modelSupportsImageUrls, modelSupportsUrl) {\n    const urls = messages.filter((message)=>message.role === \"user\").map((message)=>message.content).filter((content)=>Array.isArray(content)).flat().filter((part)=>part.type === \"image\" || part.type === \"file\").filter((part)=>!(part.type === \"image\" && modelSupportsImageUrls === true)).map((part)=>part.type === \"image\" ? part.image : part.data).map((part)=>// support string urls:\n        typeof part === \"string\" && (part.startsWith(\"http:\") || part.startsWith(\"https:\")) ? new URL(part) : part).filter((image)=>image instanceof URL).filter((url)=>!modelSupportsUrl(url));\n    const downloadedImages = await Promise.all(urls.map(async (url)=>({\n            url,\n            data: await downloadImplementation({\n                url\n            })\n        })));\n    return Object.fromEntries(downloadedImages.map(({ url, data })=>[\n            url.toString(),\n            data\n        ]));\n}\nfunction convertPartToLanguageModelPart(part, downloadedAssets) {\n    var _a17, _b, _c, _d;\n    if (part.type === \"text\") {\n        return {\n            type: \"text\",\n            text: part.text,\n            providerMetadata: (_a17 = part.providerOptions) != null ? _a17 : part.experimental_providerMetadata\n        };\n    }\n    let mimeType = part.mimeType;\n    let data;\n    let content;\n    let normalizedData;\n    const type = part.type;\n    switch(type){\n        case \"image\":\n            data = part.image;\n            break;\n        case \"file\":\n            data = part.data;\n            break;\n        default:\n            throw new Error(`Unsupported part type: ${type}`);\n    }\n    try {\n        content = typeof data === \"string\" ? new URL(data) : data;\n    } catch (error) {\n        content = data;\n    }\n    if (content instanceof URL) {\n        if (content.protocol === \"data:\") {\n            const { mimeType: dataUrlMimeType, base64Content } = splitDataUrl(content.toString());\n            if (dataUrlMimeType == null || base64Content == null) {\n                throw new Error(`Invalid data URL format in part ${type}`);\n            }\n            mimeType = dataUrlMimeType;\n            normalizedData = convertDataContentToUint8Array(base64Content);\n        } else {\n            const downloadedFile = downloadedAssets[content.toString()];\n            if (downloadedFile) {\n                normalizedData = downloadedFile.data;\n                mimeType != null ? mimeType : mimeType = downloadedFile.mimeType;\n            } else {\n                normalizedData = content;\n            }\n        }\n    } else {\n        normalizedData = convertDataContentToUint8Array(content);\n    }\n    switch(type){\n        case \"image\":\n            {\n                if (normalizedData instanceof Uint8Array) {\n                    mimeType = (_b = detectMimeType({\n                        data: normalizedData,\n                        signatures: imageMimeTypeSignatures\n                    })) != null ? _b : mimeType;\n                }\n                return {\n                    type: \"image\",\n                    image: normalizedData,\n                    mimeType,\n                    providerMetadata: (_c = part.providerOptions) != null ? _c : part.experimental_providerMetadata\n                };\n            }\n        case \"file\":\n            {\n                if (mimeType == null) {\n                    throw new Error(`Mime type is missing for file part`);\n                }\n                return {\n                    type: \"file\",\n                    data: normalizedData instanceof Uint8Array ? convertDataContentToBase64String(normalizedData) : normalizedData,\n                    filename: part.filename,\n                    mimeType,\n                    providerMetadata: (_d = part.providerOptions) != null ? _d : part.experimental_providerMetadata\n                };\n            }\n    }\n}\n// core/prompt/prepare-call-settings.ts\nfunction prepareCallSettings({ maxTokens, temperature, topP, topK, presencePenalty, frequencyPenalty, stopSequences, seed }) {\n    if (maxTokens != null) {\n        if (!Number.isInteger(maxTokens)) {\n            throw new InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be an integer\"\n            });\n        }\n        if (maxTokens < 1) {\n            throw new InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be >= 1\"\n            });\n        }\n    }\n    if (temperature != null) {\n        if (typeof temperature !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"temperature\",\n                value: temperature,\n                message: \"temperature must be a number\"\n            });\n        }\n    }\n    if (topP != null) {\n        if (typeof topP !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"topP\",\n                value: topP,\n                message: \"topP must be a number\"\n            });\n        }\n    }\n    if (topK != null) {\n        if (typeof topK !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"topK\",\n                value: topK,\n                message: \"topK must be a number\"\n            });\n        }\n    }\n    if (presencePenalty != null) {\n        if (typeof presencePenalty !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"presencePenalty\",\n                value: presencePenalty,\n                message: \"presencePenalty must be a number\"\n            });\n        }\n    }\n    if (frequencyPenalty != null) {\n        if (typeof frequencyPenalty !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"frequencyPenalty\",\n                value: frequencyPenalty,\n                message: \"frequencyPenalty must be a number\"\n            });\n        }\n    }\n    if (seed != null) {\n        if (!Number.isInteger(seed)) {\n            throw new InvalidArgumentError({\n                parameter: \"seed\",\n                value: seed,\n                message: \"seed must be an integer\"\n            });\n        }\n    }\n    return {\n        maxTokens,\n        // TODO v5 remove default 0 for temperature\n        temperature: temperature != null ? temperature : 0,\n        topP,\n        topK,\n        presencePenalty,\n        frequencyPenalty,\n        stopSequences: stopSequences != null && stopSequences.length > 0 ? stopSequences : void 0,\n        seed\n    };\n}\n// core/prompt/standardize-prompt.ts\n\n\n\n// core/prompt/attachments-to-parts.ts\nfunction attachmentsToParts(attachments) {\n    var _a17, _b, _c;\n    const parts = [];\n    for (const attachment of attachments){\n        let url;\n        try {\n            url = new URL(attachment.url);\n        } catch (error) {\n            throw new Error(`Invalid URL: ${attachment.url}`);\n        }\n        switch(url.protocol){\n            case \"http:\":\n            case \"https:\":\n                {\n                    if ((_a17 = attachment.contentType) == null ? void 0 : _a17.startsWith(\"image/\")) {\n                        parts.push({\n                            type: \"image\",\n                            image: url\n                        });\n                    } else {\n                        if (!attachment.contentType) {\n                            throw new Error(\"If the attachment is not an image, it must specify a content type\");\n                        }\n                        parts.push({\n                            type: \"file\",\n                            data: url,\n                            mimeType: attachment.contentType\n                        });\n                    }\n                    break;\n                }\n            case \"data:\":\n                {\n                    let header;\n                    let base64Content;\n                    let mimeType;\n                    try {\n                        [header, base64Content] = attachment.url.split(\",\");\n                        mimeType = header.split(\";\")[0].split(\":\")[1];\n                    } catch (error) {\n                        throw new Error(`Error processing data URL: ${attachment.url}`);\n                    }\n                    if (mimeType == null || base64Content == null) {\n                        throw new Error(`Invalid data URL format: ${attachment.url}`);\n                    }\n                    if ((_b = attachment.contentType) == null ? void 0 : _b.startsWith(\"image/\")) {\n                        parts.push({\n                            type: \"image\",\n                            image: convertDataContentToUint8Array(base64Content)\n                        });\n                    } else if ((_c = attachment.contentType) == null ? void 0 : _c.startsWith(\"text/\")) {\n                        parts.push({\n                            type: \"text\",\n                            text: convertUint8ArrayToText(convertDataContentToUint8Array(base64Content))\n                        });\n                    } else {\n                        if (!attachment.contentType) {\n                            throw new Error(\"If the attachment is not an image or text, it must specify a content type\");\n                        }\n                        parts.push({\n                            type: \"file\",\n                            data: base64Content,\n                            mimeType: attachment.contentType\n                        });\n                    }\n                    break;\n                }\n            default:\n                {\n                    throw new Error(`Unsupported URL protocol: ${url.protocol}`);\n                }\n        }\n    }\n    return parts;\n}\n// core/prompt/message-conversion-error.ts\n\nvar name8 = \"AI_MessageConversionError\";\nvar marker8 = `vercel.ai.error.${name8}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar MessageConversionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor({ originalMessage, message }){\n        super({\n            name: name8,\n            message\n        });\n        this[_a8] = true;\n        this.originalMessage = originalMessage;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker8);\n    }\n};\n_a8 = symbol8;\n// core/prompt/convert-to-core-messages.ts\nfunction convertToCoreMessages(messages, options) {\n    var _a17, _b;\n    const tools = (_a17 = options == null ? void 0 : options.tools) != null ? _a17 : {};\n    const coreMessages = [];\n    for(let i = 0; i < messages.length; i++){\n        const message = messages[i];\n        const isLastMessage = i === messages.length - 1;\n        const { role, content, experimental_attachments } = message;\n        switch(role){\n            case \"system\":\n                {\n                    coreMessages.push({\n                        role: \"system\",\n                        content\n                    });\n                    break;\n                }\n            case \"user\":\n                {\n                    if (message.parts == null) {\n                        coreMessages.push({\n                            role: \"user\",\n                            content: experimental_attachments ? [\n                                {\n                                    type: \"text\",\n                                    text: content\n                                },\n                                ...attachmentsToParts(experimental_attachments)\n                            ] : content\n                        });\n                    } else {\n                        const textParts = message.parts.filter((part)=>part.type === \"text\").map((part)=>({\n                                type: \"text\",\n                                text: part.text\n                            }));\n                        coreMessages.push({\n                            role: \"user\",\n                            content: experimental_attachments ? [\n                                ...textParts,\n                                ...attachmentsToParts(experimental_attachments)\n                            ] : textParts\n                        });\n                    }\n                    break;\n                }\n            case \"assistant\":\n                {\n                    if (message.parts != null) {\n                        let processBlock2 = function() {\n                            const content2 = [];\n                            for (const part of block){\n                                switch(part.type){\n                                    case \"file\":\n                                    case \"text\":\n                                        {\n                                            content2.push(part);\n                                            break;\n                                        }\n                                    case \"reasoning\":\n                                        {\n                                            for (const detail of part.details){\n                                                switch(detail.type){\n                                                    case \"text\":\n                                                        content2.push({\n                                                            type: \"reasoning\",\n                                                            text: detail.text,\n                                                            signature: detail.signature\n                                                        });\n                                                        break;\n                                                    case \"redacted\":\n                                                        content2.push({\n                                                            type: \"redacted-reasoning\",\n                                                            data: detail.data\n                                                        });\n                                                        break;\n                                                }\n                                            }\n                                            break;\n                                        }\n                                    case \"tool-invocation\":\n                                        content2.push({\n                                            type: \"tool-call\",\n                                            toolCallId: part.toolInvocation.toolCallId,\n                                            toolName: part.toolInvocation.toolName,\n                                            args: part.toolInvocation.args\n                                        });\n                                        break;\n                                    default:\n                                        {\n                                            const _exhaustiveCheck = part;\n                                            throw new Error(`Unsupported part: ${_exhaustiveCheck}`);\n                                        }\n                                }\n                            }\n                            coreMessages.push({\n                                role: \"assistant\",\n                                content: content2\n                            });\n                            const stepInvocations = block.filter((part)=>part.type === \"tool-invocation\").map((part)=>part.toolInvocation);\n                            if (stepInvocations.length > 0) {\n                                coreMessages.push({\n                                    role: \"tool\",\n                                    content: stepInvocations.map((toolInvocation)=>{\n                                        if (!(\"result\" in toolInvocation)) {\n                                            throw new MessageConversionError({\n                                                originalMessage: message,\n                                                message: \"ToolInvocation must have a result: \" + JSON.stringify(toolInvocation)\n                                            });\n                                        }\n                                        const { toolCallId, toolName, result } = toolInvocation;\n                                        const tool2 = tools[toolName];\n                                        return (tool2 == null ? void 0 : tool2.experimental_toToolResultContent) != null ? {\n                                            type: \"tool-result\",\n                                            toolCallId,\n                                            toolName,\n                                            result: tool2.experimental_toToolResultContent(result),\n                                            experimental_content: tool2.experimental_toToolResultContent(result)\n                                        } : {\n                                            type: \"tool-result\",\n                                            toolCallId,\n                                            toolName,\n                                            result\n                                        };\n                                    })\n                                });\n                            }\n                            block = [];\n                            blockHasToolInvocations = false;\n                            currentStep++;\n                        };\n                        var processBlock = processBlock2;\n                        let currentStep = 0;\n                        let blockHasToolInvocations = false;\n                        let block = [];\n                        for (const part of message.parts){\n                            switch(part.type){\n                                case \"text\":\n                                    {\n                                        if (blockHasToolInvocations) {\n                                            processBlock2();\n                                        }\n                                        block.push(part);\n                                        break;\n                                    }\n                                case \"file\":\n                                case \"reasoning\":\n                                    {\n                                        block.push(part);\n                                        break;\n                                    }\n                                case \"tool-invocation\":\n                                    {\n                                        if (((_b = part.toolInvocation.step) != null ? _b : 0) !== currentStep) {\n                                            processBlock2();\n                                        }\n                                        block.push(part);\n                                        blockHasToolInvocations = true;\n                                        break;\n                                    }\n                            }\n                        }\n                        processBlock2();\n                        break;\n                    }\n                    const toolInvocations = message.toolInvocations;\n                    if (toolInvocations == null || toolInvocations.length === 0) {\n                        coreMessages.push({\n                            role: \"assistant\",\n                            content\n                        });\n                        break;\n                    }\n                    const maxStep = toolInvocations.reduce((max, toolInvocation)=>{\n                        var _a18;\n                        return Math.max(max, (_a18 = toolInvocation.step) != null ? _a18 : 0);\n                    }, 0);\n                    for(let i2 = 0; i2 <= maxStep; i2++){\n                        const stepInvocations = toolInvocations.filter((toolInvocation)=>{\n                            var _a18;\n                            return ((_a18 = toolInvocation.step) != null ? _a18 : 0) === i2;\n                        });\n                        if (stepInvocations.length === 0) {\n                            continue;\n                        }\n                        coreMessages.push({\n                            role: \"assistant\",\n                            content: [\n                                ...isLastMessage && content && i2 === 0 ? [\n                                    {\n                                        type: \"text\",\n                                        text: content\n                                    }\n                                ] : [],\n                                ...stepInvocations.map(({ toolCallId, toolName, args })=>({\n                                        type: \"tool-call\",\n                                        toolCallId,\n                                        toolName,\n                                        args\n                                    }))\n                            ]\n                        });\n                        coreMessages.push({\n                            role: \"tool\",\n                            content: stepInvocations.map((toolInvocation)=>{\n                                if (!(\"result\" in toolInvocation)) {\n                                    throw new MessageConversionError({\n                                        originalMessage: message,\n                                        message: \"ToolInvocation must have a result: \" + JSON.stringify(toolInvocation)\n                                    });\n                                }\n                                const { toolCallId, toolName, result } = toolInvocation;\n                                const tool2 = tools[toolName];\n                                return (tool2 == null ? void 0 : tool2.experimental_toToolResultContent) != null ? {\n                                    type: \"tool-result\",\n                                    toolCallId,\n                                    toolName,\n                                    result: tool2.experimental_toToolResultContent(result),\n                                    experimental_content: tool2.experimental_toToolResultContent(result)\n                                } : {\n                                    type: \"tool-result\",\n                                    toolCallId,\n                                    toolName,\n                                    result\n                                };\n                            })\n                        });\n                    }\n                    if (content && !isLastMessage) {\n                        coreMessages.push({\n                            role: \"assistant\",\n                            content\n                        });\n                    }\n                    break;\n                }\n            case \"data\":\n                {\n                    break;\n                }\n            default:\n                {\n                    const _exhaustiveCheck = role;\n                    throw new MessageConversionError({\n                        originalMessage: message,\n                        message: `Unsupported role: ${_exhaustiveCheck}`\n                    });\n                }\n        }\n    }\n    return coreMessages;\n}\n// core/prompt/detect-prompt-type.ts\nfunction detectPromptType(prompt) {\n    if (!Array.isArray(prompt)) {\n        return \"other\";\n    }\n    if (prompt.length === 0) {\n        return \"messages\";\n    }\n    const characteristics = prompt.map(detectSingleMessageCharacteristics);\n    if (characteristics.some((c)=>c === \"has-ui-specific-parts\")) {\n        return \"ui-messages\";\n    } else if (characteristics.every((c)=>c === \"has-core-specific-parts\" || c === \"message\")) {\n        return \"messages\";\n    } else {\n        return \"other\";\n    }\n}\nfunction detectSingleMessageCharacteristics(message) {\n    if (typeof message === \"object\" && message !== null && (message.role === \"function\" || // UI-only role\n    message.role === \"data\" || // UI-only role\n    \"toolInvocations\" in message || // UI-specific field\n    \"parts\" in message || // UI-specific field\n    \"experimental_attachments\" in message)) {\n        return \"has-ui-specific-parts\";\n    } else if (typeof message === \"object\" && message !== null && \"content\" in message && (Array.isArray(message.content) || // Core messages can have array content\n    \"experimental_providerMetadata\" in message || \"providerOptions\" in message)) {\n        return \"has-core-specific-parts\";\n    } else if (typeof message === \"object\" && message !== null && \"role\" in message && \"content\" in message && typeof message.content === \"string\" && [\n        \"system\",\n        \"user\",\n        \"assistant\",\n        \"tool\"\n    ].includes(message.role)) {\n        return \"message\";\n    } else {\n        return \"other\";\n    }\n}\n// core/prompt/message.ts\n\n// core/types/provider-metadata.ts\n\n// core/types/json-value.ts\n\nvar jsonValueSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.lazy(()=>zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.null(),\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.number(),\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.boolean(),\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.record(zod__WEBPACK_IMPORTED_MODULE_4__.z.string(), jsonValueSchema),\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.array(jsonValueSchema)\n    ]));\n// core/types/provider-metadata.ts\nvar providerMetadataSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.record(zod__WEBPACK_IMPORTED_MODULE_4__.z.string(), zod__WEBPACK_IMPORTED_MODULE_4__.z.record(zod__WEBPACK_IMPORTED_MODULE_4__.z.string(), jsonValueSchema));\n// core/prompt/content-part.ts\n\n// core/prompt/tool-result-content.ts\n\nvar toolResultContentSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.array(zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n        type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"text\"),\n        text: zod__WEBPACK_IMPORTED_MODULE_4__.z.string()\n    }),\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n        type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"image\"),\n        data: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n        mimeType: zod__WEBPACK_IMPORTED_MODULE_4__.z.string().optional()\n    })\n]));\n// core/prompt/content-part.ts\nvar textPartSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"text\"),\n    text: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    providerOptions: providerMetadataSchema.optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar imagePartSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"image\"),\n    image: zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n        dataContentSchema,\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.instanceof(URL)\n    ]),\n    mimeType: zod__WEBPACK_IMPORTED_MODULE_4__.z.string().optional(),\n    providerOptions: providerMetadataSchema.optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar filePartSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"file\"),\n    data: zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n        dataContentSchema,\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.instanceof(URL)\n    ]),\n    filename: zod__WEBPACK_IMPORTED_MODULE_4__.z.string().optional(),\n    mimeType: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    providerOptions: providerMetadataSchema.optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar reasoningPartSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"reasoning\"),\n    text: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    providerOptions: providerMetadataSchema.optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar redactedReasoningPartSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"redacted-reasoning\"),\n    data: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    providerOptions: providerMetadataSchema.optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar toolCallPartSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"tool-call\"),\n    toolCallId: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    toolName: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    args: zod__WEBPACK_IMPORTED_MODULE_4__.z.unknown(),\n    providerOptions: providerMetadataSchema.optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar toolResultPartSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"tool-result\"),\n    toolCallId: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    toolName: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    result: zod__WEBPACK_IMPORTED_MODULE_4__.z.unknown(),\n    content: toolResultContentSchema.optional(),\n    isError: zod__WEBPACK_IMPORTED_MODULE_4__.z.boolean().optional(),\n    providerOptions: providerMetadataSchema.optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\n// core/prompt/message.ts\nvar coreSystemMessageSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"system\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    providerOptions: providerMetadataSchema.optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreUserMessageSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"user\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.array(zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n            textPartSchema,\n            imagePartSchema,\n            filePartSchema\n        ]))\n    ]),\n    providerOptions: providerMetadataSchema.optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreAssistantMessageSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"assistant\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.array(zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n            textPartSchema,\n            filePartSchema,\n            reasoningPartSchema,\n            redactedReasoningPartSchema,\n            toolCallPartSchema\n        ]))\n    ]),\n    providerOptions: providerMetadataSchema.optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreToolMessageSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"tool\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_4__.z.array(toolResultPartSchema),\n    providerOptions: providerMetadataSchema.optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreMessageSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n    coreSystemMessageSchema,\n    coreUserMessageSchema,\n    coreAssistantMessageSchema,\n    coreToolMessageSchema\n]);\n// core/prompt/standardize-prompt.ts\nfunction standardizePrompt({ prompt, tools }) {\n    if (prompt.prompt == null && prompt.messages == null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n            prompt,\n            message: \"prompt or messages must be defined\"\n        });\n    }\n    if (prompt.prompt != null && prompt.messages != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n            prompt,\n            message: \"prompt and messages cannot be defined at the same time\"\n        });\n    }\n    if (prompt.system != null && typeof prompt.system !== \"string\") {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n            prompt,\n            message: \"system must be a string\"\n        });\n    }\n    if (prompt.prompt != null) {\n        if (typeof prompt.prompt !== \"string\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n                prompt,\n                message: \"prompt must be a string\"\n            });\n        }\n        return {\n            type: \"prompt\",\n            system: prompt.system,\n            messages: [\n                {\n                    role: \"user\",\n                    content: prompt.prompt\n                }\n            ]\n        };\n    }\n    if (prompt.messages != null) {\n        const promptType = detectPromptType(prompt.messages);\n        if (promptType === \"other\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n                prompt,\n                message: \"messages must be an array of CoreMessage or UIMessage\"\n            });\n        }\n        const messages = promptType === \"ui-messages\" ? convertToCoreMessages(prompt.messages, {\n            tools\n        }) : prompt.messages;\n        if (messages.length === 0) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n                prompt,\n                message: \"messages must not be empty\"\n            });\n        }\n        const validationResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n            value: messages,\n            schema: zod__WEBPACK_IMPORTED_MODULE_4__.z.array(coreMessageSchema)\n        });\n        if (!validationResult.success) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n                prompt,\n                message: \"messages must be an array of CoreMessage or UIMessage\",\n                cause: validationResult.error\n            });\n        }\n        return {\n            type: \"messages\",\n            messages,\n            system: prompt.system\n        };\n    }\n    throw new Error(\"unreachable\");\n}\n// core/types/usage.ts\nfunction calculateLanguageModelUsage({ promptTokens, completionTokens }) {\n    return {\n        promptTokens,\n        completionTokens,\n        totalTokens: promptTokens + completionTokens\n    };\n}\nfunction addLanguageModelUsage(usage1, usage2) {\n    return {\n        promptTokens: usage1.promptTokens + usage2.promptTokens,\n        completionTokens: usage1.completionTokens + usage2.completionTokens,\n        totalTokens: usage1.totalTokens + usage2.totalTokens\n    };\n}\n// core/generate-object/inject-json-instruction.ts\nvar DEFAULT_SCHEMA_PREFIX = \"JSON schema:\";\nvar DEFAULT_SCHEMA_SUFFIX = \"You MUST answer with a JSON object that matches the JSON schema above.\";\nvar DEFAULT_GENERIC_SUFFIX = \"You MUST answer with JSON.\";\nfunction injectJsonInstruction({ prompt, schema, schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : void 0, schemaSuffix = schema != null ? DEFAULT_SCHEMA_SUFFIX : DEFAULT_GENERIC_SUFFIX }) {\n    return [\n        prompt != null && prompt.length > 0 ? prompt : void 0,\n        prompt != null && prompt.length > 0 ? \"\" : void 0,\n        // add a newline if prompt is not null\n        schemaPrefix,\n        schema != null ? JSON.stringify(schema) : void 0,\n        schemaSuffix\n    ].filter((line)=>line != null).join(\"\\n\");\n}\n// core/generate-object/output-strategy.ts\n\n\n\n// core/util/async-iterable-stream.ts\nfunction createAsyncIterableStream(source) {\n    const stream = source.pipeThrough(new TransformStream());\n    stream[Symbol.asyncIterator] = ()=>{\n        const reader = stream.getReader();\n        return {\n            async next () {\n                const { done, value } = await reader.read();\n                return done ? {\n                    done: true,\n                    value: void 0\n                } : {\n                    done: false,\n                    value\n                };\n            }\n        };\n    };\n    return stream;\n}\n// core/generate-object/output-strategy.ts\nvar noSchemaOutputStrategy = {\n    type: \"no-schema\",\n    jsonSchema: void 0,\n    validatePartialResult ({ value, textDelta }) {\n        return {\n            success: true,\n            value: {\n                partial: value,\n                textDelta\n            }\n        };\n    },\n    validateFinalResult (value, context) {\n        return value === void 0 ? {\n            success: false,\n            error: new NoObjectGeneratedError({\n                message: \"No object generated: response did not match schema.\",\n                text: context.text,\n                response: context.response,\n                usage: context.usage,\n                finishReason: context.finishReason\n            })\n        } : {\n            success: true,\n            value\n        };\n    },\n    createElementStream () {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n            functionality: \"element streams in no-schema mode\"\n        });\n    }\n};\nvar objectOutputStrategy = (schema)=>({\n        type: \"object\",\n        jsonSchema: schema.jsonSchema,\n        validatePartialResult ({ value, textDelta }) {\n            return {\n                success: true,\n                value: {\n                    // Note: currently no validation of partial results:\n                    partial: value,\n                    textDelta\n                }\n            };\n        },\n        validateFinalResult (value) {\n            return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n                value,\n                schema\n            });\n        },\n        createElementStream () {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n                functionality: \"element streams in object mode\"\n            });\n        }\n    });\nvar arrayOutputStrategy = (schema)=>{\n    const { $schema, ...itemSchema } = schema.jsonSchema;\n    return {\n        type: \"enum\",\n        // wrap in object that contains array of elements, since most LLMs will not\n        // be able to generate an array directly:\n        // possible future optimization: use arrays directly when model supports grammar-guided generation\n        jsonSchema: {\n            $schema: \"http://json-schema.org/draft-07/schema#\",\n            type: \"object\",\n            properties: {\n                elements: {\n                    type: \"array\",\n                    items: itemSchema\n                }\n            },\n            required: [\n                \"elements\"\n            ],\n            additionalProperties: false\n        },\n        validatePartialResult ({ value, latestObject, isFirstDelta, isFinalDelta }) {\n            var _a17;\n            if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.isJSONArray)(value.elements)) {\n                return {\n                    success: false,\n                    error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError({\n                        value,\n                        cause: \"value must be an object that contains an array of elements\"\n                    })\n                };\n            }\n            const inputArray = value.elements;\n            const resultArray = [];\n            for(let i = 0; i < inputArray.length; i++){\n                const element = inputArray[i];\n                const result = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n                    value: element,\n                    schema\n                });\n                if (i === inputArray.length - 1 && !isFinalDelta) {\n                    continue;\n                }\n                if (!result.success) {\n                    return result;\n                }\n                resultArray.push(result.value);\n            }\n            const publishedElementCount = (_a17 = latestObject == null ? void 0 : latestObject.length) != null ? _a17 : 0;\n            let textDelta = \"\";\n            if (isFirstDelta) {\n                textDelta += \"[\";\n            }\n            if (publishedElementCount > 0) {\n                textDelta += \",\";\n            }\n            textDelta += resultArray.slice(publishedElementCount).map((element)=>JSON.stringify(element)).join(\",\");\n            if (isFinalDelta) {\n                textDelta += \"]\";\n            }\n            return {\n                success: true,\n                value: {\n                    partial: resultArray,\n                    textDelta\n                }\n            };\n        },\n        validateFinalResult (value) {\n            if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.isJSONArray)(value.elements)) {\n                return {\n                    success: false,\n                    error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError({\n                        value,\n                        cause: \"value must be an object that contains an array of elements\"\n                    })\n                };\n            }\n            const inputArray = value.elements;\n            for (const element of inputArray){\n                const result = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n                    value: element,\n                    schema\n                });\n                if (!result.success) {\n                    return result;\n                }\n            }\n            return {\n                success: true,\n                value: inputArray\n            };\n        },\n        createElementStream (originalStream) {\n            let publishedElements = 0;\n            return createAsyncIterableStream(originalStream.pipeThrough(new TransformStream({\n                transform (chunk, controller) {\n                    switch(chunk.type){\n                        case \"object\":\n                            {\n                                const array = chunk.object;\n                                for(; publishedElements < array.length; publishedElements++){\n                                    controller.enqueue(array[publishedElements]);\n                                }\n                                break;\n                            }\n                        case \"text-delta\":\n                        case \"finish\":\n                        case \"error\":\n                            break;\n                        default:\n                            {\n                                const _exhaustiveCheck = chunk;\n                                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n                            }\n                    }\n                }\n            })));\n        }\n    };\n};\nvar enumOutputStrategy = (enumValues)=>{\n    return {\n        type: \"enum\",\n        // wrap in object that contains result, since most LLMs will not\n        // be able to generate an enum value directly:\n        // possible future optimization: use enums directly when model supports top-level enums\n        jsonSchema: {\n            $schema: \"http://json-schema.org/draft-07/schema#\",\n            type: \"object\",\n            properties: {\n                result: {\n                    type: \"string\",\n                    enum: enumValues\n                }\n            },\n            required: [\n                \"result\"\n            ],\n            additionalProperties: false\n        },\n        validateFinalResult (value) {\n            if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.isJSONObject)(value) || typeof value.result !== \"string\") {\n                return {\n                    success: false,\n                    error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError({\n                        value,\n                        cause: 'value must be an object that contains a string in the \"result\" property.'\n                    })\n                };\n            }\n            const result = value.result;\n            return enumValues.includes(result) ? {\n                success: true,\n                value: result\n            } : {\n                success: false,\n                error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError({\n                    value,\n                    cause: \"value must be a string in the enum\"\n                })\n            };\n        },\n        validatePartialResult () {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n                functionality: \"partial results in enum mode\"\n            });\n        },\n        createElementStream () {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n                functionality: \"element streams in enum mode\"\n            });\n        }\n    };\n};\nfunction getOutputStrategy({ output, schema, enumValues }) {\n    switch(output){\n        case \"object\":\n            return objectOutputStrategy((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.asSchema)(schema));\n        case \"array\":\n            return arrayOutputStrategy((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.asSchema)(schema));\n        case \"enum\":\n            return enumOutputStrategy(enumValues);\n        case \"no-schema\":\n            return noSchemaOutputStrategy;\n        default:\n            {\n                const _exhaustiveCheck = output;\n                throw new Error(`Unsupported output: ${_exhaustiveCheck}`);\n            }\n    }\n}\n// core/generate-object/validate-object-generation-input.ts\nfunction validateObjectGenerationInput({ output, mode, schema, schemaName, schemaDescription, enumValues }) {\n    if (output != null && output !== \"object\" && output !== \"array\" && output !== \"enum\" && output !== \"no-schema\") {\n        throw new InvalidArgumentError({\n            parameter: \"output\",\n            value: output,\n            message: \"Invalid output type.\"\n        });\n    }\n    if (output === \"no-schema\") {\n        if (mode === \"auto\" || mode === \"tool\") {\n            throw new InvalidArgumentError({\n                parameter: \"mode\",\n                value: mode,\n                message: 'Mode must be \"json\" for no-schema output.'\n            });\n        }\n        if (schema != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Schema is not supported for no-schema output.\"\n            });\n        }\n        if (schemaDescription != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaDescription\",\n                value: schemaDescription,\n                message: \"Schema description is not supported for no-schema output.\"\n            });\n        }\n        if (schemaName != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaName\",\n                value: schemaName,\n                message: \"Schema name is not supported for no-schema output.\"\n            });\n        }\n        if (enumValues != null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are not supported for no-schema output.\"\n            });\n        }\n    }\n    if (output === \"object\") {\n        if (schema == null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Schema is required for object output.\"\n            });\n        }\n        if (enumValues != null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are not supported for object output.\"\n            });\n        }\n    }\n    if (output === \"array\") {\n        if (schema == null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Element schema is required for array output.\"\n            });\n        }\n        if (enumValues != null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are not supported for array output.\"\n            });\n        }\n    }\n    if (output === \"enum\") {\n        if (schema != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Schema is not supported for enum output.\"\n            });\n        }\n        if (schemaDescription != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaDescription\",\n                value: schemaDescription,\n                message: \"Schema description is not supported for enum output.\"\n            });\n        }\n        if (schemaName != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaName\",\n                value: schemaName,\n                message: \"Schema name is not supported for enum output.\"\n            });\n        }\n        if (enumValues == null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are required for enum output.\"\n            });\n        }\n        for (const value of enumValues){\n            if (typeof value !== \"string\") {\n                throw new InvalidArgumentError({\n                    parameter: \"enumValues\",\n                    value,\n                    message: \"Enum values must be strings.\"\n                });\n            }\n        }\n    }\n}\n// core/generate-object/generate-object.ts\nvar originalGenerateId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n    prefix: \"aiobj\",\n    size: 24\n});\nasync function generateObject({ model, enum: enumValues, // rename bc enum is reserved by typescript\nschema: inputSchema, schemaName, schemaDescription, mode, output = \"object\", system, prompt, messages, maxRetries: maxRetriesArg, abortSignal, headers, experimental_repairText: repairText, experimental_telemetry: telemetry, experimental_providerMetadata, providerOptions = experimental_providerMetadata, _internal: { generateId: generateId3 = originalGenerateId, currentDate = ()=>/* @__PURE__ */ new Date() } = {}, ...settings }) {\n    validateObjectGenerationInput({\n        output,\n        mode,\n        schema: inputSchema,\n        schemaName,\n        schemaDescription,\n        enumValues\n    });\n    const { maxRetries, retry } = prepareRetries({\n        maxRetries: maxRetriesArg\n    });\n    const outputStrategy = getOutputStrategy({\n        output,\n        schema: inputSchema,\n        enumValues\n    });\n    if (outputStrategy.type === \"no-schema\" && mode === void 0) {\n        mode = \"json\";\n    }\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            ...settings,\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    return recordSpan({\n        name: \"ai.generateObject\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.generateObject\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.prompt\": {\n                    input: ()=>JSON.stringify({\n                            system,\n                            prompt,\n                            messages\n                        })\n                },\n                \"ai.schema\": outputStrategy.jsonSchema != null ? {\n                    input: ()=>JSON.stringify(outputStrategy.jsonSchema)\n                } : void 0,\n                \"ai.schema.name\": schemaName,\n                \"ai.schema.description\": schemaDescription,\n                \"ai.settings.output\": outputStrategy.type,\n                \"ai.settings.mode\": mode\n            }\n        }),\n        tracer,\n        fn: async (span)=>{\n            var _a17, _b, _c, _d;\n            if (mode === \"auto\" || mode == null) {\n                mode = model.defaultObjectGenerationMode;\n            }\n            let result;\n            let finishReason;\n            let usage;\n            let warnings;\n            let rawResponse;\n            let response;\n            let request;\n            let logprobs;\n            let resultProviderMetadata;\n            switch(mode){\n                case \"json\":\n                    {\n                        const standardizedPrompt = standardizePrompt({\n                            prompt: {\n                                system: outputStrategy.jsonSchema == null ? injectJsonInstruction({\n                                    prompt: system\n                                }) : model.supportsStructuredOutputs ? system : injectJsonInstruction({\n                                    prompt: system,\n                                    schema: outputStrategy.jsonSchema\n                                }),\n                                prompt,\n                                messages\n                            },\n                            tools: void 0\n                        });\n                        const promptMessages = await convertToLanguageModelPrompt({\n                            prompt: standardizedPrompt,\n                            modelSupportsImageUrls: model.supportsImageUrls,\n                            modelSupportsUrl: (_a17 = model.supportsUrl) == null ? void 0 : _a17.bind(model)\n                        });\n                        const generateResult = await retry(()=>recordSpan({\n                                name: \"ai.generateObject.doGenerate\",\n                                attributes: selectTelemetryAttributes({\n                                    telemetry,\n                                    attributes: {\n                                        ...assembleOperationName({\n                                            operationId: \"ai.generateObject.doGenerate\",\n                                            telemetry\n                                        }),\n                                        ...baseTelemetryAttributes,\n                                        \"ai.prompt.format\": {\n                                            input: ()=>standardizedPrompt.type\n                                        },\n                                        \"ai.prompt.messages\": {\n                                            input: ()=>JSON.stringify(promptMessages)\n                                        },\n                                        \"ai.settings.mode\": mode,\n                                        // standardized gen-ai llm span attributes:\n                                        \"gen_ai.system\": model.provider,\n                                        \"gen_ai.request.model\": model.modelId,\n                                        \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                                        \"gen_ai.request.max_tokens\": settings.maxTokens,\n                                        \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                                        \"gen_ai.request.temperature\": settings.temperature,\n                                        \"gen_ai.request.top_k\": settings.topK,\n                                        \"gen_ai.request.top_p\": settings.topP\n                                    }\n                                }),\n                                tracer,\n                                fn: async (span2)=>{\n                                    var _a18, _b2, _c2, _d2, _e, _f;\n                                    const result2 = await model.doGenerate({\n                                        mode: {\n                                            type: \"object-json\",\n                                            schema: outputStrategy.jsonSchema,\n                                            name: schemaName,\n                                            description: schemaDescription\n                                        },\n                                        ...prepareCallSettings(settings),\n                                        inputFormat: standardizedPrompt.type,\n                                        prompt: promptMessages,\n                                        providerMetadata: providerOptions,\n                                        abortSignal,\n                                        headers\n                                    });\n                                    const responseData = {\n                                        id: (_b2 = (_a18 = result2.response) == null ? void 0 : _a18.id) != null ? _b2 : generateId3(),\n                                        timestamp: (_d2 = (_c2 = result2.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : currentDate(),\n                                        modelId: (_f = (_e = result2.response) == null ? void 0 : _e.modelId) != null ? _f : model.modelId\n                                    };\n                                    if (result2.text === void 0) {\n                                        throw new NoObjectGeneratedError({\n                                            message: \"No object generated: the model did not return a response.\",\n                                            response: responseData,\n                                            usage: calculateLanguageModelUsage(result2.usage),\n                                            finishReason: result2.finishReason\n                                        });\n                                    }\n                                    span2.setAttributes(selectTelemetryAttributes({\n                                        telemetry,\n                                        attributes: {\n                                            \"ai.response.finishReason\": result2.finishReason,\n                                            \"ai.response.object\": {\n                                                output: ()=>result2.text\n                                            },\n                                            \"ai.response.id\": responseData.id,\n                                            \"ai.response.model\": responseData.modelId,\n                                            \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                                            \"ai.usage.promptTokens\": result2.usage.promptTokens,\n                                            \"ai.usage.completionTokens\": result2.usage.completionTokens,\n                                            // standardized gen-ai llm span attributes:\n                                            \"gen_ai.response.finish_reasons\": [\n                                                result2.finishReason\n                                            ],\n                                            \"gen_ai.response.id\": responseData.id,\n                                            \"gen_ai.response.model\": responseData.modelId,\n                                            \"gen_ai.usage.prompt_tokens\": result2.usage.promptTokens,\n                                            \"gen_ai.usage.completion_tokens\": result2.usage.completionTokens\n                                        }\n                                    }));\n                                    return {\n                                        ...result2,\n                                        objectText: result2.text,\n                                        responseData\n                                    };\n                                }\n                            }));\n                        result = generateResult.objectText;\n                        finishReason = generateResult.finishReason;\n                        usage = generateResult.usage;\n                        warnings = generateResult.warnings;\n                        rawResponse = generateResult.rawResponse;\n                        logprobs = generateResult.logprobs;\n                        resultProviderMetadata = generateResult.providerMetadata;\n                        request = (_b = generateResult.request) != null ? _b : {};\n                        response = generateResult.responseData;\n                        break;\n                    }\n                case \"tool\":\n                    {\n                        const standardizedPrompt = standardizePrompt({\n                            prompt: {\n                                system,\n                                prompt,\n                                messages\n                            },\n                            tools: void 0\n                        });\n                        const promptMessages = await convertToLanguageModelPrompt({\n                            prompt: standardizedPrompt,\n                            modelSupportsImageUrls: model.supportsImageUrls,\n                            modelSupportsUrl: (_c = model.supportsUrl) == null ? void 0 : _c.bind(model)\n                        });\n                        const inputFormat = standardizedPrompt.type;\n                        const generateResult = await retry(()=>recordSpan({\n                                name: \"ai.generateObject.doGenerate\",\n                                attributes: selectTelemetryAttributes({\n                                    telemetry,\n                                    attributes: {\n                                        ...assembleOperationName({\n                                            operationId: \"ai.generateObject.doGenerate\",\n                                            telemetry\n                                        }),\n                                        ...baseTelemetryAttributes,\n                                        \"ai.prompt.format\": {\n                                            input: ()=>inputFormat\n                                        },\n                                        \"ai.prompt.messages\": {\n                                            input: ()=>JSON.stringify(promptMessages)\n                                        },\n                                        \"ai.settings.mode\": mode,\n                                        // standardized gen-ai llm span attributes:\n                                        \"gen_ai.system\": model.provider,\n                                        \"gen_ai.request.model\": model.modelId,\n                                        \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                                        \"gen_ai.request.max_tokens\": settings.maxTokens,\n                                        \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                                        \"gen_ai.request.temperature\": settings.temperature,\n                                        \"gen_ai.request.top_k\": settings.topK,\n                                        \"gen_ai.request.top_p\": settings.topP\n                                    }\n                                }),\n                                tracer,\n                                fn: async (span2)=>{\n                                    var _a18, _b2, _c2, _d2, _e, _f, _g, _h;\n                                    const result2 = await model.doGenerate({\n                                        mode: {\n                                            type: \"object-tool\",\n                                            tool: {\n                                                type: \"function\",\n                                                name: schemaName != null ? schemaName : \"json\",\n                                                description: schemaDescription != null ? schemaDescription : \"Respond with a JSON object.\",\n                                                parameters: outputStrategy.jsonSchema\n                                            }\n                                        },\n                                        ...prepareCallSettings(settings),\n                                        inputFormat,\n                                        prompt: promptMessages,\n                                        providerMetadata: providerOptions,\n                                        abortSignal,\n                                        headers\n                                    });\n                                    const objectText = (_b2 = (_a18 = result2.toolCalls) == null ? void 0 : _a18[0]) == null ? void 0 : _b2.args;\n                                    const responseData = {\n                                        id: (_d2 = (_c2 = result2.response) == null ? void 0 : _c2.id) != null ? _d2 : generateId3(),\n                                        timestamp: (_f = (_e = result2.response) == null ? void 0 : _e.timestamp) != null ? _f : currentDate(),\n                                        modelId: (_h = (_g = result2.response) == null ? void 0 : _g.modelId) != null ? _h : model.modelId\n                                    };\n                                    if (objectText === void 0) {\n                                        throw new NoObjectGeneratedError({\n                                            message: \"No object generated: the tool was not called.\",\n                                            response: responseData,\n                                            usage: calculateLanguageModelUsage(result2.usage),\n                                            finishReason: result2.finishReason\n                                        });\n                                    }\n                                    span2.setAttributes(selectTelemetryAttributes({\n                                        telemetry,\n                                        attributes: {\n                                            \"ai.response.finishReason\": result2.finishReason,\n                                            \"ai.response.object\": {\n                                                output: ()=>objectText\n                                            },\n                                            \"ai.response.id\": responseData.id,\n                                            \"ai.response.model\": responseData.modelId,\n                                            \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                                            \"ai.usage.promptTokens\": result2.usage.promptTokens,\n                                            \"ai.usage.completionTokens\": result2.usage.completionTokens,\n                                            // standardized gen-ai llm span attributes:\n                                            \"gen_ai.response.finish_reasons\": [\n                                                result2.finishReason\n                                            ],\n                                            \"gen_ai.response.id\": responseData.id,\n                                            \"gen_ai.response.model\": responseData.modelId,\n                                            \"gen_ai.usage.input_tokens\": result2.usage.promptTokens,\n                                            \"gen_ai.usage.output_tokens\": result2.usage.completionTokens\n                                        }\n                                    }));\n                                    return {\n                                        ...result2,\n                                        objectText,\n                                        responseData\n                                    };\n                                }\n                            }));\n                        result = generateResult.objectText;\n                        finishReason = generateResult.finishReason;\n                        usage = generateResult.usage;\n                        warnings = generateResult.warnings;\n                        rawResponse = generateResult.rawResponse;\n                        logprobs = generateResult.logprobs;\n                        resultProviderMetadata = generateResult.providerMetadata;\n                        request = (_d = generateResult.request) != null ? _d : {};\n                        response = generateResult.responseData;\n                        break;\n                    }\n                case void 0:\n                    {\n                        throw new Error(\"Model does not have a default object generation mode.\");\n                    }\n                default:\n                    {\n                        const _exhaustiveCheck = mode;\n                        throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n                    }\n            }\n            function processResult(result2) {\n                const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({\n                    text: result2\n                });\n                if (!parseResult.success) {\n                    throw new NoObjectGeneratedError({\n                        message: \"No object generated: could not parse the response.\",\n                        cause: parseResult.error,\n                        text: result2,\n                        response,\n                        usage: calculateLanguageModelUsage(usage),\n                        finishReason\n                    });\n                }\n                const validationResult = outputStrategy.validateFinalResult(parseResult.value, {\n                    text: result2,\n                    response,\n                    usage: calculateLanguageModelUsage(usage)\n                });\n                if (!validationResult.success) {\n                    throw new NoObjectGeneratedError({\n                        message: \"No object generated: response did not match schema.\",\n                        cause: validationResult.error,\n                        text: result2,\n                        response,\n                        usage: calculateLanguageModelUsage(usage),\n                        finishReason\n                    });\n                }\n                return validationResult.value;\n            }\n            let object2;\n            try {\n                object2 = processResult(result);\n            } catch (error) {\n                if (repairText != null && NoObjectGeneratedError.isInstance(error) && (_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError.isInstance(error.cause) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.isInstance(error.cause))) {\n                    const repairedText = await repairText({\n                        text: result,\n                        error: error.cause\n                    });\n                    if (repairedText === null) {\n                        throw error;\n                    }\n                    object2 = processResult(repairedText);\n                } else {\n                    throw error;\n                }\n            }\n            span.setAttributes(selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    \"ai.response.finishReason\": finishReason,\n                    \"ai.response.object\": {\n                        output: ()=>JSON.stringify(object2)\n                    },\n                    \"ai.usage.promptTokens\": usage.promptTokens,\n                    \"ai.usage.completionTokens\": usage.completionTokens\n                }\n            }));\n            return new DefaultGenerateObjectResult({\n                object: object2,\n                finishReason,\n                usage: calculateLanguageModelUsage(usage),\n                warnings,\n                request,\n                response: {\n                    ...response,\n                    headers: rawResponse == null ? void 0 : rawResponse.headers,\n                    body: rawResponse == null ? void 0 : rawResponse.body\n                },\n                logprobs,\n                providerMetadata: resultProviderMetadata\n            });\n        }\n    });\n}\nvar DefaultGenerateObjectResult = class {\n    constructor(options){\n        this.object = options.object;\n        this.finishReason = options.finishReason;\n        this.usage = options.usage;\n        this.warnings = options.warnings;\n        this.providerMetadata = options.providerMetadata;\n        this.experimental_providerMetadata = options.providerMetadata;\n        this.response = options.response;\n        this.request = options.request;\n        this.logprobs = options.logprobs;\n    }\n    toJsonResponse(init) {\n        var _a17;\n        return new Response(JSON.stringify(this.object), {\n            status: (_a17 = init == null ? void 0 : init.status) != null ? _a17 : 200,\n            headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {\n                contentType: \"application/json; charset=utf-8\"\n            })\n        });\n    }\n};\n// core/generate-object/stream-object.ts\n\n\n// util/delayed-promise.ts\nvar DelayedPromise = class {\n    constructor(){\n        this.status = {\n            type: \"pending\"\n        };\n        this._resolve = void 0;\n        this._reject = void 0;\n    }\n    get value() {\n        if (this.promise) {\n            return this.promise;\n        }\n        this.promise = new Promise((resolve, reject)=>{\n            if (this.status.type === \"resolved\") {\n                resolve(this.status.value);\n            } else if (this.status.type === \"rejected\") {\n                reject(this.status.error);\n            }\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        return this.promise;\n    }\n    resolve(value) {\n        var _a17;\n        this.status = {\n            type: \"resolved\",\n            value\n        };\n        if (this.promise) {\n            (_a17 = this._resolve) == null ? void 0 : _a17.call(this, value);\n        }\n    }\n    reject(error) {\n        var _a17;\n        this.status = {\n            type: \"rejected\",\n            error\n        };\n        if (this.promise) {\n            (_a17 = this._reject) == null ? void 0 : _a17.call(this, error);\n        }\n    }\n};\n// util/create-resolvable-promise.ts\nfunction createResolvablePromise() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    return {\n        promise,\n        resolve,\n        reject\n    };\n}\n// core/util/create-stitchable-stream.ts\nfunction createStitchableStream() {\n    let innerStreamReaders = [];\n    let controller = null;\n    let isClosed = false;\n    let waitForNewStream = createResolvablePromise();\n    const processPull = async ()=>{\n        if (isClosed && innerStreamReaders.length === 0) {\n            controller == null ? void 0 : controller.close();\n            return;\n        }\n        if (innerStreamReaders.length === 0) {\n            waitForNewStream = createResolvablePromise();\n            await waitForNewStream.promise;\n            return processPull();\n        }\n        try {\n            const { value, done } = await innerStreamReaders[0].read();\n            if (done) {\n                innerStreamReaders.shift();\n                if (innerStreamReaders.length > 0) {\n                    await processPull();\n                } else if (isClosed) {\n                    controller == null ? void 0 : controller.close();\n                }\n            } else {\n                controller == null ? void 0 : controller.enqueue(value);\n            }\n        } catch (error) {\n            controller == null ? void 0 : controller.error(error);\n            innerStreamReaders.shift();\n            if (isClosed && innerStreamReaders.length === 0) {\n                controller == null ? void 0 : controller.close();\n            }\n        }\n    };\n    return {\n        stream: new ReadableStream({\n            start (controllerParam) {\n                controller = controllerParam;\n            },\n            pull: processPull,\n            async cancel () {\n                for (const reader of innerStreamReaders){\n                    await reader.cancel();\n                }\n                innerStreamReaders = [];\n                isClosed = true;\n            }\n        }),\n        addStream: (innerStream)=>{\n            if (isClosed) {\n                throw new Error(\"Cannot add inner stream: outer stream is closed\");\n            }\n            innerStreamReaders.push(innerStream.getReader());\n            waitForNewStream.resolve();\n        },\n        /**\n     * Gracefully close the outer stream. This will let the inner streams\n     * finish processing and then close the outer stream.\n     */ close: ()=>{\n            isClosed = true;\n            waitForNewStream.resolve();\n            if (innerStreamReaders.length === 0) {\n                controller == null ? void 0 : controller.close();\n            }\n        },\n        /**\n     * Immediately close the outer stream. This will cancel all inner streams\n     * and close the outer stream.\n     */ terminate: ()=>{\n            isClosed = true;\n            waitForNewStream.resolve();\n            innerStreamReaders.forEach((reader)=>reader.cancel());\n            innerStreamReaders = [];\n            controller == null ? void 0 : controller.close();\n        }\n    };\n}\n// core/util/now.ts\nfunction now() {\n    var _a17, _b;\n    return (_b = (_a17 = globalThis == null ? void 0 : globalThis.performance) == null ? void 0 : _a17.now()) != null ? _b : Date.now();\n}\n// core/generate-object/stream-object.ts\nvar originalGenerateId2 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n    prefix: \"aiobj\",\n    size: 24\n});\nfunction streamObject({ model, schema: inputSchema, schemaName, schemaDescription, mode, output = \"object\", system, prompt, messages, maxRetries, abortSignal, headers, experimental_telemetry: telemetry, experimental_providerMetadata, providerOptions = experimental_providerMetadata, onError, onFinish, _internal: { generateId: generateId3 = originalGenerateId2, currentDate = ()=>/* @__PURE__ */ new Date(), now: now2 = now } = {}, ...settings }) {\n    validateObjectGenerationInput({\n        output,\n        mode,\n        schema: inputSchema,\n        schemaName,\n        schemaDescription\n    });\n    const outputStrategy = getOutputStrategy({\n        output,\n        schema: inputSchema\n    });\n    if (outputStrategy.type === \"no-schema\" && mode === void 0) {\n        mode = \"json\";\n    }\n    return new DefaultStreamObjectResult({\n        model,\n        telemetry,\n        headers,\n        settings,\n        maxRetries,\n        abortSignal,\n        outputStrategy,\n        system,\n        prompt,\n        messages,\n        schemaName,\n        schemaDescription,\n        providerOptions,\n        mode,\n        onError,\n        onFinish,\n        generateId: generateId3,\n        currentDate,\n        now: now2\n    });\n}\nvar DefaultStreamObjectResult = class {\n    constructor({ model, headers, telemetry, settings, maxRetries: maxRetriesArg, abortSignal, outputStrategy, system, prompt, messages, schemaName, schemaDescription, providerOptions, mode, onError, onFinish, generateId: generateId3, currentDate, now: now2 }){\n        this.objectPromise = new DelayedPromise();\n        this.usagePromise = new DelayedPromise();\n        this.providerMetadataPromise = new DelayedPromise();\n        this.warningsPromise = new DelayedPromise();\n        this.requestPromise = new DelayedPromise();\n        this.responsePromise = new DelayedPromise();\n        const { maxRetries, retry } = prepareRetries({\n            maxRetries: maxRetriesArg\n        });\n        const baseTelemetryAttributes = getBaseTelemetryAttributes({\n            model,\n            telemetry,\n            headers,\n            settings: {\n                ...settings,\n                maxRetries\n            }\n        });\n        const tracer = getTracer(telemetry);\n        const self = this;\n        const stitchableStream = createStitchableStream();\n        const eventProcessor = new TransformStream({\n            transform (chunk, controller) {\n                controller.enqueue(chunk);\n                if (chunk.type === \"error\") {\n                    onError == null ? void 0 : onError({\n                        error: chunk.error\n                    });\n                }\n            }\n        });\n        this.baseStream = stitchableStream.stream.pipeThrough(eventProcessor);\n        recordSpan({\n            name: \"ai.streamObject\",\n            attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    ...assembleOperationName({\n                        operationId: \"ai.streamObject\",\n                        telemetry\n                    }),\n                    ...baseTelemetryAttributes,\n                    // specific settings that only make sense on the outer level:\n                    \"ai.prompt\": {\n                        input: ()=>JSON.stringify({\n                                system,\n                                prompt,\n                                messages\n                            })\n                    },\n                    \"ai.schema\": outputStrategy.jsonSchema != null ? {\n                        input: ()=>JSON.stringify(outputStrategy.jsonSchema)\n                    } : void 0,\n                    \"ai.schema.name\": schemaName,\n                    \"ai.schema.description\": schemaDescription,\n                    \"ai.settings.output\": outputStrategy.type,\n                    \"ai.settings.mode\": mode\n                }\n            }),\n            tracer,\n            endWhenDone: false,\n            fn: async (rootSpan)=>{\n                var _a17, _b;\n                if (mode === \"auto\" || mode == null) {\n                    mode = model.defaultObjectGenerationMode;\n                }\n                let callOptions;\n                let transformer;\n                switch(mode){\n                    case \"json\":\n                        {\n                            const standardizedPrompt = standardizePrompt({\n                                prompt: {\n                                    system: outputStrategy.jsonSchema == null ? injectJsonInstruction({\n                                        prompt: system\n                                    }) : model.supportsStructuredOutputs ? system : injectJsonInstruction({\n                                        prompt: system,\n                                        schema: outputStrategy.jsonSchema\n                                    }),\n                                    prompt,\n                                    messages\n                                },\n                                tools: void 0\n                            });\n                            callOptions = {\n                                mode: {\n                                    type: \"object-json\",\n                                    schema: outputStrategy.jsonSchema,\n                                    name: schemaName,\n                                    description: schemaDescription\n                                },\n                                ...prepareCallSettings(settings),\n                                inputFormat: standardizedPrompt.type,\n                                prompt: await convertToLanguageModelPrompt({\n                                    prompt: standardizedPrompt,\n                                    modelSupportsImageUrls: model.supportsImageUrls,\n                                    modelSupportsUrl: (_a17 = model.supportsUrl) == null ? void 0 : _a17.bind(model)\n                                }),\n                                providerMetadata: providerOptions,\n                                abortSignal,\n                                headers\n                            };\n                            transformer = {\n                                transform: (chunk, controller)=>{\n                                    switch(chunk.type){\n                                        case \"text-delta\":\n                                            controller.enqueue(chunk.textDelta);\n                                            break;\n                                        case \"response-metadata\":\n                                        case \"finish\":\n                                        case \"error\":\n                                            controller.enqueue(chunk);\n                                            break;\n                                    }\n                                }\n                            };\n                            break;\n                        }\n                    case \"tool\":\n                        {\n                            const standardizedPrompt = standardizePrompt({\n                                prompt: {\n                                    system,\n                                    prompt,\n                                    messages\n                                },\n                                tools: void 0\n                            });\n                            callOptions = {\n                                mode: {\n                                    type: \"object-tool\",\n                                    tool: {\n                                        type: \"function\",\n                                        name: schemaName != null ? schemaName : \"json\",\n                                        description: schemaDescription != null ? schemaDescription : \"Respond with a JSON object.\",\n                                        parameters: outputStrategy.jsonSchema\n                                    }\n                                },\n                                ...prepareCallSettings(settings),\n                                inputFormat: standardizedPrompt.type,\n                                prompt: await convertToLanguageModelPrompt({\n                                    prompt: standardizedPrompt,\n                                    modelSupportsImageUrls: model.supportsImageUrls,\n                                    modelSupportsUrl: (_b = model.supportsUrl) == null ? void 0 : _b.bind(model)\n                                }),\n                                providerMetadata: providerOptions,\n                                abortSignal,\n                                headers\n                            };\n                            transformer = {\n                                transform (chunk, controller) {\n                                    switch(chunk.type){\n                                        case \"tool-call-delta\":\n                                            controller.enqueue(chunk.argsTextDelta);\n                                            break;\n                                        case \"response-metadata\":\n                                        case \"finish\":\n                                        case \"error\":\n                                            controller.enqueue(chunk);\n                                            break;\n                                    }\n                                }\n                            };\n                            break;\n                        }\n                    case void 0:\n                        {\n                            throw new Error(\"Model does not have a default object generation mode.\");\n                        }\n                    default:\n                        {\n                            const _exhaustiveCheck = mode;\n                            throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n                        }\n                }\n                const { result: { stream, warnings, rawResponse, request }, doStreamSpan, startTimestampMs } = await retry(()=>recordSpan({\n                        name: \"ai.streamObject.doStream\",\n                        attributes: selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                ...assembleOperationName({\n                                    operationId: \"ai.streamObject.doStream\",\n                                    telemetry\n                                }),\n                                ...baseTelemetryAttributes,\n                                \"ai.prompt.format\": {\n                                    input: ()=>callOptions.inputFormat\n                                },\n                                \"ai.prompt.messages\": {\n                                    input: ()=>JSON.stringify(callOptions.prompt)\n                                },\n                                \"ai.settings.mode\": mode,\n                                // standardized gen-ai llm span attributes:\n                                \"gen_ai.system\": model.provider,\n                                \"gen_ai.request.model\": model.modelId,\n                                \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                                \"gen_ai.request.max_tokens\": settings.maxTokens,\n                                \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                                \"gen_ai.request.temperature\": settings.temperature,\n                                \"gen_ai.request.top_k\": settings.topK,\n                                \"gen_ai.request.top_p\": settings.topP\n                            }\n                        }),\n                        tracer,\n                        endWhenDone: false,\n                        fn: async (doStreamSpan2)=>({\n                                startTimestampMs: now2(),\n                                doStreamSpan: doStreamSpan2,\n                                result: await model.doStream(callOptions)\n                            })\n                    }));\n                self.requestPromise.resolve(request != null ? request : {});\n                let usage;\n                let finishReason;\n                let providerMetadata;\n                let object2;\n                let error;\n                let accumulatedText = \"\";\n                let textDelta = \"\";\n                let response = {\n                    id: generateId3(),\n                    timestamp: currentDate(),\n                    modelId: model.modelId\n                };\n                let latestObjectJson = void 0;\n                let latestObject = void 0;\n                let isFirstChunk = true;\n                let isFirstDelta = true;\n                const transformedStream = stream.pipeThrough(new TransformStream(transformer)).pipeThrough(new TransformStream({\n                    async transform (chunk, controller) {\n                        var _a18, _b2, _c;\n                        if (isFirstChunk) {\n                            const msToFirstChunk = now2() - startTimestampMs;\n                            isFirstChunk = false;\n                            doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n                                \"ai.stream.msToFirstChunk\": msToFirstChunk\n                            });\n                            doStreamSpan.setAttributes({\n                                \"ai.stream.msToFirstChunk\": msToFirstChunk\n                            });\n                        }\n                        if (typeof chunk === \"string\") {\n                            accumulatedText += chunk;\n                            textDelta += chunk;\n                            const { value: currentObjectJson, state: parseState } = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.parsePartialJson)(accumulatedText);\n                            if (currentObjectJson !== void 0 && !(0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.isDeepEqualData)(latestObjectJson, currentObjectJson)) {\n                                const validationResult = outputStrategy.validatePartialResult({\n                                    value: currentObjectJson,\n                                    textDelta,\n                                    latestObject,\n                                    isFirstDelta,\n                                    isFinalDelta: parseState === \"successful-parse\"\n                                });\n                                if (validationResult.success && !(0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.isDeepEqualData)(latestObject, validationResult.value.partial)) {\n                                    latestObjectJson = currentObjectJson;\n                                    latestObject = validationResult.value.partial;\n                                    controller.enqueue({\n                                        type: \"object\",\n                                        object: latestObject\n                                    });\n                                    controller.enqueue({\n                                        type: \"text-delta\",\n                                        textDelta: validationResult.value.textDelta\n                                    });\n                                    textDelta = \"\";\n                                    isFirstDelta = false;\n                                }\n                            }\n                            return;\n                        }\n                        switch(chunk.type){\n                            case \"response-metadata\":\n                                {\n                                    response = {\n                                        id: (_a18 = chunk.id) != null ? _a18 : response.id,\n                                        timestamp: (_b2 = chunk.timestamp) != null ? _b2 : response.timestamp,\n                                        modelId: (_c = chunk.modelId) != null ? _c : response.modelId\n                                    };\n                                    break;\n                                }\n                            case \"finish\":\n                                {\n                                    if (textDelta !== \"\") {\n                                        controller.enqueue({\n                                            type: \"text-delta\",\n                                            textDelta\n                                        });\n                                    }\n                                    finishReason = chunk.finishReason;\n                                    usage = calculateLanguageModelUsage(chunk.usage);\n                                    providerMetadata = chunk.providerMetadata;\n                                    controller.enqueue({\n                                        ...chunk,\n                                        usage,\n                                        response\n                                    });\n                                    self.usagePromise.resolve(usage);\n                                    self.providerMetadataPromise.resolve(providerMetadata);\n                                    self.responsePromise.resolve({\n                                        ...response,\n                                        headers: rawResponse == null ? void 0 : rawResponse.headers\n                                    });\n                                    const validationResult = outputStrategy.validateFinalResult(latestObjectJson, {\n                                        text: accumulatedText,\n                                        response,\n                                        usage\n                                    });\n                                    if (validationResult.success) {\n                                        object2 = validationResult.value;\n                                        self.objectPromise.resolve(object2);\n                                    } else {\n                                        error = new NoObjectGeneratedError({\n                                            message: \"No object generated: response did not match schema.\",\n                                            cause: validationResult.error,\n                                            text: accumulatedText,\n                                            response,\n                                            usage,\n                                            finishReason\n                                        });\n                                        self.objectPromise.reject(error);\n                                    }\n                                    break;\n                                }\n                            default:\n                                {\n                                    controller.enqueue(chunk);\n                                    break;\n                                }\n                        }\n                    },\n                    // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n                    async flush (controller) {\n                        try {\n                            const finalUsage = usage != null ? usage : {\n                                promptTokens: NaN,\n                                completionTokens: NaN,\n                                totalTokens: NaN\n                            };\n                            doStreamSpan.setAttributes(selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.response.finishReason\": finishReason,\n                                    \"ai.response.object\": {\n                                        output: ()=>JSON.stringify(object2)\n                                    },\n                                    \"ai.response.id\": response.id,\n                                    \"ai.response.model\": response.modelId,\n                                    \"ai.response.timestamp\": response.timestamp.toISOString(),\n                                    \"ai.usage.promptTokens\": finalUsage.promptTokens,\n                                    \"ai.usage.completionTokens\": finalUsage.completionTokens,\n                                    // standardized gen-ai llm span attributes:\n                                    \"gen_ai.response.finish_reasons\": [\n                                        finishReason\n                                    ],\n                                    \"gen_ai.response.id\": response.id,\n                                    \"gen_ai.response.model\": response.modelId,\n                                    \"gen_ai.usage.input_tokens\": finalUsage.promptTokens,\n                                    \"gen_ai.usage.output_tokens\": finalUsage.completionTokens\n                                }\n                            }));\n                            doStreamSpan.end();\n                            rootSpan.setAttributes(selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.usage.promptTokens\": finalUsage.promptTokens,\n                                    \"ai.usage.completionTokens\": finalUsage.completionTokens,\n                                    \"ai.response.object\": {\n                                        output: ()=>JSON.stringify(object2)\n                                    }\n                                }\n                            }));\n                            await (onFinish == null ? void 0 : onFinish({\n                                usage: finalUsage,\n                                object: object2,\n                                error,\n                                response: {\n                                    ...response,\n                                    headers: rawResponse == null ? void 0 : rawResponse.headers\n                                },\n                                warnings,\n                                providerMetadata,\n                                experimental_providerMetadata: providerMetadata\n                            }));\n                        } catch (error2) {\n                            controller.enqueue({\n                                type: \"error\",\n                                error: error2\n                            });\n                        } finally{\n                            rootSpan.end();\n                        }\n                    }\n                }));\n                stitchableStream.addStream(transformedStream);\n            }\n        }).catch((error)=>{\n            stitchableStream.addStream(new ReadableStream({\n                start (controller) {\n                    controller.enqueue({\n                        type: \"error\",\n                        error\n                    });\n                    controller.close();\n                }\n            }));\n        }).finally(()=>{\n            stitchableStream.close();\n        });\n        this.outputStrategy = outputStrategy;\n    }\n    get object() {\n        return this.objectPromise.value;\n    }\n    get usage() {\n        return this.usagePromise.value;\n    }\n    get experimental_providerMetadata() {\n        return this.providerMetadataPromise.value;\n    }\n    get providerMetadata() {\n        return this.providerMetadataPromise.value;\n    }\n    get warnings() {\n        return this.warningsPromise.value;\n    }\n    get request() {\n        return this.requestPromise.value;\n    }\n    get response() {\n        return this.responsePromise.value;\n    }\n    get partialObjectStream() {\n        return createAsyncIterableStream(this.baseStream.pipeThrough(new TransformStream({\n            transform (chunk, controller) {\n                switch(chunk.type){\n                    case \"object\":\n                        controller.enqueue(chunk.object);\n                        break;\n                    case \"text-delta\":\n                    case \"finish\":\n                    case \"error\":\n                        break;\n                    default:\n                        {\n                            const _exhaustiveCheck = chunk;\n                            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n                        }\n                }\n            }\n        })));\n    }\n    get elementStream() {\n        return this.outputStrategy.createElementStream(this.baseStream);\n    }\n    get textStream() {\n        return createAsyncIterableStream(this.baseStream.pipeThrough(new TransformStream({\n            transform (chunk, controller) {\n                switch(chunk.type){\n                    case \"text-delta\":\n                        controller.enqueue(chunk.textDelta);\n                        break;\n                    case \"object\":\n                    case \"finish\":\n                    case \"error\":\n                        break;\n                    default:\n                        {\n                            const _exhaustiveCheck = chunk;\n                            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n                        }\n                }\n            }\n        })));\n    }\n    get fullStream() {\n        return createAsyncIterableStream(this.baseStream);\n    }\n    pipeTextStreamToResponse(response, init) {\n        writeToServerResponse({\n            response,\n            status: init == null ? void 0 : init.status,\n            statusText: init == null ? void 0 : init.statusText,\n            headers: prepareOutgoingHttpHeaders(init == null ? void 0 : init.headers, {\n                contentType: \"text/plain; charset=utf-8\"\n            }),\n            stream: this.textStream.pipeThrough(new TextEncoderStream())\n        });\n    }\n    toTextStreamResponse(init) {\n        var _a17;\n        return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n            status: (_a17 = init == null ? void 0 : init.status) != null ? _a17 : 200,\n            headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {\n                contentType: \"text/plain; charset=utf-8\"\n            })\n        });\n    }\n};\n// core/generate-text/generate-text.ts\n\n// errors/no-output-specified-error.ts\n\nvar name9 = \"AI_NoOutputSpecifiedError\";\nvar marker9 = `vercel.ai.error.${name9}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar NoOutputSpecifiedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    // used in isInstance\n    constructor({ message = \"No output specified.\" } = {}){\n        super({\n            name: name9,\n            message\n        });\n        this[_a9] = true;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker9);\n    }\n};\n_a9 = symbol9;\n// errors/tool-execution-error.ts\n\nvar name10 = \"AI_ToolExecutionError\";\nvar marker10 = `vercel.ai.error.${name10}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar ToolExecutionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor({ toolArgs, toolName, toolCallId, cause, message = `Error executing tool ${toolName}: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.getErrorMessage)(cause)}` }){\n        super({\n            name: name10,\n            message,\n            cause\n        });\n        this[_a10] = true;\n        this.toolArgs = toolArgs;\n        this.toolName = toolName;\n        this.toolCallId = toolCallId;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker10);\n    }\n};\n_a10 = symbol10;\n// core/prompt/prepare-tools-and-tool-choice.ts\n\n// core/util/is-non-empty-object.ts\nfunction isNonEmptyObject(object2) {\n    return object2 != null && Object.keys(object2).length > 0;\n}\n// core/prompt/prepare-tools-and-tool-choice.ts\nfunction prepareToolsAndToolChoice({ tools, toolChoice, activeTools }) {\n    if (!isNonEmptyObject(tools)) {\n        return {\n            tools: void 0,\n            toolChoice: void 0\n        };\n    }\n    const filteredTools = activeTools != null ? Object.entries(tools).filter(([name17])=>activeTools.includes(name17)) : Object.entries(tools);\n    return {\n        tools: filteredTools.map(([name17, tool2])=>{\n            const toolType = tool2.type;\n            switch(toolType){\n                case void 0:\n                case \"function\":\n                    return {\n                        type: \"function\",\n                        name: name17,\n                        description: tool2.description,\n                        parameters: (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.asSchema)(tool2.parameters).jsonSchema\n                    };\n                case \"provider-defined\":\n                    return {\n                        type: \"provider-defined\",\n                        name: name17,\n                        id: tool2.id,\n                        args: tool2.args\n                    };\n                default:\n                    {\n                        const exhaustiveCheck = toolType;\n                        throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);\n                    }\n            }\n        }),\n        toolChoice: toolChoice == null ? {\n            type: \"auto\"\n        } : typeof toolChoice === \"string\" ? {\n            type: toolChoice\n        } : {\n            type: \"tool\",\n            toolName: toolChoice.toolName\n        }\n    };\n}\n// core/util/split-on-last-whitespace.ts\nvar lastWhitespaceRegexp = /^([\\s\\S]*?)(\\s+)(\\S*)$/;\nfunction splitOnLastWhitespace(text2) {\n    const match = text2.match(lastWhitespaceRegexp);\n    return match ? {\n        prefix: match[1],\n        whitespace: match[2],\n        suffix: match[3]\n    } : void 0;\n}\n// core/util/remove-text-after-last-whitespace.ts\nfunction removeTextAfterLastWhitespace(text2) {\n    const match = splitOnLastWhitespace(text2);\n    return match ? match.prefix + match.whitespace : text2;\n}\n// core/generate-text/parse-tool-call.ts\n\n\n// errors/invalid-tool-arguments-error.ts\n\nvar name11 = \"AI_InvalidToolArgumentsError\";\nvar marker11 = `vercel.ai.error.${name11}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar InvalidToolArgumentsError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor({ toolArgs, toolName, cause, message = `Invalid arguments for tool ${toolName}: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.getErrorMessage)(cause)}` }){\n        super({\n            name: name11,\n            message,\n            cause\n        });\n        this[_a11] = true;\n        this.toolArgs = toolArgs;\n        this.toolName = toolName;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker11);\n    }\n};\n_a11 = symbol11;\n// errors/no-such-tool-error.ts\n\nvar name12 = \"AI_NoSuchToolError\";\nvar marker12 = `vercel.ai.error.${name12}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\nvar NoSuchToolError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor({ toolName, availableTools = void 0, message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? \"No tools are available.\" : `Available tools: ${availableTools.join(\", \")}.`}` }){\n        super({\n            name: name12,\n            message\n        });\n        this[_a12] = true;\n        this.toolName = toolName;\n        this.availableTools = availableTools;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker12);\n    }\n};\n_a12 = symbol12;\n// errors/tool-call-repair-error.ts\n\nvar name13 = \"AI_ToolCallRepairError\";\nvar marker13 = `vercel.ai.error.${name13}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar ToolCallRepairError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor({ cause, originalError, message = `Error repairing tool call: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.getErrorMessage)(cause)}` }){\n        super({\n            name: name13,\n            message,\n            cause\n        });\n        this[_a13] = true;\n        this.originalError = originalError;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker13);\n    }\n};\n_a13 = symbol13;\n// core/generate-text/parse-tool-call.ts\nasync function parseToolCall({ toolCall, tools, repairToolCall, system, messages }) {\n    if (tools == null) {\n        throw new NoSuchToolError({\n            toolName: toolCall.toolName\n        });\n    }\n    try {\n        return await doParseToolCall({\n            toolCall,\n            tools\n        });\n    } catch (error) {\n        if (repairToolCall == null || !(NoSuchToolError.isInstance(error) || InvalidToolArgumentsError.isInstance(error))) {\n            throw error;\n        }\n        let repairedToolCall = null;\n        try {\n            repairedToolCall = await repairToolCall({\n                toolCall,\n                tools,\n                parameterSchema: ({ toolName })=>(0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.asSchema)(tools[toolName].parameters).jsonSchema,\n                system,\n                messages,\n                error\n            });\n        } catch (repairError) {\n            throw new ToolCallRepairError({\n                cause: repairError,\n                originalError: error\n            });\n        }\n        if (repairedToolCall == null) {\n            throw error;\n        }\n        return await doParseToolCall({\n            toolCall: repairedToolCall,\n            tools\n        });\n    }\n}\nasync function doParseToolCall({ toolCall, tools }) {\n    const toolName = toolCall.toolName;\n    const tool2 = tools[toolName];\n    if (tool2 == null) {\n        throw new NoSuchToolError({\n            toolName: toolCall.toolName,\n            availableTools: Object.keys(tools)\n        });\n    }\n    const schema = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.asSchema)(tool2.parameters);\n    const parseResult = toolCall.args.trim() === \"\" ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n        value: {},\n        schema\n    }) : (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({\n        text: toolCall.args,\n        schema\n    });\n    if (parseResult.success === false) {\n        throw new InvalidToolArgumentsError({\n            toolName,\n            toolArgs: toolCall.args,\n            cause: parseResult.error\n        });\n    }\n    return {\n        type: \"tool-call\",\n        toolCallId: toolCall.toolCallId,\n        toolName,\n        args: parseResult.value\n    };\n}\n// core/generate-text/reasoning-detail.ts\nfunction asReasoningText(reasoning) {\n    const reasoningText = reasoning.filter((part)=>part.type === \"text\").map((part)=>part.text).join(\"\");\n    return reasoningText.length > 0 ? reasoningText : void 0;\n}\n// core/generate-text/to-response-messages.ts\nfunction toResponseMessages({ text: text2 = \"\", files, reasoning, tools, toolCalls, toolResults, messageId, generateMessageId }) {\n    const responseMessages = [];\n    const content = [];\n    if (reasoning.length > 0) {\n        content.push(...reasoning.map((part)=>part.type === \"text\" ? {\n                ...part,\n                type: \"reasoning\"\n            } : {\n                ...part,\n                type: \"redacted-reasoning\"\n            }));\n    }\n    if (files.length > 0) {\n        content.push(...files.map((file)=>({\n                type: \"file\",\n                data: file.base64,\n                mimeType: file.mimeType\n            })));\n    }\n    if (text2.length > 0) {\n        content.push({\n            type: \"text\",\n            text: text2\n        });\n    }\n    if (toolCalls.length > 0) {\n        content.push(...toolCalls);\n    }\n    if (content.length > 0) {\n        responseMessages.push({\n            role: \"assistant\",\n            content,\n            id: messageId\n        });\n    }\n    if (toolResults.length > 0) {\n        responseMessages.push({\n            role: \"tool\",\n            id: generateMessageId(),\n            content: toolResults.map((toolResult)=>{\n                const tool2 = tools[toolResult.toolName];\n                return (tool2 == null ? void 0 : tool2.experimental_toToolResultContent) != null ? {\n                    type: \"tool-result\",\n                    toolCallId: toolResult.toolCallId,\n                    toolName: toolResult.toolName,\n                    result: tool2.experimental_toToolResultContent(toolResult.result),\n                    experimental_content: tool2.experimental_toToolResultContent(toolResult.result)\n                } : {\n                    type: \"tool-result\",\n                    toolCallId: toolResult.toolCallId,\n                    toolName: toolResult.toolName,\n                    result: toolResult.result\n                };\n            })\n        });\n    }\n    return responseMessages;\n}\n// core/generate-text/generate-text.ts\nvar originalGenerateId3 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n    prefix: \"aitxt\",\n    size: 24\n});\nvar originalGenerateMessageId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n    prefix: \"msg\",\n    size: 24\n});\nasync function generateText({ model, tools, toolChoice, system, prompt, messages, maxRetries: maxRetriesArg, abortSignal, headers, maxSteps = 1, experimental_generateMessageId: generateMessageId = originalGenerateMessageId, experimental_output: output, experimental_continueSteps: continueSteps = false, experimental_telemetry: telemetry, experimental_providerMetadata, providerOptions = experimental_providerMetadata, experimental_activeTools: activeTools, experimental_repairToolCall: repairToolCall, _internal: { generateId: generateId3 = originalGenerateId3, currentDate = ()=>/* @__PURE__ */ new Date() } = {}, onStepFinish, ...settings }) {\n    var _a17;\n    if (maxSteps < 1) {\n        throw new InvalidArgumentError({\n            parameter: \"maxSteps\",\n            value: maxSteps,\n            message: \"maxSteps must be at least 1\"\n        });\n    }\n    const { maxRetries, retry } = prepareRetries({\n        maxRetries: maxRetriesArg\n    });\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            ...settings,\n            maxRetries\n        }\n    });\n    const initialPrompt = standardizePrompt({\n        prompt: {\n            system: (_a17 = output == null ? void 0 : output.injectIntoSystemPrompt({\n                system,\n                model\n            })) != null ? _a17 : system,\n            prompt,\n            messages\n        },\n        tools\n    });\n    const tracer = getTracer(telemetry);\n    return recordSpan({\n        name: \"ai.generateText\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.generateText\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.prompt\": {\n                    input: ()=>JSON.stringify({\n                            system,\n                            prompt,\n                            messages\n                        })\n                },\n                \"ai.settings.maxSteps\": maxSteps\n            }\n        }),\n        tracer,\n        fn: async (span)=>{\n            var _a18, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;\n            const mode = {\n                type: \"regular\",\n                ...prepareToolsAndToolChoice({\n                    tools,\n                    toolChoice,\n                    activeTools\n                })\n            };\n            const callSettings = prepareCallSettings(settings);\n            let currentModelResponse;\n            let currentToolCalls = [];\n            let currentToolResults = [];\n            let currentReasoningDetails = [];\n            let stepCount = 0;\n            const responseMessages = [];\n            let text2 = \"\";\n            const sources = [];\n            const steps = [];\n            let usage = {\n                completionTokens: 0,\n                promptTokens: 0,\n                totalTokens: 0\n            };\n            let stepType = \"initial\";\n            do {\n                const promptFormat = stepCount === 0 ? initialPrompt.type : \"messages\";\n                const stepInputMessages = [\n                    ...initialPrompt.messages,\n                    ...responseMessages\n                ];\n                const promptMessages = await convertToLanguageModelPrompt({\n                    prompt: {\n                        type: promptFormat,\n                        system: initialPrompt.system,\n                        messages: stepInputMessages\n                    },\n                    modelSupportsImageUrls: model.supportsImageUrls,\n                    modelSupportsUrl: (_a18 = model.supportsUrl) == null ? void 0 : _a18.bind(model)\n                });\n                currentModelResponse = await retry(()=>recordSpan({\n                        name: \"ai.generateText.doGenerate\",\n                        attributes: selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                ...assembleOperationName({\n                                    operationId: \"ai.generateText.doGenerate\",\n                                    telemetry\n                                }),\n                                ...baseTelemetryAttributes,\n                                \"ai.prompt.format\": {\n                                    input: ()=>promptFormat\n                                },\n                                \"ai.prompt.messages\": {\n                                    input: ()=>JSON.stringify(promptMessages)\n                                },\n                                \"ai.prompt.tools\": {\n                                    // convert the language model level tools:\n                                    input: ()=>{\n                                        var _a19;\n                                        return (_a19 = mode.tools) == null ? void 0 : _a19.map((tool2)=>JSON.stringify(tool2));\n                                    }\n                                },\n                                \"ai.prompt.toolChoice\": {\n                                    input: ()=>mode.toolChoice != null ? JSON.stringify(mode.toolChoice) : void 0\n                                },\n                                // standardized gen-ai llm span attributes:\n                                \"gen_ai.system\": model.provider,\n                                \"gen_ai.request.model\": model.modelId,\n                                \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                                \"gen_ai.request.max_tokens\": settings.maxTokens,\n                                \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                                \"gen_ai.request.stop_sequences\": settings.stopSequences,\n                                \"gen_ai.request.temperature\": settings.temperature,\n                                \"gen_ai.request.top_k\": settings.topK,\n                                \"gen_ai.request.top_p\": settings.topP\n                            }\n                        }),\n                        tracer,\n                        fn: async (span2)=>{\n                            var _a19, _b2, _c2, _d2, _e2, _f2;\n                            const result = await model.doGenerate({\n                                mode,\n                                ...callSettings,\n                                inputFormat: promptFormat,\n                                responseFormat: output == null ? void 0 : output.responseFormat({\n                                    model\n                                }),\n                                prompt: promptMessages,\n                                providerMetadata: providerOptions,\n                                abortSignal,\n                                headers\n                            });\n                            const responseData = {\n                                id: (_b2 = (_a19 = result.response) == null ? void 0 : _a19.id) != null ? _b2 : generateId3(),\n                                timestamp: (_d2 = (_c2 = result.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : currentDate(),\n                                modelId: (_f2 = (_e2 = result.response) == null ? void 0 : _e2.modelId) != null ? _f2 : model.modelId\n                            };\n                            span2.setAttributes(selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.response.finishReason\": result.finishReason,\n                                    \"ai.response.text\": {\n                                        output: ()=>result.text\n                                    },\n                                    \"ai.response.toolCalls\": {\n                                        output: ()=>JSON.stringify(result.toolCalls)\n                                    },\n                                    \"ai.response.id\": responseData.id,\n                                    \"ai.response.model\": responseData.modelId,\n                                    \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                                    \"ai.usage.promptTokens\": result.usage.promptTokens,\n                                    \"ai.usage.completionTokens\": result.usage.completionTokens,\n                                    // standardized gen-ai llm span attributes:\n                                    \"gen_ai.response.finish_reasons\": [\n                                        result.finishReason\n                                    ],\n                                    \"gen_ai.response.id\": responseData.id,\n                                    \"gen_ai.response.model\": responseData.modelId,\n                                    \"gen_ai.usage.input_tokens\": result.usage.promptTokens,\n                                    \"gen_ai.usage.output_tokens\": result.usage.completionTokens\n                                }\n                            }));\n                            return {\n                                ...result,\n                                response: responseData\n                            };\n                        }\n                    }));\n                currentToolCalls = await Promise.all(((_b = currentModelResponse.toolCalls) != null ? _b : []).map((toolCall)=>parseToolCall({\n                        toolCall,\n                        tools,\n                        repairToolCall,\n                        system,\n                        messages: stepInputMessages\n                    })));\n                currentToolResults = tools == null ? [] : await executeTools({\n                    toolCalls: currentToolCalls,\n                    tools,\n                    tracer,\n                    telemetry,\n                    messages: stepInputMessages,\n                    abortSignal\n                });\n                const currentUsage = calculateLanguageModelUsage(currentModelResponse.usage);\n                usage = addLanguageModelUsage(usage, currentUsage);\n                let nextStepType = \"done\";\n                if (++stepCount < maxSteps) {\n                    if (continueSteps && currentModelResponse.finishReason === \"length\" && // only use continue when there are no tool calls:\n                    currentToolCalls.length === 0) {\n                        nextStepType = \"continue\";\n                    } else if (// there are tool calls:\n                    currentToolCalls.length > 0 && // all current tool calls have results:\n                    currentToolResults.length === currentToolCalls.length) {\n                        nextStepType = \"tool-result\";\n                    }\n                }\n                const originalText = (_c = currentModelResponse.text) != null ? _c : \"\";\n                const stepTextLeadingWhitespaceTrimmed = stepType === \"continue\" && // only for continue steps\n                text2.trimEnd() !== text2 ? originalText.trimStart() : originalText;\n                const stepText = nextStepType === \"continue\" ? removeTextAfterLastWhitespace(stepTextLeadingWhitespaceTrimmed) : stepTextLeadingWhitespaceTrimmed;\n                text2 = nextStepType === \"continue\" || stepType === \"continue\" ? text2 + stepText : stepText;\n                currentReasoningDetails = asReasoningDetails(currentModelResponse.reasoning);\n                sources.push(...(_d = currentModelResponse.sources) != null ? _d : []);\n                if (stepType === \"continue\") {\n                    const lastMessage = responseMessages[responseMessages.length - 1];\n                    if (typeof lastMessage.content === \"string\") {\n                        lastMessage.content += stepText;\n                    } else {\n                        lastMessage.content.push({\n                            text: stepText,\n                            type: \"text\"\n                        });\n                    }\n                } else {\n                    responseMessages.push(...toResponseMessages({\n                        text: text2,\n                        files: asFiles(currentModelResponse.files),\n                        reasoning: asReasoningDetails(currentModelResponse.reasoning),\n                        tools: tools != null ? tools : {},\n                        toolCalls: currentToolCalls,\n                        toolResults: currentToolResults,\n                        messageId: generateMessageId(),\n                        generateMessageId\n                    }));\n                }\n                const currentStepResult = {\n                    stepType,\n                    text: stepText,\n                    // TODO v5: rename reasoning to reasoningText (and use reasoning for composite array)\n                    reasoning: asReasoningText(currentReasoningDetails),\n                    reasoningDetails: currentReasoningDetails,\n                    files: asFiles(currentModelResponse.files),\n                    sources: (_e = currentModelResponse.sources) != null ? _e : [],\n                    toolCalls: currentToolCalls,\n                    toolResults: currentToolResults,\n                    finishReason: currentModelResponse.finishReason,\n                    usage: currentUsage,\n                    warnings: currentModelResponse.warnings,\n                    logprobs: currentModelResponse.logprobs,\n                    request: (_f = currentModelResponse.request) != null ? _f : {},\n                    response: {\n                        ...currentModelResponse.response,\n                        headers: (_g = currentModelResponse.rawResponse) == null ? void 0 : _g.headers,\n                        body: (_h = currentModelResponse.rawResponse) == null ? void 0 : _h.body,\n                        // deep clone msgs to avoid mutating past messages in multi-step:\n                        messages: structuredClone(responseMessages)\n                    },\n                    providerMetadata: currentModelResponse.providerMetadata,\n                    experimental_providerMetadata: currentModelResponse.providerMetadata,\n                    isContinued: nextStepType === \"continue\"\n                };\n                steps.push(currentStepResult);\n                await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n                stepType = nextStepType;\n            }while (stepType !== \"done\");\n            span.setAttributes(selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    \"ai.response.finishReason\": currentModelResponse.finishReason,\n                    \"ai.response.text\": {\n                        output: ()=>currentModelResponse.text\n                    },\n                    \"ai.response.toolCalls\": {\n                        output: ()=>JSON.stringify(currentModelResponse.toolCalls)\n                    },\n                    \"ai.usage.promptTokens\": currentModelResponse.usage.promptTokens,\n                    \"ai.usage.completionTokens\": currentModelResponse.usage.completionTokens\n                }\n            }));\n            return new DefaultGenerateTextResult({\n                text: text2,\n                files: asFiles(currentModelResponse.files),\n                reasoning: asReasoningText(currentReasoningDetails),\n                reasoningDetails: currentReasoningDetails,\n                sources,\n                outputResolver: ()=>{\n                    if (output == null) {\n                        throw new NoOutputSpecifiedError();\n                    }\n                    return output.parseOutput({\n                        text: text2\n                    }, {\n                        response: currentModelResponse.response,\n                        usage,\n                        finishReason: currentModelResponse.finishReason\n                    });\n                },\n                toolCalls: currentToolCalls,\n                toolResults: currentToolResults,\n                finishReason: currentModelResponse.finishReason,\n                usage,\n                warnings: currentModelResponse.warnings,\n                request: (_i = currentModelResponse.request) != null ? _i : {},\n                response: {\n                    ...currentModelResponse.response,\n                    headers: (_j = currentModelResponse.rawResponse) == null ? void 0 : _j.headers,\n                    body: (_k = currentModelResponse.rawResponse) == null ? void 0 : _k.body,\n                    messages: responseMessages\n                },\n                logprobs: currentModelResponse.logprobs,\n                steps,\n                providerMetadata: currentModelResponse.providerMetadata\n            });\n        }\n    });\n}\nasync function executeTools({ toolCalls, tools, tracer, telemetry, messages, abortSignal }) {\n    const toolResults = await Promise.all(toolCalls.map(async ({ toolCallId, toolName, args })=>{\n        const tool2 = tools[toolName];\n        if ((tool2 == null ? void 0 : tool2.execute) == null) {\n            return void 0;\n        }\n        const result = await recordSpan({\n            name: \"ai.toolCall\",\n            attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    ...assembleOperationName({\n                        operationId: \"ai.toolCall\",\n                        telemetry\n                    }),\n                    \"ai.toolCall.name\": toolName,\n                    \"ai.toolCall.id\": toolCallId,\n                    \"ai.toolCall.args\": {\n                        output: ()=>JSON.stringify(args)\n                    }\n                }\n            }),\n            tracer,\n            fn: async (span)=>{\n                try {\n                    const result2 = await tool2.execute(args, {\n                        toolCallId,\n                        messages,\n                        abortSignal\n                    });\n                    try {\n                        span.setAttributes(selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                \"ai.toolCall.result\": {\n                                    output: ()=>JSON.stringify(result2)\n                                }\n                            }\n                        }));\n                    } catch (ignored) {}\n                    return result2;\n                } catch (error) {\n                    throw new ToolExecutionError({\n                        toolCallId,\n                        toolName,\n                        toolArgs: args,\n                        cause: error\n                    });\n                }\n            }\n        });\n        return {\n            type: \"tool-result\",\n            toolCallId,\n            toolName,\n            args,\n            result\n        };\n    }));\n    return toolResults.filter((result)=>result != null);\n}\nvar DefaultGenerateTextResult = class {\n    constructor(options){\n        this.text = options.text;\n        this.files = options.files;\n        this.reasoning = options.reasoning;\n        this.reasoningDetails = options.reasoningDetails;\n        this.toolCalls = options.toolCalls;\n        this.toolResults = options.toolResults;\n        this.finishReason = options.finishReason;\n        this.usage = options.usage;\n        this.warnings = options.warnings;\n        this.request = options.request;\n        this.response = options.response;\n        this.steps = options.steps;\n        this.experimental_providerMetadata = options.providerMetadata;\n        this.providerMetadata = options.providerMetadata;\n        this.logprobs = options.logprobs;\n        this.outputResolver = options.outputResolver;\n        this.sources = options.sources;\n    }\n    get experimental_output() {\n        return this.outputResolver();\n    }\n};\nfunction asReasoningDetails(reasoning) {\n    if (reasoning == null) {\n        return [];\n    }\n    if (typeof reasoning === \"string\") {\n        return [\n            {\n                type: \"text\",\n                text: reasoning\n            }\n        ];\n    }\n    return reasoning;\n}\nfunction asFiles(files) {\n    var _a17;\n    return (_a17 = files == null ? void 0 : files.map((file)=>new DefaultGeneratedFile(file))) != null ? _a17 : [];\n}\n// core/generate-text/output.ts\nvar output_exports = {};\n__export(output_exports, {\n    object: ()=>object,\n    text: ()=>text\n});\n\n\n// errors/index.ts\n\n// errors/invalid-stream-part-error.ts\n\nvar name14 = \"AI_InvalidStreamPartError\";\nvar marker14 = `vercel.ai.error.${name14}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\nvar InvalidStreamPartError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor({ chunk, message }){\n        super({\n            name: name14,\n            message\n        });\n        this[_a14] = true;\n        this.chunk = chunk;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker14);\n    }\n};\n_a14 = symbol14;\n// errors/mcp-client-error.ts\n\nvar name15 = \"AI_MCPClientError\";\nvar marker15 = `vercel.ai.error.${name15}`;\nvar symbol15 = Symbol.for(marker15);\nvar _a15;\nvar MCPClientError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor({ name: name17 = \"MCPClientError\", message, cause }){\n        super({\n            name: name17,\n            message,\n            cause\n        });\n        this[_a15] = true;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker15);\n    }\n};\n_a15 = symbol15;\n// core/generate-text/output.ts\nvar text = ()=>({\n        type: \"text\",\n        responseFormat: ()=>({\n                type: \"text\"\n            }),\n        injectIntoSystemPrompt ({ system }) {\n            return system;\n        },\n        parsePartial ({ text: text2 }) {\n            return {\n                partial: text2\n            };\n        },\n        parseOutput ({ text: text2 }) {\n            return text2;\n        }\n    });\nvar object = ({ schema: inputSchema })=>{\n    const schema = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.asSchema)(inputSchema);\n    return {\n        type: \"object\",\n        responseFormat: ({ model })=>({\n                type: \"json\",\n                schema: model.supportsStructuredOutputs ? schema.jsonSchema : void 0\n            }),\n        injectIntoSystemPrompt ({ system, model }) {\n            return model.supportsStructuredOutputs ? system : injectJsonInstruction({\n                prompt: system,\n                schema: schema.jsonSchema\n            });\n        },\n        parsePartial ({ text: text2 }) {\n            const result = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.parsePartialJson)(text2);\n            switch(result.state){\n                case \"failed-parse\":\n                case \"undefined-input\":\n                    return void 0;\n                case \"repaired-parse\":\n                case \"successful-parse\":\n                    return {\n                        // Note: currently no validation of partial results:\n                        partial: result.value\n                    };\n                default:\n                    {\n                        const _exhaustiveCheck = result.state;\n                        throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);\n                    }\n            }\n        },\n        parseOutput ({ text: text2 }, context) {\n            const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({\n                text: text2\n            });\n            if (!parseResult.success) {\n                throw new NoObjectGeneratedError({\n                    message: \"No object generated: could not parse the response.\",\n                    cause: parseResult.error,\n                    text: text2,\n                    response: context.response,\n                    usage: context.usage,\n                    finishReason: context.finishReason\n                });\n            }\n            const validationResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n                value: parseResult.value,\n                schema\n            });\n            if (!validationResult.success) {\n                throw new NoObjectGeneratedError({\n                    message: \"No object generated: response did not match schema.\",\n                    cause: validationResult.error,\n                    text: text2,\n                    response: context.response,\n                    usage: context.usage,\n                    finishReason: context.finishReason\n                });\n            }\n            return validationResult.value;\n        }\n    };\n};\n// core/generate-text/smooth-stream.ts\n\n\nvar CHUNKING_REGEXPS = {\n    word: /\\S+\\s+/m,\n    line: /\\n+/m\n};\nfunction smoothStream({ delayInMs = 10, chunking = \"word\", _internal: { delay: delay2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay } = {} } = {}) {\n    let detectChunk;\n    if (typeof chunking === \"function\") {\n        detectChunk = (buffer)=>{\n            const match = chunking(buffer);\n            if (match == null) {\n                return null;\n            }\n            if (!match.length) {\n                throw new Error(`Chunking function must return a non-empty string.`);\n            }\n            if (!buffer.startsWith(match)) {\n                throw new Error(`Chunking function must return a match that is a prefix of the buffer. Received: \"${match}\" expected to start with \"${buffer}\"`);\n            }\n            return match;\n        };\n    } else {\n        const chunkingRegex = typeof chunking === \"string\" ? CHUNKING_REGEXPS[chunking] : chunking;\n        if (chunkingRegex == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n                argument: \"chunking\",\n                message: `Chunking must be \"word\" or \"line\" or a RegExp. Received: ${chunking}`\n            });\n        }\n        detectChunk = (buffer)=>{\n            const match = chunkingRegex.exec(buffer);\n            if (!match) {\n                return null;\n            }\n            return buffer.slice(0, match.index) + (match == null ? void 0 : match[0]);\n        };\n    }\n    return ()=>{\n        let buffer = \"\";\n        return new TransformStream({\n            async transform (chunk, controller) {\n                if (chunk.type !== \"text-delta\") {\n                    if (buffer.length > 0) {\n                        controller.enqueue({\n                            type: \"text-delta\",\n                            textDelta: buffer\n                        });\n                        buffer = \"\";\n                    }\n                    controller.enqueue(chunk);\n                    return;\n                }\n                buffer += chunk.textDelta;\n                let match;\n                while((match = detectChunk(buffer)) != null){\n                    controller.enqueue({\n                        type: \"text-delta\",\n                        textDelta: match\n                    });\n                    buffer = buffer.slice(match.length);\n                    await delay2(delayInMs);\n                }\n            }\n        });\n    };\n}\n// core/generate-text/stream-text.ts\n\n\n\n// util/as-array.ts\nfunction asArray(value) {\n    return value === void 0 ? [] : Array.isArray(value) ? value : [\n        value\n    ];\n}\n// util/consume-stream.ts\nasync function consumeStream({ stream, onError }) {\n    const reader = stream.getReader();\n    try {\n        while(true){\n            const { done } = await reader.read();\n            if (done) break;\n        }\n    } catch (error) {\n        onError == null ? void 0 : onError(error);\n    } finally{\n        reader.releaseLock();\n    }\n}\n// core/util/merge-streams.ts\nfunction mergeStreams(stream1, stream2) {\n    const reader1 = stream1.getReader();\n    const reader2 = stream2.getReader();\n    let lastRead1 = void 0;\n    let lastRead2 = void 0;\n    let stream1Done = false;\n    let stream2Done = false;\n    async function readStream1(controller) {\n        try {\n            if (lastRead1 == null) {\n                lastRead1 = reader1.read();\n            }\n            const result = await lastRead1;\n            lastRead1 = void 0;\n            if (!result.done) {\n                controller.enqueue(result.value);\n            } else {\n                controller.close();\n            }\n        } catch (error) {\n            controller.error(error);\n        }\n    }\n    async function readStream2(controller) {\n        try {\n            if (lastRead2 == null) {\n                lastRead2 = reader2.read();\n            }\n            const result = await lastRead2;\n            lastRead2 = void 0;\n            if (!result.done) {\n                controller.enqueue(result.value);\n            } else {\n                controller.close();\n            }\n        } catch (error) {\n            controller.error(error);\n        }\n    }\n    return new ReadableStream({\n        async pull (controller) {\n            try {\n                if (stream1Done) {\n                    await readStream2(controller);\n                    return;\n                }\n                if (stream2Done) {\n                    await readStream1(controller);\n                    return;\n                }\n                if (lastRead1 == null) {\n                    lastRead1 = reader1.read();\n                }\n                if (lastRead2 == null) {\n                    lastRead2 = reader2.read();\n                }\n                const { result, reader } = await Promise.race([\n                    lastRead1.then((result2)=>({\n                            result: result2,\n                            reader: reader1\n                        })),\n                    lastRead2.then((result2)=>({\n                            result: result2,\n                            reader: reader2\n                        }))\n                ]);\n                if (!result.done) {\n                    controller.enqueue(result.value);\n                }\n                if (reader === reader1) {\n                    lastRead1 = void 0;\n                    if (result.done) {\n                        await readStream2(controller);\n                        stream1Done = true;\n                    }\n                } else {\n                    lastRead2 = void 0;\n                    if (result.done) {\n                        stream2Done = true;\n                        await readStream1(controller);\n                    }\n                }\n            } catch (error) {\n                controller.error(error);\n            }\n        },\n        cancel () {\n            reader1.cancel();\n            reader2.cancel();\n        }\n    });\n}\n// core/generate-text/run-tools-transformation.ts\n\nfunction runToolsTransformation({ tools, generatorStream, toolCallStreaming, tracer, telemetry, system, messages, abortSignal, repairToolCall }) {\n    let toolResultsStreamController = null;\n    const toolResultsStream = new ReadableStream({\n        start (controller) {\n            toolResultsStreamController = controller;\n        }\n    });\n    const activeToolCalls = {};\n    const outstandingToolResults = /* @__PURE__ */ new Set();\n    let canClose = false;\n    let finishChunk = void 0;\n    function attemptClose() {\n        if (canClose && outstandingToolResults.size === 0) {\n            if (finishChunk != null) {\n                toolResultsStreamController.enqueue(finishChunk);\n            }\n            toolResultsStreamController.close();\n        }\n    }\n    const forwardStream = new TransformStream({\n        async transform (chunk, controller) {\n            const chunkType = chunk.type;\n            switch(chunkType){\n                case \"text-delta\":\n                case \"reasoning\":\n                case \"reasoning-signature\":\n                case \"redacted-reasoning\":\n                case \"source\":\n                case \"response-metadata\":\n                case \"error\":\n                    {\n                        controller.enqueue(chunk);\n                        break;\n                    }\n                case \"file\":\n                    {\n                        controller.enqueue(new DefaultGeneratedFileWithType({\n                            data: chunk.data,\n                            mimeType: chunk.mimeType\n                        }));\n                        break;\n                    }\n                case \"tool-call-delta\":\n                    {\n                        if (toolCallStreaming) {\n                            if (!activeToolCalls[chunk.toolCallId]) {\n                                controller.enqueue({\n                                    type: \"tool-call-streaming-start\",\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: chunk.toolName\n                                });\n                                activeToolCalls[chunk.toolCallId] = true;\n                            }\n                            controller.enqueue({\n                                type: \"tool-call-delta\",\n                                toolCallId: chunk.toolCallId,\n                                toolName: chunk.toolName,\n                                argsTextDelta: chunk.argsTextDelta\n                            });\n                        }\n                        break;\n                    }\n                case \"tool-call\":\n                    {\n                        try {\n                            const toolCall = await parseToolCall({\n                                toolCall: chunk,\n                                tools,\n                                repairToolCall,\n                                system,\n                                messages\n                            });\n                            controller.enqueue(toolCall);\n                            const tool2 = tools[toolCall.toolName];\n                            if (tool2.execute != null) {\n                                const toolExecutionId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId)();\n                                outstandingToolResults.add(toolExecutionId);\n                                recordSpan({\n                                    name: \"ai.toolCall\",\n                                    attributes: selectTelemetryAttributes({\n                                        telemetry,\n                                        attributes: {\n                                            ...assembleOperationName({\n                                                operationId: \"ai.toolCall\",\n                                                telemetry\n                                            }),\n                                            \"ai.toolCall.name\": toolCall.toolName,\n                                            \"ai.toolCall.id\": toolCall.toolCallId,\n                                            \"ai.toolCall.args\": {\n                                                output: ()=>JSON.stringify(toolCall.args)\n                                            }\n                                        }\n                                    }),\n                                    tracer,\n                                    fn: async (span)=>tool2.execute(toolCall.args, {\n                                            toolCallId: toolCall.toolCallId,\n                                            messages,\n                                            abortSignal\n                                        }).then((result)=>{\n                                            toolResultsStreamController.enqueue({\n                                                ...toolCall,\n                                                type: \"tool-result\",\n                                                result\n                                            });\n                                            outstandingToolResults.delete(toolExecutionId);\n                                            attemptClose();\n                                            try {\n                                                span.setAttributes(selectTelemetryAttributes({\n                                                    telemetry,\n                                                    attributes: {\n                                                        \"ai.toolCall.result\": {\n                                                            output: ()=>JSON.stringify(result)\n                                                        }\n                                                    }\n                                                }));\n                                            } catch (ignored) {}\n                                        }, (error)=>{\n                                            toolResultsStreamController.enqueue({\n                                                type: \"error\",\n                                                error: new ToolExecutionError({\n                                                    toolCallId: toolCall.toolCallId,\n                                                    toolName: toolCall.toolName,\n                                                    toolArgs: toolCall.args,\n                                                    cause: error\n                                                })\n                                            });\n                                            outstandingToolResults.delete(toolExecutionId);\n                                            attemptClose();\n                                        })\n                                });\n                            }\n                        } catch (error) {\n                            toolResultsStreamController.enqueue({\n                                type: \"error\",\n                                error\n                            });\n                        }\n                        break;\n                    }\n                case \"finish\":\n                    {\n                        finishChunk = {\n                            type: \"finish\",\n                            finishReason: chunk.finishReason,\n                            logprobs: chunk.logprobs,\n                            usage: calculateLanguageModelUsage(chunk.usage),\n                            experimental_providerMetadata: chunk.providerMetadata\n                        };\n                        break;\n                    }\n                default:\n                    {\n                        const _exhaustiveCheck = chunkType;\n                        throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n                    }\n            }\n        },\n        flush () {\n            canClose = true;\n            attemptClose();\n        }\n    });\n    return new ReadableStream({\n        async start (controller) {\n            return Promise.all([\n                generatorStream.pipeThrough(forwardStream).pipeTo(new WritableStream({\n                    write (chunk) {\n                        controller.enqueue(chunk);\n                    },\n                    close () {}\n                })),\n                toolResultsStream.pipeTo(new WritableStream({\n                    write (chunk) {\n                        controller.enqueue(chunk);\n                    },\n                    close () {\n                        controller.close();\n                    }\n                }))\n            ]);\n        }\n    });\n}\n// core/generate-text/stream-text.ts\nvar originalGenerateId4 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n    prefix: \"aitxt\",\n    size: 24\n});\nvar originalGenerateMessageId2 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n    prefix: \"msg\",\n    size: 24\n});\nfunction streamText({ model, tools, toolChoice, system, prompt, messages, maxRetries, abortSignal, headers, maxSteps = 1, experimental_generateMessageId: generateMessageId = originalGenerateMessageId2, experimental_output: output, experimental_continueSteps: continueSteps = false, experimental_telemetry: telemetry, experimental_providerMetadata, providerOptions = experimental_providerMetadata, experimental_toolCallStreaming = false, toolCallStreaming = experimental_toolCallStreaming, experimental_activeTools: activeTools, experimental_repairToolCall: repairToolCall, experimental_transform: transform, onChunk, onError, onFinish, onStepFinish, _internal: { now: now2 = now, generateId: generateId3 = originalGenerateId4, currentDate = ()=>/* @__PURE__ */ new Date() } = {}, ...settings }) {\n    return new DefaultStreamTextResult({\n        model,\n        telemetry,\n        headers,\n        settings,\n        maxRetries,\n        abortSignal,\n        system,\n        prompt,\n        messages,\n        tools,\n        toolChoice,\n        toolCallStreaming,\n        transforms: asArray(transform),\n        activeTools,\n        repairToolCall,\n        maxSteps,\n        output,\n        continueSteps,\n        providerOptions,\n        onChunk,\n        onError,\n        onFinish,\n        onStepFinish,\n        now: now2,\n        currentDate,\n        generateId: generateId3,\n        generateMessageId\n    });\n}\nfunction createOutputTransformStream(output) {\n    if (!output) {\n        return new TransformStream({\n            transform (chunk, controller) {\n                controller.enqueue({\n                    part: chunk,\n                    partialOutput: void 0\n                });\n            }\n        });\n    }\n    let text2 = \"\";\n    let textChunk = \"\";\n    let lastPublishedJson = \"\";\n    function publishTextChunk({ controller, partialOutput = void 0 }) {\n        controller.enqueue({\n            part: {\n                type: \"text-delta\",\n                textDelta: textChunk\n            },\n            partialOutput\n        });\n        textChunk = \"\";\n    }\n    return new TransformStream({\n        transform (chunk, controller) {\n            if (chunk.type === \"step-finish\") {\n                publishTextChunk({\n                    controller\n                });\n            }\n            if (chunk.type !== \"text-delta\") {\n                controller.enqueue({\n                    part: chunk,\n                    partialOutput: void 0\n                });\n                return;\n            }\n            text2 += chunk.textDelta;\n            textChunk += chunk.textDelta;\n            const result = output.parsePartial({\n                text: text2\n            });\n            if (result != null) {\n                const currentJson = JSON.stringify(result.partial);\n                if (currentJson !== lastPublishedJson) {\n                    publishTextChunk({\n                        controller,\n                        partialOutput: result.partial\n                    });\n                    lastPublishedJson = currentJson;\n                }\n            }\n        },\n        flush (controller) {\n            if (textChunk.length > 0) {\n                publishTextChunk({\n                    controller\n                });\n            }\n        }\n    });\n}\nvar DefaultStreamTextResult = class {\n    constructor({ model, telemetry, headers, settings, maxRetries: maxRetriesArg, abortSignal, system, prompt, messages, tools, toolChoice, toolCallStreaming, transforms, activeTools, repairToolCall, maxSteps, output, continueSteps, providerOptions, now: now2, currentDate, generateId: generateId3, generateMessageId, onChunk, onError, onFinish, onStepFinish }){\n        this.warningsPromise = new DelayedPromise();\n        this.usagePromise = new DelayedPromise();\n        this.finishReasonPromise = new DelayedPromise();\n        this.providerMetadataPromise = new DelayedPromise();\n        this.textPromise = new DelayedPromise();\n        this.reasoningPromise = new DelayedPromise();\n        this.reasoningDetailsPromise = new DelayedPromise();\n        this.sourcesPromise = new DelayedPromise();\n        this.filesPromise = new DelayedPromise();\n        this.toolCallsPromise = new DelayedPromise();\n        this.toolResultsPromise = new DelayedPromise();\n        this.requestPromise = new DelayedPromise();\n        this.responsePromise = new DelayedPromise();\n        this.stepsPromise = new DelayedPromise();\n        var _a17;\n        if (maxSteps < 1) {\n            throw new InvalidArgumentError({\n                parameter: \"maxSteps\",\n                value: maxSteps,\n                message: \"maxSteps must be at least 1\"\n            });\n        }\n        this.output = output;\n        let recordedStepText = \"\";\n        let recordedContinuationText = \"\";\n        let recordedFullText = \"\";\n        let stepReasoning = [];\n        let stepFiles = [];\n        let activeReasoningText = void 0;\n        let recordedStepSources = [];\n        const recordedSources = [];\n        const recordedResponse = {\n            id: generateId3(),\n            timestamp: currentDate(),\n            modelId: model.modelId,\n            messages: []\n        };\n        let recordedToolCalls = [];\n        let recordedToolResults = [];\n        let recordedFinishReason = void 0;\n        let recordedUsage = void 0;\n        let stepType = \"initial\";\n        const recordedSteps = [];\n        let rootSpan;\n        const eventProcessor = new TransformStream({\n            async transform (chunk, controller) {\n                controller.enqueue(chunk);\n                const { part } = chunk;\n                if (part.type === \"text-delta\" || part.type === \"reasoning\" || part.type === \"source\" || part.type === \"tool-call\" || part.type === \"tool-result\" || part.type === \"tool-call-streaming-start\" || part.type === \"tool-call-delta\") {\n                    await (onChunk == null ? void 0 : onChunk({\n                        chunk: part\n                    }));\n                }\n                if (part.type === \"error\") {\n                    await (onError == null ? void 0 : onError({\n                        error: part.error\n                    }));\n                }\n                if (part.type === \"text-delta\") {\n                    recordedStepText += part.textDelta;\n                    recordedContinuationText += part.textDelta;\n                    recordedFullText += part.textDelta;\n                }\n                if (part.type === \"reasoning\") {\n                    if (activeReasoningText == null) {\n                        activeReasoningText = {\n                            type: \"text\",\n                            text: part.textDelta\n                        };\n                        stepReasoning.push(activeReasoningText);\n                    } else {\n                        activeReasoningText.text += part.textDelta;\n                    }\n                }\n                if (part.type === \"reasoning-signature\") {\n                    if (activeReasoningText == null) {\n                        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError({\n                            name: \"InvalidStreamPart\",\n                            message: \"reasoning-signature without reasoning\"\n                        });\n                    }\n                    activeReasoningText.signature = part.signature;\n                    activeReasoningText = void 0;\n                }\n                if (part.type === \"redacted-reasoning\") {\n                    stepReasoning.push({\n                        type: \"redacted\",\n                        data: part.data\n                    });\n                }\n                if (part.type === \"file\") {\n                    stepFiles.push(part);\n                }\n                if (part.type === \"source\") {\n                    recordedSources.push(part.source);\n                    recordedStepSources.push(part.source);\n                }\n                if (part.type === \"tool-call\") {\n                    recordedToolCalls.push(part);\n                }\n                if (part.type === \"tool-result\") {\n                    recordedToolResults.push(part);\n                }\n                if (part.type === \"step-finish\") {\n                    const stepMessages = toResponseMessages({\n                        text: recordedContinuationText,\n                        files: stepFiles,\n                        reasoning: stepReasoning,\n                        tools: tools != null ? tools : {},\n                        toolCalls: recordedToolCalls,\n                        toolResults: recordedToolResults,\n                        messageId: part.messageId,\n                        generateMessageId\n                    });\n                    const currentStep = recordedSteps.length;\n                    let nextStepType = \"done\";\n                    if (currentStep + 1 < maxSteps) {\n                        if (continueSteps && part.finishReason === \"length\" && // only use continue when there are no tool calls:\n                        recordedToolCalls.length === 0) {\n                            nextStepType = \"continue\";\n                        } else if (// there are tool calls:\n                        recordedToolCalls.length > 0 && // all current tool calls have results:\n                        recordedToolResults.length === recordedToolCalls.length) {\n                            nextStepType = \"tool-result\";\n                        }\n                    }\n                    const currentStepResult = {\n                        stepType,\n                        text: recordedStepText,\n                        reasoning: asReasoningText(stepReasoning),\n                        reasoningDetails: stepReasoning,\n                        files: stepFiles,\n                        sources: recordedStepSources,\n                        toolCalls: recordedToolCalls,\n                        toolResults: recordedToolResults,\n                        finishReason: part.finishReason,\n                        usage: part.usage,\n                        warnings: part.warnings,\n                        logprobs: part.logprobs,\n                        request: part.request,\n                        response: {\n                            ...part.response,\n                            messages: [\n                                ...recordedResponse.messages,\n                                ...stepMessages\n                            ]\n                        },\n                        providerMetadata: part.experimental_providerMetadata,\n                        experimental_providerMetadata: part.experimental_providerMetadata,\n                        isContinued: part.isContinued\n                    };\n                    await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n                    recordedSteps.push(currentStepResult);\n                    recordedToolCalls = [];\n                    recordedToolResults = [];\n                    recordedStepText = \"\";\n                    recordedStepSources = [];\n                    stepReasoning = [];\n                    stepFiles = [];\n                    activeReasoningText = void 0;\n                    if (nextStepType !== \"done\") {\n                        stepType = nextStepType;\n                    }\n                    if (nextStepType !== \"continue\") {\n                        recordedResponse.messages.push(...stepMessages);\n                        recordedContinuationText = \"\";\n                    }\n                }\n                if (part.type === \"finish\") {\n                    recordedResponse.id = part.response.id;\n                    recordedResponse.timestamp = part.response.timestamp;\n                    recordedResponse.modelId = part.response.modelId;\n                    recordedResponse.headers = part.response.headers;\n                    recordedUsage = part.usage;\n                    recordedFinishReason = part.finishReason;\n                }\n            },\n            async flush (controller) {\n                var _a18;\n                try {\n                    if (recordedSteps.length === 0) {\n                        return;\n                    }\n                    const lastStep = recordedSteps[recordedSteps.length - 1];\n                    self.warningsPromise.resolve(lastStep.warnings);\n                    self.requestPromise.resolve(lastStep.request);\n                    self.responsePromise.resolve(lastStep.response);\n                    self.toolCallsPromise.resolve(lastStep.toolCalls);\n                    self.toolResultsPromise.resolve(lastStep.toolResults);\n                    self.providerMetadataPromise.resolve(lastStep.experimental_providerMetadata);\n                    self.reasoningPromise.resolve(lastStep.reasoning);\n                    self.reasoningDetailsPromise.resolve(lastStep.reasoningDetails);\n                    const finishReason = recordedFinishReason != null ? recordedFinishReason : \"unknown\";\n                    const usage = recordedUsage != null ? recordedUsage : {\n                        completionTokens: NaN,\n                        promptTokens: NaN,\n                        totalTokens: NaN\n                    };\n                    self.finishReasonPromise.resolve(finishReason);\n                    self.usagePromise.resolve(usage);\n                    self.textPromise.resolve(recordedFullText);\n                    self.sourcesPromise.resolve(recordedSources);\n                    self.filesPromise.resolve(lastStep.files);\n                    self.stepsPromise.resolve(recordedSteps);\n                    await (onFinish == null ? void 0 : onFinish({\n                        finishReason,\n                        logprobs: void 0,\n                        usage,\n                        text: recordedFullText,\n                        reasoning: lastStep.reasoning,\n                        reasoningDetails: lastStep.reasoningDetails,\n                        files: lastStep.files,\n                        sources: lastStep.sources,\n                        toolCalls: lastStep.toolCalls,\n                        toolResults: lastStep.toolResults,\n                        request: (_a18 = lastStep.request) != null ? _a18 : {},\n                        response: lastStep.response,\n                        warnings: lastStep.warnings,\n                        providerMetadata: lastStep.providerMetadata,\n                        experimental_providerMetadata: lastStep.experimental_providerMetadata,\n                        steps: recordedSteps\n                    }));\n                    rootSpan.setAttributes(selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                            \"ai.response.finishReason\": finishReason,\n                            \"ai.response.text\": {\n                                output: ()=>recordedFullText\n                            },\n                            \"ai.response.toolCalls\": {\n                                output: ()=>{\n                                    var _a19;\n                                    return ((_a19 = lastStep.toolCalls) == null ? void 0 : _a19.length) ? JSON.stringify(lastStep.toolCalls) : void 0;\n                                }\n                            },\n                            \"ai.usage.promptTokens\": usage.promptTokens,\n                            \"ai.usage.completionTokens\": usage.completionTokens\n                        }\n                    }));\n                } catch (error) {\n                    controller.error(error);\n                } finally{\n                    rootSpan.end();\n                }\n            }\n        });\n        const stitchableStream = createStitchableStream();\n        this.addStream = stitchableStream.addStream;\n        this.closeStream = stitchableStream.close;\n        let stream = stitchableStream.stream;\n        for (const transform of transforms){\n            stream = stream.pipeThrough(transform({\n                tools,\n                stopStream () {\n                    stitchableStream.terminate();\n                }\n            }));\n        }\n        this.baseStream = stream.pipeThrough(createOutputTransformStream(output)).pipeThrough(eventProcessor);\n        const { maxRetries, retry } = prepareRetries({\n            maxRetries: maxRetriesArg\n        });\n        const tracer = getTracer(telemetry);\n        const baseTelemetryAttributes = getBaseTelemetryAttributes({\n            model,\n            telemetry,\n            headers,\n            settings: {\n                ...settings,\n                maxRetries\n            }\n        });\n        const initialPrompt = standardizePrompt({\n            prompt: {\n                system: (_a17 = output == null ? void 0 : output.injectIntoSystemPrompt({\n                    system,\n                    model\n                })) != null ? _a17 : system,\n                prompt,\n                messages\n            },\n            tools\n        });\n        const self = this;\n        recordSpan({\n            name: \"ai.streamText\",\n            attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    ...assembleOperationName({\n                        operationId: \"ai.streamText\",\n                        telemetry\n                    }),\n                    ...baseTelemetryAttributes,\n                    // specific settings that only make sense on the outer level:\n                    \"ai.prompt\": {\n                        input: ()=>JSON.stringify({\n                                system,\n                                prompt,\n                                messages\n                            })\n                    },\n                    \"ai.settings.maxSteps\": maxSteps\n                }\n            }),\n            tracer,\n            endWhenDone: false,\n            fn: async (rootSpanArg)=>{\n                rootSpan = rootSpanArg;\n                async function streamStep({ currentStep, responseMessages, usage, stepType: stepType2, previousStepText, hasLeadingWhitespace, messageId }) {\n                    var _a18;\n                    const promptFormat = responseMessages.length === 0 ? initialPrompt.type : \"messages\";\n                    const stepInputMessages = [\n                        ...initialPrompt.messages,\n                        ...responseMessages\n                    ];\n                    const promptMessages = await convertToLanguageModelPrompt({\n                        prompt: {\n                            type: promptFormat,\n                            system: initialPrompt.system,\n                            messages: stepInputMessages\n                        },\n                        modelSupportsImageUrls: model.supportsImageUrls,\n                        modelSupportsUrl: (_a18 = model.supportsUrl) == null ? void 0 : _a18.bind(model)\n                    });\n                    const mode = {\n                        type: \"regular\",\n                        ...prepareToolsAndToolChoice({\n                            tools,\n                            toolChoice,\n                            activeTools\n                        })\n                    };\n                    const { result: { stream: stream2, warnings, rawResponse, request }, doStreamSpan, startTimestampMs } = await retry(()=>recordSpan({\n                            name: \"ai.streamText.doStream\",\n                            attributes: selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    ...assembleOperationName({\n                                        operationId: \"ai.streamText.doStream\",\n                                        telemetry\n                                    }),\n                                    ...baseTelemetryAttributes,\n                                    \"ai.prompt.format\": {\n                                        input: ()=>promptFormat\n                                    },\n                                    \"ai.prompt.messages\": {\n                                        input: ()=>JSON.stringify(promptMessages)\n                                    },\n                                    \"ai.prompt.tools\": {\n                                        // convert the language model level tools:\n                                        input: ()=>{\n                                            var _a19;\n                                            return (_a19 = mode.tools) == null ? void 0 : _a19.map((tool2)=>JSON.stringify(tool2));\n                                        }\n                                    },\n                                    \"ai.prompt.toolChoice\": {\n                                        input: ()=>mode.toolChoice != null ? JSON.stringify(mode.toolChoice) : void 0\n                                    },\n                                    // standardized gen-ai llm span attributes:\n                                    \"gen_ai.system\": model.provider,\n                                    \"gen_ai.request.model\": model.modelId,\n                                    \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                                    \"gen_ai.request.max_tokens\": settings.maxTokens,\n                                    \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                                    \"gen_ai.request.stop_sequences\": settings.stopSequences,\n                                    \"gen_ai.request.temperature\": settings.temperature,\n                                    \"gen_ai.request.top_k\": settings.topK,\n                                    \"gen_ai.request.top_p\": settings.topP\n                                }\n                            }),\n                            tracer,\n                            endWhenDone: false,\n                            fn: async (doStreamSpan2)=>({\n                                    startTimestampMs: now2(),\n                                    // get before the call\n                                    doStreamSpan: doStreamSpan2,\n                                    result: await model.doStream({\n                                        mode,\n                                        ...prepareCallSettings(settings),\n                                        inputFormat: promptFormat,\n                                        responseFormat: output == null ? void 0 : output.responseFormat({\n                                            model\n                                        }),\n                                        prompt: promptMessages,\n                                        providerMetadata: providerOptions,\n                                        abortSignal,\n                                        headers\n                                    })\n                                })\n                        }));\n                    const transformedStream = runToolsTransformation({\n                        tools,\n                        generatorStream: stream2,\n                        toolCallStreaming,\n                        tracer,\n                        telemetry,\n                        system,\n                        messages: stepInputMessages,\n                        repairToolCall,\n                        abortSignal\n                    });\n                    const stepRequest = request != null ? request : {};\n                    const stepToolCalls = [];\n                    const stepToolResults = [];\n                    const stepReasoning2 = [];\n                    const stepFiles2 = [];\n                    let activeReasoningText2 = void 0;\n                    let stepFinishReason = \"unknown\";\n                    let stepUsage = {\n                        promptTokens: 0,\n                        completionTokens: 0,\n                        totalTokens: 0\n                    };\n                    let stepProviderMetadata;\n                    let stepFirstChunk = true;\n                    let stepText = \"\";\n                    let fullStepText = stepType2 === \"continue\" ? previousStepText : \"\";\n                    let stepLogProbs;\n                    let stepResponse = {\n                        id: generateId3(),\n                        timestamp: currentDate(),\n                        modelId: model.modelId\n                    };\n                    let chunkBuffer = \"\";\n                    let chunkTextPublished = false;\n                    let inWhitespacePrefix = true;\n                    let hasWhitespaceSuffix = false;\n                    async function publishTextChunk({ controller, chunk }) {\n                        controller.enqueue(chunk);\n                        stepText += chunk.textDelta;\n                        fullStepText += chunk.textDelta;\n                        chunkTextPublished = true;\n                        hasWhitespaceSuffix = chunk.textDelta.trimEnd() !== chunk.textDelta;\n                    }\n                    self.addStream(transformedStream.pipeThrough(new TransformStream({\n                        async transform (chunk, controller) {\n                            var _a19, _b, _c;\n                            if (stepFirstChunk) {\n                                const msToFirstChunk = now2() - startTimestampMs;\n                                stepFirstChunk = false;\n                                doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n                                    \"ai.response.msToFirstChunk\": msToFirstChunk\n                                });\n                                doStreamSpan.setAttributes({\n                                    \"ai.response.msToFirstChunk\": msToFirstChunk\n                                });\n                                controller.enqueue({\n                                    type: \"step-start\",\n                                    messageId,\n                                    request: stepRequest,\n                                    warnings: warnings != null ? warnings : []\n                                });\n                            }\n                            if (chunk.type === \"text-delta\" && chunk.textDelta.length === 0) {\n                                return;\n                            }\n                            const chunkType = chunk.type;\n                            switch(chunkType){\n                                case \"text-delta\":\n                                    {\n                                        if (continueSteps) {\n                                            const trimmedChunkText = inWhitespacePrefix && hasLeadingWhitespace ? chunk.textDelta.trimStart() : chunk.textDelta;\n                                            if (trimmedChunkText.length === 0) {\n                                                break;\n                                            }\n                                            inWhitespacePrefix = false;\n                                            chunkBuffer += trimmedChunkText;\n                                            const split = splitOnLastWhitespace(chunkBuffer);\n                                            if (split != null) {\n                                                chunkBuffer = split.suffix;\n                                                await publishTextChunk({\n                                                    controller,\n                                                    chunk: {\n                                                        type: \"text-delta\",\n                                                        textDelta: split.prefix + split.whitespace\n                                                    }\n                                                });\n                                            }\n                                        } else {\n                                            await publishTextChunk({\n                                                controller,\n                                                chunk\n                                            });\n                                        }\n                                        break;\n                                    }\n                                case \"reasoning\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        if (activeReasoningText2 == null) {\n                                            activeReasoningText2 = {\n                                                type: \"text\",\n                                                text: chunk.textDelta\n                                            };\n                                            stepReasoning2.push(activeReasoningText2);\n                                        } else {\n                                            activeReasoningText2.text += chunk.textDelta;\n                                        }\n                                        break;\n                                    }\n                                case \"reasoning-signature\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        if (activeReasoningText2 == null) {\n                                            throw new InvalidStreamPartError({\n                                                chunk,\n                                                message: \"reasoning-signature without reasoning\"\n                                            });\n                                        }\n                                        activeReasoningText2.signature = chunk.signature;\n                                        activeReasoningText2 = void 0;\n                                        break;\n                                    }\n                                case \"redacted-reasoning\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        stepReasoning2.push({\n                                            type: \"redacted\",\n                                            data: chunk.data\n                                        });\n                                        break;\n                                    }\n                                case \"tool-call\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        stepToolCalls.push(chunk);\n                                        break;\n                                    }\n                                case \"tool-result\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        stepToolResults.push(chunk);\n                                        break;\n                                    }\n                                case \"response-metadata\":\n                                    {\n                                        stepResponse = {\n                                            id: (_a19 = chunk.id) != null ? _a19 : stepResponse.id,\n                                            timestamp: (_b = chunk.timestamp) != null ? _b : stepResponse.timestamp,\n                                            modelId: (_c = chunk.modelId) != null ? _c : stepResponse.modelId\n                                        };\n                                        break;\n                                    }\n                                case \"finish\":\n                                    {\n                                        stepUsage = chunk.usage;\n                                        stepFinishReason = chunk.finishReason;\n                                        stepProviderMetadata = chunk.experimental_providerMetadata;\n                                        stepLogProbs = chunk.logprobs;\n                                        const msToFinish = now2() - startTimestampMs;\n                                        doStreamSpan.addEvent(\"ai.stream.finish\");\n                                        doStreamSpan.setAttributes({\n                                            \"ai.response.msToFinish\": msToFinish,\n                                            \"ai.response.avgCompletionTokensPerSecond\": 1e3 * stepUsage.completionTokens / msToFinish\n                                        });\n                                        break;\n                                    }\n                                case \"file\":\n                                    {\n                                        stepFiles2.push(chunk);\n                                        controller.enqueue(chunk);\n                                        break;\n                                    }\n                                case \"source\":\n                                case \"tool-call-streaming-start\":\n                                case \"tool-call-delta\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        break;\n                                    }\n                                case \"error\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        stepFinishReason = \"error\";\n                                        break;\n                                    }\n                                default:\n                                    {\n                                        const exhaustiveCheck = chunkType;\n                                        throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                                    }\n                            }\n                        },\n                        // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n                        async flush (controller) {\n                            const stepToolCallsJson = stepToolCalls.length > 0 ? JSON.stringify(stepToolCalls) : void 0;\n                            let nextStepType = \"done\";\n                            if (currentStep + 1 < maxSteps) {\n                                if (continueSteps && stepFinishReason === \"length\" && // only use continue when there are no tool calls:\n                                stepToolCalls.length === 0) {\n                                    nextStepType = \"continue\";\n                                } else if (// there are tool calls:\n                                stepToolCalls.length > 0 && // all current tool calls have results:\n                                stepToolResults.length === stepToolCalls.length) {\n                                    nextStepType = \"tool-result\";\n                                }\n                            }\n                            if (continueSteps && chunkBuffer.length > 0 && (nextStepType !== \"continue\" || // when the next step is a regular step, publish the buffer\n                            stepType2 === \"continue\" && !chunkTextPublished)) {\n                                await publishTextChunk({\n                                    controller,\n                                    chunk: {\n                                        type: \"text-delta\",\n                                        textDelta: chunkBuffer\n                                    }\n                                });\n                                chunkBuffer = \"\";\n                            }\n                            try {\n                                doStreamSpan.setAttributes(selectTelemetryAttributes({\n                                    telemetry,\n                                    attributes: {\n                                        \"ai.response.finishReason\": stepFinishReason,\n                                        \"ai.response.text\": {\n                                            output: ()=>stepText\n                                        },\n                                        \"ai.response.toolCalls\": {\n                                            output: ()=>stepToolCallsJson\n                                        },\n                                        \"ai.response.id\": stepResponse.id,\n                                        \"ai.response.model\": stepResponse.modelId,\n                                        \"ai.response.timestamp\": stepResponse.timestamp.toISOString(),\n                                        \"ai.usage.promptTokens\": stepUsage.promptTokens,\n                                        \"ai.usage.completionTokens\": stepUsage.completionTokens,\n                                        // standardized gen-ai llm span attributes:\n                                        \"gen_ai.response.finish_reasons\": [\n                                            stepFinishReason\n                                        ],\n                                        \"gen_ai.response.id\": stepResponse.id,\n                                        \"gen_ai.response.model\": stepResponse.modelId,\n                                        \"gen_ai.usage.input_tokens\": stepUsage.promptTokens,\n                                        \"gen_ai.usage.output_tokens\": stepUsage.completionTokens\n                                    }\n                                }));\n                            } catch (error) {} finally{\n                                doStreamSpan.end();\n                            }\n                            controller.enqueue({\n                                type: \"step-finish\",\n                                finishReason: stepFinishReason,\n                                usage: stepUsage,\n                                providerMetadata: stepProviderMetadata,\n                                experimental_providerMetadata: stepProviderMetadata,\n                                logprobs: stepLogProbs,\n                                request: stepRequest,\n                                response: {\n                                    ...stepResponse,\n                                    headers: rawResponse == null ? void 0 : rawResponse.headers\n                                },\n                                warnings,\n                                isContinued: nextStepType === \"continue\",\n                                messageId\n                            });\n                            const combinedUsage = addLanguageModelUsage(usage, stepUsage);\n                            if (nextStepType === \"done\") {\n                                controller.enqueue({\n                                    type: \"finish\",\n                                    finishReason: stepFinishReason,\n                                    usage: combinedUsage,\n                                    providerMetadata: stepProviderMetadata,\n                                    experimental_providerMetadata: stepProviderMetadata,\n                                    logprobs: stepLogProbs,\n                                    response: {\n                                        ...stepResponse,\n                                        headers: rawResponse == null ? void 0 : rawResponse.headers\n                                    }\n                                });\n                                self.closeStream();\n                            } else {\n                                if (stepType2 === \"continue\") {\n                                    const lastMessage = responseMessages[responseMessages.length - 1];\n                                    if (typeof lastMessage.content === \"string\") {\n                                        lastMessage.content += stepText;\n                                    } else {\n                                        lastMessage.content.push({\n                                            text: stepText,\n                                            type: \"text\"\n                                        });\n                                    }\n                                } else {\n                                    responseMessages.push(...toResponseMessages({\n                                        text: stepText,\n                                        files: stepFiles2,\n                                        reasoning: stepReasoning2,\n                                        tools: tools != null ? tools : {},\n                                        toolCalls: stepToolCalls,\n                                        toolResults: stepToolResults,\n                                        messageId,\n                                        generateMessageId\n                                    }));\n                                }\n                                await streamStep({\n                                    currentStep: currentStep + 1,\n                                    responseMessages,\n                                    usage: combinedUsage,\n                                    stepType: nextStepType,\n                                    previousStepText: fullStepText,\n                                    hasLeadingWhitespace: hasWhitespaceSuffix,\n                                    messageId: // keep the same id when continuing a step:\n                                    nextStepType === \"continue\" ? messageId : generateMessageId()\n                                });\n                            }\n                        }\n                    })));\n                }\n                await streamStep({\n                    currentStep: 0,\n                    responseMessages: [],\n                    usage: {\n                        promptTokens: 0,\n                        completionTokens: 0,\n                        totalTokens: 0\n                    },\n                    previousStepText: \"\",\n                    stepType: \"initial\",\n                    hasLeadingWhitespace: false,\n                    messageId: generateMessageId()\n                });\n            }\n        }).catch((error)=>{\n            self.addStream(new ReadableStream({\n                start (controller) {\n                    controller.enqueue({\n                        type: \"error\",\n                        error\n                    });\n                    controller.close();\n                }\n            }));\n            self.closeStream();\n        });\n    }\n    get warnings() {\n        return this.warningsPromise.value;\n    }\n    get usage() {\n        return this.usagePromise.value;\n    }\n    get finishReason() {\n        return this.finishReasonPromise.value;\n    }\n    get experimental_providerMetadata() {\n        return this.providerMetadataPromise.value;\n    }\n    get providerMetadata() {\n        return this.providerMetadataPromise.value;\n    }\n    get text() {\n        return this.textPromise.value;\n    }\n    get reasoning() {\n        return this.reasoningPromise.value;\n    }\n    get reasoningDetails() {\n        return this.reasoningDetailsPromise.value;\n    }\n    get sources() {\n        return this.sourcesPromise.value;\n    }\n    get files() {\n        return this.filesPromise.value;\n    }\n    get toolCalls() {\n        return this.toolCallsPromise.value;\n    }\n    get toolResults() {\n        return this.toolResultsPromise.value;\n    }\n    get request() {\n        return this.requestPromise.value;\n    }\n    get response() {\n        return this.responsePromise.value;\n    }\n    get steps() {\n        return this.stepsPromise.value;\n    }\n    /**\n  Split out a new stream from the original stream.\n  The original stream is replaced to allow for further splitting,\n  since we do not know how many times the stream will be split.\n  \n  Note: this leads to buffering the stream content on the server.\n  However, the LLM results are expected to be small enough to not cause issues.\n     */ teeStream() {\n        const [stream1, stream2] = this.baseStream.tee();\n        this.baseStream = stream2;\n        return stream1;\n    }\n    get textStream() {\n        return createAsyncIterableStream(this.teeStream().pipeThrough(new TransformStream({\n            transform ({ part }, controller) {\n                if (part.type === \"text-delta\") {\n                    controller.enqueue(part.textDelta);\n                }\n            }\n        })));\n    }\n    get fullStream() {\n        return createAsyncIterableStream(this.teeStream().pipeThrough(new TransformStream({\n            transform ({ part }, controller) {\n                controller.enqueue(part);\n            }\n        })));\n    }\n    async consumeStream(options) {\n        var _a17;\n        try {\n            await consumeStream({\n                stream: this.fullStream,\n                onError: options == null ? void 0 : options.onError\n            });\n        } catch (error) {\n            (_a17 = options == null ? void 0 : options.onError) == null ? void 0 : _a17.call(options, error);\n        }\n    }\n    get experimental_partialOutputStream() {\n        if (this.output == null) {\n            throw new NoOutputSpecifiedError();\n        }\n        return createAsyncIterableStream(this.teeStream().pipeThrough(new TransformStream({\n            transform ({ partialOutput }, controller) {\n                if (partialOutput != null) {\n                    controller.enqueue(partialOutput);\n                }\n            }\n        })));\n    }\n    toDataStreamInternal({ getErrorMessage: getErrorMessage5 = ()=>\"An error occurred.\", // mask error messages for safety by default\n    sendUsage = true, sendReasoning = false, sendSources = false, experimental_sendFinish = true }) {\n        return this.fullStream.pipeThrough(new TransformStream({\n            transform: async (chunk, controller)=>{\n                const chunkType = chunk.type;\n                switch(chunkType){\n                    case \"text-delta\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"text\", chunk.textDelta));\n                            break;\n                        }\n                    case \"reasoning\":\n                        {\n                            if (sendReasoning) {\n                                controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"reasoning\", chunk.textDelta));\n                            }\n                            break;\n                        }\n                    case \"redacted-reasoning\":\n                        {\n                            if (sendReasoning) {\n                                controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"redacted_reasoning\", {\n                                    data: chunk.data\n                                }));\n                            }\n                            break;\n                        }\n                    case \"reasoning-signature\":\n                        {\n                            if (sendReasoning) {\n                                controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"reasoning_signature\", {\n                                    signature: chunk.signature\n                                }));\n                            }\n                            break;\n                        }\n                    case \"file\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"file\", {\n                                mimeType: chunk.mimeType,\n                                data: chunk.base64\n                            }));\n                            break;\n                        }\n                    case \"source\":\n                        {\n                            if (sendSources) {\n                                controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"source\", chunk.source));\n                            }\n                            break;\n                        }\n                    case \"tool-call-streaming-start\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"tool_call_streaming_start\", {\n                                toolCallId: chunk.toolCallId,\n                                toolName: chunk.toolName\n                            }));\n                            break;\n                        }\n                    case \"tool-call-delta\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"tool_call_delta\", {\n                                toolCallId: chunk.toolCallId,\n                                argsTextDelta: chunk.argsTextDelta\n                            }));\n                            break;\n                        }\n                    case \"tool-call\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"tool_call\", {\n                                toolCallId: chunk.toolCallId,\n                                toolName: chunk.toolName,\n                                args: chunk.args\n                            }));\n                            break;\n                        }\n                    case \"tool-result\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"tool_result\", {\n                                toolCallId: chunk.toolCallId,\n                                result: chunk.result\n                            }));\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"error\", getErrorMessage5(chunk.error)));\n                            break;\n                        }\n                    case \"step-start\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"start_step\", {\n                                messageId: chunk.messageId\n                            }));\n                            break;\n                        }\n                    case \"step-finish\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"finish_step\", {\n                                finishReason: chunk.finishReason,\n                                usage: sendUsage ? {\n                                    promptTokens: chunk.usage.promptTokens,\n                                    completionTokens: chunk.usage.completionTokens\n                                } : void 0,\n                                isContinued: chunk.isContinued\n                            }));\n                            break;\n                        }\n                    case \"finish\":\n                        {\n                            if (experimental_sendFinish) {\n                                controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"finish_message\", {\n                                    finishReason: chunk.finishReason,\n                                    usage: sendUsage ? {\n                                        promptTokens: chunk.usage.promptTokens,\n                                        completionTokens: chunk.usage.completionTokens\n                                    } : void 0\n                                }));\n                            }\n                            break;\n                        }\n                    default:\n                        {\n                            const exhaustiveCheck = chunkType;\n                            throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                        }\n                }\n            }\n        }));\n    }\n    pipeDataStreamToResponse(response, { status, statusText, headers, data, getErrorMessage: getErrorMessage5, sendUsage, sendReasoning, sendSources, experimental_sendFinish } = {}) {\n        writeToServerResponse({\n            response,\n            status,\n            statusText,\n            headers: prepareOutgoingHttpHeaders(headers, {\n                contentType: \"text/plain; charset=utf-8\",\n                dataStreamVersion: \"v1\"\n            }),\n            stream: this.toDataStream({\n                data,\n                getErrorMessage: getErrorMessage5,\n                sendUsage,\n                sendReasoning,\n                sendSources,\n                experimental_sendFinish\n            })\n        });\n    }\n    pipeTextStreamToResponse(response, init) {\n        writeToServerResponse({\n            response,\n            status: init == null ? void 0 : init.status,\n            statusText: init == null ? void 0 : init.statusText,\n            headers: prepareOutgoingHttpHeaders(init == null ? void 0 : init.headers, {\n                contentType: \"text/plain; charset=utf-8\"\n            }),\n            stream: this.textStream.pipeThrough(new TextEncoderStream())\n        });\n    }\n    // TODO breaking change 5.0: remove pipeThrough(new TextEncoderStream())\n    toDataStream(options) {\n        const stream = this.toDataStreamInternal({\n            getErrorMessage: options == null ? void 0 : options.getErrorMessage,\n            sendUsage: options == null ? void 0 : options.sendUsage,\n            sendReasoning: options == null ? void 0 : options.sendReasoning,\n            sendSources: options == null ? void 0 : options.sendSources,\n            experimental_sendFinish: options == null ? void 0 : options.experimental_sendFinish\n        }).pipeThrough(new TextEncoderStream());\n        return (options == null ? void 0 : options.data) ? mergeStreams(options == null ? void 0 : options.data.stream, stream) : stream;\n    }\n    mergeIntoDataStream(writer, options) {\n        writer.merge(this.toDataStreamInternal({\n            getErrorMessage: writer.onError,\n            sendUsage: options == null ? void 0 : options.sendUsage,\n            sendReasoning: options == null ? void 0 : options.sendReasoning,\n            sendSources: options == null ? void 0 : options.sendSources,\n            experimental_sendFinish: options == null ? void 0 : options.experimental_sendFinish\n        }));\n    }\n    toDataStreamResponse({ headers, status, statusText, data, getErrorMessage: getErrorMessage5, sendUsage, sendReasoning, sendSources, experimental_sendFinish } = {}) {\n        return new Response(this.toDataStream({\n            data,\n            getErrorMessage: getErrorMessage5,\n            sendUsage,\n            sendReasoning,\n            sendSources,\n            experimental_sendFinish\n        }), {\n            status,\n            statusText,\n            headers: prepareResponseHeaders(headers, {\n                contentType: \"text/plain; charset=utf-8\",\n                dataStreamVersion: \"v1\"\n            })\n        });\n    }\n    toTextStreamResponse(init) {\n        var _a17;\n        return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n            status: (_a17 = init == null ? void 0 : init.status) != null ? _a17 : 200,\n            headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {\n                contentType: \"text/plain; charset=utf-8\"\n            })\n        });\n    }\n};\n// errors/no-speech-generated-error.ts\n\nvar NoSpeechGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor(options){\n        super({\n            name: \"AI_NoSpeechGeneratedError\",\n            message: \"No speech audio generated.\"\n        });\n        this.responses = options.responses;\n    }\n};\n// core/generate-speech/generated-audio-file.ts\nvar DefaultGeneratedAudioFile = class extends DefaultGeneratedFile {\n    constructor({ data, mimeType }){\n        super({\n            data,\n            mimeType\n        });\n        let format = \"mp3\";\n        if (mimeType) {\n            const mimeTypeParts = mimeType.split(\"/\");\n            if (mimeTypeParts.length === 2) {\n                if (mimeType !== \"audio/mpeg\") {\n                    format = mimeTypeParts[1];\n                }\n            }\n        }\n        if (!format) {\n            throw new Error(\"Audio format must be provided or determinable from mimeType\");\n        }\n        this.format = format;\n    }\n};\n// core/generate-speech/generate-speech.ts\nasync function generateSpeech({ model, text: text2, voice, outputFormat, instructions, speed, providerOptions = {}, maxRetries: maxRetriesArg, abortSignal, headers }) {\n    var _a17;\n    const { retry } = prepareRetries({\n        maxRetries: maxRetriesArg\n    });\n    const result = await retry(()=>model.doGenerate({\n            text: text2,\n            voice,\n            outputFormat,\n            instructions,\n            speed,\n            abortSignal,\n            headers,\n            providerOptions\n        }));\n    if (!result.audio || result.audio.length === 0) {\n        throw new NoSpeechGeneratedError({\n            responses: [\n                result.response\n            ]\n        });\n    }\n    return new DefaultSpeechResult({\n        audio: new DefaultGeneratedAudioFile({\n            data: result.audio,\n            mimeType: (_a17 = detectMimeType({\n                data: result.audio,\n                signatures: audioMimeTypeSignatures\n            })) != null ? _a17 : \"audio/mp3\"\n        }),\n        warnings: result.warnings,\n        responses: [\n            result.response\n        ],\n        providerMetadata: result.providerMetadata\n    });\n}\nvar DefaultSpeechResult = class {\n    constructor(options){\n        var _a17;\n        this.audio = options.audio;\n        this.warnings = options.warnings;\n        this.responses = options.responses;\n        this.providerMetadata = (_a17 = options.providerMetadata) != null ? _a17 : {};\n    }\n};\n// errors/no-transcript-generated-error.ts\n\nvar NoTranscriptGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor(options){\n        super({\n            name: \"AI_NoTranscriptGeneratedError\",\n            message: \"No transcript generated.\"\n        });\n        this.responses = options.responses;\n    }\n};\n// core/transcribe/transcribe.ts\nasync function transcribe({ model, audio, providerOptions = {}, maxRetries: maxRetriesArg, abortSignal, headers }) {\n    const { retry } = prepareRetries({\n        maxRetries: maxRetriesArg\n    });\n    const audioData = audio instanceof URL ? (await download({\n        url: audio\n    })).data : convertDataContentToUint8Array(audio);\n    const result = await retry(()=>{\n        var _a17;\n        return model.doGenerate({\n            audio: audioData,\n            abortSignal,\n            headers,\n            providerOptions,\n            mediaType: (_a17 = detectMimeType({\n                data: audioData,\n                signatures: audioMimeTypeSignatures\n            })) != null ? _a17 : \"audio/wav\"\n        });\n    });\n    if (!result.text) {\n        throw new NoTranscriptGeneratedError({\n            responses: [\n                result.response\n            ]\n        });\n    }\n    return new DefaultTranscriptionResult({\n        text: result.text,\n        segments: result.segments,\n        language: result.language,\n        durationInSeconds: result.durationInSeconds,\n        warnings: result.warnings,\n        responses: [\n            result.response\n        ],\n        providerMetadata: result.providerMetadata\n    });\n}\nvar DefaultTranscriptionResult = class {\n    constructor(options){\n        var _a17;\n        this.text = options.text;\n        this.segments = options.segments;\n        this.language = options.language;\n        this.durationInSeconds = options.durationInSeconds;\n        this.warnings = options.warnings;\n        this.responses = options.responses;\n        this.providerMetadata = (_a17 = options.providerMetadata) != null ? _a17 : {};\n    }\n};\n// core/util/merge-objects.ts\nfunction mergeObjects(target, source) {\n    if (target === void 0 && source === void 0) {\n        return void 0;\n    }\n    if (target === void 0) {\n        return source;\n    }\n    if (source === void 0) {\n        return target;\n    }\n    const result = {\n        ...target\n    };\n    for(const key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            const sourceValue = source[key];\n            if (sourceValue === void 0) continue;\n            const targetValue = key in target ? target[key] : void 0;\n            const isSourceObject = sourceValue !== null && typeof sourceValue === \"object\" && !Array.isArray(sourceValue) && !(sourceValue instanceof Date) && !(sourceValue instanceof RegExp);\n            const isTargetObject = targetValue !== null && targetValue !== void 0 && typeof targetValue === \"object\" && !Array.isArray(targetValue) && !(targetValue instanceof Date) && !(targetValue instanceof RegExp);\n            if (isSourceObject && isTargetObject) {\n                result[key] = mergeObjects(targetValue, sourceValue);\n            } else {\n                result[key] = sourceValue;\n            }\n        }\n    }\n    return result;\n}\n// core/middleware/default-settings-middleware.ts\nfunction defaultSettingsMiddleware({ settings }) {\n    return {\n        middlewareVersion: \"v1\",\n        transformParams: async ({ params })=>{\n            var _a17;\n            return {\n                ...settings,\n                ...params,\n                providerMetadata: mergeObjects(settings.providerMetadata, params.providerMetadata),\n                // special case for temperature 0\n                // TODO remove when temperature defaults to undefined\n                temperature: params.temperature === 0 || params.temperature == null ? (_a17 = settings.temperature) != null ? _a17 : 0 : params.temperature\n            };\n        }\n    };\n}\n// core/util/get-potential-start-index.ts\nfunction getPotentialStartIndex(text2, searchedText) {\n    if (searchedText.length === 0) {\n        return null;\n    }\n    const directIndex = text2.indexOf(searchedText);\n    if (directIndex !== -1) {\n        return directIndex;\n    }\n    for(let i = text2.length - 1; i >= 0; i--){\n        const suffix = text2.substring(i);\n        if (searchedText.startsWith(suffix)) {\n            return i;\n        }\n    }\n    return null;\n}\n// core/middleware/extract-reasoning-middleware.ts\nfunction extractReasoningMiddleware({ tagName, separator = \"\\n\", startWithReasoning = false }) {\n    const openingTag = `<${tagName}>`;\n    const closingTag = `</${tagName}>`;\n    return {\n        middlewareVersion: \"v1\",\n        wrapGenerate: async ({ doGenerate })=>{\n            const { text: rawText, ...rest } = await doGenerate();\n            if (rawText == null) {\n                return {\n                    text: rawText,\n                    ...rest\n                };\n            }\n            const text2 = startWithReasoning ? openingTag + rawText : rawText;\n            const regexp = new RegExp(`${openingTag}(.*?)${closingTag}`, \"gs\");\n            const matches = Array.from(text2.matchAll(regexp));\n            if (!matches.length) {\n                return {\n                    text: text2,\n                    ...rest\n                };\n            }\n            const reasoning = matches.map((match)=>match[1]).join(separator);\n            let textWithoutReasoning = text2;\n            for(let i = matches.length - 1; i >= 0; i--){\n                const match = matches[i];\n                const beforeMatch = textWithoutReasoning.slice(0, match.index);\n                const afterMatch = textWithoutReasoning.slice(match.index + match[0].length);\n                textWithoutReasoning = beforeMatch + (beforeMatch.length > 0 && afterMatch.length > 0 ? separator : \"\") + afterMatch;\n            }\n            return {\n                ...rest,\n                text: textWithoutReasoning,\n                reasoning\n            };\n        },\n        wrapStream: async ({ doStream })=>{\n            const { stream, ...rest } = await doStream();\n            let isFirstReasoning = true;\n            let isFirstText = true;\n            let afterSwitch = false;\n            let isReasoning = startWithReasoning;\n            let buffer = \"\";\n            return {\n                stream: stream.pipeThrough(new TransformStream({\n                    transform: (chunk, controller)=>{\n                        if (chunk.type !== \"text-delta\") {\n                            controller.enqueue(chunk);\n                            return;\n                        }\n                        buffer += chunk.textDelta;\n                        function publish(text2) {\n                            if (text2.length > 0) {\n                                const prefix = afterSwitch && (isReasoning ? !isFirstReasoning : !isFirstText) ? separator : \"\";\n                                controller.enqueue({\n                                    type: isReasoning ? \"reasoning\" : \"text-delta\",\n                                    textDelta: prefix + text2\n                                });\n                                afterSwitch = false;\n                                if (isReasoning) {\n                                    isFirstReasoning = false;\n                                } else {\n                                    isFirstText = false;\n                                }\n                            }\n                        }\n                        do {\n                            const nextTag = isReasoning ? closingTag : openingTag;\n                            const startIndex = getPotentialStartIndex(buffer, nextTag);\n                            if (startIndex == null) {\n                                publish(buffer);\n                                buffer = \"\";\n                                break;\n                            }\n                            publish(buffer.slice(0, startIndex));\n                            const foundFullMatch = startIndex + nextTag.length <= buffer.length;\n                            if (foundFullMatch) {\n                                buffer = buffer.slice(startIndex + nextTag.length);\n                                isReasoning = !isReasoning;\n                                afterSwitch = true;\n                            } else {\n                                buffer = buffer.slice(startIndex);\n                                break;\n                            }\n                        }while (true);\n                    }\n                })),\n                ...rest\n            };\n        }\n    };\n}\n// core/middleware/simulate-streaming-middleware.ts\nfunction simulateStreamingMiddleware() {\n    return {\n        middlewareVersion: \"v1\",\n        wrapStream: async ({ doGenerate })=>{\n            const result = await doGenerate();\n            const simulatedStream = new ReadableStream({\n                start (controller) {\n                    controller.enqueue({\n                        type: \"response-metadata\",\n                        ...result.response\n                    });\n                    if (result.reasoning) {\n                        if (typeof result.reasoning === \"string\") {\n                            controller.enqueue({\n                                type: \"reasoning\",\n                                textDelta: result.reasoning\n                            });\n                        } else {\n                            for (const reasoning of result.reasoning){\n                                switch(reasoning.type){\n                                    case \"text\":\n                                        {\n                                            controller.enqueue({\n                                                type: \"reasoning\",\n                                                textDelta: reasoning.text\n                                            });\n                                            if (reasoning.signature != null) {\n                                                controller.enqueue({\n                                                    type: \"reasoning-signature\",\n                                                    signature: reasoning.signature\n                                                });\n                                            }\n                                            break;\n                                        }\n                                    case \"redacted\":\n                                        {\n                                            controller.enqueue({\n                                                type: \"redacted-reasoning\",\n                                                data: reasoning.data\n                                            });\n                                            break;\n                                        }\n                                }\n                            }\n                        }\n                    }\n                    if (result.text) {\n                        controller.enqueue({\n                            type: \"text-delta\",\n                            textDelta: result.text\n                        });\n                    }\n                    if (result.toolCalls) {\n                        for (const toolCall of result.toolCalls){\n                            controller.enqueue({\n                                type: \"tool-call-delta\",\n                                toolCallType: \"function\",\n                                toolCallId: toolCall.toolCallId,\n                                toolName: toolCall.toolName,\n                                argsTextDelta: toolCall.args\n                            });\n                            controller.enqueue({\n                                type: \"tool-call\",\n                                ...toolCall\n                            });\n                        }\n                    }\n                    controller.enqueue({\n                        type: \"finish\",\n                        finishReason: result.finishReason,\n                        usage: result.usage,\n                        logprobs: result.logprobs,\n                        providerMetadata: result.providerMetadata\n                    });\n                    controller.close();\n                }\n            });\n            return {\n                stream: simulatedStream,\n                rawCall: result.rawCall,\n                rawResponse: result.rawResponse,\n                warnings: result.warnings\n            };\n        }\n    };\n}\n// core/middleware/wrap-language-model.ts\nvar wrapLanguageModel = ({ model, middleware: middlewareArg, modelId, providerId })=>{\n    return asArray(middlewareArg).reverse().reduce((wrappedModel, middleware)=>{\n        return doWrap({\n            model: wrappedModel,\n            middleware,\n            modelId,\n            providerId\n        });\n    }, model);\n};\nvar doWrap = ({ model, middleware: { transformParams, wrapGenerate, wrapStream }, modelId, providerId })=>{\n    var _a17;\n    async function doTransform({ params, type }) {\n        return transformParams ? await transformParams({\n            params,\n            type\n        }) : params;\n    }\n    return {\n        specificationVersion: \"v1\",\n        provider: providerId != null ? providerId : model.provider,\n        modelId: modelId != null ? modelId : model.modelId,\n        defaultObjectGenerationMode: model.defaultObjectGenerationMode,\n        supportsImageUrls: model.supportsImageUrls,\n        supportsUrl: (_a17 = model.supportsUrl) == null ? void 0 : _a17.bind(model),\n        supportsStructuredOutputs: model.supportsStructuredOutputs,\n        async doGenerate (params) {\n            const transformedParams = await doTransform({\n                params,\n                type: \"generate\"\n            });\n            const doGenerate = async ()=>model.doGenerate(transformedParams);\n            const doStream = async ()=>model.doStream(transformedParams);\n            return wrapGenerate ? wrapGenerate({\n                doGenerate,\n                doStream,\n                params: transformedParams,\n                model\n            }) : doGenerate();\n        },\n        async doStream (params) {\n            const transformedParams = await doTransform({\n                params,\n                type: \"stream\"\n            });\n            const doGenerate = async ()=>model.doGenerate(transformedParams);\n            const doStream = async ()=>model.doStream(transformedParams);\n            return wrapStream ? wrapStream({\n                doGenerate,\n                doStream,\n                params: transformedParams,\n                model\n            }) : doStream();\n        }\n    };\n};\nvar experimental_wrapLanguageModel = wrapLanguageModel;\n// core/prompt/append-client-message.ts\nfunction appendClientMessage({ messages, message }) {\n    return [\n        ...messages.length > 0 && messages[messages.length - 1].id === message.id ? messages.slice(0, -1) : messages,\n        message\n    ];\n}\n// core/prompt/append-response-messages.ts\n\n\nfunction appendResponseMessages({ messages, responseMessages, _internal: { currentDate = ()=>/* @__PURE__ */ new Date() } = {} }) {\n    var _a17, _b, _c, _d;\n    const clonedMessages = structuredClone(messages);\n    for (const message of responseMessages){\n        const role = message.role;\n        const lastMessage = clonedMessages[clonedMessages.length - 1];\n        const isLastMessageAssistant = lastMessage.role === \"assistant\";\n        switch(role){\n            case \"assistant\":\n                {\n                    let getToolInvocations2 = function(step) {\n                        return (typeof message.content === \"string\" ? [] : message.content.filter((part)=>part.type === \"tool-call\")).map((call)=>({\n                                state: \"call\",\n                                step,\n                                args: call.args,\n                                toolCallId: call.toolCallId,\n                                toolName: call.toolName\n                            }));\n                    };\n                    var getToolInvocations = getToolInvocations2;\n                    const parts = [\n                        {\n                            type: \"step-start\"\n                        }\n                    ];\n                    let textContent = \"\";\n                    let reasoningTextContent = void 0;\n                    if (typeof message.content === \"string\") {\n                        textContent = message.content;\n                        parts.push({\n                            type: \"text\",\n                            text: message.content\n                        });\n                    } else {\n                        let reasoningPart = void 0;\n                        for (const part of message.content){\n                            switch(part.type){\n                                case \"text\":\n                                    {\n                                        reasoningPart = void 0;\n                                        textContent += part.text;\n                                        parts.push({\n                                            type: \"text\",\n                                            text: part.text\n                                        });\n                                        break;\n                                    }\n                                case \"reasoning\":\n                                    {\n                                        if (reasoningPart == null) {\n                                            reasoningPart = {\n                                                type: \"reasoning\",\n                                                reasoning: \"\",\n                                                details: []\n                                            };\n                                            parts.push(reasoningPart);\n                                        }\n                                        reasoningTextContent = (reasoningTextContent != null ? reasoningTextContent : \"\") + part.text;\n                                        reasoningPart.reasoning += part.text;\n                                        reasoningPart.details.push({\n                                            type: \"text\",\n                                            text: part.text,\n                                            signature: part.signature\n                                        });\n                                        break;\n                                    }\n                                case \"redacted-reasoning\":\n                                    {\n                                        if (reasoningPart == null) {\n                                            reasoningPart = {\n                                                type: \"reasoning\",\n                                                reasoning: \"\",\n                                                details: []\n                                            };\n                                            parts.push(reasoningPart);\n                                        }\n                                        reasoningPart.details.push({\n                                            type: \"redacted\",\n                                            data: part.data\n                                        });\n                                        break;\n                                    }\n                                case \"tool-call\":\n                                    break;\n                                case \"file\":\n                                    if (part.data instanceof URL) {\n                                        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError({\n                                            name: \"InvalidAssistantFileData\",\n                                            message: \"File data cannot be a URL\"\n                                        });\n                                    }\n                                    parts.push({\n                                        type: \"file\",\n                                        mimeType: part.mimeType,\n                                        data: convertDataContentToBase64String(part.data)\n                                    });\n                                    break;\n                            }\n                        }\n                    }\n                    if (isLastMessageAssistant) {\n                        const maxStep = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.extractMaxToolInvocationStep)(lastMessage.toolInvocations);\n                        (_a17 = lastMessage.parts) != null ? _a17 : lastMessage.parts = [];\n                        lastMessage.content = textContent;\n                        lastMessage.reasoning = reasoningTextContent;\n                        lastMessage.parts.push(...parts);\n                        lastMessage.toolInvocations = [\n                            ...(_b = lastMessage.toolInvocations) != null ? _b : [],\n                            ...getToolInvocations2(maxStep === void 0 ? 0 : maxStep + 1)\n                        ];\n                        getToolInvocations2(maxStep === void 0 ? 0 : maxStep + 1).map((call)=>({\n                                type: \"tool-invocation\",\n                                toolInvocation: call\n                            })).forEach((part)=>{\n                            lastMessage.parts.push(part);\n                        });\n                    } else {\n                        clonedMessages.push({\n                            role: \"assistant\",\n                            id: message.id,\n                            createdAt: currentDate(),\n                            // generate a createdAt date for the message, will be overridden by the client\n                            content: textContent,\n                            reasoning: reasoningTextContent,\n                            toolInvocations: getToolInvocations2(0),\n                            parts: [\n                                ...parts,\n                                ...getToolInvocations2(0).map((call)=>({\n                                        type: \"tool-invocation\",\n                                        toolInvocation: call\n                                    }))\n                            ]\n                        });\n                    }\n                    break;\n                }\n            case \"tool\":\n                {\n                    (_c = lastMessage.toolInvocations) != null ? _c : lastMessage.toolInvocations = [];\n                    if (lastMessage.role !== \"assistant\") {\n                        throw new Error(`Tool result must follow an assistant message: ${lastMessage.role}`);\n                    }\n                    (_d = lastMessage.parts) != null ? _d : lastMessage.parts = [];\n                    for (const contentPart of message.content){\n                        const toolCall = lastMessage.toolInvocations.find((call)=>call.toolCallId === contentPart.toolCallId);\n                        const toolCallPart = lastMessage.parts.find((part)=>part.type === \"tool-invocation\" && part.toolInvocation.toolCallId === contentPart.toolCallId);\n                        if (!toolCall) {\n                            throw new Error(\"Tool call not found in previous message\");\n                        }\n                        toolCall.state = \"result\";\n                        const toolResult = toolCall;\n                        toolResult.result = contentPart.result;\n                        if (toolCallPart) {\n                            toolCallPart.toolInvocation = toolResult;\n                        } else {\n                            lastMessage.parts.push({\n                                type: \"tool-invocation\",\n                                toolInvocation: toolResult\n                            });\n                        }\n                    }\n                    break;\n                }\n            default:\n                {\n                    const _exhaustiveCheck = role;\n                    throw new Error(`Unsupported message role: ${_exhaustiveCheck}`);\n                }\n        }\n    }\n    return clonedMessages;\n}\n// core/registry/custom-provider.ts\n\nfunction customProvider({ languageModels, textEmbeddingModels, imageModels, fallbackProvider }) {\n    return {\n        languageModel (modelId) {\n            if (languageModels != null && modelId in languageModels) {\n                return languageModels[modelId];\n            }\n            if (fallbackProvider) {\n                return fallbackProvider.languageModel(modelId);\n            }\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchModelError({\n                modelId,\n                modelType: \"languageModel\"\n            });\n        },\n        textEmbeddingModel (modelId) {\n            if (textEmbeddingModels != null && modelId in textEmbeddingModels) {\n                return textEmbeddingModels[modelId];\n            }\n            if (fallbackProvider) {\n                return fallbackProvider.textEmbeddingModel(modelId);\n            }\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchModelError({\n                modelId,\n                modelType: \"textEmbeddingModel\"\n            });\n        },\n        imageModel (modelId) {\n            if (imageModels != null && modelId in imageModels) {\n                return imageModels[modelId];\n            }\n            if (fallbackProvider == null ? void 0 : fallbackProvider.imageModel) {\n                return fallbackProvider.imageModel(modelId);\n            }\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchModelError({\n                modelId,\n                modelType: \"imageModel\"\n            });\n        }\n    };\n}\nvar experimental_customProvider = customProvider;\n// core/registry/no-such-provider-error.ts\n\nvar name16 = \"AI_NoSuchProviderError\";\nvar marker16 = `vercel.ai.error.${name16}`;\nvar symbol16 = Symbol.for(marker16);\nvar _a16;\nvar NoSuchProviderError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchModelError {\n    constructor({ modelId, modelType, providerId, availableProviders, message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})` }){\n        super({\n            errorName: name16,\n            modelId,\n            modelType,\n            message\n        });\n        this[_a16] = true;\n        this.providerId = providerId;\n        this.availableProviders = availableProviders;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker16);\n    }\n};\n_a16 = symbol16;\n// core/registry/provider-registry.ts\n\nfunction createProviderRegistry(providers, { separator = \":\" } = {}) {\n    const registry = new DefaultProviderRegistry({\n        separator\n    });\n    for (const [id, provider] of Object.entries(providers)){\n        registry.registerProvider({\n            id,\n            provider\n        });\n    }\n    return registry;\n}\nvar experimental_createProviderRegistry = createProviderRegistry;\nvar DefaultProviderRegistry = class {\n    constructor({ separator }){\n        this.providers = {};\n        this.separator = separator;\n    }\n    registerProvider({ id, provider }) {\n        this.providers[id] = provider;\n    }\n    getProvider(id) {\n        const provider = this.providers[id];\n        if (provider == null) {\n            throw new NoSuchProviderError({\n                modelId: id,\n                modelType: \"languageModel\",\n                providerId: id,\n                availableProviders: Object.keys(this.providers)\n            });\n        }\n        return provider;\n    }\n    splitId(id, modelType) {\n        const index = id.indexOf(this.separator);\n        if (index === -1) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchModelError({\n                modelId: id,\n                modelType,\n                message: `Invalid ${modelType} id for registry: ${id} (must be in the format \"providerId${this.separator}modelId\")`\n            });\n        }\n        return [\n            id.slice(0, index),\n            id.slice(index + this.separator.length)\n        ];\n    }\n    languageModel(id) {\n        var _a17, _b;\n        const [providerId, modelId] = this.splitId(id, \"languageModel\");\n        const model = (_b = (_a17 = this.getProvider(providerId)).languageModel) == null ? void 0 : _b.call(_a17, modelId);\n        if (model == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchModelError({\n                modelId: id,\n                modelType: \"languageModel\"\n            });\n        }\n        return model;\n    }\n    textEmbeddingModel(id) {\n        var _a17;\n        const [providerId, modelId] = this.splitId(id, \"textEmbeddingModel\");\n        const provider = this.getProvider(providerId);\n        const model = (_a17 = provider.textEmbeddingModel) == null ? void 0 : _a17.call(provider, modelId);\n        if (model == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchModelError({\n                modelId: id,\n                modelType: \"textEmbeddingModel\"\n            });\n        }\n        return model;\n    }\n    imageModel(id) {\n        var _a17;\n        const [providerId, modelId] = this.splitId(id, \"imageModel\");\n        const provider = this.getProvider(providerId);\n        const model = (_a17 = provider.imageModel) == null ? void 0 : _a17.call(provider, modelId);\n        if (model == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchModelError({\n                modelId: id,\n                modelType: \"imageModel\"\n            });\n        }\n        return model;\n    }\n};\n// core/tool/mcp/mcp-client.ts\n\n// core/tool/tool.ts\nfunction tool(tool2) {\n    return tool2;\n}\n// core/tool/mcp/mcp-sse-transport.ts\n\n// core/tool/mcp/json-rpc-message.ts\n\n// core/tool/mcp/types.ts\n\nvar LATEST_PROTOCOL_VERSION = \"2024-11-05\";\nvar SUPPORTED_PROTOCOL_VERSIONS = [\n    LATEST_PROTOCOL_VERSION,\n    \"2024-10-07\"\n];\nvar ClientOrServerImplementationSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    name: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    version: zod__WEBPACK_IMPORTED_MODULE_4__.z.string()\n}).passthrough();\nvar BaseParamsSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    _meta: zod__WEBPACK_IMPORTED_MODULE_4__.z.optional(zod__WEBPACK_IMPORTED_MODULE_4__.z.object({}).passthrough())\n}).passthrough();\nvar ResultSchema = BaseParamsSchema;\nvar RequestSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    method: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    params: zod__WEBPACK_IMPORTED_MODULE_4__.z.optional(BaseParamsSchema)\n});\nvar ServerCapabilitiesSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    experimental: zod__WEBPACK_IMPORTED_MODULE_4__.z.optional(zod__WEBPACK_IMPORTED_MODULE_4__.z.object({}).passthrough()),\n    logging: zod__WEBPACK_IMPORTED_MODULE_4__.z.optional(zod__WEBPACK_IMPORTED_MODULE_4__.z.object({}).passthrough()),\n    prompts: zod__WEBPACK_IMPORTED_MODULE_4__.z.optional(zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n        listChanged: zod__WEBPACK_IMPORTED_MODULE_4__.z.optional(zod__WEBPACK_IMPORTED_MODULE_4__.z.boolean())\n    }).passthrough()),\n    resources: zod__WEBPACK_IMPORTED_MODULE_4__.z.optional(zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n        subscribe: zod__WEBPACK_IMPORTED_MODULE_4__.z.optional(zod__WEBPACK_IMPORTED_MODULE_4__.z.boolean()),\n        listChanged: zod__WEBPACK_IMPORTED_MODULE_4__.z.optional(zod__WEBPACK_IMPORTED_MODULE_4__.z.boolean())\n    }).passthrough()),\n    tools: zod__WEBPACK_IMPORTED_MODULE_4__.z.optional(zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n        listChanged: zod__WEBPACK_IMPORTED_MODULE_4__.z.optional(zod__WEBPACK_IMPORTED_MODULE_4__.z.boolean())\n    }).passthrough())\n}).passthrough();\nvar InitializeResultSchema = ResultSchema.extend({\n    protocolVersion: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    capabilities: ServerCapabilitiesSchema,\n    serverInfo: ClientOrServerImplementationSchema,\n    instructions: zod__WEBPACK_IMPORTED_MODULE_4__.z.optional(zod__WEBPACK_IMPORTED_MODULE_4__.z.string())\n});\nvar PaginatedResultSchema = ResultSchema.extend({\n    nextCursor: zod__WEBPACK_IMPORTED_MODULE_4__.z.optional(zod__WEBPACK_IMPORTED_MODULE_4__.z.string())\n});\nvar ToolSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    name: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    description: zod__WEBPACK_IMPORTED_MODULE_4__.z.optional(zod__WEBPACK_IMPORTED_MODULE_4__.z.string()),\n    inputSchema: zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n        type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"object\"),\n        properties: zod__WEBPACK_IMPORTED_MODULE_4__.z.optional(zod__WEBPACK_IMPORTED_MODULE_4__.z.object({}).passthrough())\n    }).passthrough()\n}).passthrough();\nvar ListToolsResultSchema = PaginatedResultSchema.extend({\n    tools: zod__WEBPACK_IMPORTED_MODULE_4__.z.array(ToolSchema)\n});\nvar TextContentSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"text\"),\n    text: zod__WEBPACK_IMPORTED_MODULE_4__.z.string()\n}).passthrough();\nvar ImageContentSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"image\"),\n    data: zod__WEBPACK_IMPORTED_MODULE_4__.z.string().base64(),\n    mimeType: zod__WEBPACK_IMPORTED_MODULE_4__.z.string()\n}).passthrough();\nvar ResourceContentsSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    /**\n   * The URI of this resource.\n   */ uri: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    /**\n   * The MIME type of this resource, if known.\n   */ mimeType: zod__WEBPACK_IMPORTED_MODULE_4__.z.optional(zod__WEBPACK_IMPORTED_MODULE_4__.z.string())\n}).passthrough();\nvar TextResourceContentsSchema = ResourceContentsSchema.extend({\n    text: zod__WEBPACK_IMPORTED_MODULE_4__.z.string()\n});\nvar BlobResourceContentsSchema = ResourceContentsSchema.extend({\n    blob: zod__WEBPACK_IMPORTED_MODULE_4__.z.string().base64()\n});\nvar EmbeddedResourceSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"resource\"),\n    resource: zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n        TextResourceContentsSchema,\n        BlobResourceContentsSchema\n    ])\n}).passthrough();\nvar CallToolResultSchema = ResultSchema.extend({\n    content: zod__WEBPACK_IMPORTED_MODULE_4__.z.array(zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n        TextContentSchema,\n        ImageContentSchema,\n        EmbeddedResourceSchema\n    ])),\n    isError: zod__WEBPACK_IMPORTED_MODULE_4__.z.boolean().default(false).optional()\n}).or(ResultSchema.extend({\n    toolResult: zod__WEBPACK_IMPORTED_MODULE_4__.z.unknown()\n}));\n// core/tool/mcp/json-rpc-message.ts\nvar JSONRPC_VERSION = \"2.0\";\nvar JSONRPCRequestSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    jsonrpc: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(JSONRPC_VERSION),\n    id: zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.number().int()\n    ])\n}).merge(RequestSchema).strict();\nvar JSONRPCResponseSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    jsonrpc: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(JSONRPC_VERSION),\n    id: zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.number().int()\n    ]),\n    result: ResultSchema\n}).strict();\nvar JSONRPCErrorSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    jsonrpc: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(JSONRPC_VERSION),\n    id: zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.number().int()\n    ]),\n    error: zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n        code: zod__WEBPACK_IMPORTED_MODULE_4__.z.number().int(),\n        message: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n        data: zod__WEBPACK_IMPORTED_MODULE_4__.z.optional(zod__WEBPACK_IMPORTED_MODULE_4__.z.unknown())\n    })\n}).strict();\nvar JSONRPCNotificationSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    jsonrpc: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(JSONRPC_VERSION)\n}).merge(zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    method: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    params: zod__WEBPACK_IMPORTED_MODULE_4__.z.optional(BaseParamsSchema)\n})).strict();\nvar JSONRPCMessageSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n    JSONRPCRequestSchema,\n    JSONRPCNotificationSchema,\n    JSONRPCResponseSchema,\n    JSONRPCErrorSchema\n]);\n// core/tool/mcp/mcp-sse-transport.ts\nvar SseMCPTransport = class {\n    constructor({ url, headers }){\n        this.connected = false;\n        this.url = new URL(url);\n        this.headers = headers;\n    }\n    async start() {\n        return new Promise((resolve, reject)=>{\n            if (this.connected) {\n                return resolve();\n            }\n            this.abortController = new AbortController();\n            const establishConnection = async ()=>{\n                var _a17, _b, _c;\n                try {\n                    const headers = new Headers(this.headers);\n                    headers.set(\"Accept\", \"text/event-stream\");\n                    const response = await fetch(this.url.href, {\n                        headers,\n                        signal: (_a17 = this.abortController) == null ? void 0 : _a17.signal\n                    });\n                    if (!response.ok || !response.body) {\n                        const error = new MCPClientError({\n                            message: `MCP SSE Transport Error: ${response.status} ${response.statusText}`\n                        });\n                        (_b = this.onerror) == null ? void 0 : _b.call(this, error);\n                        return reject(error);\n                    }\n                    const stream = response.body.pipeThrough(new TextDecoderStream()).pipeThrough((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createEventSourceParserStream)());\n                    const reader = stream.getReader();\n                    const processEvents = async ()=>{\n                        var _a18, _b2, _c2;\n                        try {\n                            while(true){\n                                const { done, value } = await reader.read();\n                                if (done) {\n                                    if (this.connected) {\n                                        this.connected = false;\n                                        throw new MCPClientError({\n                                            message: \"MCP SSE Transport Error: Connection closed unexpectedly\"\n                                        });\n                                    }\n                                    return;\n                                }\n                                const { event, data } = value;\n                                if (event === \"endpoint\") {\n                                    this.endpoint = new URL(data, this.url);\n                                    if (this.endpoint.origin !== this.url.origin) {\n                                        throw new MCPClientError({\n                                            message: `MCP SSE Transport Error: Endpoint origin does not match connection origin: ${this.endpoint.origin}`\n                                        });\n                                    }\n                                    this.connected = true;\n                                    resolve();\n                                } else if (event === \"message\") {\n                                    try {\n                                        const message = JSONRPCMessageSchema.parse(JSON.parse(data));\n                                        (_a18 = this.onmessage) == null ? void 0 : _a18.call(this, message);\n                                    } catch (error) {\n                                        const e = new MCPClientError({\n                                            message: \"MCP SSE Transport Error: Failed to parse message\",\n                                            cause: error\n                                        });\n                                        (_b2 = this.onerror) == null ? void 0 : _b2.call(this, e);\n                                    }\n                                }\n                            }\n                        } catch (error) {\n                            if (error instanceof Error && error.name === \"AbortError\") {\n                                return;\n                            }\n                            (_c2 = this.onerror) == null ? void 0 : _c2.call(this, error);\n                            reject(error);\n                        }\n                    };\n                    this.sseConnection = {\n                        close: ()=>reader.cancel()\n                    };\n                    processEvents();\n                } catch (error) {\n                    if (error instanceof Error && error.name === \"AbortError\") {\n                        return;\n                    }\n                    (_c = this.onerror) == null ? void 0 : _c.call(this, error);\n                    reject(error);\n                }\n            };\n            establishConnection();\n        });\n    }\n    async close() {\n        var _a17, _b, _c;\n        this.connected = false;\n        (_a17 = this.sseConnection) == null ? void 0 : _a17.close();\n        (_b = this.abortController) == null ? void 0 : _b.abort();\n        (_c = this.onclose) == null ? void 0 : _c.call(this);\n    }\n    async send(message) {\n        var _a17, _b, _c;\n        if (!this.endpoint || !this.connected) {\n            throw new MCPClientError({\n                message: \"MCP SSE Transport Error: Not connected\"\n            });\n        }\n        try {\n            const headers = new Headers(this.headers);\n            headers.set(\"Content-Type\", \"application/json\");\n            const init = {\n                method: \"POST\",\n                headers,\n                body: JSON.stringify(message),\n                signal: (_a17 = this.abortController) == null ? void 0 : _a17.signal\n            };\n            const response = await fetch(this.endpoint, init);\n            if (!response.ok) {\n                const text2 = await response.text().catch(()=>null);\n                const error = new MCPClientError({\n                    message: `MCP SSE Transport Error: POSTing to endpoint (HTTP ${response.status}): ${text2}`\n                });\n                (_b = this.onerror) == null ? void 0 : _b.call(this, error);\n                return;\n            }\n        } catch (error) {\n            (_c = this.onerror) == null ? void 0 : _c.call(this, error);\n            return;\n        }\n    }\n};\n// core/tool/mcp/mcp-transport.ts\nfunction createMcpTransport(config) {\n    if (config.type !== \"sse\") {\n        throw new MCPClientError({\n            message: \"Unsupported or invalid transport configuration. If you are using a custom transport, make sure it implements the MCPTransport interface.\"\n        });\n    }\n    return new SseMCPTransport(config);\n}\nfunction isCustomMcpTransport(transport) {\n    return \"start\" in transport && typeof transport.start === \"function\" && \"send\" in transport && typeof transport.send === \"function\" && \"close\" in transport && typeof transport.close === \"function\";\n}\n// core/tool/mcp/mcp-client.ts\nvar CLIENT_VERSION = \"1.0.0\";\nasync function createMCPClient(config) {\n    const client = new MCPClient(config);\n    await client.init();\n    return client;\n}\nvar MCPClient = class {\n    constructor({ transport: transportConfig, name: name17 = \"ai-sdk-mcp-client\", onUncaughtError }){\n        this.requestMessageId = 0;\n        this.responseHandlers = /* @__PURE__ */ new Map();\n        this.serverCapabilities = {};\n        this.isClosed = true;\n        this.onUncaughtError = onUncaughtError;\n        if (isCustomMcpTransport(transportConfig)) {\n            this.transport = transportConfig;\n        } else {\n            this.transport = createMcpTransport(transportConfig);\n        }\n        this.transport.onclose = ()=>this.onClose();\n        this.transport.onerror = (error)=>this.onError(error);\n        this.transport.onmessage = (message)=>{\n            if (\"method\" in message) {\n                this.onError(new MCPClientError({\n                    message: \"Unsupported message type\"\n                }));\n                return;\n            }\n            this.onResponse(message);\n        };\n        this.clientInfo = {\n            name: name17,\n            version: CLIENT_VERSION\n        };\n    }\n    async init() {\n        try {\n            await this.transport.start();\n            this.isClosed = false;\n            const result = await this.request({\n                request: {\n                    method: \"initialize\",\n                    params: {\n                        protocolVersion: LATEST_PROTOCOL_VERSION,\n                        capabilities: {},\n                        clientInfo: this.clientInfo\n                    }\n                },\n                resultSchema: InitializeResultSchema\n            });\n            if (result === void 0) {\n                throw new MCPClientError({\n                    message: \"Server sent invalid initialize result\"\n                });\n            }\n            if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {\n                throw new MCPClientError({\n                    message: `Server's protocol version is not supported: ${result.protocolVersion}`\n                });\n            }\n            this.serverCapabilities = result.capabilities;\n            await this.notification({\n                method: \"notifications/initialized\"\n            });\n            return this;\n        } catch (error) {\n            await this.close();\n            throw error;\n        }\n    }\n    async close() {\n        var _a17;\n        if (this.isClosed) return;\n        await ((_a17 = this.transport) == null ? void 0 : _a17.close());\n        this.onClose();\n    }\n    async request({ request, resultSchema, options }) {\n        return new Promise((resolve, reject)=>{\n            if (this.isClosed) {\n                return reject(new MCPClientError({\n                    message: \"Attempted to send a request from a closed client\"\n                }));\n            }\n            const signal = options == null ? void 0 : options.signal;\n            signal == null ? void 0 : signal.throwIfAborted();\n            const messageId = this.requestMessageId++;\n            const jsonrpcRequest = {\n                ...request,\n                jsonrpc: \"2.0\",\n                id: messageId\n            };\n            const cleanup = ()=>{\n                this.responseHandlers.delete(messageId);\n            };\n            this.responseHandlers.set(messageId, (response)=>{\n                if (signal == null ? void 0 : signal.aborted) {\n                    return reject(new MCPClientError({\n                        message: \"Request was aborted\",\n                        cause: signal.reason\n                    }));\n                }\n                if (response instanceof Error) {\n                    return reject(response);\n                }\n                try {\n                    const result = resultSchema.parse(response.result);\n                    resolve(result);\n                } catch (error) {\n                    const parseError = new MCPClientError({\n                        message: \"Failed to parse server initialization result\",\n                        cause: error\n                    });\n                    reject(parseError);\n                }\n            });\n            this.transport.send(jsonrpcRequest).catch((error)=>{\n                cleanup();\n                reject(error);\n            });\n        });\n    }\n    async listTools({ params, options } = {}) {\n        if (!this.serverCapabilities.tools) {\n            throw new MCPClientError({\n                message: `Server does not support tools`\n            });\n        }\n        try {\n            return this.request({\n                request: {\n                    method: \"tools/list\",\n                    params\n                },\n                resultSchema: ListToolsResultSchema,\n                options\n            });\n        } catch (error) {\n            throw error;\n        }\n    }\n    async callTool({ name: name17, args, options }) {\n        if (!this.serverCapabilities.tools) {\n            throw new MCPClientError({\n                message: `Server does not support tools`\n            });\n        }\n        try {\n            return this.request({\n                request: {\n                    method: \"tools/call\",\n                    params: {\n                        name: name17,\n                        arguments: args\n                    }\n                },\n                resultSchema: CallToolResultSchema,\n                options: {\n                    signal: options == null ? void 0 : options.abortSignal\n                }\n            });\n        } catch (error) {\n            throw error;\n        }\n    }\n    async notification(notification) {\n        const jsonrpcNotification = {\n            ...notification,\n            jsonrpc: \"2.0\"\n        };\n        await this.transport.send(jsonrpcNotification);\n    }\n    /**\n   * Returns a set of AI SDK tools from the MCP server\n   * @returns A record of tool names to their implementations\n   */ async tools({ schemas = \"automatic\" } = {}) {\n        var _a17;\n        const tools = {};\n        try {\n            const listToolsResult = await this.listTools();\n            for (const { name: name17, description, inputSchema } of listToolsResult.tools){\n                if (schemas !== \"automatic\" && !(name17 in schemas)) {\n                    continue;\n                }\n                const parameters = schemas === \"automatic\" ? (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.jsonSchema)({\n                    ...inputSchema,\n                    properties: (_a17 = inputSchema.properties) != null ? _a17 : {},\n                    additionalProperties: false\n                }) : schemas[name17].parameters;\n                const self = this;\n                const toolWithExecute = tool({\n                    description,\n                    parameters,\n                    execute: async (args, options)=>{\n                        var _a18;\n                        (_a18 = options == null ? void 0 : options.abortSignal) == null ? void 0 : _a18.throwIfAborted();\n                        return self.callTool({\n                            name: name17,\n                            args,\n                            options\n                        });\n                    }\n                });\n                tools[name17] = toolWithExecute;\n            }\n            return tools;\n        } catch (error) {\n            throw error;\n        }\n    }\n    onClose() {\n        if (this.isClosed) return;\n        this.isClosed = true;\n        const error = new MCPClientError({\n            message: \"Connection closed\"\n        });\n        for (const handler of this.responseHandlers.values()){\n            handler(error);\n        }\n        this.responseHandlers.clear();\n    }\n    onError(error) {\n        if (this.onUncaughtError) {\n            this.onUncaughtError(error);\n        }\n    }\n    onResponse(response) {\n        const messageId = Number(response.id);\n        const handler = this.responseHandlers.get(messageId);\n        if (handler === void 0) {\n            throw new MCPClientError({\n                message: `Protocol error: Received a response for an unknown message ID: ${JSON.stringify(response)}`\n            });\n        }\n        this.responseHandlers.delete(messageId);\n        handler(\"result\" in response ? response : new MCPClientError({\n            message: response.error.message,\n            cause: response.error\n        }));\n    }\n};\n// core/util/cosine-similarity.ts\nfunction cosineSimilarity(vector1, vector2, options) {\n    if (vector1.length !== vector2.length) {\n        throw new InvalidArgumentError({\n            parameter: \"vector1,vector2\",\n            value: {\n                vector1Length: vector1.length,\n                vector2Length: vector2.length\n            },\n            message: `Vectors must have the same length`\n        });\n    }\n    const n = vector1.length;\n    if (n === 0) {\n        if (options == null ? void 0 : options.throwErrorForEmptyVectors) {\n            throw new InvalidArgumentError({\n                parameter: \"vector1\",\n                value: vector1,\n                message: \"Vectors cannot be empty\"\n            });\n        }\n        return 0;\n    }\n    let magnitudeSquared1 = 0;\n    let magnitudeSquared2 = 0;\n    let dotProduct = 0;\n    for(let i = 0; i < n; i++){\n        const value1 = vector1[i];\n        const value2 = vector2[i];\n        magnitudeSquared1 += value1 * value1;\n        magnitudeSquared2 += value2 * value2;\n        dotProduct += value1 * value2;\n    }\n    return magnitudeSquared1 === 0 || magnitudeSquared2 === 0 ? 0 : dotProduct / (Math.sqrt(magnitudeSquared1) * Math.sqrt(magnitudeSquared2));\n}\n// core/util/simulate-readable-stream.ts\n\nfunction simulateReadableStream({ chunks, initialDelayInMs = 0, chunkDelayInMs = 0, _internal }) {\n    var _a17;\n    const delay2 = (_a17 = _internal == null ? void 0 : _internal.delay) != null ? _a17 : _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay;\n    let index = 0;\n    return new ReadableStream({\n        async pull (controller) {\n            if (index < chunks.length) {\n                await delay2(index === 0 ? initialDelayInMs : chunkDelayInMs);\n                controller.enqueue(chunks[index++]);\n            } else {\n                controller.close();\n            }\n        }\n    });\n}\n// streams/assistant-response.ts\n\nfunction AssistantResponse({ threadId, messageId }, process2) {\n    const stream = new ReadableStream({\n        async start (controller) {\n            var _a17;\n            const textEncoder = new TextEncoder();\n            const sendMessage = (message)=>{\n                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatAssistantStreamPart)(\"assistant_message\", message)));\n            };\n            const sendDataMessage = (message)=>{\n                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatAssistantStreamPart)(\"data_message\", message)));\n            };\n            const sendError = (errorMessage)=>{\n                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatAssistantStreamPart)(\"error\", errorMessage)));\n            };\n            const forwardStream = async (stream2)=>{\n                var _a18, _b;\n                let result = void 0;\n                for await (const value of stream2){\n                    switch(value.event){\n                        case \"thread.message.created\":\n                            {\n                                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatAssistantStreamPart)(\"assistant_message\", {\n                                    id: value.data.id,\n                                    role: \"assistant\",\n                                    content: [\n                                        {\n                                            type: \"text\",\n                                            text: {\n                                                value: \"\"\n                                            }\n                                        }\n                                    ]\n                                })));\n                                break;\n                            }\n                        case \"thread.message.delta\":\n                            {\n                                const content = (_a18 = value.data.delta.content) == null ? void 0 : _a18[0];\n                                if ((content == null ? void 0 : content.type) === \"text\" && ((_b = content.text) == null ? void 0 : _b.value) != null) {\n                                    controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatAssistantStreamPart)(\"text\", content.text.value)));\n                                }\n                                break;\n                            }\n                        case \"thread.run.completed\":\n                        case \"thread.run.requires_action\":\n                            {\n                                result = value.data;\n                                break;\n                            }\n                    }\n                }\n                return result;\n            };\n            controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatAssistantStreamPart)(\"assistant_control_data\", {\n                threadId,\n                messageId\n            })));\n            try {\n                await process2({\n                    sendMessage,\n                    sendDataMessage,\n                    forwardStream\n                });\n            } catch (error) {\n                sendError((_a17 = error.message) != null ? _a17 : `${error}`);\n            } finally{\n                controller.close();\n            }\n        },\n        pull (controller) {},\n        cancel () {}\n    });\n    return new Response(stream, {\n        status: 200,\n        headers: {\n            \"Content-Type\": \"text/plain; charset=utf-8\"\n        }\n    });\n}\n// streams/langchain-adapter.ts\nvar langchain_adapter_exports = {};\n__export(langchain_adapter_exports, {\n    mergeIntoDataStream: ()=>mergeIntoDataStream,\n    toDataStream: ()=>toDataStream,\n    toDataStreamResponse: ()=>toDataStreamResponse\n});\n\n// streams/stream-callbacks.ts\nfunction createCallbacksTransformer(callbacks = {}) {\n    const textEncoder = new TextEncoder();\n    let aggregatedResponse = \"\";\n    return new TransformStream({\n        async start () {\n            if (callbacks.onStart) await callbacks.onStart();\n        },\n        async transform (message, controller) {\n            controller.enqueue(textEncoder.encode(message));\n            aggregatedResponse += message;\n            if (callbacks.onToken) await callbacks.onToken(message);\n            if (callbacks.onText && typeof message === \"string\") {\n                await callbacks.onText(message);\n            }\n        },\n        async flush () {\n            if (callbacks.onCompletion) {\n                await callbacks.onCompletion(aggregatedResponse);\n            }\n            if (callbacks.onFinal) {\n                await callbacks.onFinal(aggregatedResponse);\n            }\n        }\n    });\n}\n// streams/langchain-adapter.ts\nfunction toDataStreamInternal(stream, callbacks) {\n    return stream.pipeThrough(new TransformStream({\n        transform: async (value, controller)=>{\n            var _a17;\n            if (typeof value === \"string\") {\n                controller.enqueue(value);\n                return;\n            }\n            if (\"event\" in value) {\n                if (value.event === \"on_chat_model_stream\") {\n                    forwardAIMessageChunk((_a17 = value.data) == null ? void 0 : _a17.chunk, controller);\n                }\n                return;\n            }\n            forwardAIMessageChunk(value, controller);\n        }\n    })).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(new TextDecoderStream()).pipeThrough(new TransformStream({\n        transform: async (chunk, controller)=>{\n            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"text\", chunk));\n        }\n    }));\n}\nfunction toDataStream(stream, callbacks) {\n    return toDataStreamInternal(stream, callbacks).pipeThrough(new TextEncoderStream());\n}\nfunction toDataStreamResponse(stream, options) {\n    var _a17;\n    const dataStream = toDataStreamInternal(stream, options == null ? void 0 : options.callbacks).pipeThrough(new TextEncoderStream());\n    const data = options == null ? void 0 : options.data;\n    const init = options == null ? void 0 : options.init;\n    const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;\n    return new Response(responseStream, {\n        status: (_a17 = init == null ? void 0 : init.status) != null ? _a17 : 200,\n        statusText: init == null ? void 0 : init.statusText,\n        headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {\n            contentType: \"text/plain; charset=utf-8\",\n            dataStreamVersion: \"v1\"\n        })\n    });\n}\nfunction mergeIntoDataStream(stream, options) {\n    options.dataStream.merge(toDataStreamInternal(stream, options.callbacks));\n}\nfunction forwardAIMessageChunk(chunk, controller) {\n    if (typeof chunk.content === \"string\") {\n        controller.enqueue(chunk.content);\n    } else {\n        const content = chunk.content;\n        for (const item of content){\n            if (item.type === \"text\") {\n                controller.enqueue(item.text);\n            }\n        }\n    }\n}\n// streams/llamaindex-adapter.ts\nvar llamaindex_adapter_exports = {};\n__export(llamaindex_adapter_exports, {\n    mergeIntoDataStream: ()=>mergeIntoDataStream2,\n    toDataStream: ()=>toDataStream2,\n    toDataStreamResponse: ()=>toDataStreamResponse2\n});\n\n\nfunction toDataStreamInternal2(stream, callbacks) {\n    const trimStart = trimStartOfStream();\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertAsyncIteratorToReadableStream)(stream[Symbol.asyncIterator]()).pipeThrough(new TransformStream({\n        async transform (message, controller) {\n            controller.enqueue(trimStart(message.delta));\n        }\n    })).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(new TextDecoderStream()).pipeThrough(new TransformStream({\n        transform: async (chunk, controller)=>{\n            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"text\", chunk));\n        }\n    }));\n}\nfunction toDataStream2(stream, callbacks) {\n    return toDataStreamInternal2(stream, callbacks).pipeThrough(new TextEncoderStream());\n}\nfunction toDataStreamResponse2(stream, options = {}) {\n    var _a17;\n    const { init, data, callbacks } = options;\n    const dataStream = toDataStreamInternal2(stream, callbacks).pipeThrough(new TextEncoderStream());\n    const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;\n    return new Response(responseStream, {\n        status: (_a17 = init == null ? void 0 : init.status) != null ? _a17 : 200,\n        statusText: init == null ? void 0 : init.statusText,\n        headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {\n            contentType: \"text/plain; charset=utf-8\",\n            dataStreamVersion: \"v1\"\n        })\n    });\n}\nfunction mergeIntoDataStream2(stream, options) {\n    options.dataStream.merge(toDataStreamInternal2(stream, options.callbacks));\n}\nfunction trimStartOfStream() {\n    let isStreamStart = true;\n    return (text2)=>{\n        if (isStreamStart) {\n            text2 = text2.trimStart();\n            if (text2) isStreamStart = false;\n        }\n        return text2;\n    };\n}\n// streams/stream-data.ts\n\n// util/constants.ts\nvar HANGING_STREAM_WARNING_TIME_MS = 15 * 1e3;\n// streams/stream-data.ts\nvar StreamData = class {\n    constructor(){\n        this.encoder = new TextEncoder();\n        this.controller = null;\n        this.isClosed = false;\n        this.warningTimeout = null;\n        const self = this;\n        this.stream = new ReadableStream({\n            start: async (controller)=>{\n                self.controller = controller;\n                if (true) {\n                    self.warningTimeout = setTimeout(()=>{\n                        console.warn(\"The data stream is hanging. Did you forget to close it with `data.close()`?\");\n                    }, HANGING_STREAM_WARNING_TIME_MS);\n                }\n            },\n            pull: (controller)=>{},\n            cancel: (reason)=>{\n                this.isClosed = true;\n            }\n        });\n    }\n    async close() {\n        if (this.isClosed) {\n            throw new Error(\"Data Stream has already been closed.\");\n        }\n        if (!this.controller) {\n            throw new Error(\"Stream controller is not initialized.\");\n        }\n        this.controller.close();\n        this.isClosed = true;\n        if (this.warningTimeout) {\n            clearTimeout(this.warningTimeout);\n        }\n    }\n    append(value) {\n        if (this.isClosed) {\n            throw new Error(\"Data Stream has already been closed.\");\n        }\n        if (!this.controller) {\n            throw new Error(\"Stream controller is not initialized.\");\n        }\n        this.controller.enqueue(this.encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"data\", [\n            value\n        ])));\n    }\n    appendMessageAnnotation(value) {\n        if (this.isClosed) {\n            throw new Error(\"Data Stream has already been closed.\");\n        }\n        if (!this.controller) {\n            throw new Error(\"Stream controller is not initialized.\");\n        }\n        this.controller.enqueue(this.encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"message_annotations\", [\n            value\n        ])));\n    }\n};\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWkvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsWUFBWUMsT0FBT0MsY0FBYztBQUNyQyxJQUFJQyxXQUFXLENBQUNDLFFBQVFDO0lBQ3RCLElBQUssSUFBSUMsVUFBVUQsSUFDakJMLFVBQVVJLFFBQVFFLFFBQVE7UUFBRUMsS0FBS0YsR0FBRyxDQUFDQyxPQUFPO1FBQUVFLFlBQVk7SUFBSztBQUNuRTtBQUVBLGdCQUFnQjtBQUM0RjtBQVVsRjtBQUUxQix5Q0FBeUM7QUFDZTtBQUN4RCxTQUFTZSxpQkFBaUIsRUFDeEJDLE9BQU8sRUFDUEMsVUFBVSxJQUFNLG9CQUFvQixFQUVyQztJQUNDLElBQUlDO0lBQ0osTUFBTUMsd0JBQXdCLEVBQUU7SUFDaEMsTUFBTUMsU0FBUyxJQUFJQyxlQUFlO1FBQ2hDQyxPQUFNQyxhQUFhO1lBQ2pCTCxhQUFhSztRQUNmO0lBQ0Y7SUFDQSxTQUFTQyxZQUFZQyxJQUFJO1FBQ3ZCLElBQUk7WUFDRlAsV0FBV1EsT0FBTyxDQUFDRDtRQUNyQixFQUFFLE9BQU9FLE9BQU8sQ0FDaEI7SUFDRjtJQUNBLElBQUk7UUFDRixNQUFNQyxTQUFTWixRQUFRO1lBQ3JCYSxPQUFNSixJQUFJO2dCQUNSRCxZQUFZQztZQUNkO1lBQ0FLLFdBQVVMLElBQUk7Z0JBQ1pELFlBQVlsQixzRUFBb0JBLENBQUMsUUFBUTtvQkFBQ21CO2lCQUFLO1lBQ2pEO1lBQ0FNLHdCQUF1QkMsVUFBVTtnQkFDL0JSLFlBQVlsQixzRUFBb0JBLENBQUMsdUJBQXVCO29CQUFDMEI7aUJBQVc7WUFDdEU7WUFDQUMsYUFBWUMsTUFBTTtnQkFDaEJWLFlBQVlsQixzRUFBb0JBLENBQUMsVUFBVTRCO1lBQzdDO1lBQ0FDLE9BQU1DLFNBQVM7Z0JBQ2JqQixz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QUFDTCxjQUFjO1FBQ2xDO0lBQ0Y7SUFDQU0sT0FBTzNuQyxLQUFLLEVBQUU7UUFDWixJQUFJLElBQUksQ0FBQ2loQixRQUFRLEVBQUU7WUFDakIsTUFBTSxJQUFJNWMsTUFBTTtRQUNsQjtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUM1RixVQUFVLEVBQUU7WUFDcEIsTUFBTSxJQUFJNEYsTUFBTTtRQUNsQjtRQUNBLElBQUksQ0FBQzVGLFVBQVUsQ0FBQ1EsT0FBTyxDQUNyQixJQUFJLENBQUNtb0MsT0FBTyxDQUFDOUIsTUFBTSxDQUFDMkIsc0VBQXFCQSxDQUFDLFFBQVE7WUFBQ2puQztTQUFNO0lBRTdEO0lBQ0E0bkMsd0JBQXdCNW5DLEtBQUssRUFBRTtRQUM3QixJQUFJLElBQUksQ0FBQ2loQixRQUFRLEVBQUU7WUFDakIsTUFBTSxJQUFJNWMsTUFBTTtRQUNsQjtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUM1RixVQUFVLEVBQUU7WUFDcEIsTUFBTSxJQUFJNEYsTUFBTTtRQUNsQjtRQUNBLElBQUksQ0FBQzVGLFVBQVUsQ0FBQ1EsT0FBTyxDQUNyQixJQUFJLENBQUNtb0MsT0FBTyxDQUFDOUIsTUFBTSxDQUFDMkIsc0VBQXFCQSxDQUFDLHVCQUF1QjtZQUFDam5DO1NBQU07SUFFNUU7QUFDRjtBQThFRSxDQUNGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9haS9kaXN0L2luZGV4Lm1qcz84MWViIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZTE3IGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lMTcsIHsgZ2V0OiBhbGxbbmFtZTE3XSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIGNvcmUvaW5kZXgudHNcbmltcG9ydCB7IGNyZWF0ZUlkR2VuZXJhdG9yIGFzIGNyZWF0ZUlkR2VuZXJhdG9yNSwgZ2VuZXJhdGVJZCBhcyBnZW5lcmF0ZUlkMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQge1xuICBmb3JtYXRBc3Npc3RhbnRTdHJlYW1QYXJ0LFxuICBmb3JtYXREYXRhU3RyZWFtUGFydCBhcyBmb3JtYXREYXRhU3RyZWFtUGFydDMsXG4gIGpzb25TY2hlbWEgYXMganNvblNjaGVtYTIsXG4gIHBhcnNlQXNzaXN0YW50U3RyZWFtUGFydCxcbiAgcGFyc2VEYXRhU3RyZWFtUGFydCxcbiAgcHJvY2Vzc0RhdGFTdHJlYW0sXG4gIHByb2Nlc3NUZXh0U3RyZWFtLFxuICB6b2RTY2hlbWFcbn0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcblxuLy8gY29yZS9kYXRhLXN0cmVhbS9jcmVhdGUtZGF0YS1zdHJlYW0udHNcbmltcG9ydCB7IGZvcm1hdERhdGFTdHJlYW1QYXJ0IH0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcbmZ1bmN0aW9uIGNyZWF0ZURhdGFTdHJlYW0oe1xuICBleGVjdXRlLFxuICBvbkVycm9yID0gKCkgPT4gXCJBbiBlcnJvciBvY2N1cnJlZC5cIlxuICAvLyBtYXNrIGVycm9yIG1lc3NhZ2VzIGZvciBzYWZldHkgYnkgZGVmYXVsdFxufSkge1xuICBsZXQgY29udHJvbGxlcjtcbiAgY29uc3Qgb25nb2luZ1N0cmVhbVByb21pc2VzID0gW107XG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlckFyZykge1xuICAgICAgY29udHJvbGxlciA9IGNvbnRyb2xsZXJBcmc7XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gc2FmZUVucXVldWUoZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBleGVjdXRlKHtcbiAgICAgIHdyaXRlKGRhdGEpIHtcbiAgICAgICAgc2FmZUVucXVldWUoZGF0YSk7XG4gICAgICB9LFxuICAgICAgd3JpdGVEYXRhKGRhdGEpIHtcbiAgICAgICAgc2FmZUVucXVldWUoZm9ybWF0RGF0YVN0cmVhbVBhcnQoXCJkYXRhXCIsIFtkYXRhXSkpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlTWVzc2FnZUFubm90YXRpb24oYW5ub3RhdGlvbikge1xuICAgICAgICBzYWZlRW5xdWV1ZShmb3JtYXREYXRhU3RyZWFtUGFydChcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiwgW2Fubm90YXRpb25dKSk7XG4gICAgICB9LFxuICAgICAgd3JpdGVTb3VyY2Uoc291cmNlKSB7XG4gICAgICAgIHNhZmVFbnF1ZXVlKGZvcm1hdERhdGFTdHJlYW1QYXJ0KFwic291cmNlXCIsIHNvdXJjZSkpO1xuICAgICAgfSxcbiAgICAgIG1lcmdlKHN0cmVhbUFyZykge1xuICAgICAgICBvbmdvaW5nU3RyZWFtUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtQXJnLmdldFJlYWRlcigpO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIHNhZmVFbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSgpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgc2FmZUVucXVldWUoZm9ybWF0RGF0YVN0cmVhbVBhcnQoXCJlcnJvclwiLCBvbkVycm9yKGVycm9yKSkpO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgb25FcnJvclxuICAgIH0pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIG9uZ29pbmdTdHJlYW1Qcm9taXNlcy5wdXNoKFxuICAgICAgICByZXN1bHQuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgc2FmZUVucXVldWUoZm9ybWF0RGF0YVN0cmVhbVBhcnQoXCJlcnJvclwiLCBvbkVycm9yKGVycm9yKSkpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgc2FmZUVucXVldWUoZm9ybWF0RGF0YVN0cmVhbVBhcnQoXCJlcnJvclwiLCBvbkVycm9yKGVycm9yKSkpO1xuICB9XG4gIGNvbnN0IHdhaXRGb3JTdHJlYW1zID0gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICB3aGlsZSAob25nb2luZ1N0cmVhbVByb21pc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIGF3YWl0IG9uZ29pbmdTdHJlYW1Qcm9taXNlcy5zaGlmdCgpO1xuICAgIH1cbiAgICByZXNvbHZlKCk7XG4gIH0pO1xuICB3YWl0Rm9yU3RyZWFtcy5maW5hbGx5KCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxuLy8gY29yZS91dGlsL3ByZXBhcmUtcmVzcG9uc2UtaGVhZGVycy50c1xuZnVuY3Rpb24gcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhoZWFkZXJzLCB7XG4gIGNvbnRlbnRUeXBlLFxuICBkYXRhU3RyZWFtVmVyc2lvblxufSkge1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBuZXcgSGVhZGVycyhoZWFkZXJzICE9IG51bGwgPyBoZWFkZXJzIDoge30pO1xuICBpZiAoIXJlc3BvbnNlSGVhZGVycy5oYXMoXCJDb250ZW50LVR5cGVcIikpIHtcbiAgICByZXNwb25zZUhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIGNvbnRlbnRUeXBlKTtcbiAgfVxuICBpZiAoZGF0YVN0cmVhbVZlcnNpb24gIT09IHZvaWQgMCkge1xuICAgIHJlc3BvbnNlSGVhZGVycy5zZXQoXCJYLVZlcmNlbC1BSS1EYXRhLVN0cmVhbVwiLCBkYXRhU3RyZWFtVmVyc2lvbik7XG4gIH1cbiAgcmV0dXJuIHJlc3BvbnNlSGVhZGVycztcbn1cblxuLy8gY29yZS9kYXRhLXN0cmVhbS9jcmVhdGUtZGF0YS1zdHJlYW0tcmVzcG9uc2UudHNcbmZ1bmN0aW9uIGNyZWF0ZURhdGFTdHJlYW1SZXNwb25zZSh7XG4gIHN0YXR1cyxcbiAgc3RhdHVzVGV4dCxcbiAgaGVhZGVycyxcbiAgZXhlY3V0ZSxcbiAgb25FcnJvclxufSkge1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKFxuICAgIGNyZWF0ZURhdGFTdHJlYW0oeyBleGVjdXRlLCBvbkVycm9yIH0pLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKSxcbiAgICB7XG4gICAgICBzdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhoZWFkZXJzLCB7XG4gICAgICAgIGNvbnRlbnRUeXBlOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgICAgZGF0YVN0cmVhbVZlcnNpb246IFwidjFcIlxuICAgICAgfSlcbiAgICB9XG4gICk7XG59XG5cbi8vIGNvcmUvdXRpbC9wcmVwYXJlLW91dGdvaW5nLWh0dHAtaGVhZGVycy50c1xuZnVuY3Rpb24gcHJlcGFyZU91dGdvaW5nSHR0cEhlYWRlcnMoaGVhZGVycywge1xuICBjb250ZW50VHlwZSxcbiAgZGF0YVN0cmVhbVZlcnNpb25cbn0pIHtcbiAgY29uc3Qgb3V0Z29pbmdIZWFkZXJzID0ge307XG4gIGlmIChoZWFkZXJzICE9IG51bGwpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhoZWFkZXJzKSkge1xuICAgICAgb3V0Z29pbmdIZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKG91dGdvaW5nSGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9PSBudWxsKSB7XG4gICAgb3V0Z29pbmdIZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gY29udGVudFR5cGU7XG4gIH1cbiAgaWYgKGRhdGFTdHJlYW1WZXJzaW9uICE9PSB2b2lkIDApIHtcbiAgICBvdXRnb2luZ0hlYWRlcnNbXCJYLVZlcmNlbC1BSS1EYXRhLVN0cmVhbVwiXSA9IGRhdGFTdHJlYW1WZXJzaW9uO1xuICB9XG4gIHJldHVybiBvdXRnb2luZ0hlYWRlcnM7XG59XG5cbi8vIGNvcmUvdXRpbC93cml0ZS10by1zZXJ2ZXItcmVzcG9uc2UudHNcbmZ1bmN0aW9uIHdyaXRlVG9TZXJ2ZXJSZXNwb25zZSh7XG4gIHJlc3BvbnNlLFxuICBzdGF0dXMsXG4gIHN0YXR1c1RleHQsXG4gIGhlYWRlcnMsXG4gIHN0cmVhbVxufSkge1xuICByZXNwb25zZS53cml0ZUhlYWQoc3RhdHVzICE9IG51bGwgPyBzdGF0dXMgOiAyMDAsIHN0YXR1c1RleHQsIGhlYWRlcnMpO1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIGNvbnN0IHJlYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICByZXNwb25zZS53cml0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZmluYWxseSB7XG4gICAgICByZXNwb25zZS5lbmQoKTtcbiAgICB9XG4gIH07XG4gIHJlYWQoKTtcbn1cblxuLy8gY29yZS9kYXRhLXN0cmVhbS9waXBlLWRhdGEtc3RyZWFtLXRvLXJlc3BvbnNlLnRzXG5mdW5jdGlvbiBwaXBlRGF0YVN0cmVhbVRvUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgc3RhdHVzLFxuICBzdGF0dXNUZXh0LFxuICBoZWFkZXJzLFxuICBleGVjdXRlLFxuICBvbkVycm9yXG59KSB7XG4gIHdyaXRlVG9TZXJ2ZXJSZXNwb25zZSh7XG4gICAgcmVzcG9uc2UsXG4gICAgc3RhdHVzLFxuICAgIHN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogcHJlcGFyZU91dGdvaW5nSHR0cEhlYWRlcnMoaGVhZGVycywge1xuICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgZGF0YVN0cmVhbVZlcnNpb246IFwidjFcIlxuICAgIH0pLFxuICAgIHN0cmVhbTogY3JlYXRlRGF0YVN0cmVhbSh7IGV4ZWN1dGUsIG9uRXJyb3IgfSkucGlwZVRocm91Z2goXG4gICAgICBuZXcgVGV4dEVuY29kZXJTdHJlYW0oKVxuICAgIClcbiAgfSk7XG59XG5cbi8vIGVycm9ycy9pbnZhbGlkLWFyZ3VtZW50LWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lID0gXCJBSV9JbnZhbGlkQXJndW1lbnRFcnJvclwiO1xudmFyIG1hcmtlciA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lfWA7XG52YXIgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xudmFyIF9hO1xudmFyIEludmFsaWRBcmd1bWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHBhcmFtZXRlcixcbiAgICB2YWx1ZSxcbiAgICBtZXNzYWdlXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lLFxuICAgICAgbWVzc2FnZTogYEludmFsaWQgYXJndW1lbnQgZm9yIHBhcmFtZXRlciAke3BhcmFtZXRlcn06ICR7bWVzc2FnZX1gXG4gICAgfSk7XG4gICAgdGhpc1tfYV0gPSB0cnVlO1xuICAgIHRoaXMucGFyYW1ldGVyID0gcGFyYW1ldGVyO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyKTtcbiAgfVxufTtcbl9hID0gc3ltYm9sO1xuXG4vLyB1dGlsL3JldHJ5LXdpdGgtZXhwb25lbnRpYWwtYmFja29mZi50c1xuaW1wb3J0IHsgQVBJQ2FsbEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IGRlbGF5LCBnZXRFcnJvck1lc3NhZ2UsIGlzQWJvcnRFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHV0aWwvcmV0cnktZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUyID0gXCJBSV9SZXRyeUVycm9yXCI7XG52YXIgbWFya2VyMiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMn1gO1xudmFyIHN5bWJvbDIgPSBTeW1ib2wuZm9yKG1hcmtlcjIpO1xudmFyIF9hMjtcbnZhciBSZXRyeUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMiB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlLFxuICAgIHJlYXNvbixcbiAgICBlcnJvcnNcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTIsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTJdID0gdHJ1ZTtcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB0aGlzLmxhc3RFcnJvciA9IGVycm9yc1tlcnJvcnMubGVuZ3RoIC0gMV07XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjIuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIyKTtcbiAgfVxufTtcbl9hMiA9IHN5bWJvbDI7XG5cbi8vIHV0aWwvcmV0cnktd2l0aC1leHBvbmVudGlhbC1iYWNrb2ZmLnRzXG52YXIgcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmID0gKHtcbiAgbWF4UmV0cmllcyA9IDIsXG4gIGluaXRpYWxEZWxheUluTXMgPSAyZTMsXG4gIGJhY2tvZmZGYWN0b3IgPSAyXG59ID0ge30pID0+IGFzeW5jIChmKSA9PiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKGYsIHtcbiAgbWF4UmV0cmllcyxcbiAgZGVsYXlJbk1zOiBpbml0aWFsRGVsYXlJbk1zLFxuICBiYWNrb2ZmRmFjdG9yXG59KTtcbmFzeW5jIGZ1bmN0aW9uIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoZiwge1xuICBtYXhSZXRyaWVzLFxuICBkZWxheUluTXMsXG4gIGJhY2tvZmZGYWN0b3Jcbn0sIGVycm9ycyA9IFtdKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGYoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChtYXhSZXRyaWVzID09PSAwKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKTtcbiAgICBjb25zdCBuZXdFcnJvcnMgPSBbLi4uZXJyb3JzLCBlcnJvcl07XG4gICAgY29uc3QgdHJ5TnVtYmVyID0gbmV3RXJyb3JzLmxlbmd0aDtcbiAgICBpZiAodHJ5TnVtYmVyID4gbWF4UmV0cmllcykge1xuICAgICAgdGhyb3cgbmV3IFJldHJ5RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBgRmFpbGVkIGFmdGVyICR7dHJ5TnVtYmVyfSBhdHRlbXB0cy4gTGFzdCBlcnJvcjogJHtlcnJvck1lc3NhZ2V9YCxcbiAgICAgICAgcmVhc29uOiBcIm1heFJldHJpZXNFeGNlZWRlZFwiLFxuICAgICAgICBlcnJvcnM6IG5ld0Vycm9yc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIEFQSUNhbGxFcnJvci5pc0luc3RhbmNlKGVycm9yKSAmJiBlcnJvci5pc1JldHJ5YWJsZSA9PT0gdHJ1ZSAmJiB0cnlOdW1iZXIgPD0gbWF4UmV0cmllcykge1xuICAgICAgYXdhaXQgZGVsYXkoZGVsYXlJbk1zKTtcbiAgICAgIHJldHVybiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKFxuICAgICAgICBmLFxuICAgICAgICB7IG1heFJldHJpZXMsIGRlbGF5SW5NczogYmFja29mZkZhY3RvciAqIGRlbGF5SW5NcywgYmFja29mZkZhY3RvciB9LFxuICAgICAgICBuZXdFcnJvcnNcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0cnlOdW1iZXIgPT09IDEpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUmV0cnlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgRmFpbGVkIGFmdGVyICR7dHJ5TnVtYmVyfSBhdHRlbXB0cyB3aXRoIG5vbi1yZXRyeWFibGUgZXJyb3I6ICcke2Vycm9yTWVzc2FnZX0nYCxcbiAgICAgIHJlYXNvbjogXCJlcnJvck5vdFJldHJ5YWJsZVwiLFxuICAgICAgZXJyb3JzOiBuZXdFcnJvcnNcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBjb3JlL3Byb21wdC9wcmVwYXJlLXJldHJpZXMudHNcbmZ1bmN0aW9uIHByZXBhcmVSZXRyaWVzKHtcbiAgbWF4UmV0cmllc1xufSkge1xuICBpZiAobWF4UmV0cmllcyAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJldHJpZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4UmV0cmllc1wiLFxuICAgICAgICB2YWx1ZTogbWF4UmV0cmllcyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhSZXRyaWVzIG11c3QgYmUgYW4gaW50ZWdlclwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG1heFJldHJpZXMgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4UmV0cmllc1wiLFxuICAgICAgICB2YWx1ZTogbWF4UmV0cmllcyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhSZXRyaWVzIG11c3QgYmUgPj0gMFwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgbWF4UmV0cmllc1Jlc3VsdCA9IG1heFJldHJpZXMgIT0gbnVsbCA/IG1heFJldHJpZXMgOiAyO1xuICByZXR1cm4ge1xuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNSZXN1bHQsXG4gICAgcmV0cnk6IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZih7IG1heFJldHJpZXM6IG1heFJldHJpZXNSZXN1bHQgfSlcbiAgfTtcbn1cblxuLy8gY29yZS90ZWxlbWV0cnkvYXNzZW1ibGUtb3BlcmF0aW9uLW5hbWUudHNcbmZ1bmN0aW9uIGFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gIG9wZXJhdGlvbklkLFxuICB0ZWxlbWV0cnlcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICAvLyBzdGFuZGFyZGl6ZWQgb3BlcmF0aW9uIGFuZCByZXNvdXJjZSBuYW1lOlxuICAgIFwib3BlcmF0aW9uLm5hbWVcIjogYCR7b3BlcmF0aW9uSWR9JHsodGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuZnVuY3Rpb25JZCkgIT0gbnVsbCA/IGAgJHt0ZWxlbWV0cnkuZnVuY3Rpb25JZH1gIDogXCJcIn1gLFxuICAgIFwicmVzb3VyY2UubmFtZVwiOiB0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5mdW5jdGlvbklkLFxuICAgIC8vIGRldGFpbGVkLCBBSSBTREsgc3BlY2lmaWMgZGF0YTpcbiAgICBcImFpLm9wZXJhdGlvbklkXCI6IG9wZXJhdGlvbklkLFxuICAgIFwiYWkudGVsZW1ldHJ5LmZ1bmN0aW9uSWRcIjogdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuZnVuY3Rpb25JZFxuICB9O1xufVxuXG4vLyBjb3JlL3RlbGVtZXRyeS9nZXQtYmFzZS10ZWxlbWV0cnktYXR0cmlidXRlcy50c1xuZnVuY3Rpb24gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICBtb2RlbCxcbiAgc2V0dGluZ3MsXG4gIHRlbGVtZXRyeSxcbiAgaGVhZGVyc1xufSkge1xuICB2YXIgX2ExNztcbiAgcmV0dXJuIHtcbiAgICBcImFpLm1vZGVsLnByb3ZpZGVyXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgIFwiYWkubW9kZWwuaWRcIjogbW9kZWwubW9kZWxJZCxcbiAgICAvLyBzZXR0aW5nczpcbiAgICAuLi5PYmplY3QuZW50cmllcyhzZXR0aW5ncykucmVkdWNlKChhdHRyaWJ1dGVzLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGF0dHJpYnV0ZXNbYGFpLnNldHRpbmdzLiR7a2V5fWBdID0gdmFsdWU7XG4gICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICB9LCB7fSksXG4gICAgLy8gYWRkIG1ldGFkYXRhIGFzIGF0dHJpYnV0ZXM6XG4gICAgLi4uT2JqZWN0LmVudHJpZXMoKF9hMTcgPSB0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5tZXRhZGF0YSkgIT0gbnVsbCA/IF9hMTcgOiB7fSkucmVkdWNlKFxuICAgICAgKGF0dHJpYnV0ZXMsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBhdHRyaWJ1dGVzW2BhaS50ZWxlbWV0cnkubWV0YWRhdGEuJHtrZXl9YF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgICB9LFxuICAgICAge31cbiAgICApLFxuICAgIC8vIHJlcXVlc3QgaGVhZGVyc1xuICAgIC4uLk9iamVjdC5lbnRyaWVzKGhlYWRlcnMgIT0gbnVsbCA/IGhlYWRlcnMgOiB7fSkucmVkdWNlKChhdHRyaWJ1dGVzLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbYGFpLnJlcXVlc3QuaGVhZGVycy4ke2tleX1gXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgfSwge30pXG4gIH07XG59XG5cbi8vIGNvcmUvdGVsZW1ldHJ5L2dldC10cmFjZXIudHNcbmltcG9ydCB7IHRyYWNlIH0gZnJvbSBcIkBvcGVudGVsZW1ldHJ5L2FwaVwiO1xuXG4vLyBjb3JlL3RlbGVtZXRyeS9ub29wLXRyYWNlci50c1xudmFyIG5vb3BUcmFjZXIgPSB7XG4gIHN0YXJ0U3BhbigpIHtcbiAgICByZXR1cm4gbm9vcFNwYW47XG4gIH0sXG4gIHN0YXJ0QWN0aXZlU3BhbihuYW1lMTcsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBpZiAodHlwZW9mIGFyZzEgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFyZzEobm9vcFNwYW4pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZzIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFyZzIobm9vcFNwYW4pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZzMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFyZzMobm9vcFNwYW4pO1xuICAgIH1cbiAgfVxufTtcbnZhciBub29wU3BhbiA9IHtcbiAgc3BhbkNvbnRleHQoKSB7XG4gICAgcmV0dXJuIG5vb3BTcGFuQ29udGV4dDtcbiAgfSxcbiAgc2V0QXR0cmlidXRlKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzZXRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRFdmVudCgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkTGluaygpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkTGlua3MoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNldFN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgdXBkYXRlTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW5kKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBpc1JlY29yZGluZygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIHJlY29yZEV4Y2VwdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbnZhciBub29wU3BhbkNvbnRleHQgPSB7XG4gIHRyYWNlSWQ6IFwiXCIsXG4gIHNwYW5JZDogXCJcIixcbiAgdHJhY2VGbGFnczogMFxufTtcblxuLy8gY29yZS90ZWxlbWV0cnkvZ2V0LXRyYWNlci50c1xuZnVuY3Rpb24gZ2V0VHJhY2VyKHtcbiAgaXNFbmFibGVkID0gZmFsc2UsXG4gIHRyYWNlclxufSA9IHt9KSB7XG4gIGlmICghaXNFbmFibGVkKSB7XG4gICAgcmV0dXJuIG5vb3BUcmFjZXI7XG4gIH1cbiAgaWYgKHRyYWNlcikge1xuICAgIHJldHVybiB0cmFjZXI7XG4gIH1cbiAgcmV0dXJuIHRyYWNlLmdldFRyYWNlcihcImFpXCIpO1xufVxuXG4vLyBjb3JlL3RlbGVtZXRyeS9yZWNvcmQtc3Bhbi50c1xuaW1wb3J0IHsgU3BhblN0YXR1c0NvZGUgfSBmcm9tIFwiQG9wZW50ZWxlbWV0cnkvYXBpXCI7XG5mdW5jdGlvbiByZWNvcmRTcGFuKHtcbiAgbmFtZTogbmFtZTE3LFxuICB0cmFjZXIsXG4gIGF0dHJpYnV0ZXMsXG4gIGZuLFxuICBlbmRXaGVuRG9uZSA9IHRydWVcbn0pIHtcbiAgcmV0dXJuIHRyYWNlci5zdGFydEFjdGl2ZVNwYW4obmFtZTE3LCB7IGF0dHJpYnV0ZXMgfSwgYXN5bmMgKHNwYW4pID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZm4oc3Bhbik7XG4gICAgICBpZiAoZW5kV2hlbkRvbmUpIHtcbiAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgc3Bhbi5yZWNvcmRFeGNlcHRpb24oe1xuICAgICAgICAgICAgbmFtZTogZXJyb3IubmFtZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBzdGFjazogZXJyb3Iuc3RhY2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzcGFuLnNldFN0YXR1cyh7XG4gICAgICAgICAgICBjb2RlOiBTcGFuU3RhdHVzQ29kZS5FUlJPUixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcGFuLnNldFN0YXR1cyh7IGNvZGU6IFNwYW5TdGF0dXNDb2RlLkVSUk9SIH0pO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gY29yZS90ZWxlbWV0cnkvc2VsZWN0LXRlbGVtZXRyeS1hdHRyaWJ1dGVzLnRzXG5mdW5jdGlvbiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgdGVsZW1ldHJ5LFxuICBhdHRyaWJ1dGVzXG59KSB7XG4gIGlmICgodGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuaXNFbmFibGVkKSAhPT0gdHJ1ZSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykucmVkdWNlKChhdHRyaWJ1dGVzMiwgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzMjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBcImlucHV0XCIgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLmlucHV0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmICgodGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkucmVjb3JkSW5wdXRzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXMyO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUuaW5wdXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHZvaWQgMCA/IGF0dHJpYnV0ZXMyIDogeyAuLi5hdHRyaWJ1dGVzMiwgW2tleV06IHJlc3VsdCB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIFwib3V0cHV0XCIgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLm91dHB1dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBpZiAoKHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LnJlY29yZE91dHB1dHMpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlczI7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5vdXRwdXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHZvaWQgMCA/IGF0dHJpYnV0ZXMyIDogeyAuLi5hdHRyaWJ1dGVzMiwgW2tleV06IHJlc3VsdCB9O1xuICAgIH1cbiAgICByZXR1cm4geyAuLi5hdHRyaWJ1dGVzMiwgW2tleV06IHZhbHVlIH07XG4gIH0sIHt9KTtcbn1cblxuLy8gY29yZS9lbWJlZC9lbWJlZC50c1xuYXN5bmMgZnVuY3Rpb24gZW1iZWQoe1xuICBtb2RlbCxcbiAgdmFsdWUsXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzLFxuICBleHBlcmltZW50YWxfdGVsZW1ldHJ5OiB0ZWxlbWV0cnlcbn0pIHtcbiAgY29uc3QgeyBtYXhSZXRyaWVzLCByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoeyBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnIH0pO1xuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5nczogeyBtYXhSZXRyaWVzIH1cbiAgfSk7XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5lbWJlZFwiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoeyBvcGVyYXRpb25JZDogXCJhaS5lbWJlZFwiLCB0ZWxlbWV0cnkgfSksXG4gICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICBcImFpLnZhbHVlXCI6IHsgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSB9XG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgY29uc3QgeyBlbWJlZGRpbmcsIHVzYWdlLCByYXdSZXNwb25zZSB9ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICgpID0+IChcbiAgICAgICAgICAvLyBuZXN0ZWQgc3BhbnMgdG8gYWxpZ24gd2l0aCB0aGUgZW1iZWRNYW55IHRlbGVtZXRyeSBkYXRhOlxuICAgICAgICAgIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5lbWJlZC5kb0VtYmVkXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmVtYmVkLmRvRW1iZWRcIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICAgICAgICBcImFpLnZhbHVlc1wiOiB7IGlucHV0OiAoKSA9PiBbSlNPTi5zdHJpbmdpZnkodmFsdWUpXSB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZm46IGFzeW5jIChkb0VtYmVkU3BhbikgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2ExNztcbiAgICAgICAgICAgICAgY29uc3QgbW9kZWxSZXNwb25zZSA9IGF3YWl0IG1vZGVsLmRvRW1iZWQoe1xuICAgICAgICAgICAgICAgIHZhbHVlczogW3ZhbHVlXSxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCBlbWJlZGRpbmcyID0gbW9kZWxSZXNwb25zZS5lbWJlZGRpbmdzWzBdO1xuICAgICAgICAgICAgICBjb25zdCB1c2FnZTIgPSAoX2ExNyA9IG1vZGVsUmVzcG9uc2UudXNhZ2UpICE9IG51bGwgPyBfYTE3IDogeyB0b2tlbnM6IE5hTiB9O1xuICAgICAgICAgICAgICBkb0VtYmVkU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gbW9kZWxSZXNwb25zZS5lbWJlZGRpbmdzLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgIChlbWJlZGRpbmczKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmczKVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UyLnRva2Vuc1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZW1iZWRkaW5nOiBlbWJlZGRpbmcyLFxuICAgICAgICAgICAgICAgIHVzYWdlOiB1c2FnZTIsXG4gICAgICAgICAgICAgICAgcmF3UmVzcG9uc2U6IG1vZGVsUmVzcG9uc2UucmF3UmVzcG9uc2VcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdcIjogeyBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZykgfSxcbiAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHVzYWdlLnRva2Vuc1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRFbWJlZFJlc3VsdCh7IHZhbHVlLCBlbWJlZGRpbmcsIHVzYWdlLCByYXdSZXNwb25zZSB9KTtcbiAgICB9XG4gIH0pO1xufVxudmFyIERlZmF1bHRFbWJlZFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMudmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHRoaXMuZW1iZWRkaW5nID0gb3B0aW9ucy5lbWJlZGRpbmc7XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gICAgdGhpcy5yYXdSZXNwb25zZSA9IG9wdGlvbnMucmF3UmVzcG9uc2U7XG4gIH1cbn07XG5cbi8vIGNvcmUvdXRpbC9zcGxpdC1hcnJheS50c1xuZnVuY3Rpb24gc3BsaXRBcnJheShhcnJheSwgY2h1bmtTaXplKSB7XG4gIGlmIChjaHVua1NpemUgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNodW5rU2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSBjaHVua1NpemUpIHtcbiAgICByZXN1bHQucHVzaChhcnJheS5zbGljZShpLCBpICsgY2h1bmtTaXplKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gY29yZS9lbWJlZC9lbWJlZC1tYW55LnRzXG5hc3luYyBmdW5jdGlvbiBlbWJlZE1hbnkoe1xuICBtb2RlbCxcbiAgdmFsdWVzLFxuICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5XG59KSB7XG4gIGNvbnN0IHsgbWF4UmV0cmllcywgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHsgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyB9KTtcbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3M6IHsgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgIG5hbWU6IFwiYWkuZW1iZWRNYW55XCIsXG4gICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7IG9wZXJhdGlvbklkOiBcImFpLmVtYmVkTWFueVwiLCB0ZWxlbWV0cnkgfSksXG4gICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgIFwiYWkudmFsdWVzXCI6IHtcbiAgICAgICAgICBpbnB1dDogKCkgPT4gdmFsdWVzLm1hcCgodmFsdWUpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLFxuICAgIHRyYWNlcixcbiAgICBmbjogYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgIGNvbnN0IG1heEVtYmVkZGluZ3NQZXJDYWxsID0gbW9kZWwubWF4RW1iZWRkaW5nc1BlckNhbGw7XG4gICAgICBpZiAobWF4RW1iZWRkaW5nc1BlckNhbGwgPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB7IGVtYmVkZGluZ3M6IGVtYmVkZGluZ3MyLCB1c2FnZSB9ID0gYXdhaXQgcmV0cnkoKCkgPT4ge1xuICAgICAgICAgIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWkuZW1iZWRNYW55LmRvRW1iZWRcIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZW1iZWRNYW55LmRvRW1iZWRcIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICAgICAgICBcImFpLnZhbHVlc1wiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gdmFsdWVzLm1hcCgodmFsdWUpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZm46IGFzeW5jIChkb0VtYmVkU3BhbikgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2ExNztcbiAgICAgICAgICAgICAgY29uc3QgbW9kZWxSZXNwb25zZSA9IGF3YWl0IG1vZGVsLmRvRW1iZWQoe1xuICAgICAgICAgICAgICAgIHZhbHVlcyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCBlbWJlZGRpbmdzMyA9IG1vZGVsUmVzcG9uc2UuZW1iZWRkaW5ncztcbiAgICAgICAgICAgICAgY29uc3QgdXNhZ2UyID0gKF9hMTcgPSBtb2RlbFJlc3BvbnNlLnVzYWdlKSAhPSBudWxsID8gX2ExNyA6IHsgdG9rZW5zOiBOYU4gfTtcbiAgICAgICAgICAgICAgZG9FbWJlZFNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGVtYmVkZGluZ3MzLm1hcCgoZW1iZWRkaW5nKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZTIudG9rZW5zXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgZW1iZWRkaW5nczogZW1iZWRkaW5nczMsIHVzYWdlOiB1c2FnZTIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGVtYmVkZGluZ3MyLm1hcCgoZW1iZWRkaW5nKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpKVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZS50b2tlbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbmV3IERlZmF1bHRFbWJlZE1hbnlSZXN1bHQoeyB2YWx1ZXMsIGVtYmVkZGluZ3M6IGVtYmVkZGluZ3MyLCB1c2FnZSB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlQ2h1bmtzID0gc3BsaXRBcnJheSh2YWx1ZXMsIG1heEVtYmVkZGluZ3NQZXJDYWxsKTtcbiAgICAgIGNvbnN0IGVtYmVkZGluZ3MgPSBbXTtcbiAgICAgIGxldCB0b2tlbnMgPSAwO1xuICAgICAgZm9yIChjb25zdCBjaHVuayBvZiB2YWx1ZUNodW5rcykge1xuICAgICAgICBjb25zdCB7IGVtYmVkZGluZ3M6IHJlc3BvbnNlRW1iZWRkaW5ncywgdXNhZ2UgfSA9IGF3YWl0IHJldHJ5KCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICBuYW1lOiBcImFpLmVtYmVkTWFueS5kb0VtYmVkXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmVtYmVkTWFueS5kb0VtYmVkXCIsXG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgICAgICAgXCJhaS52YWx1ZXNcIjoge1xuICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IGNodW5rLm1hcCgodmFsdWUpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZm46IGFzeW5jIChkb0VtYmVkU3BhbikgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2ExNztcbiAgICAgICAgICAgICAgY29uc3QgbW9kZWxSZXNwb25zZSA9IGF3YWl0IG1vZGVsLmRvRW1iZWQoe1xuICAgICAgICAgICAgICAgIHZhbHVlczogY2h1bmssXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgZW1iZWRkaW5nczIgPSBtb2RlbFJlc3BvbnNlLmVtYmVkZGluZ3M7XG4gICAgICAgICAgICAgIGNvbnN0IHVzYWdlMiA9IChfYTE3ID0gbW9kZWxSZXNwb25zZS51c2FnZSkgIT0gbnVsbCA/IF9hMTcgOiB7IHRva2VuczogTmFOIH07XG4gICAgICAgICAgICAgIGRvRW1iZWRTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBlbWJlZGRpbmdzMi5tYXAoKGVtYmVkZGluZykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UyLnRva2Vuc1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB7IGVtYmVkZGluZ3M6IGVtYmVkZGluZ3MyLCB1c2FnZTogdXNhZ2UyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbWJlZGRpbmdzLnB1c2goLi4ucmVzcG9uc2VFbWJlZGRpbmdzKTtcbiAgICAgICAgdG9rZW5zICs9IHVzYWdlLnRva2VucztcbiAgICAgIH1cbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZW1iZWRkaW5ncy5tYXAoKGVtYmVkZGluZykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB0b2tlbnNcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0RW1iZWRNYW55UmVzdWx0KHtcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICBlbWJlZGRpbmdzLFxuICAgICAgICB1c2FnZTogeyB0b2tlbnMgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0RW1iZWRNYW55UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy52YWx1ZXMgPSBvcHRpb25zLnZhbHVlcztcbiAgICB0aGlzLmVtYmVkZGluZ3MgPSBvcHRpb25zLmVtYmVkZGluZ3M7XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gIH1cbn07XG5cbi8vIGVycm9ycy9uby1pbWFnZS1nZW5lcmF0ZWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUzID0gXCJBSV9Ob0ltYWdlR2VuZXJhdGVkRXJyb3JcIjtcbnZhciBtYXJrZXIzID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUzfWA7XG52YXIgc3ltYm9sMyA9IFN5bWJvbC5mb3IobWFya2VyMyk7XG52YXIgX2EzO1xudmFyIE5vSW1hZ2VHZW5lcmF0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjMge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSA9IFwiTm8gaW1hZ2UgZ2VuZXJhdGVkLlwiLFxuICAgIGNhdXNlLFxuICAgIHJlc3BvbnNlc1xuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMywgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTNdID0gdHJ1ZTtcbiAgICB0aGlzLnJlc3BvbnNlcyA9IHJlc3BvbnNlcztcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMy5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjMpO1xuICB9XG59O1xuX2EzID0gc3ltYm9sMztcblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L2dlbmVyYXRlZC1maWxlLnRzXG5pbXBvcnQge1xuICBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5LFxuICBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG52YXIgRGVmYXVsdEdlbmVyYXRlZEZpbGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkYXRhLFxuICAgIG1pbWVUeXBlXG4gIH0pIHtcbiAgICBjb25zdCBpc1VpbnQ4QXJyYXkgPSBkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbiAgICB0aGlzLmJhc2U2NERhdGEgPSBpc1VpbnQ4QXJyYXkgPyB2b2lkIDAgOiBkYXRhO1xuICAgIHRoaXMudWludDhBcnJheURhdGEgPSBpc1VpbnQ4QXJyYXkgPyBkYXRhIDogdm9pZCAwO1xuICAgIHRoaXMubWltZVR5cGUgPSBtaW1lVHlwZTtcbiAgfVxuICAvLyBsYXp5IGNvbnZlcnNpb24gd2l0aCBjYWNoaW5nIHRvIGF2b2lkIHVubmVjZXNzYXJ5IGNvbnZlcnNpb24gb3ZlcmhlYWQ6XG4gIGdldCBiYXNlNjQoKSB7XG4gICAgaWYgKHRoaXMuYmFzZTY0RGF0YSA9PSBudWxsKSB7XG4gICAgICB0aGlzLmJhc2U2NERhdGEgPSBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0KHRoaXMudWludDhBcnJheURhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5iYXNlNjREYXRhO1xuICB9XG4gIC8vIGxhenkgY29udmVyc2lvbiB3aXRoIGNhY2hpbmcgdG8gYXZvaWQgdW5uZWNlc3NhcnkgY29udmVyc2lvbiBvdmVyaGVhZDpcbiAgZ2V0IHVpbnQ4QXJyYXkoKSB7XG4gICAgaWYgKHRoaXMudWludDhBcnJheURhdGEgPT0gbnVsbCkge1xuICAgICAgdGhpcy51aW50OEFycmF5RGF0YSA9IGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkodGhpcy5iYXNlNjREYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudWludDhBcnJheURhdGE7XG4gIH1cbn07XG52YXIgRGVmYXVsdEdlbmVyYXRlZEZpbGVXaXRoVHlwZSA9IGNsYXNzIGV4dGVuZHMgRGVmYXVsdEdlbmVyYXRlZEZpbGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgdGhpcy50eXBlID0gXCJmaWxlXCI7XG4gIH1cbn07XG5cbi8vIGNvcmUvdXRpbC9kZXRlY3QtbWltZXR5cGUudHNcbmltcG9ydCB7IGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkgYXMgY29udmVydEJhc2U2NFRvVWludDhBcnJheTIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xudmFyIGltYWdlTWltZVR5cGVTaWduYXR1cmVzID0gW1xuICB7XG4gICAgbWltZVR5cGU6IFwiaW1hZ2UvZ2lmXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFs3MSwgNzMsIDcwXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiUjBsR1wiXG4gIH0sXG4gIHtcbiAgICBtaW1lVHlwZTogXCJpbWFnZS9wbmdcIixcbiAgICBieXRlc1ByZWZpeDogWzEzNywgODAsIDc4LCA3MV0sXG4gICAgYmFzZTY0UHJlZml4OiBcImlWQk9Sd1wiXG4gIH0sXG4gIHtcbiAgICBtaW1lVHlwZTogXCJpbWFnZS9qcGVnXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsyNTUsIDIxNl0sXG4gICAgYmFzZTY0UHJlZml4OiBcIi85ai9cIlxuICB9LFxuICB7XG4gICAgbWltZVR5cGU6IFwiaW1hZ2Uvd2VicFwiLFxuICAgIGJ5dGVzUHJlZml4OiBbODIsIDczLCA3MCwgNzBdLFxuICAgIGJhc2U2NFByZWZpeDogXCJVa2xHUmdcIlxuICB9LFxuICB7XG4gICAgbWltZVR5cGU6IFwiaW1hZ2UvYm1wXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFs2NiwgNzddLFxuICAgIGJhc2U2NFByZWZpeDogXCJRa1wiXG4gIH0sXG4gIHtcbiAgICBtaW1lVHlwZTogXCJpbWFnZS90aWZmXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFs3MywgNzMsIDQyLCAwXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiU1VrcUFBXCJcbiAgfSxcbiAge1xuICAgIG1pbWVUeXBlOiBcImltYWdlL3RpZmZcIixcbiAgICBieXRlc1ByZWZpeDogWzc3LCA3NywgMCwgNDJdLFxuICAgIGJhc2U2NFByZWZpeDogXCJUVTBBS2dcIlxuICB9LFxuICB7XG4gICAgbWltZVR5cGU6IFwiaW1hZ2UvYXZpZlwiLFxuICAgIGJ5dGVzUHJlZml4OiBbXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAzMixcbiAgICAgIDEwMixcbiAgICAgIDExNixcbiAgICAgIDEyMSxcbiAgICAgIDExMixcbiAgICAgIDk3LFxuICAgICAgMTE4LFxuICAgICAgMTA1LFxuICAgICAgMTAyXG4gICAgXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiQUFBQUlHWjBlWEJoZG1sbVwiXG4gIH0sXG4gIHtcbiAgICBtaW1lVHlwZTogXCJpbWFnZS9oZWljXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFtcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDMyLFxuICAgICAgMTAyLFxuICAgICAgMTE2LFxuICAgICAgMTIxLFxuICAgICAgMTEyLFxuICAgICAgMTA0LFxuICAgICAgMTAxLFxuICAgICAgMTA1LFxuICAgICAgOTlcbiAgICBdLFxuICAgIGJhc2U2NFByZWZpeDogXCJBQUFBSUdaMGVYQm9aV2xqXCJcbiAgfVxuXTtcbnZhciBhdWRpb01pbWVUeXBlU2lnbmF0dXJlcyA9IFtcbiAge1xuICAgIG1pbWVUeXBlOiBcImF1ZGlvL21wZWdcIixcbiAgICBieXRlc1ByZWZpeDogWzI1NSwgMjUxXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiLy9zPVwiXG4gIH0sXG4gIHtcbiAgICBtaW1lVHlwZTogXCJhdWRpby93YXZcIixcbiAgICBieXRlc1ByZWZpeDogWzgyLCA3MywgNzAsIDcwXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiVWtsR1JcIlxuICB9LFxuICB7XG4gICAgbWltZVR5cGU6IFwiYXVkaW8vb2dnXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFs3OSwgMTAzLCAxMDMsIDgzXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiVDJkblV3XCJcbiAgfSxcbiAge1xuICAgIG1pbWVUeXBlOiBcImF1ZGlvL2ZsYWNcIixcbiAgICBieXRlc1ByZWZpeDogWzEwMiwgNzYsIDk3LCA2N10sXG4gICAgYmFzZTY0UHJlZml4OiBcIlpreGhRd1wiXG4gIH0sXG4gIHtcbiAgICBtaW1lVHlwZTogXCJhdWRpby9hYWNcIixcbiAgICBieXRlc1ByZWZpeDogWzY0LCAyMSwgMCwgMF0sXG4gICAgYmFzZTY0UHJlZml4OiBcIlFCVUFcIlxuICB9LFxuICB7XG4gICAgbWltZVR5cGU6IFwiYXVkaW8vbXA0XCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsxMDIsIDExNiwgMTIxLCAxMTJdLFxuICAgIGJhc2U2NFByZWZpeDogXCJablI1Y0FcIlxuICB9XG5dO1xudmFyIHN0cmlwSUQzID0gKGRhdGEpID0+IHtcbiAgY29uc3QgYnl0ZXMgPSB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkyKGRhdGEpIDogZGF0YTtcbiAgY29uc3QgaWQzU2l6ZSA9IChieXRlc1s2XSAmIDEyNykgPDwgMjEgfCAoYnl0ZXNbN10gJiAxMjcpIDw8IDE0IHwgKGJ5dGVzWzhdICYgMTI3KSA8PCA3IHwgYnl0ZXNbOV0gJiAxMjc7XG4gIHJldHVybiBieXRlcy5zbGljZShpZDNTaXplICsgMTApO1xufTtcbmZ1bmN0aW9uIHN0cmlwSUQzVGFnc0lmUHJlc2VudChkYXRhKSB7XG4gIGNvbnN0IGhhc0lkMyA9IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICYmIGRhdGEuc3RhcnRzV2l0aChcIlNVUXpcIikgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgJiYgZGF0YS5sZW5ndGggPiAxMCAmJiBkYXRhWzBdID09PSA3MyAmJiAvLyAnSSdcbiAgZGF0YVsxXSA9PT0gNjggJiYgLy8gJ0QnXG4gIGRhdGFbMl0gPT09IDUxO1xuICByZXR1cm4gaGFzSWQzID8gc3RyaXBJRDMoZGF0YSkgOiBkYXRhO1xufVxuZnVuY3Rpb24gZGV0ZWN0TWltZVR5cGUoe1xuICBkYXRhLFxuICBzaWduYXR1cmVzXG59KSB7XG4gIGNvbnN0IHByb2Nlc3NlZERhdGEgPSBzdHJpcElEM1RhZ3NJZlByZXNlbnQoZGF0YSk7XG4gIGZvciAoY29uc3Qgc2lnbmF0dXJlIG9mIHNpZ25hdHVyZXMpIHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3NlZERhdGEgPT09IFwic3RyaW5nXCIgPyBwcm9jZXNzZWREYXRhLnN0YXJ0c1dpdGgoc2lnbmF0dXJlLmJhc2U2NFByZWZpeCkgOiBwcm9jZXNzZWREYXRhLmxlbmd0aCA+PSBzaWduYXR1cmUuYnl0ZXNQcmVmaXgubGVuZ3RoICYmIHNpZ25hdHVyZS5ieXRlc1ByZWZpeC5ldmVyeShcbiAgICAgIChieXRlLCBpbmRleCkgPT4gcHJvY2Vzc2VkRGF0YVtpbmRleF0gPT09IGJ5dGVcbiAgICApKSB7XG4gICAgICByZXR1cm4gc2lnbmF0dXJlLm1pbWVUeXBlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLWltYWdlL2dlbmVyYXRlLWltYWdlLnRzXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUltYWdlKHtcbiAgbW9kZWwsXG4gIHByb21wdCxcbiAgbiA9IDEsXG4gIHNpemUsXG4gIGFzcGVjdFJhdGlvLFxuICBzZWVkLFxuICBwcm92aWRlck9wdGlvbnMsXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzXG59KSB7XG4gIHZhciBfYTE3O1xuICBjb25zdCB7IHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7IG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcgfSk7XG4gIGNvbnN0IG1heEltYWdlc1BlckNhbGwgPSAoX2ExNyA9IG1vZGVsLm1heEltYWdlc1BlckNhbGwpICE9IG51bGwgPyBfYTE3IDogMTtcbiAgY29uc3QgY2FsbENvdW50ID0gTWF0aC5jZWlsKG4gLyBtYXhJbWFnZXNQZXJDYWxsKTtcbiAgY29uc3QgY2FsbEltYWdlQ291bnRzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogY2FsbENvdW50IH0sIChfLCBpKSA9PiB7XG4gICAgaWYgKGkgPCBjYWxsQ291bnQgLSAxKSB7XG4gICAgICByZXR1cm4gbWF4SW1hZ2VzUGVyQ2FsbDtcbiAgICB9XG4gICAgY29uc3QgcmVtYWluZGVyID0gbiAlIG1heEltYWdlc1BlckNhbGw7XG4gICAgcmV0dXJuIHJlbWFpbmRlciA9PT0gMCA/IG1heEltYWdlc1BlckNhbGwgOiByZW1haW5kZXI7XG4gIH0pO1xuICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgY2FsbEltYWdlQ291bnRzLm1hcChcbiAgICAgIGFzeW5jIChjYWxsSW1hZ2VDb3VudCkgPT4gcmV0cnkoXG4gICAgICAgICgpID0+IG1vZGVsLmRvR2VuZXJhdGUoe1xuICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICBuOiBjYWxsSW1hZ2VDb3VudCxcbiAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIHNpemUsXG4gICAgICAgICAgYXNwZWN0UmF0aW8sXG4gICAgICAgICAgc2VlZCxcbiAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyT3B0aW9ucyAhPSBudWxsID8gcHJvdmlkZXJPcHRpb25zIDoge31cbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApXG4gICk7XG4gIGNvbnN0IGltYWdlcyA9IFtdO1xuICBjb25zdCB3YXJuaW5ncyA9IFtdO1xuICBjb25zdCByZXNwb25zZXMgPSBbXTtcbiAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgIGltYWdlcy5wdXNoKFxuICAgICAgLi4ucmVzdWx0LmltYWdlcy5tYXAoXG4gICAgICAgIChpbWFnZSkgPT4ge1xuICAgICAgICAgIHZhciBfYTE4O1xuICAgICAgICAgIHJldHVybiBuZXcgRGVmYXVsdEdlbmVyYXRlZEZpbGUoe1xuICAgICAgICAgICAgZGF0YTogaW1hZ2UsXG4gICAgICAgICAgICBtaW1lVHlwZTogKF9hMTggPSBkZXRlY3RNaW1lVHlwZSh7XG4gICAgICAgICAgICAgIGRhdGE6IGltYWdlLFxuICAgICAgICAgICAgICBzaWduYXR1cmVzOiBpbWFnZU1pbWVUeXBlU2lnbmF0dXJlc1xuICAgICAgICAgICAgfSkpICE9IG51bGwgPyBfYTE4IDogXCJpbWFnZS9wbmdcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgICB3YXJuaW5ncy5wdXNoKC4uLnJlc3VsdC53YXJuaW5ncyk7XG4gICAgcmVzcG9uc2VzLnB1c2gocmVzdWx0LnJlc3BvbnNlKTtcbiAgfVxuICBpZiAoIWltYWdlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgTm9JbWFnZUdlbmVyYXRlZEVycm9yKHsgcmVzcG9uc2VzIH0pO1xuICB9XG4gIHJldHVybiBuZXcgRGVmYXVsdEdlbmVyYXRlSW1hZ2VSZXN1bHQoeyBpbWFnZXMsIHdhcm5pbmdzLCByZXNwb25zZXMgfSk7XG59XG52YXIgRGVmYXVsdEdlbmVyYXRlSW1hZ2VSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLmltYWdlcyA9IG9wdGlvbnMuaW1hZ2VzO1xuICAgIHRoaXMud2FybmluZ3MgPSBvcHRpb25zLndhcm5pbmdzO1xuICAgIHRoaXMucmVzcG9uc2VzID0gb3B0aW9ucy5yZXNwb25zZXM7XG4gIH1cbiAgZ2V0IGltYWdlKCkge1xuICAgIHJldHVybiB0aGlzLmltYWdlc1swXTtcbiAgfVxufTtcblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3QvZ2VuZXJhdGUtb2JqZWN0LnRzXG5pbXBvcnQge1xuICBKU09OUGFyc2VFcnJvcixcbiAgVHlwZVZhbGlkYXRpb25FcnJvciBhcyBUeXBlVmFsaWRhdGlvbkVycm9yMlxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHsgY3JlYXRlSWRHZW5lcmF0b3IsIHNhZmVQYXJzZUpTT04gfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBlcnJvcnMvbm8tb2JqZWN0LWdlbmVyYXRlZC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yNCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTQgPSBcIkFJX05vT2JqZWN0R2VuZXJhdGVkRXJyb3JcIjtcbnZhciBtYXJrZXI0ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU0fWA7XG52YXIgc3ltYm9sNCA9IFN5bWJvbC5mb3IobWFya2VyNCk7XG52YXIgX2E0O1xudmFyIE5vT2JqZWN0R2VuZXJhdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I0IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UgPSBcIk5vIG9iamVjdCBnZW5lcmF0ZWQuXCIsXG4gICAgY2F1c2UsXG4gICAgdGV4dDogdGV4dDIsXG4gICAgcmVzcG9uc2UsXG4gICAgdXNhZ2UsXG4gICAgZmluaXNoUmVhc29uXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU0LCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hNF0gPSB0cnVlO1xuICAgIHRoaXMudGV4dCA9IHRleHQyO1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB0aGlzLnVzYWdlID0gdXNhZ2U7XG4gICAgdGhpcy5maW5pc2hSZWFzb24gPSBmaW5pc2hSZWFzb247XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjQuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI0KTtcbiAgfVxufTtcbl9hNCA9IHN5bWJvbDQ7XG5cbi8vIHV0aWwvZG93bmxvYWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjUgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU1ID0gXCJBSV9Eb3dubG9hZEVycm9yXCI7XG52YXIgbWFya2VyNSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNX1gO1xudmFyIHN5bWJvbDUgPSBTeW1ib2wuZm9yKG1hcmtlcjUpO1xudmFyIF9hNTtcbnZhciBEb3dubG9hZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yNSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1cmwsXG4gICAgc3RhdHVzQ29kZSxcbiAgICBzdGF0dXNUZXh0LFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBjYXVzZSA9PSBudWxsID8gYEZhaWxlZCB0byBkb3dubG9hZCAke3VybH06ICR7c3RhdHVzQ29kZX0gJHtzdGF0dXNUZXh0fWAgOiBgRmFpbGVkIHRvIGRvd25sb2FkICR7dXJsfTogJHtjYXVzZX1gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU1LCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hNV0gPSB0cnVlO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yNS5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjUpO1xuICB9XG59O1xuX2E1ID0gc3ltYm9sNTtcblxuLy8gdXRpbC9kb3dubG9hZC50c1xuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWQoeyB1cmwgfSkge1xuICB2YXIgX2ExNztcbiAgY29uc3QgdXJsVGV4dCA9IHVybC50b1N0cmluZygpO1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsVGV4dCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IERvd25sb2FkRXJyb3Ioe1xuICAgICAgICB1cmw6IHVybFRleHQsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBuZXcgVWludDhBcnJheShhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpKSxcbiAgICAgIG1pbWVUeXBlOiAoX2ExNyA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpKSAhPSBudWxsID8gX2ExNyA6IHZvaWQgMFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKERvd25sb2FkRXJyb3IuaXNJbnN0YW5jZShlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRG93bmxvYWRFcnJvcih7IHVybDogdXJsVGV4dCwgY2F1c2U6IGVycm9yIH0pO1xuICB9XG59XG5cbi8vIGNvcmUvcHJvbXB0L2RhdGEtY29udGVudC50c1xuaW1wb3J0IHtcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSBhcyBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5MyxcbiAgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCBhcyBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0MlxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBjb3JlL3Byb21wdC9pbnZhbGlkLWRhdGEtY29udGVudC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yNiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTYgPSBcIkFJX0ludmFsaWREYXRhQ29udGVudEVycm9yXCI7XG52YXIgbWFya2VyNiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNn1gO1xudmFyIHN5bWJvbDYgPSBTeW1ib2wuZm9yKG1hcmtlcjYpO1xudmFyIF9hNjtcbnZhciBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjYge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29udGVudCxcbiAgICBjYXVzZSxcbiAgICBtZXNzYWdlID0gYEludmFsaWQgZGF0YSBjb250ZW50LiBFeHBlY3RlZCBhIGJhc2U2NCBzdHJpbmcsIFVpbnQ4QXJyYXksIEFycmF5QnVmZmVyLCBvciBCdWZmZXIsIGJ1dCBnb3QgJHt0eXBlb2YgY29udGVudH0uYFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNiwgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTZdID0gdHJ1ZTtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I2Lmhhc01hcmtlcihlcnJvciwgbWFya2VyNik7XG4gIH1cbn07XG5fYTYgPSBzeW1ib2w2O1xuXG4vLyBjb3JlL3Byb21wdC9kYXRhLWNvbnRlbnQudHNcbmltcG9ydCB7IHogfSBmcm9tIFwiem9kXCI7XG52YXIgZGF0YUNvbnRlbnRTY2hlbWEgPSB6LnVuaW9uKFtcbiAgei5zdHJpbmcoKSxcbiAgei5pbnN0YW5jZW9mKFVpbnQ4QXJyYXkpLFxuICB6Lmluc3RhbmNlb2YoQXJyYXlCdWZmZXIpLFxuICB6LmN1c3RvbShcbiAgICAvLyBCdWZmZXIgbWlnaHQgbm90IGJlIGF2YWlsYWJsZSBpbiBzb21lIGVudmlyb25tZW50cyBzdWNoIGFzIENsb3VkRmxhcmU6XG4gICAgKHZhbHVlKSA9PiB7XG4gICAgICB2YXIgX2ExNywgX2I7XG4gICAgICByZXR1cm4gKF9iID0gKF9hMTcgPSBnbG9iYWxUaGlzLkJ1ZmZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuaXNCdWZmZXIodmFsdWUpKSAhPSBudWxsID8gX2IgOiBmYWxzZTtcbiAgICB9LFxuICAgIHsgbWVzc2FnZTogXCJNdXN0IGJlIGEgQnVmZmVyXCIgfVxuICApXG5dKTtcbmZ1bmN0aW9uIGNvbnZlcnREYXRhQ29udGVudFRvQmFzZTY0U3RyaW5nKGNvbnRlbnQpIHtcbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0MihuZXcgVWludDhBcnJheShjb250ZW50KSk7XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQyKGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGNvbnRlbnQpIHtcbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5Myhjb250ZW50KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWREYXRhQ29udGVudEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIGRhdGEgY29udGVudC4gQ29udGVudCBzdHJpbmcgaXMgbm90IGEgYmFzZTY0LWVuY29kZWQgbWVkaWEuXCIsXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY29udGVudCk7XG4gIH1cbiAgdGhyb3cgbmV3IEludmFsaWREYXRhQ29udGVudEVycm9yKHsgY29udGVudCB9KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRVaW50OEFycmF5VG9UZXh0KHVpbnQ4QXJyYXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHVpbnQ4QXJyYXkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGRlY29kaW5nIFVpbnQ4QXJyYXkgdG8gdGV4dFwiKTtcbiAgfVxufVxuXG4vLyBjb3JlL3Byb21wdC9pbnZhbGlkLW1lc3NhZ2Utcm9sZS1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yNyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTcgPSBcIkFJX0ludmFsaWRNZXNzYWdlUm9sZUVycm9yXCI7XG52YXIgbWFya2VyNyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lN31gO1xudmFyIHN5bWJvbDcgPSBTeW1ib2wuZm9yKG1hcmtlcjcpO1xudmFyIF9hNztcbnZhciBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjcge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcm9sZSxcbiAgICBtZXNzYWdlID0gYEludmFsaWQgbWVzc2FnZSByb2xlOiAnJHtyb2xlfScuIE11c3QgYmUgb25lIG9mOiBcInN5c3RlbVwiLCBcInVzZXJcIiwgXCJhc3Npc3RhbnRcIiwgXCJ0b29sXCIuYFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNywgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hN10gPSB0cnVlO1xuICAgIHRoaXMucm9sZSA9IHJvbGU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjcuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI3KTtcbiAgfVxufTtcbl9hNyA9IHN5bWJvbDc7XG5cbi8vIGNvcmUvcHJvbXB0L3NwbGl0LWRhdGEtdXJsLnRzXG5mdW5jdGlvbiBzcGxpdERhdGFVcmwoZGF0YVVybCkge1xuICB0cnkge1xuICAgIGNvbnN0IFtoZWFkZXIsIGJhc2U2NENvbnRlbnRdID0gZGF0YVVybC5zcGxpdChcIixcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbWVUeXBlOiBoZWFkZXIuc3BsaXQoXCI7XCIpWzBdLnNwbGl0KFwiOlwiKVsxXSxcbiAgICAgIGJhc2U2NENvbnRlbnRcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBtaW1lVHlwZTogdm9pZCAwLFxuICAgICAgYmFzZTY0Q29udGVudDogdm9pZCAwXG4gICAgfTtcbiAgfVxufVxuXG4vLyBjb3JlL3Byb21wdC9jb252ZXJ0LXRvLWxhbmd1YWdlLW1vZGVsLXByb21wdC50c1xuYXN5bmMgZnVuY3Rpb24gY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gIHByb21wdCxcbiAgbW9kZWxTdXBwb3J0c0ltYWdlVXJscyA9IHRydWUsXG4gIG1vZGVsU3VwcG9ydHNVcmwgPSAoKSA9PiBmYWxzZSxcbiAgZG93bmxvYWRJbXBsZW1lbnRhdGlvbiA9IGRvd25sb2FkXG59KSB7XG4gIGNvbnN0IGRvd25sb2FkZWRBc3NldHMgPSBhd2FpdCBkb3dubG9hZEFzc2V0cyhcbiAgICBwcm9tcHQubWVzc2FnZXMsXG4gICAgZG93bmxvYWRJbXBsZW1lbnRhdGlvbixcbiAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzLFxuICAgIG1vZGVsU3VwcG9ydHNVcmxcbiAgKTtcbiAgcmV0dXJuIFtcbiAgICAuLi5wcm9tcHQuc3lzdGVtICE9IG51bGwgPyBbeyByb2xlOiBcInN5c3RlbVwiLCBjb250ZW50OiBwcm9tcHQuc3lzdGVtIH1dIDogW10sXG4gICAgLi4ucHJvbXB0Lm1lc3NhZ2VzLm1hcChcbiAgICAgIChtZXNzYWdlKSA9PiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsTWVzc2FnZShtZXNzYWdlLCBkb3dubG9hZGVkQXNzZXRzKVxuICAgIClcbiAgXTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxNZXNzYWdlKG1lc3NhZ2UsIGRvd25sb2FkZWRBc3NldHMpIHtcbiAgdmFyIF9hMTcsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgY29uc3Qgcm9sZSA9IG1lc3NhZ2Uucm9sZTtcbiAgc3dpdGNoIChyb2xlKSB7XG4gICAgY2FzZSBcInN5c3RlbVwiOiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQsXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IChfYTE3ID0gbWVzc2FnZS5wcm92aWRlck9wdGlvbnMpICE9IG51bGwgPyBfYTE3IDogbWVzc2FnZS5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogbWVzc2FnZS5jb250ZW50IH1dLFxuICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IChfYiA9IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zKSAhPSBudWxsID8gX2IgOiBtZXNzYWdlLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50Lm1hcCgocGFydCkgPT4gY29udmVydFBhcnRUb0xhbmd1YWdlTW9kZWxQYXJ0KHBhcnQsIGRvd25sb2FkZWRBc3NldHMpKS5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSAhPT0gXCJ0ZXh0XCIgfHwgcGFydC50ZXh0ICE9PSBcIlwiKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogKF9jID0gbWVzc2FnZS5wcm92aWRlck9wdGlvbnMpICE9IG51bGwgPyBfYyA6IG1lc3NhZ2UuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJhc3Npc3RhbnRcIjoge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBtZXNzYWdlLmNvbnRlbnQgfV0sXG4gICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogKF9kID0gbWVzc2FnZS5wcm92aWRlck9wdGlvbnMpICE9IG51bGwgPyBfZCA6IG1lc3NhZ2UuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5maWx0ZXIoXG4gICAgICAgICAgLy8gcmVtb3ZlIGVtcHR5IHRleHQgcGFydHM6XG4gICAgICAgICAgKHBhcnQpID0+IHBhcnQudHlwZSAhPT0gXCJ0ZXh0XCIgfHwgcGFydC50ZXh0ICE9PSBcIlwiXG4gICAgICAgICkubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgICAgdmFyIF9hMTg7XG4gICAgICAgICAgY29uc3QgcHJvdmlkZXJPcHRpb25zID0gKF9hMTggPSBwYXJ0LnByb3ZpZGVyT3B0aW9ucykgIT0gbnVsbCA/IF9hMTggOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZmlsZVwiOiB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgICAgICAgZGF0YTogcGFydC5kYXRhIGluc3RhbmNlb2YgVVJMID8gcGFydC5kYXRhIDogY29udmVydERhdGFDb250ZW50VG9CYXNlNjRTdHJpbmcocGFydC5kYXRhKSxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogcGFydC5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICBtaW1lVHlwZTogcGFydC5taW1lVHlwZSxcbiAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck9wdGlvbnNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmdcIjoge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgICAgICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogcGFydC5zaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicmVkYWN0ZWQtcmVhc29uaW5nXCI6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJlZGFjdGVkLXJlYXNvbmluZ1wiLFxuICAgICAgICAgICAgICAgIGRhdGE6IHBhcnQuZGF0YSxcbiAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck9wdGlvbnNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICBhcmdzOiBwYXJ0LmFyZ3MsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogKF9lID0gbWVzc2FnZS5wcm92aWRlck9wdGlvbnMpICE9IG51bGwgPyBfZSA6IG1lc3NhZ2UuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJ0b29sXCI6IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgICAgdmFyIF9hMTg7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgcmVzdWx0OiBwYXJ0LnJlc3VsdCxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHBhcnQuZXhwZXJpbWVudGFsX2NvbnRlbnQsXG4gICAgICAgICAgICBpc0Vycm9yOiBwYXJ0LmlzRXJyb3IsXG4gICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiAoX2ExOCA9IHBhcnQucHJvdmlkZXJPcHRpb25zKSAhPSBudWxsID8gX2ExOCA6IHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogKF9mID0gbWVzc2FnZS5wcm92aWRlck9wdGlvbnMpICE9IG51bGwgPyBfZiA6IG1lc3NhZ2UuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgIH07XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSByb2xlO1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRNZXNzYWdlUm9sZUVycm9yKHsgcm9sZTogX2V4aGF1c3RpdmVDaGVjayB9KTtcbiAgICB9XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkQXNzZXRzKG1lc3NhZ2VzLCBkb3dubG9hZEltcGxlbWVudGF0aW9uLCBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzLCBtb2RlbFN1cHBvcnRzVXJsKSB7XG4gIGNvbnN0IHVybHMgPSBtZXNzYWdlcy5maWx0ZXIoKG1lc3NhZ2UpID0+IG1lc3NhZ2Uucm9sZSA9PT0gXCJ1c2VyXCIpLm1hcCgobWVzc2FnZSkgPT4gbWVzc2FnZS5jb250ZW50KS5maWx0ZXIoXG4gICAgKGNvbnRlbnQpID0+IEFycmF5LmlzQXJyYXkoY29udGVudClcbiAgKS5mbGF0KCkuZmlsdGVyKFxuICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwiaW1hZ2VcIiB8fCBwYXJ0LnR5cGUgPT09IFwiZmlsZVwiXG4gICkuZmlsdGVyKFxuICAgIChwYXJ0KSA9PiAhKHBhcnQudHlwZSA9PT0gXCJpbWFnZVwiICYmIG1vZGVsU3VwcG9ydHNJbWFnZVVybHMgPT09IHRydWUpXG4gICkubWFwKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwiaW1hZ2VcIiA/IHBhcnQuaW1hZ2UgOiBwYXJ0LmRhdGEpLm1hcChcbiAgICAocGFydCkgPT4gKFxuICAgICAgLy8gc3VwcG9ydCBzdHJpbmcgdXJsczpcbiAgICAgIHR5cGVvZiBwYXJ0ID09PSBcInN0cmluZ1wiICYmIChwYXJ0LnN0YXJ0c1dpdGgoXCJodHRwOlwiKSB8fCBwYXJ0LnN0YXJ0c1dpdGgoXCJodHRwczpcIikpID8gbmV3IFVSTChwYXJ0KSA6IHBhcnRcbiAgICApXG4gICkuZmlsdGVyKChpbWFnZSkgPT4gaW1hZ2UgaW5zdGFuY2VvZiBVUkwpLmZpbHRlcigodXJsKSA9PiAhbW9kZWxTdXBwb3J0c1VybCh1cmwpKTtcbiAgY29uc3QgZG93bmxvYWRlZEltYWdlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHVybHMubWFwKGFzeW5jICh1cmwpID0+ICh7XG4gICAgICB1cmwsXG4gICAgICBkYXRhOiBhd2FpdCBkb3dubG9hZEltcGxlbWVudGF0aW9uKHsgdXJsIH0pXG4gICAgfSkpXG4gICk7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgZG93bmxvYWRlZEltYWdlcy5tYXAoKHsgdXJsLCBkYXRhIH0pID0+IFt1cmwudG9TdHJpbmcoKSwgZGF0YV0pXG4gICk7XG59XG5mdW5jdGlvbiBjb252ZXJ0UGFydFRvTGFuZ3VhZ2VNb2RlbFBhcnQocGFydCwgZG93bmxvYWRlZEFzc2V0cykge1xuICB2YXIgX2ExNywgX2IsIF9jLCBfZDtcbiAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICBwcm92aWRlck1ldGFkYXRhOiAoX2ExNyA9IHBhcnQucHJvdmlkZXJPcHRpb25zKSAhPSBudWxsID8gX2ExNyA6IHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICB9O1xuICB9XG4gIGxldCBtaW1lVHlwZSA9IHBhcnQubWltZVR5cGU7XG4gIGxldCBkYXRhO1xuICBsZXQgY29udGVudDtcbiAgbGV0IG5vcm1hbGl6ZWREYXRhO1xuICBjb25zdCB0eXBlID0gcGFydC50eXBlO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgIGRhdGEgPSBwYXJ0LmltYWdlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImZpbGVcIjpcbiAgICAgIGRhdGEgPSBwYXJ0LmRhdGE7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwYXJ0IHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnRlbnQgPSB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IG5ldyBVUkwoZGF0YSkgOiBkYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnRlbnQgPSBkYXRhO1xuICB9XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgVVJMKSB7XG4gICAgaWYgKGNvbnRlbnQucHJvdG9jb2wgPT09IFwiZGF0YTpcIikge1xuICAgICAgY29uc3QgeyBtaW1lVHlwZTogZGF0YVVybE1pbWVUeXBlLCBiYXNlNjRDb250ZW50IH0gPSBzcGxpdERhdGFVcmwoXG4gICAgICAgIGNvbnRlbnQudG9TdHJpbmcoKVxuICAgICAgKTtcbiAgICAgIGlmIChkYXRhVXJsTWltZVR5cGUgPT0gbnVsbCB8fCBiYXNlNjRDb250ZW50ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGEgVVJMIGZvcm1hdCBpbiBwYXJ0ICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICAgIG1pbWVUeXBlID0gZGF0YVVybE1pbWVUeXBlO1xuICAgICAgbm9ybWFsaXplZERhdGEgPSBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoYmFzZTY0Q29udGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRvd25sb2FkZWRGaWxlID0gZG93bmxvYWRlZEFzc2V0c1tjb250ZW50LnRvU3RyaW5nKCldO1xuICAgICAgaWYgKGRvd25sb2FkZWRGaWxlKSB7XG4gICAgICAgIG5vcm1hbGl6ZWREYXRhID0gZG93bmxvYWRlZEZpbGUuZGF0YTtcbiAgICAgICAgbWltZVR5cGUgIT0gbnVsbCA/IG1pbWVUeXBlIDogbWltZVR5cGUgPSBkb3dubG9hZGVkRmlsZS5taW1lVHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vcm1hbGl6ZWREYXRhID0gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9ybWFsaXplZERhdGEgPSBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoY29udGVudCk7XG4gIH1cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImltYWdlXCI6IHtcbiAgICAgIGlmIChub3JtYWxpemVkRGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgbWltZVR5cGUgPSAoX2IgPSBkZXRlY3RNaW1lVHlwZSh7XG4gICAgICAgICAgZGF0YTogbm9ybWFsaXplZERhdGEsXG4gICAgICAgICAgc2lnbmF0dXJlczogaW1hZ2VNaW1lVHlwZVNpZ25hdHVyZXNcbiAgICAgICAgfSkpICE9IG51bGwgPyBfYiA6IG1pbWVUeXBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJpbWFnZVwiLFxuICAgICAgICBpbWFnZTogbm9ybWFsaXplZERhdGEsXG4gICAgICAgIG1pbWVUeXBlLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiAoX2MgPSBwYXJ0LnByb3ZpZGVyT3B0aW9ucykgIT0gbnVsbCA/IF9jIDogcGFydC5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgaWYgKG1pbWVUeXBlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaW1lIHR5cGUgaXMgbWlzc2luZyBmb3IgZmlsZSBwYXJ0YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgZGF0YTogbm9ybWFsaXplZERhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gY29udmVydERhdGFDb250ZW50VG9CYXNlNjRTdHJpbmcobm9ybWFsaXplZERhdGEpIDogbm9ybWFsaXplZERhdGEsXG4gICAgICAgIGZpbGVuYW1lOiBwYXJ0LmZpbGVuYW1lLFxuICAgICAgICBtaW1lVHlwZSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogKF9kID0gcGFydC5wcm92aWRlck9wdGlvbnMpICE9IG51bGwgPyBfZCA6IHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbi8vIGNvcmUvcHJvbXB0L3ByZXBhcmUtY2FsbC1zZXR0aW5ncy50c1xuZnVuY3Rpb24gcHJlcGFyZUNhbGxTZXR0aW5ncyh7XG4gIG1heFRva2VucyxcbiAgdGVtcGVyYXR1cmUsXG4gIHRvcFAsXG4gIHRvcEssXG4gIHByZXNlbmNlUGVuYWx0eSxcbiAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgc3RvcFNlcXVlbmNlcyxcbiAgc2VlZFxufSkge1xuICBpZiAobWF4VG9rZW5zICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4VG9rZW5zKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFRva2Vuc1wiLFxuICAgICAgICB2YWx1ZTogbWF4VG9rZW5zLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFRva2VucyBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChtYXhUb2tlbnMgPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4VG9rZW5zXCIsXG4gICAgICAgIHZhbHVlOiBtYXhUb2tlbnMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4VG9rZW5zIG11c3QgYmUgPj0gMVwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHRlbXBlcmF0dXJlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwidGVtcGVyYXR1cmVcIixcbiAgICAgICAgdmFsdWU6IHRlbXBlcmF0dXJlLFxuICAgICAgICBtZXNzYWdlOiBcInRlbXBlcmF0dXJlIG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmICh0b3BQICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHRvcFAgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJ0b3BQXCIsXG4gICAgICAgIHZhbHVlOiB0b3BQLFxuICAgICAgICBtZXNzYWdlOiBcInRvcFAgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHRvcEsgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdG9wSyAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInRvcEtcIixcbiAgICAgICAgdmFsdWU6IHRvcEssXG4gICAgICAgIG1lc3NhZ2U6IFwidG9wSyBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAocHJlc2VuY2VQZW5hbHR5ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHByZXNlbmNlUGVuYWx0eSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInByZXNlbmNlUGVuYWx0eVwiLFxuICAgICAgICB2YWx1ZTogcHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICBtZXNzYWdlOiBcInByZXNlbmNlUGVuYWx0eSBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoZnJlcXVlbmN5UGVuYWx0eSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBmcmVxdWVuY3lQZW5hbHR5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwiZnJlcXVlbmN5UGVuYWx0eVwiLFxuICAgICAgICB2YWx1ZTogZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgbWVzc2FnZTogXCJmcmVxdWVuY3lQZW5hbHR5IG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChzZWVkICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoc2VlZCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzZWVkXCIsXG4gICAgICAgIHZhbHVlOiBzZWVkLFxuICAgICAgICBtZXNzYWdlOiBcInNlZWQgbXVzdCBiZSBhbiBpbnRlZ2VyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIG1heFRva2VucyxcbiAgICAvLyBUT0RPIHY1IHJlbW92ZSBkZWZhdWx0IDAgZm9yIHRlbXBlcmF0dXJlXG4gICAgdGVtcGVyYXR1cmU6IHRlbXBlcmF0dXJlICE9IG51bGwgPyB0ZW1wZXJhdHVyZSA6IDAsXG4gICAgdG9wUCxcbiAgICB0b3BLLFxuICAgIHByZXNlbmNlUGVuYWx0eSxcbiAgICBmcmVxdWVuY3lQZW5hbHR5LFxuICAgIHN0b3BTZXF1ZW5jZXM6IHN0b3BTZXF1ZW5jZXMgIT0gbnVsbCAmJiBzdG9wU2VxdWVuY2VzLmxlbmd0aCA+IDAgPyBzdG9wU2VxdWVuY2VzIDogdm9pZCAwLFxuICAgIHNlZWRcbiAgfTtcbn1cblxuLy8gY29yZS9wcm9tcHQvc3RhbmRhcmRpemUtcHJvbXB0LnRzXG5pbXBvcnQgeyBJbnZhbGlkUHJvbXB0RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHsgc2FmZVZhbGlkYXRlVHlwZXMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuaW1wb3J0IHsgeiBhcyB6NyB9IGZyb20gXCJ6b2RcIjtcblxuLy8gY29yZS9wcm9tcHQvYXR0YWNobWVudHMtdG8tcGFydHMudHNcbmZ1bmN0aW9uIGF0dGFjaG1lbnRzVG9QYXJ0cyhhdHRhY2htZW50cykge1xuICB2YXIgX2ExNywgX2IsIF9jO1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuICBmb3IgKGNvbnN0IGF0dGFjaG1lbnQgb2YgYXR0YWNobWVudHMpIHtcbiAgICBsZXQgdXJsO1xuICAgIHRyeSB7XG4gICAgICB1cmwgPSBuZXcgVVJMKGF0dGFjaG1lbnQudXJsKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFVSTDogJHthdHRhY2htZW50LnVybH1gKTtcbiAgICB9XG4gICAgc3dpdGNoICh1cmwucHJvdG9jb2wpIHtcbiAgICAgIGNhc2UgXCJodHRwOlwiOlxuICAgICAgY2FzZSBcImh0dHBzOlwiOiB7XG4gICAgICAgIGlmICgoX2ExNyA9IGF0dGFjaG1lbnQuY29udGVudFR5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LnN0YXJ0c1dpdGgoXCJpbWFnZS9cIikpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHsgdHlwZTogXCJpbWFnZVwiLCBpbWFnZTogdXJsIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghYXR0YWNobWVudC5jb250ZW50VHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBcIklmIHRoZSBhdHRhY2htZW50IGlzIG5vdCBhbiBpbWFnZSwgaXQgbXVzdCBzcGVjaWZ5IGEgY29udGVudCB0eXBlXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgICBkYXRhOiB1cmwsXG4gICAgICAgICAgICBtaW1lVHlwZTogYXR0YWNobWVudC5jb250ZW50VHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRhdGE6XCI6IHtcbiAgICAgICAgbGV0IGhlYWRlcjtcbiAgICAgICAgbGV0IGJhc2U2NENvbnRlbnQ7XG4gICAgICAgIGxldCBtaW1lVHlwZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBbaGVhZGVyLCBiYXNlNjRDb250ZW50XSA9IGF0dGFjaG1lbnQudXJsLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICBtaW1lVHlwZSA9IGhlYWRlci5zcGxpdChcIjtcIilbMF0uc3BsaXQoXCI6XCIpWzFdO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBkYXRhIFVSTDogJHthdHRhY2htZW50LnVybH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWltZVR5cGUgPT0gbnVsbCB8fCBiYXNlNjRDb250ZW50ID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGF0YSBVUkwgZm9ybWF0OiAke2F0dGFjaG1lbnQudXJsfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoX2IgPSBhdHRhY2htZW50LmNvbnRlbnRUeXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2Iuc3RhcnRzV2l0aChcImltYWdlL1wiKSkge1xuICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJpbWFnZVwiLFxuICAgICAgICAgICAgaW1hZ2U6IGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShiYXNlNjRDb250ZW50KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKChfYyA9IGF0dGFjaG1lbnQuY29udGVudFR5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfYy5zdGFydHNXaXRoKFwidGV4dC9cIikpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgdGV4dDogY29udmVydFVpbnQ4QXJyYXlUb1RleHQoXG4gICAgICAgICAgICAgIGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShiYXNlNjRDb250ZW50KVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghYXR0YWNobWVudC5jb250ZW50VHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBcIklmIHRoZSBhdHRhY2htZW50IGlzIG5vdCBhbiBpbWFnZSBvciB0ZXh0LCBpdCBtdXN0IHNwZWNpZnkgYSBjb250ZW50IHR5cGVcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgIGRhdGE6IGJhc2U2NENvbnRlbnQsXG4gICAgICAgICAgICBtaW1lVHlwZTogYXR0YWNobWVudC5jb250ZW50VHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIFVSTCBwcm90b2NvbDogJHt1cmwucHJvdG9jb2x9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gY29yZS9wcm9tcHQvbWVzc2FnZS1jb252ZXJzaW9uLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I4IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lOCA9IFwiQUlfTWVzc2FnZUNvbnZlcnNpb25FcnJvclwiO1xudmFyIG1hcmtlcjggPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTh9YDtcbnZhciBzeW1ib2w4ID0gU3ltYm9sLmZvcihtYXJrZXI4KTtcbnZhciBfYTg7XG52YXIgTWVzc2FnZUNvbnZlcnNpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjgge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgb3JpZ2luYWxNZXNzYWdlLFxuICAgIG1lc3NhZ2VcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTgsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYThdID0gdHJ1ZTtcbiAgICB0aGlzLm9yaWdpbmFsTWVzc2FnZSA9IG9yaWdpbmFsTWVzc2FnZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yOC5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjgpO1xuICB9XG59O1xuX2E4ID0gc3ltYm9sODtcblxuLy8gY29yZS9wcm9tcHQvY29udmVydC10by1jb3JlLW1lc3NhZ2VzLnRzXG5mdW5jdGlvbiBjb252ZXJ0VG9Db3JlTWVzc2FnZXMobWVzc2FnZXMsIG9wdGlvbnMpIHtcbiAgdmFyIF9hMTcsIF9iO1xuICBjb25zdCB0b29scyA9IChfYTE3ID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50b29scykgIT0gbnVsbCA/IF9hMTcgOiB7fTtcbiAgY29uc3QgY29yZU1lc3NhZ2VzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZXNbaV07XG4gICAgY29uc3QgaXNMYXN0TWVzc2FnZSA9IGkgPT09IG1lc3NhZ2VzLmxlbmd0aCAtIDE7XG4gICAgY29uc3QgeyByb2xlLCBjb250ZW50LCBleHBlcmltZW50YWxfYXR0YWNobWVudHMgfSA9IG1lc3NhZ2U7XG4gICAgc3dpdGNoIChyb2xlKSB7XG4gICAgICBjYXNlIFwic3lzdGVtXCI6IHtcbiAgICAgICAgY29yZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgICAgY29udGVudFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwidXNlclwiOiB7XG4gICAgICAgIGlmIChtZXNzYWdlLnBhcnRzID09IG51bGwpIHtcbiAgICAgICAgICBjb3JlTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IGV4cGVyaW1lbnRhbF9hdHRhY2htZW50cyA/IFtcbiAgICAgICAgICAgICAgeyB0eXBlOiBcInRleHRcIiwgdGV4dDogY29udGVudCB9LFxuICAgICAgICAgICAgICAuLi5hdHRhY2htZW50c1RvUGFydHMoZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzKVxuICAgICAgICAgICAgXSA6IGNvbnRlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB0ZXh0UGFydHMgPSBtZXNzYWdlLnBhcnRzLmZpbHRlcigocGFydCkgPT4gcGFydC50eXBlID09PSBcInRleHRcIikubWFwKChwYXJ0KSA9PiAoe1xuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICB0ZXh0OiBwYXJ0LnRleHRcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgY29yZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgICBjb250ZW50OiBleHBlcmltZW50YWxfYXR0YWNobWVudHMgPyBbLi4udGV4dFBhcnRzLCAuLi5hdHRhY2htZW50c1RvUGFydHMoZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzKV0gOiB0ZXh0UGFydHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJhc3Npc3RhbnRcIjoge1xuICAgICAgICBpZiAobWVzc2FnZS5wYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgICAgbGV0IHByb2Nlc3NCbG9jazIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQyID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgYmxvY2spIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmlsZVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQyLnB1c2gocGFydCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZ1wiOiB7XG4gICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRldGFpbCBvZiBwYXJ0LmRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChkZXRhaWwudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50Mi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZGV0YWlsLnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogZGV0YWlsLnNpZ25hdHVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmVkYWN0ZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQyLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJlZGFjdGVkLXJlYXNvbmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkZXRhaWwuZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWludm9jYXRpb25cIjpcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQyLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xJbnZvY2F0aW9uLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xJbnZvY2F0aW9uLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBwYXJ0LnRvb2xJbnZvY2F0aW9uLmFyZ3NcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IHBhcnQ7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHBhcnQ6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgICAgY29udGVudDogY29udGVudDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgc3RlcEludm9jYXRpb25zID0gYmxvY2suZmlsdGVyKFxuICAgICAgICAgICAgICAocGFydCkgPT4gcGFydC50eXBlID09PSBcInRvb2wtaW52b2NhdGlvblwiXG4gICAgICAgICAgICApLm1hcCgocGFydCkgPT4gcGFydC50b29sSW52b2NhdGlvbik7XG4gICAgICAgICAgICBpZiAoc3RlcEludm9jYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY29yZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHN0ZXBJbnZvY2F0aW9ucy5tYXAoXG4gICAgICAgICAgICAgICAgICAodG9vbEludm9jYXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoXCJyZXN1bHRcIiBpbiB0b29sSW52b2NhdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWVzc2FnZUNvbnZlcnNpb25FcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbE1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlRvb2xJbnZvY2F0aW9uIG11c3QgaGF2ZSBhIHJlc3VsdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0b29sSW52b2NhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRvb2xDYWxsSWQsIHRvb2xOYW1lLCByZXN1bHQgfSA9IHRvb2xJbnZvY2F0aW9uO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sMiA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIuZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQpICE9IG51bGwgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB0b29sMi5leHBlcmltZW50YWxfdG9Ub29sUmVzdWx0Q29udGVudChyZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZW50OiB0b29sMi5leHBlcmltZW50YWxfdG9Ub29sUmVzdWx0Q29udGVudChyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJsb2NrID0gW107XG4gICAgICAgICAgICBibG9ja0hhc1Rvb2xJbnZvY2F0aW9ucyA9IGZhbHNlO1xuICAgICAgICAgICAgY3VycmVudFN0ZXArKztcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBwcm9jZXNzQmxvY2sgPSBwcm9jZXNzQmxvY2syO1xuICAgICAgICAgIGxldCBjdXJyZW50U3RlcCA9IDA7XG4gICAgICAgICAgbGV0IGJsb2NrSGFzVG9vbEludm9jYXRpb25zID0gZmFsc2U7XG4gICAgICAgICAgbGV0IGJsb2NrID0gW107XG4gICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIG1lc3NhZ2UucGFydHMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tIYXNUb29sSW52b2NhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgIHByb2Nlc3NCbG9jazIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmxvY2sucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwiZmlsZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nXCI6IHtcbiAgICAgICAgICAgICAgICBibG9jay5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWludm9jYXRpb25cIjoge1xuICAgICAgICAgICAgICAgIGlmICgoKF9iID0gcGFydC50b29sSW52b2NhdGlvbi5zdGVwKSAhPSBudWxsID8gX2IgOiAwKSAhPT0gY3VycmVudFN0ZXApIHtcbiAgICAgICAgICAgICAgICAgIHByb2Nlc3NCbG9jazIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmxvY2sucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgICBibG9ja0hhc1Rvb2xJbnZvY2F0aW9ucyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvY2Vzc0Jsb2NrMigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvb2xJbnZvY2F0aW9ucyA9IG1lc3NhZ2UudG9vbEludm9jYXRpb25zO1xuICAgICAgICBpZiAodG9vbEludm9jYXRpb25zID09IG51bGwgfHwgdG9vbEludm9jYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHsgcm9sZTogXCJhc3Npc3RhbnRcIiwgY29udGVudCB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXhTdGVwID0gdG9vbEludm9jYXRpb25zLnJlZHVjZSgobWF4LCB0b29sSW52b2NhdGlvbikgPT4ge1xuICAgICAgICAgIHZhciBfYTE4O1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heChtYXgsIChfYTE4ID0gdG9vbEludm9jYXRpb24uc3RlcCkgIT0gbnVsbCA/IF9hMTggOiAwKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPD0gbWF4U3RlcDsgaTIrKykge1xuICAgICAgICAgIGNvbnN0IHN0ZXBJbnZvY2F0aW9ucyA9IHRvb2xJbnZvY2F0aW9ucy5maWx0ZXIoXG4gICAgICAgICAgICAodG9vbEludm9jYXRpb24pID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hMTg7XG4gICAgICAgICAgICAgIHJldHVybiAoKF9hMTggPSB0b29sSW52b2NhdGlvbi5zdGVwKSAhPSBudWxsID8gX2ExOCA6IDApID09PSBpMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChzdGVwSW52b2NhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29yZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgLi4uaXNMYXN0TWVzc2FnZSAmJiBjb250ZW50ICYmIGkyID09PSAwID8gW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IGNvbnRlbnQgfV0gOiBbXSxcbiAgICAgICAgICAgICAgLi4uc3RlcEludm9jYXRpb25zLm1hcChcbiAgICAgICAgICAgICAgICAoeyB0b29sQ2FsbElkLCB0b29sTmFtZSwgYXJncyB9KSA9PiAoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIGFyZ3NcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29yZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgICAgICBjb250ZW50OiBzdGVwSW52b2NhdGlvbnMubWFwKCh0b29sSW52b2NhdGlvbikgPT4ge1xuICAgICAgICAgICAgICBpZiAoIShcInJlc3VsdFwiIGluIHRvb2xJbnZvY2F0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBNZXNzYWdlQ29udmVyc2lvbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgIG9yaWdpbmFsTWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiVG9vbEludm9jYXRpb24gbXVzdCBoYXZlIGEgcmVzdWx0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRvb2xJbnZvY2F0aW9uKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHsgdG9vbENhbGxJZCwgdG9vbE5hbWUsIHJlc3VsdCB9ID0gdG9vbEludm9jYXRpb247XG4gICAgICAgICAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHNbdG9vbE5hbWVdO1xuICAgICAgICAgICAgICByZXR1cm4gKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi5leHBlcmltZW50YWxfdG9Ub29sUmVzdWx0Q29udGVudCkgIT0gbnVsbCA/IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHRvb2wyLmV4cGVyaW1lbnRhbF90b1Rvb2xSZXN1bHRDb250ZW50KHJlc3VsdCksXG4gICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRlbnQ6IHRvb2wyLmV4cGVyaW1lbnRhbF90b1Rvb2xSZXN1bHRDb250ZW50KHJlc3VsdClcbiAgICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRlbnQgJiYgIWlzTGFzdE1lc3NhZ2UpIHtcbiAgICAgICAgICBjb3JlTWVzc2FnZXMucHVzaCh7IHJvbGU6IFwiYXNzaXN0YW50XCIsIGNvbnRlbnQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZGF0YVwiOiB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gcm9sZTtcbiAgICAgICAgdGhyb3cgbmV3IE1lc3NhZ2VDb252ZXJzaW9uRXJyb3Ioe1xuICAgICAgICAgIG9yaWdpbmFsTWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICBtZXNzYWdlOiBgVW5zdXBwb3J0ZWQgcm9sZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3JlTWVzc2FnZXM7XG59XG5cbi8vIGNvcmUvcHJvbXB0L2RldGVjdC1wcm9tcHQtdHlwZS50c1xuZnVuY3Rpb24gZGV0ZWN0UHJvbXB0VHlwZShwcm9tcHQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHByb21wdCkpIHtcbiAgICByZXR1cm4gXCJvdGhlclwiO1xuICB9XG4gIGlmIChwcm9tcHQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFwibWVzc2FnZXNcIjtcbiAgfVxuICBjb25zdCBjaGFyYWN0ZXJpc3RpY3MgPSBwcm9tcHQubWFwKGRldGVjdFNpbmdsZU1lc3NhZ2VDaGFyYWN0ZXJpc3RpY3MpO1xuICBpZiAoY2hhcmFjdGVyaXN0aWNzLnNvbWUoKGMpID0+IGMgPT09IFwiaGFzLXVpLXNwZWNpZmljLXBhcnRzXCIpKSB7XG4gICAgcmV0dXJuIFwidWktbWVzc2FnZXNcIjtcbiAgfSBlbHNlIGlmIChjaGFyYWN0ZXJpc3RpY3MuZXZlcnkoXG4gICAgKGMpID0+IGMgPT09IFwiaGFzLWNvcmUtc3BlY2lmaWMtcGFydHNcIiB8fCBjID09PSBcIm1lc3NhZ2VcIlxuICApKSB7XG4gICAgcmV0dXJuIFwibWVzc2FnZXNcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJvdGhlclwiO1xuICB9XG59XG5mdW5jdGlvbiBkZXRlY3RTaW5nbGVNZXNzYWdlQ2hhcmFjdGVyaXN0aWNzKG1lc3NhZ2UpIHtcbiAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcIm9iamVjdFwiICYmIG1lc3NhZ2UgIT09IG51bGwgJiYgKG1lc3NhZ2Uucm9sZSA9PT0gXCJmdW5jdGlvblwiIHx8IC8vIFVJLW9ubHkgcm9sZVxuICBtZXNzYWdlLnJvbGUgPT09IFwiZGF0YVwiIHx8IC8vIFVJLW9ubHkgcm9sZVxuICBcInRvb2xJbnZvY2F0aW9uc1wiIGluIG1lc3NhZ2UgfHwgLy8gVUktc3BlY2lmaWMgZmllbGRcbiAgXCJwYXJ0c1wiIGluIG1lc3NhZ2UgfHwgLy8gVUktc3BlY2lmaWMgZmllbGRcbiAgXCJleHBlcmltZW50YWxfYXR0YWNobWVudHNcIiBpbiBtZXNzYWdlKSkge1xuICAgIHJldHVybiBcImhhcy11aS1zcGVjaWZpYy1wYXJ0c1wiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcIm9iamVjdFwiICYmIG1lc3NhZ2UgIT09IG51bGwgJiYgXCJjb250ZW50XCIgaW4gbWVzc2FnZSAmJiAoQXJyYXkuaXNBcnJheShtZXNzYWdlLmNvbnRlbnQpIHx8IC8vIENvcmUgbWVzc2FnZXMgY2FuIGhhdmUgYXJyYXkgY29udGVudFxuICBcImV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXCIgaW4gbWVzc2FnZSB8fCBcInByb3ZpZGVyT3B0aW9uc1wiIGluIG1lc3NhZ2UpKSB7XG4gICAgcmV0dXJuIFwiaGFzLWNvcmUtc3BlY2lmaWMtcGFydHNcIjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJvYmplY3RcIiAmJiBtZXNzYWdlICE9PSBudWxsICYmIFwicm9sZVwiIGluIG1lc3NhZ2UgJiYgXCJjb250ZW50XCIgaW4gbWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiICYmIFtcInN5c3RlbVwiLCBcInVzZXJcIiwgXCJhc3Npc3RhbnRcIiwgXCJ0b29sXCJdLmluY2x1ZGVzKG1lc3NhZ2Uucm9sZSkpIHtcbiAgICByZXR1cm4gXCJtZXNzYWdlXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwib3RoZXJcIjtcbiAgfVxufVxuXG4vLyBjb3JlL3Byb21wdC9tZXNzYWdlLnRzXG5pbXBvcnQgeyB6IGFzIHo2IH0gZnJvbSBcInpvZFwiO1xuXG4vLyBjb3JlL3R5cGVzL3Byb3ZpZGVyLW1ldGFkYXRhLnRzXG5pbXBvcnQgeyB6IGFzIHozIH0gZnJvbSBcInpvZFwiO1xuXG4vLyBjb3JlL3R5cGVzL2pzb24tdmFsdWUudHNcbmltcG9ydCB7IHogYXMgejIgfSBmcm9tIFwiem9kXCI7XG52YXIganNvblZhbHVlU2NoZW1hID0gejIubGF6eShcbiAgKCkgPT4gejIudW5pb24oW1xuICAgIHoyLm51bGwoKSxcbiAgICB6Mi5zdHJpbmcoKSxcbiAgICB6Mi5udW1iZXIoKSxcbiAgICB6Mi5ib29sZWFuKCksXG4gICAgejIucmVjb3JkKHoyLnN0cmluZygpLCBqc29uVmFsdWVTY2hlbWEpLFxuICAgIHoyLmFycmF5KGpzb25WYWx1ZVNjaGVtYSlcbiAgXSlcbik7XG5cbi8vIGNvcmUvdHlwZXMvcHJvdmlkZXItbWV0YWRhdGEudHNcbnZhciBwcm92aWRlck1ldGFkYXRhU2NoZW1hID0gejMucmVjb3JkKFxuICB6My5zdHJpbmcoKSxcbiAgejMucmVjb3JkKHozLnN0cmluZygpLCBqc29uVmFsdWVTY2hlbWEpXG4pO1xuXG4vLyBjb3JlL3Byb21wdC9jb250ZW50LXBhcnQudHNcbmltcG9ydCB7IHogYXMgejUgfSBmcm9tIFwiem9kXCI7XG5cbi8vIGNvcmUvcHJvbXB0L3Rvb2wtcmVzdWx0LWNvbnRlbnQudHNcbmltcG9ydCB7IHogYXMgejQgfSBmcm9tIFwiem9kXCI7XG52YXIgdG9vbFJlc3VsdENvbnRlbnRTY2hlbWEgPSB6NC5hcnJheShcbiAgejQudW5pb24oW1xuICAgIHo0Lm9iamVjdCh7IHR5cGU6IHo0LmxpdGVyYWwoXCJ0ZXh0XCIpLCB0ZXh0OiB6NC5zdHJpbmcoKSB9KSxcbiAgICB6NC5vYmplY3Qoe1xuICAgICAgdHlwZTogejQubGl0ZXJhbChcImltYWdlXCIpLFxuICAgICAgZGF0YTogejQuc3RyaW5nKCksXG4gICAgICBtaW1lVHlwZTogejQuc3RyaW5nKCkub3B0aW9uYWwoKVxuICAgIH0pXG4gIF0pXG4pO1xuXG4vLyBjb3JlL3Byb21wdC9jb250ZW50LXBhcnQudHNcbnZhciB0ZXh0UGFydFNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIHR5cGU6IHo1LmxpdGVyYWwoXCJ0ZXh0XCIpLFxuICB0ZXh0OiB6NS5zdHJpbmcoKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIGltYWdlUGFydFNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIHR5cGU6IHo1LmxpdGVyYWwoXCJpbWFnZVwiKSxcbiAgaW1hZ2U6IHo1LnVuaW9uKFtkYXRhQ29udGVudFNjaGVtYSwgejUuaW5zdGFuY2VvZihVUkwpXSksXG4gIG1pbWVUeXBlOiB6NS5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgZmlsZVBhcnRTY2hlbWEgPSB6NS5vYmplY3Qoe1xuICB0eXBlOiB6NS5saXRlcmFsKFwiZmlsZVwiKSxcbiAgZGF0YTogejUudW5pb24oW2RhdGFDb250ZW50U2NoZW1hLCB6NS5pbnN0YW5jZW9mKFVSTCldKSxcbiAgZmlsZW5hbWU6IHo1LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIG1pbWVUeXBlOiB6NS5zdHJpbmcoKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIHJlYXNvbmluZ1BhcnRTY2hlbWEgPSB6NS5vYmplY3Qoe1xuICB0eXBlOiB6NS5saXRlcmFsKFwicmVhc29uaW5nXCIpLFxuICB0ZXh0OiB6NS5zdHJpbmcoKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIHJlZGFjdGVkUmVhc29uaW5nUGFydFNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIHR5cGU6IHo1LmxpdGVyYWwoXCJyZWRhY3RlZC1yZWFzb25pbmdcIiksXG4gIGRhdGE6IHo1LnN0cmluZygpLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgdG9vbENhbGxQYXJ0U2NoZW1hID0gejUub2JqZWN0KHtcbiAgdHlwZTogejUubGl0ZXJhbChcInRvb2wtY2FsbFwiKSxcbiAgdG9vbENhbGxJZDogejUuc3RyaW5nKCksXG4gIHRvb2xOYW1lOiB6NS5zdHJpbmcoKSxcbiAgYXJnczogejUudW5rbm93bigpLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgdG9vbFJlc3VsdFBhcnRTY2hlbWEgPSB6NS5vYmplY3Qoe1xuICB0eXBlOiB6NS5saXRlcmFsKFwidG9vbC1yZXN1bHRcIiksXG4gIHRvb2xDYWxsSWQ6IHo1LnN0cmluZygpLFxuICB0b29sTmFtZTogejUuc3RyaW5nKCksXG4gIHJlc3VsdDogejUudW5rbm93bigpLFxuICBjb250ZW50OiB0b29sUmVzdWx0Q29udGVudFNjaGVtYS5vcHRpb25hbCgpLFxuICBpc0Vycm9yOiB6NS5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xuXG4vLyBjb3JlL3Byb21wdC9tZXNzYWdlLnRzXG52YXIgY29yZVN5c3RlbU1lc3NhZ2VTY2hlbWEgPSB6Ni5vYmplY3Qoe1xuICByb2xlOiB6Ni5saXRlcmFsKFwic3lzdGVtXCIpLFxuICBjb250ZW50OiB6Ni5zdHJpbmcoKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIGNvcmVVc2VyTWVzc2FnZVNjaGVtYSA9IHo2Lm9iamVjdCh7XG4gIHJvbGU6IHo2LmxpdGVyYWwoXCJ1c2VyXCIpLFxuICBjb250ZW50OiB6Ni51bmlvbihbXG4gICAgejYuc3RyaW5nKCksXG4gICAgejYuYXJyYXkoejYudW5pb24oW3RleHRQYXJ0U2NoZW1hLCBpbWFnZVBhcnRTY2hlbWEsIGZpbGVQYXJ0U2NoZW1hXSkpXG4gIF0pLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgY29yZUFzc2lzdGFudE1lc3NhZ2VTY2hlbWEgPSB6Ni5vYmplY3Qoe1xuICByb2xlOiB6Ni5saXRlcmFsKFwiYXNzaXN0YW50XCIpLFxuICBjb250ZW50OiB6Ni51bmlvbihbXG4gICAgejYuc3RyaW5nKCksXG4gICAgejYuYXJyYXkoXG4gICAgICB6Ni51bmlvbihbXG4gICAgICAgIHRleHRQYXJ0U2NoZW1hLFxuICAgICAgICBmaWxlUGFydFNjaGVtYSxcbiAgICAgICAgcmVhc29uaW5nUGFydFNjaGVtYSxcbiAgICAgICAgcmVkYWN0ZWRSZWFzb25pbmdQYXJ0U2NoZW1hLFxuICAgICAgICB0b29sQ2FsbFBhcnRTY2hlbWFcbiAgICAgIF0pXG4gICAgKVxuICBdKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIGNvcmVUb29sTWVzc2FnZVNjaGVtYSA9IHo2Lm9iamVjdCh7XG4gIHJvbGU6IHo2LmxpdGVyYWwoXCJ0b29sXCIpLFxuICBjb250ZW50OiB6Ni5hcnJheSh0b29sUmVzdWx0UGFydFNjaGVtYSksXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBjb3JlTWVzc2FnZVNjaGVtYSA9IHo2LnVuaW9uKFtcbiAgY29yZVN5c3RlbU1lc3NhZ2VTY2hlbWEsXG4gIGNvcmVVc2VyTWVzc2FnZVNjaGVtYSxcbiAgY29yZUFzc2lzdGFudE1lc3NhZ2VTY2hlbWEsXG4gIGNvcmVUb29sTWVzc2FnZVNjaGVtYVxuXSk7XG5cbi8vIGNvcmUvcHJvbXB0L3N0YW5kYXJkaXplLXByb21wdC50c1xuZnVuY3Rpb24gc3RhbmRhcmRpemVQcm9tcHQoe1xuICBwcm9tcHQsXG4gIHRvb2xzXG59KSB7XG4gIGlmIChwcm9tcHQucHJvbXB0ID09IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwicHJvbXB0IG9yIG1lc3NhZ2VzIG11c3QgYmUgZGVmaW5lZFwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb21wdC5wcm9tcHQgIT0gbnVsbCAmJiBwcm9tcHQubWVzc2FnZXMgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogXCJwcm9tcHQgYW5kIG1lc3NhZ2VzIGNhbm5vdCBiZSBkZWZpbmVkIGF0IHRoZSBzYW1lIHRpbWVcIlxuICAgIH0pO1xuICB9XG4gIGlmIChwcm9tcHQuc3lzdGVtICE9IG51bGwgJiYgdHlwZW9mIHByb21wdC5zeXN0ZW0gIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwic3lzdGVtIG11c3QgYmUgYSBzdHJpbmdcIlxuICAgIH0pO1xuICB9XG4gIGlmIChwcm9tcHQucHJvbXB0ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHByb21wdC5wcm9tcHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2U6IFwicHJvbXB0IG11c3QgYmUgYSBzdHJpbmdcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInByb21wdFwiLFxuICAgICAgc3lzdGVtOiBwcm9tcHQuc3lzdGVtLFxuICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IHByb21wdC5wcm9tcHRcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG4gIH1cbiAgaWYgKHByb21wdC5tZXNzYWdlcyAhPSBudWxsKSB7XG4gICAgY29uc3QgcHJvbXB0VHlwZSA9IGRldGVjdFByb21wdFR5cGUocHJvbXB0Lm1lc3NhZ2VzKTtcbiAgICBpZiAocHJvbXB0VHlwZSA9PT0gXCJvdGhlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICBtZXNzYWdlOiBcIm1lc3NhZ2VzIG11c3QgYmUgYW4gYXJyYXkgb2YgQ29yZU1lc3NhZ2Ugb3IgVUlNZXNzYWdlXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IHByb21wdFR5cGUgPT09IFwidWktbWVzc2FnZXNcIiA/IGNvbnZlcnRUb0NvcmVNZXNzYWdlcyhwcm9tcHQubWVzc2FnZXMsIHtcbiAgICAgIHRvb2xzXG4gICAgfSkgOiBwcm9tcHQubWVzc2FnZXM7XG4gICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcih7XG4gICAgICAgIHByb21wdCxcbiAgICAgICAgbWVzc2FnZTogXCJtZXNzYWdlcyBtdXN0IG5vdCBiZSBlbXB0eVwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IHNhZmVWYWxpZGF0ZVR5cGVzKHtcbiAgICAgIHZhbHVlOiBtZXNzYWdlcyxcbiAgICAgIHNjaGVtYTogejcuYXJyYXkoY29yZU1lc3NhZ2VTY2hlbWEpXG4gICAgfSk7XG4gICAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2U6IFwibWVzc2FnZXMgbXVzdCBiZSBhbiBhcnJheSBvZiBDb3JlTWVzc2FnZSBvciBVSU1lc3NhZ2VcIixcbiAgICAgICAgY2F1c2U6IHZhbGlkYXRpb25SZXN1bHQuZXJyb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJtZXNzYWdlc1wiLFxuICAgICAgbWVzc2FnZXMsXG4gICAgICBzeXN0ZW06IHByb21wdC5zeXN0ZW1cbiAgICB9O1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcInVucmVhY2hhYmxlXCIpO1xufVxuXG4vLyBjb3JlL3R5cGVzL3VzYWdlLnRzXG5mdW5jdGlvbiBjYWxjdWxhdGVMYW5ndWFnZU1vZGVsVXNhZ2Uoe1xuICBwcm9tcHRUb2tlbnMsXG4gIGNvbXBsZXRpb25Ub2tlbnNcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9tcHRUb2tlbnMsXG4gICAgY29tcGxldGlvblRva2VucyxcbiAgICB0b3RhbFRva2VuczogcHJvbXB0VG9rZW5zICsgY29tcGxldGlvblRva2Vuc1xuICB9O1xufVxuZnVuY3Rpb24gYWRkTGFuZ3VhZ2VNb2RlbFVzYWdlKHVzYWdlMSwgdXNhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAgcHJvbXB0VG9rZW5zOiB1c2FnZTEucHJvbXB0VG9rZW5zICsgdXNhZ2UyLnByb21wdFRva2VucyxcbiAgICBjb21wbGV0aW9uVG9rZW5zOiB1c2FnZTEuY29tcGxldGlvblRva2VucyArIHVzYWdlMi5jb21wbGV0aW9uVG9rZW5zLFxuICAgIHRvdGFsVG9rZW5zOiB1c2FnZTEudG90YWxUb2tlbnMgKyB1c2FnZTIudG90YWxUb2tlbnNcbiAgfTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3QvaW5qZWN0LWpzb24taW5zdHJ1Y3Rpb24udHNcbnZhciBERUZBVUxUX1NDSEVNQV9QUkVGSVggPSBcIkpTT04gc2NoZW1hOlwiO1xudmFyIERFRkFVTFRfU0NIRU1BX1NVRkZJWCA9IFwiWW91IE1VU1QgYW5zd2VyIHdpdGggYSBKU09OIG9iamVjdCB0aGF0IG1hdGNoZXMgdGhlIEpTT04gc2NoZW1hIGFib3ZlLlwiO1xudmFyIERFRkFVTFRfR0VORVJJQ19TVUZGSVggPSBcIllvdSBNVVNUIGFuc3dlciB3aXRoIEpTT04uXCI7XG5mdW5jdGlvbiBpbmplY3RKc29uSW5zdHJ1Y3Rpb24oe1xuICBwcm9tcHQsXG4gIHNjaGVtYSxcbiAgc2NoZW1hUHJlZml4ID0gc2NoZW1hICE9IG51bGwgPyBERUZBVUxUX1NDSEVNQV9QUkVGSVggOiB2b2lkIDAsXG4gIHNjaGVtYVN1ZmZpeCA9IHNjaGVtYSAhPSBudWxsID8gREVGQVVMVF9TQ0hFTUFfU1VGRklYIDogREVGQVVMVF9HRU5FUklDX1NVRkZJWFxufSkge1xuICByZXR1cm4gW1xuICAgIHByb21wdCAhPSBudWxsICYmIHByb21wdC5sZW5ndGggPiAwID8gcHJvbXB0IDogdm9pZCAwLFxuICAgIHByb21wdCAhPSBudWxsICYmIHByb21wdC5sZW5ndGggPiAwID8gXCJcIiA6IHZvaWQgMCxcbiAgICAvLyBhZGQgYSBuZXdsaW5lIGlmIHByb21wdCBpcyBub3QgbnVsbFxuICAgIHNjaGVtYVByZWZpeCxcbiAgICBzY2hlbWEgIT0gbnVsbCA/IEpTT04uc3RyaW5naWZ5KHNjaGVtYSkgOiB2b2lkIDAsXG4gICAgc2NoZW1hU3VmZml4XG4gIF0uZmlsdGVyKChsaW5lKSA9PiBsaW5lICE9IG51bGwpLmpvaW4oXCJcXG5cIik7XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L291dHB1dC1zdHJhdGVneS50c1xuaW1wb3J0IHtcbiAgaXNKU09OQXJyYXksXG4gIGlzSlNPTk9iamVjdCxcbiAgVHlwZVZhbGlkYXRpb25FcnJvcixcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Jcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IHNhZmVWYWxpZGF0ZVR5cGVzIGFzIHNhZmVWYWxpZGF0ZVR5cGVzMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyBhc1NjaGVtYSB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5cbi8vIGNvcmUvdXRpbC9hc3luYy1pdGVyYWJsZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oc291cmNlKSB7XG4gIGNvbnN0IHN0cmVhbSA9IHNvdXJjZS5waXBlVGhyb3VnaChuZXcgVHJhbnNmb3JtU3RyZWFtKCkpO1xuICBzdHJlYW1bU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gKCkgPT4ge1xuICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICByZXR1cm4ge1xuICAgICAgYXN5bmMgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgcmV0dXJuIGRvbmUgPyB7IGRvbmU6IHRydWUsIHZhbHVlOiB2b2lkIDAgfSA6IHsgZG9uZTogZmFsc2UsIHZhbHVlIH07XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3Qvb3V0cHV0LXN0cmF0ZWd5LnRzXG52YXIgbm9TY2hlbWFPdXRwdXRTdHJhdGVneSA9IHtcbiAgdHlwZTogXCJuby1zY2hlbWFcIixcbiAganNvblNjaGVtYTogdm9pZCAwLFxuICB2YWxpZGF0ZVBhcnRpYWxSZXN1bHQoeyB2YWx1ZSwgdGV4dERlbHRhIH0pIHtcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogeyBwYXJ0aWFsOiB2YWx1ZSwgdGV4dERlbHRhIH0gfTtcbiAgfSxcbiAgdmFsaWRhdGVGaW5hbFJlc3VsdCh2YWx1ZSwgY29udGV4dCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IHJlc3BvbnNlIGRpZCBub3QgbWF0Y2ggc2NoZW1hLlwiLFxuICAgICAgICB0ZXh0OiBjb250ZXh0LnRleHQsXG4gICAgICAgIHJlc3BvbnNlOiBjb250ZXh0LnJlc3BvbnNlLFxuICAgICAgICB1c2FnZTogY29udGV4dC51c2FnZSxcbiAgICAgICAgZmluaXNoUmVhc29uOiBjb250ZXh0LmZpbmlzaFJlYXNvblxuICAgICAgfSlcbiAgICB9IDogeyBzdWNjZXNzOiB0cnVlLCB2YWx1ZSB9O1xuICB9LFxuICBjcmVhdGVFbGVtZW50U3RyZWFtKCkge1xuICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcih7XG4gICAgICBmdW5jdGlvbmFsaXR5OiBcImVsZW1lbnQgc3RyZWFtcyBpbiBuby1zY2hlbWEgbW9kZVwiXG4gICAgfSk7XG4gIH1cbn07XG52YXIgb2JqZWN0T3V0cHV0U3RyYXRlZ3kgPSAoc2NoZW1hKSA9PiAoe1xuICB0eXBlOiBcIm9iamVjdFwiLFxuICBqc29uU2NoZW1hOiBzY2hlbWEuanNvblNjaGVtYSxcbiAgdmFsaWRhdGVQYXJ0aWFsUmVzdWx0KHsgdmFsdWUsIHRleHREZWx0YSB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICB2YWx1ZToge1xuICAgICAgICAvLyBOb3RlOiBjdXJyZW50bHkgbm8gdmFsaWRhdGlvbiBvZiBwYXJ0aWFsIHJlc3VsdHM6XG4gICAgICAgIHBhcnRpYWw6IHZhbHVlLFxuICAgICAgICB0ZXh0RGVsdGFcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICB2YWxpZGF0ZUZpbmFsUmVzdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHNhZmVWYWxpZGF0ZVR5cGVzMih7IHZhbHVlLCBzY2hlbWEgfSk7XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnRTdHJlYW0oKSB7XG4gICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yKHtcbiAgICAgIGZ1bmN0aW9uYWxpdHk6IFwiZWxlbWVudCBzdHJlYW1zIGluIG9iamVjdCBtb2RlXCJcbiAgICB9KTtcbiAgfVxufSk7XG52YXIgYXJyYXlPdXRwdXRTdHJhdGVneSA9IChzY2hlbWEpID0+IHtcbiAgY29uc3QgeyAkc2NoZW1hLCAuLi5pdGVtU2NoZW1hIH0gPSBzY2hlbWEuanNvblNjaGVtYTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICAvLyB3cmFwIGluIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFycmF5IG9mIGVsZW1lbnRzLCBzaW5jZSBtb3N0IExMTXMgd2lsbCBub3RcbiAgICAvLyBiZSBhYmxlIHRvIGdlbmVyYXRlIGFuIGFycmF5IGRpcmVjdGx5OlxuICAgIC8vIHBvc3NpYmxlIGZ1dHVyZSBvcHRpbWl6YXRpb246IHVzZSBhcnJheXMgZGlyZWN0bHkgd2hlbiBtb2RlbCBzdXBwb3J0cyBncmFtbWFyLWd1aWRlZCBnZW5lcmF0aW9uXG4gICAganNvblNjaGVtYToge1xuICAgICAgJHNjaGVtYTogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIixcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGVsZW1lbnRzOiB7IHR5cGU6IFwiYXJyYXlcIiwgaXRlbXM6IGl0ZW1TY2hlbWEgfVxuICAgICAgfSxcbiAgICAgIHJlcXVpcmVkOiBbXCJlbGVtZW50c1wiXSxcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZVxuICAgIH0sXG4gICAgdmFsaWRhdGVQYXJ0aWFsUmVzdWx0KHsgdmFsdWUsIGxhdGVzdE9iamVjdCwgaXNGaXJzdERlbHRhLCBpc0ZpbmFsRGVsdGEgfSkge1xuICAgICAgdmFyIF9hMTc7XG4gICAgICBpZiAoIWlzSlNPTk9iamVjdCh2YWx1ZSkgfHwgIWlzSlNPTkFycmF5KHZhbHVlLmVsZW1lbnRzKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcih7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiBcInZhbHVlIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYW4gYXJyYXkgb2YgZWxlbWVudHNcIlxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBpbnB1dEFycmF5ID0gdmFsdWUuZWxlbWVudHM7XG4gICAgICBjb25zdCByZXN1bHRBcnJheSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBpbnB1dEFycmF5W2ldO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzYWZlVmFsaWRhdGVUeXBlczIoeyB2YWx1ZTogZWxlbWVudCwgc2NoZW1hIH0pO1xuICAgICAgICBpZiAoaSA9PT0gaW5wdXRBcnJheS5sZW5ndGggLSAxICYmICFpc0ZpbmFsRGVsdGEpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRBcnJheS5wdXNoKHJlc3VsdC52YWx1ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwdWJsaXNoZWRFbGVtZW50Q291bnQgPSAoX2ExNyA9IGxhdGVzdE9iamVjdCA9PSBudWxsID8gdm9pZCAwIDogbGF0ZXN0T2JqZWN0Lmxlbmd0aCkgIT0gbnVsbCA/IF9hMTcgOiAwO1xuICAgICAgbGV0IHRleHREZWx0YSA9IFwiXCI7XG4gICAgICBpZiAoaXNGaXJzdERlbHRhKSB7XG4gICAgICAgIHRleHREZWx0YSArPSBcIltcIjtcbiAgICAgIH1cbiAgICAgIGlmIChwdWJsaXNoZWRFbGVtZW50Q291bnQgPiAwKSB7XG4gICAgICAgIHRleHREZWx0YSArPSBcIixcIjtcbiAgICAgIH1cbiAgICAgIHRleHREZWx0YSArPSByZXN1bHRBcnJheS5zbGljZShwdWJsaXNoZWRFbGVtZW50Q291bnQpLm1hcCgoZWxlbWVudCkgPT4gSlNPTi5zdHJpbmdpZnkoZWxlbWVudCkpLmpvaW4oXCIsXCIpO1xuICAgICAgaWYgKGlzRmluYWxEZWx0YSkge1xuICAgICAgICB0ZXh0RGVsdGEgKz0gXCJdXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHBhcnRpYWw6IHJlc3VsdEFycmF5LFxuICAgICAgICAgIHRleHREZWx0YVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdmFsaWRhdGVGaW5hbFJlc3VsdCh2YWx1ZSkge1xuICAgICAgaWYgKCFpc0pTT05PYmplY3QodmFsdWUpIHx8ICFpc0pTT05BcnJheSh2YWx1ZS5lbGVtZW50cykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogXCJ2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFuIGFycmF5IG9mIGVsZW1lbnRzXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgaW5wdXRBcnJheSA9IHZhbHVlLmVsZW1lbnRzO1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGlucHV0QXJyYXkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc2FmZVZhbGlkYXRlVHlwZXMyKHsgdmFsdWU6IGVsZW1lbnQsIHNjaGVtYSB9KTtcbiAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiBpbnB1dEFycmF5IH07XG4gICAgfSxcbiAgICBjcmVhdGVFbGVtZW50U3RyZWFtKG9yaWdpbmFsU3RyZWFtKSB7XG4gICAgICBsZXQgcHVibGlzaGVkRWxlbWVudHMgPSAwO1xuICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oXG4gICAgICAgIG9yaWdpbmFsU3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgICAgICAgY29uc3QgYXJyYXkgPSBjaHVuay5vYmplY3Q7XG4gICAgICAgICAgICAgICAgICBmb3IgKDsgcHVibGlzaGVkRWxlbWVudHMgPCBhcnJheS5sZW5ndGg7IHB1Ymxpc2hlZEVsZW1lbnRzKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGFycmF5W3B1Ymxpc2hlZEVsZW1lbnRzXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGBVbnN1cHBvcnRlZCBjaHVuayB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn07XG52YXIgZW51bU91dHB1dFN0cmF0ZWd5ID0gKGVudW1WYWx1ZXMpID0+IHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICAvLyB3cmFwIGluIG9iamVjdCB0aGF0IGNvbnRhaW5zIHJlc3VsdCwgc2luY2UgbW9zdCBMTE1zIHdpbGwgbm90XG4gICAgLy8gYmUgYWJsZSB0byBnZW5lcmF0ZSBhbiBlbnVtIHZhbHVlIGRpcmVjdGx5OlxuICAgIC8vIHBvc3NpYmxlIGZ1dHVyZSBvcHRpbWl6YXRpb246IHVzZSBlbnVtcyBkaXJlY3RseSB3aGVuIG1vZGVsIHN1cHBvcnRzIHRvcC1sZXZlbCBlbnVtc1xuICAgIGpzb25TY2hlbWE6IHtcbiAgICAgICRzY2hlbWE6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICByZXN1bHQ6IHsgdHlwZTogXCJzdHJpbmdcIiwgZW51bTogZW51bVZhbHVlcyB9XG4gICAgICB9LFxuICAgICAgcmVxdWlyZWQ6IFtcInJlc3VsdFwiXSxcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZVxuICAgIH0sXG4gICAgdmFsaWRhdGVGaW5hbFJlc3VsdCh2YWx1ZSkge1xuICAgICAgaWYgKCFpc0pTT05PYmplY3QodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5yZXN1bHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogJ3ZhbHVlIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBzdHJpbmcgaW4gdGhlIFwicmVzdWx0XCIgcHJvcGVydHkuJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5yZXN1bHQ7XG4gICAgICByZXR1cm4gZW51bVZhbHVlcy5pbmNsdWRlcyhyZXN1bHQpID8geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogcmVzdWx0IH0gOiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3Ioe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGNhdXNlOiBcInZhbHVlIG11c3QgYmUgYSBzdHJpbmcgaW4gdGhlIGVudW1cIlxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9LFxuICAgIHZhbGlkYXRlUGFydGlhbFJlc3VsdCgpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcih7XG4gICAgICAgIGZ1bmN0aW9uYWxpdHk6IFwicGFydGlhbCByZXN1bHRzIGluIGVudW0gbW9kZVwiXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGNyZWF0ZUVsZW1lbnRTdHJlYW0oKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Ioe1xuICAgICAgICBmdW5jdGlvbmFsaXR5OiBcImVsZW1lbnQgc3RyZWFtcyBpbiBlbnVtIG1vZGVcIlxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIGdldE91dHB1dFN0cmF0ZWd5KHtcbiAgb3V0cHV0LFxuICBzY2hlbWEsXG4gIGVudW1WYWx1ZXNcbn0pIHtcbiAgc3dpdGNoIChvdXRwdXQpIHtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICByZXR1cm4gb2JqZWN0T3V0cHV0U3RyYXRlZ3koYXNTY2hlbWEoc2NoZW1hKSk7XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICByZXR1cm4gYXJyYXlPdXRwdXRTdHJhdGVneShhc1NjaGVtYShzY2hlbWEpKTtcbiAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgcmV0dXJuIGVudW1PdXRwdXRTdHJhdGVneShlbnVtVmFsdWVzKTtcbiAgICBjYXNlIFwibm8tc2NoZW1hXCI6XG4gICAgICByZXR1cm4gbm9TY2hlbWFPdXRwdXRTdHJhdGVneTtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gb3V0cHV0O1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvdXRwdXQ6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3QvdmFsaWRhdGUtb2JqZWN0LWdlbmVyYXRpb24taW5wdXQudHNcbmZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0R2VuZXJhdGlvbklucHV0KHtcbiAgb3V0cHV0LFxuICBtb2RlLFxuICBzY2hlbWEsXG4gIHNjaGVtYU5hbWUsXG4gIHNjaGVtYURlc2NyaXB0aW9uLFxuICBlbnVtVmFsdWVzXG59KSB7XG4gIGlmIChvdXRwdXQgIT0gbnVsbCAmJiBvdXRwdXQgIT09IFwib2JqZWN0XCIgJiYgb3V0cHV0ICE9PSBcImFycmF5XCIgJiYgb3V0cHV0ICE9PSBcImVudW1cIiAmJiBvdXRwdXQgIT09IFwibm8tc2NoZW1hXCIpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgcGFyYW1ldGVyOiBcIm91dHB1dFwiLFxuICAgICAgdmFsdWU6IG91dHB1dCxcbiAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBvdXRwdXQgdHlwZS5cIlxuICAgIH0pO1xuICB9XG4gIGlmIChvdXRwdXQgPT09IFwibm8tc2NoZW1hXCIpIHtcbiAgICBpZiAobW9kZSA9PT0gXCJhdXRvXCIgfHwgbW9kZSA9PT0gXCJ0b29sXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtb2RlXCIsXG4gICAgICAgIHZhbHVlOiBtb2RlLFxuICAgICAgICBtZXNzYWdlOiAnTW9kZSBtdXN0IGJlIFwianNvblwiIGZvciBuby1zY2hlbWEgb3V0cHV0LidcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYSxcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgaXMgbm90IHN1cHBvcnRlZCBmb3Igbm8tc2NoZW1hIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFEZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hRGVzY3JpcHRpb25cIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYURlc2NyaXB0aW9uLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBkZXNjcmlwdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGZvciBuby1zY2hlbWEgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYU5hbWUgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYU5hbWVcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYU5hbWUsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIG5hbWUgaXMgbm90IHN1cHBvcnRlZCBmb3Igbm8tc2NoZW1hIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbnVtVmFsdWVzICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgIHZhbHVlOiBlbnVtVmFsdWVzLFxuICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBuby1zY2hlbWEgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKG91dHB1dCA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBpcyByZXF1aXJlZCBmb3Igb2JqZWN0IG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbnVtVmFsdWVzICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgIHZhbHVlOiBlbnVtVmFsdWVzLFxuICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBvYmplY3Qgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKG91dHB1dCA9PT0gXCJhcnJheVwiKSB7XG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgIG1lc3NhZ2U6IFwiRWxlbWVudCBzY2hlbWEgaXMgcmVxdWlyZWQgZm9yIGFycmF5IG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbnVtVmFsdWVzICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgIHZhbHVlOiBlbnVtVmFsdWVzLFxuICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBhcnJheSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAob3V0cHV0ID09PSBcImVudW1cIikge1xuICAgIGlmIChzY2hlbWEgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBpcyBub3Qgc3VwcG9ydGVkIGZvciBlbnVtIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFEZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hRGVzY3JpcHRpb25cIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYURlc2NyaXB0aW9uLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBkZXNjcmlwdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGZvciBlbnVtIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFOYW1lICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFOYW1lXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWFOYW1lLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBuYW1lIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGVudW0gb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVudW1WYWx1ZXMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgdmFsdWU6IGVudW1WYWx1ZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgYXJlIHJlcXVpcmVkIGZvciBlbnVtIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgZW51bVZhbHVlcykge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgbWVzc2FnZTogXCJFbnVtIHZhbHVlcyBtdXN0IGJlIHN0cmluZ3MuXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L2dlbmVyYXRlLW9iamVjdC50c1xudmFyIG9yaWdpbmFsR2VuZXJhdGVJZCA9IGNyZWF0ZUlkR2VuZXJhdG9yKHsgcHJlZml4OiBcImFpb2JqXCIsIHNpemU6IDI0IH0pO1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVPYmplY3Qoe1xuICBtb2RlbCxcbiAgZW51bTogZW51bVZhbHVlcyxcbiAgLy8gcmVuYW1lIGJjIGVudW0gaXMgcmVzZXJ2ZWQgYnkgdHlwZXNjcmlwdFxuICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICBzY2hlbWFOYW1lLFxuICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgbW9kZSxcbiAgb3V0cHV0ID0gXCJvYmplY3RcIixcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgZXhwZXJpbWVudGFsX3JlcGFpclRleHQ6IHJlcGFpclRleHQsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEsXG4gIHByb3ZpZGVyT3B0aW9ucyA9IGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLFxuICBfaW50ZXJuYWw6IHtcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyA9IG9yaWdpbmFsR2VuZXJhdGVJZCxcbiAgICBjdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gIH0gPSB7fSxcbiAgLi4uc2V0dGluZ3Ncbn0pIHtcbiAgdmFsaWRhdGVPYmplY3RHZW5lcmF0aW9uSW5wdXQoe1xuICAgIG91dHB1dCxcbiAgICBtb2RlLFxuICAgIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gICAgc2NoZW1hTmFtZSxcbiAgICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICBlbnVtVmFsdWVzXG4gIH0pO1xuICBjb25zdCB7IG1heFJldHJpZXMsIHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7IG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcgfSk7XG4gIGNvbnN0IG91dHB1dFN0cmF0ZWd5ID0gZ2V0T3V0cHV0U3RyYXRlZ3koe1xuICAgIG91dHB1dCxcbiAgICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICAgIGVudW1WYWx1ZXNcbiAgfSk7XG4gIGlmIChvdXRwdXRTdHJhdGVneS50eXBlID09PSBcIm5vLXNjaGVtYVwiICYmIG1vZGUgPT09IHZvaWQgMCkge1xuICAgIG1vZGUgPSBcImpzb25cIjtcbiAgfVxuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5nczogeyAuLi5zZXR0aW5ncywgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgIG5hbWU6IFwiYWkuZ2VuZXJhdGVPYmplY3RcIixcbiAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZU9iamVjdFwiLFxuICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICB9KSxcbiAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgXCJhaS5wcm9tcHRcIjoge1xuICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9KVxuICAgICAgICB9LFxuICAgICAgICBcImFpLnNjaGVtYVwiOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hICE9IG51bGwgPyB7IGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hKSB9IDogdm9pZCAwLFxuICAgICAgICBcImFpLnNjaGVtYS5uYW1lXCI6IHNjaGVtYU5hbWUsXG4gICAgICAgIFwiYWkuc2NoZW1hLmRlc2NyaXB0aW9uXCI6IHNjaGVtYURlc2NyaXB0aW9uLFxuICAgICAgICBcImFpLnNldHRpbmdzLm91dHB1dFwiOiBvdXRwdXRTdHJhdGVneS50eXBlLFxuICAgICAgICBcImFpLnNldHRpbmdzLm1vZGVcIjogbW9kZVxuICAgICAgfVxuICAgIH0pLFxuICAgIHRyYWNlcixcbiAgICBmbjogYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgIHZhciBfYTE3LCBfYiwgX2MsIF9kO1xuICAgICAgaWYgKG1vZGUgPT09IFwiYXV0b1wiIHx8IG1vZGUgPT0gbnVsbCkge1xuICAgICAgICBtb2RlID0gbW9kZWwuZGVmYXVsdE9iamVjdEdlbmVyYXRpb25Nb2RlO1xuICAgICAgfVxuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIGxldCBmaW5pc2hSZWFzb247XG4gICAgICBsZXQgdXNhZ2U7XG4gICAgICBsZXQgd2FybmluZ3M7XG4gICAgICBsZXQgcmF3UmVzcG9uc2U7XG4gICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICBsZXQgcmVxdWVzdDtcbiAgICAgIGxldCBsb2dwcm9icztcbiAgICAgIGxldCByZXN1bHRQcm92aWRlck1ldGFkYXRhO1xuICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgIGNhc2UgXCJqc29uXCI6IHtcbiAgICAgICAgICBjb25zdCBzdGFuZGFyZGl6ZWRQcm9tcHQgPSBzdGFuZGFyZGl6ZVByb21wdCh7XG4gICAgICAgICAgICBwcm9tcHQ6IHtcbiAgICAgICAgICAgICAgc3lzdGVtOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hID09IG51bGwgPyBpbmplY3RKc29uSW5zdHJ1Y3Rpb24oeyBwcm9tcHQ6IHN5c3RlbSB9KSA6IG1vZGVsLnN1cHBvcnRzU3RydWN0dXJlZE91dHB1dHMgPyBzeXN0ZW0gOiBpbmplY3RKc29uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICAgICAgICAgIHByb21wdDogc3lzdGVtLFxuICAgICAgICAgICAgICAgIHNjaGVtYTogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgcHJvbXB0LFxuICAgICAgICAgICAgICBtZXNzYWdlc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvb2xzOiB2b2lkIDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgICAgcHJvbXB0OiBzdGFuZGFyZGl6ZWRQcm9tcHQsXG4gICAgICAgICAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJscyxcbiAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNVcmw6IChfYTE3ID0gbW9kZWwuc3VwcG9ydHNVcmwpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LmJpbmQobW9kZWwpXG4gICAgICAgICAgICAvLyBzdXBwb3J0ICd0aGlzJyBjb250ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgZ2VuZXJhdGVSZXN1bHQgPSBhd2FpdCByZXRyeShcbiAgICAgICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgICBuYW1lOiBcImFpLmdlbmVyYXRlT2JqZWN0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmdlbmVyYXRlT2JqZWN0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQuZm9ybWF0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHN0YW5kYXJkaXplZFByb21wdC50eXBlXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQubWVzc2FnZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocHJvbXB0TWVzc2FnZXMpXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJhaS5zZXR0aW5ncy5tb2RlXCI6IG1vZGUsXG4gICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LmZyZXF1ZW5jeV9wZW5hbHR5XCI6IHNldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogc2V0dGluZ3MubWF4VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI6IHNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjogc2V0dGluZ3MudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9rXCI6IHNldHRpbmdzLnRvcEssXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI6IHNldHRpbmdzLnRvcFBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICAgIGZuOiBhc3luYyAoc3BhbjIpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2ExOCwgX2IyLCBfYzIsIF9kMiwgX2UsIF9mO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCBtb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICAgICAgICAgIG1vZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3QtanNvblwiLFxuICAgICAgICAgICAgICAgICAgICBzY2hlbWE6IG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHNjaGVtYU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBzY2hlbWFEZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIC4uLnByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpLFxuICAgICAgICAgICAgICAgICAgaW5wdXRGb3JtYXQ6IHN0YW5kYXJkaXplZFByb21wdC50eXBlLFxuICAgICAgICAgICAgICAgICAgcHJvbXB0OiBwcm9tcHRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgIGlkOiAoX2IyID0gKF9hMTggPSByZXN1bHQyLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExOC5pZCkgIT0gbnVsbCA/IF9iMiA6IGdlbmVyYXRlSWQzKCksXG4gICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IChfZDIgPSAoX2MyID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jMi50aW1lc3RhbXApICE9IG51bGwgPyBfZDIgOiBjdXJyZW50RGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgbW9kZWxJZDogKF9mID0gKF9lID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLm1vZGVsSWQpICE9IG51bGwgPyBfZiA6IG1vZGVsLm1vZGVsSWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQyLnRleHQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IHRoZSBtb2RlbCBkaWQgbm90IHJldHVybiBhIHJlc3BvbnNlLlwiLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2VEYXRhLFxuICAgICAgICAgICAgICAgICAgICB1c2FnZTogY2FsY3VsYXRlTGFuZ3VhZ2VNb2RlbFVzYWdlKHJlc3VsdDIudXNhZ2UpLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IHJlc3VsdDIuZmluaXNoUmVhc29uXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3BhbjIuc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiByZXN1bHQyLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7IG91dHB1dDogKCkgPT4gcmVzdWx0Mi50ZXh0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5pZFwiOiByZXNwb25zZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tb2RlbFwiOiByZXNwb25zZURhdGEubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRpbWVzdGFtcFwiOiByZXNwb25zZURhdGEudGltZXN0YW1wLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogcmVzdWx0Mi51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjogW3Jlc3VsdDIuZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5pZFwiOiByZXNwb25zZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UucHJvbXB0X3Rva2Vuc1wiOiByZXN1bHQyLnVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5jb21wbGV0aW9uX3Rva2Vuc1wiOiByZXN1bHQyLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLnJlc3VsdDIsIG9iamVjdFRleHQ6IHJlc3VsdDIudGV4dCwgcmVzcG9uc2VEYXRhIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXN1bHQgPSBnZW5lcmF0ZVJlc3VsdC5vYmplY3RUZXh0O1xuICAgICAgICAgIGZpbmlzaFJlYXNvbiA9IGdlbmVyYXRlUmVzdWx0LmZpbmlzaFJlYXNvbjtcbiAgICAgICAgICB1c2FnZSA9IGdlbmVyYXRlUmVzdWx0LnVzYWdlO1xuICAgICAgICAgIHdhcm5pbmdzID0gZ2VuZXJhdGVSZXN1bHQud2FybmluZ3M7XG4gICAgICAgICAgcmF3UmVzcG9uc2UgPSBnZW5lcmF0ZVJlc3VsdC5yYXdSZXNwb25zZTtcbiAgICAgICAgICBsb2dwcm9icyA9IGdlbmVyYXRlUmVzdWx0LmxvZ3Byb2JzO1xuICAgICAgICAgIHJlc3VsdFByb3ZpZGVyTWV0YWRhdGEgPSBnZW5lcmF0ZVJlc3VsdC5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgIHJlcXVlc3QgPSAoX2IgPSBnZW5lcmF0ZVJlc3VsdC5yZXF1ZXN0KSAhPSBudWxsID8gX2IgOiB7fTtcbiAgICAgICAgICByZXNwb25zZSA9IGdlbmVyYXRlUmVzdWx0LnJlc3BvbnNlRGF0YTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwidG9vbFwiOiB7XG4gICAgICAgICAgY29uc3Qgc3RhbmRhcmRpemVkUHJvbXB0ID0gc3RhbmRhcmRpemVQcm9tcHQoe1xuICAgICAgICAgICAgcHJvbXB0OiB7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9LFxuICAgICAgICAgICAgdG9vbHM6IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHByb21wdE1lc3NhZ2VzID0gYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgICAgICBwcm9tcHQ6IHN0YW5kYXJkaXplZFByb21wdCxcbiAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNJbWFnZVVybHM6IG1vZGVsLnN1cHBvcnRzSW1hZ2VVcmxzLFxuICAgICAgICAgICAgbW9kZWxTdXBwb3J0c1VybDogKF9jID0gbW9kZWwuc3VwcG9ydHNVcmwpID09IG51bGwgPyB2b2lkIDAgOiBfYy5iaW5kKG1vZGVsKVxuICAgICAgICAgICAgLy8gc3VwcG9ydCAndGhpcycgY29udGV4dCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBpbnB1dEZvcm1hdCA9IHN0YW5kYXJkaXplZFByb21wdC50eXBlO1xuICAgICAgICAgIGNvbnN0IGdlbmVyYXRlUmVzdWx0ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICAgICAoKSA9PiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgICAgbmFtZTogXCJhaS5nZW5lcmF0ZU9iamVjdC5kb0dlbmVyYXRlXCIsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZU9iamVjdC5kb0dlbmVyYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LmZvcm1hdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBpbnB1dEZvcm1hdFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0Lm1lc3NhZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHByb21wdE1lc3NhZ2VzKVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiYWkuc2V0dGluZ3MubW9kZVwiOiBtb2RlLFxuICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBzZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IHNldHRpbmdzLm1heFRva2VucyxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QucHJlc2VuY2VfcGVuYWx0eVwiOiBzZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IHNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3Bfa1wiOiBzZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBzZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICBmbjogYXN5bmMgKHNwYW4yKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hMTgsIF9iMiwgX2MyLCBfZDIsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCBtb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICAgICAgICAgIG1vZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3QtdG9vbFwiLFxuICAgICAgICAgICAgICAgICAgICB0b29sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHNjaGVtYU5hbWUgIT0gbnVsbCA/IHNjaGVtYU5hbWUgOiBcImpzb25cIixcbiAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogc2NoZW1hRGVzY3JpcHRpb24gIT0gbnVsbCA/IHNjaGVtYURlc2NyaXB0aW9uIDogXCJSZXNwb25kIHdpdGggYSBKU09OIG9iamVjdC5cIixcbiAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICAgICAgICAgIGlucHV0Rm9ybWF0LFxuICAgICAgICAgICAgICAgICAgcHJvbXB0OiBwcm9tcHRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdFRleHQgPSAoX2IyID0gKF9hMTggPSByZXN1bHQyLnRvb2xDYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMThbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYjIuYXJncztcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICBpZDogKF9kMiA9IChfYzIgPSByZXN1bHQyLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2MyLmlkKSAhPSBudWxsID8gX2QyIDogZ2VuZXJhdGVJZDMoKSxcbiAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogKF9mID0gKF9lID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLnRpbWVzdGFtcCkgIT0gbnVsbCA/IF9mIDogY3VycmVudERhdGUoKSxcbiAgICAgICAgICAgICAgICAgIG1vZGVsSWQ6IChfaCA9IChfZyA9IHJlc3VsdDIucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZy5tb2RlbElkKSAhPSBudWxsID8gX2ggOiBtb2RlbC5tb2RlbElkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0VGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gb2JqZWN0IGdlbmVyYXRlZDogdGhlIHRvb2wgd2FzIG5vdCBjYWxsZWQuXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZURhdGEsXG4gICAgICAgICAgICAgICAgICAgIHVzYWdlOiBjYWxjdWxhdGVMYW5ndWFnZU1vZGVsVXNhZ2UocmVzdWx0Mi51c2FnZSksXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogcmVzdWx0Mi5maW5pc2hSZWFzb25cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcGFuMi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IHJlc3VsdDIuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2Uub2JqZWN0XCI6IHsgb3V0cHV0OiAoKSA9PiBvYmplY3RUZXh0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5pZFwiOiByZXNwb25zZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tb2RlbFwiOiByZXNwb25zZURhdGEubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRpbWVzdGFtcFwiOiByZXNwb25zZURhdGEudGltZXN0YW1wLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogcmVzdWx0Mi51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjogW3Jlc3VsdDIuZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5pZFwiOiByZXNwb25zZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogcmVzdWx0Mi51c2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5yZXN1bHQyLCBvYmplY3RUZXh0LCByZXNwb25zZURhdGEgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRlUmVzdWx0Lm9iamVjdFRleHQ7XG4gICAgICAgICAgZmluaXNoUmVhc29uID0gZ2VuZXJhdGVSZXN1bHQuZmluaXNoUmVhc29uO1xuICAgICAgICAgIHVzYWdlID0gZ2VuZXJhdGVSZXN1bHQudXNhZ2U7XG4gICAgICAgICAgd2FybmluZ3MgPSBnZW5lcmF0ZVJlc3VsdC53YXJuaW5ncztcbiAgICAgICAgICByYXdSZXNwb25zZSA9IGdlbmVyYXRlUmVzdWx0LnJhd1Jlc3BvbnNlO1xuICAgICAgICAgIGxvZ3Byb2JzID0gZ2VuZXJhdGVSZXN1bHQubG9ncHJvYnM7XG4gICAgICAgICAgcmVzdWx0UHJvdmlkZXJNZXRhZGF0YSA9IGdlbmVyYXRlUmVzdWx0LnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgcmVxdWVzdCA9IChfZCA9IGdlbmVyYXRlUmVzdWx0LnJlcXVlc3QpICE9IG51bGwgPyBfZCA6IHt9O1xuICAgICAgICAgIHJlc3BvbnNlID0gZ2VuZXJhdGVSZXN1bHQucmVzcG9uc2VEYXRhO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2Ugdm9pZCAwOiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJNb2RlbCBkb2VzIG5vdCBoYXZlIGEgZGVmYXVsdCBvYmplY3QgZ2VuZXJhdGlvbiBtb2RlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IG1vZGU7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtb2RlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHByb2Nlc3NSZXN1bHQocmVzdWx0Mikge1xuICAgICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IHNhZmVQYXJzZUpTT04oeyB0ZXh0OiByZXN1bHQyIH0pO1xuICAgICAgICBpZiAoIXBhcnNlUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IGNvdWxkIG5vdCBwYXJzZSB0aGUgcmVzcG9uc2UuXCIsXG4gICAgICAgICAgICBjYXVzZTogcGFyc2VSZXN1bHQuZXJyb3IsXG4gICAgICAgICAgICB0ZXh0OiByZXN1bHQyLFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICB1c2FnZTogY2FsY3VsYXRlTGFuZ3VhZ2VNb2RlbFVzYWdlKHVzYWdlKSxcbiAgICAgICAgICAgIGZpbmlzaFJlYXNvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBvdXRwdXRTdHJhdGVneS52YWxpZGF0ZUZpbmFsUmVzdWx0KFxuICAgICAgICAgIHBhcnNlUmVzdWx0LnZhbHVlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRleHQ6IHJlc3VsdDIsXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIHVzYWdlOiBjYWxjdWxhdGVMYW5ndWFnZU1vZGVsVXNhZ2UodXNhZ2UpXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBpZiAoIXZhbGlkYXRpb25SZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gb2JqZWN0IGdlbmVyYXRlZDogcmVzcG9uc2UgZGlkIG5vdCBtYXRjaCBzY2hlbWEuXCIsXG4gICAgICAgICAgICBjYXVzZTogdmFsaWRhdGlvblJlc3VsdC5lcnJvcixcbiAgICAgICAgICAgIHRleHQ6IHJlc3VsdDIsXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIHVzYWdlOiBjYWxjdWxhdGVMYW5ndWFnZU1vZGVsVXNhZ2UodXNhZ2UpLFxuICAgICAgICAgICAgZmluaXNoUmVhc29uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkYXRpb25SZXN1bHQudmFsdWU7XG4gICAgICB9XG4gICAgICBsZXQgb2JqZWN0MjtcbiAgICAgIHRyeSB7XG4gICAgICAgIG9iamVjdDIgPSBwcm9jZXNzUmVzdWx0KHJlc3VsdCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAocmVwYWlyVGV4dCAhPSBudWxsICYmIE5vT2JqZWN0R2VuZXJhdGVkRXJyb3IuaXNJbnN0YW5jZShlcnJvcikgJiYgKEpTT05QYXJzZUVycm9yLmlzSW5zdGFuY2UoZXJyb3IuY2F1c2UpIHx8IFR5cGVWYWxpZGF0aW9uRXJyb3IyLmlzSW5zdGFuY2UoZXJyb3IuY2F1c2UpKSkge1xuICAgICAgICAgIGNvbnN0IHJlcGFpcmVkVGV4dCA9IGF3YWl0IHJlcGFpclRleHQoe1xuICAgICAgICAgICAgdGV4dDogcmVzdWx0LFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yLmNhdXNlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHJlcGFpcmVkVGV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iamVjdDIgPSBwcm9jZXNzUmVzdWx0KHJlcGFpcmVkVGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IGZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2Uub2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvYmplY3QyKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiB1c2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdEdlbmVyYXRlT2JqZWN0UmVzdWx0KHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QyLFxuICAgICAgICBmaW5pc2hSZWFzb24sXG4gICAgICAgIHVzYWdlOiBjYWxjdWxhdGVMYW5ndWFnZU1vZGVsVXNhZ2UodXNhZ2UpLFxuICAgICAgICB3YXJuaW5ncyxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAuLi5yZXNwb25zZSxcbiAgICAgICAgICBoZWFkZXJzOiByYXdSZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogcmF3UmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICBib2R5OiByYXdSZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogcmF3UmVzcG9uc2UuYm9keVxuICAgICAgICB9LFxuICAgICAgICBsb2dwcm9icyxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcmVzdWx0UHJvdmlkZXJNZXRhZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0R2VuZXJhdGVPYmplY3RSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9iamVjdCA9IG9wdGlvbnMub2JqZWN0O1xuICAgIHRoaXMuZmluaXNoUmVhc29uID0gb3B0aW9ucy5maW5pc2hSZWFzb247XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gICAgdGhpcy53YXJuaW5ncyA9IG9wdGlvbnMud2FybmluZ3M7XG4gICAgdGhpcy5wcm92aWRlck1ldGFkYXRhID0gb3B0aW9ucy5wcm92aWRlck1ldGFkYXRhO1xuICAgIHRoaXMuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgdGhpcy5yZXNwb25zZSA9IG9wdGlvbnMucmVzcG9uc2U7XG4gICAgdGhpcy5yZXF1ZXN0ID0gb3B0aW9ucy5yZXF1ZXN0O1xuICAgIHRoaXMubG9ncHJvYnMgPSBvcHRpb25zLmxvZ3Byb2JzO1xuICB9XG4gIHRvSnNvblJlc3BvbnNlKGluaXQpIHtcbiAgICB2YXIgX2ExNztcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KHRoaXMub2JqZWN0KSwge1xuICAgICAgc3RhdHVzOiAoX2ExNyA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzKSAhPSBudWxsID8gX2ExNyA6IDIwMCxcbiAgICAgIGhlYWRlcnM6IHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzLCB7XG4gICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIlxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3Qvc3RyZWFtLW9iamVjdC50c1xuaW1wb3J0IHsgY3JlYXRlSWRHZW5lcmF0b3IgYXMgY3JlYXRlSWRHZW5lcmF0b3IyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7XG4gIGlzRGVlcEVxdWFsRGF0YSxcbiAgcGFyc2VQYXJ0aWFsSnNvblxufSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuXG4vLyB1dGlsL2RlbGF5ZWQtcHJvbWlzZS50c1xudmFyIERlbGF5ZWRQcm9taXNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN0YXR1cyA9IHsgdHlwZTogXCJwZW5kaW5nXCIgfTtcbiAgICB0aGlzLl9yZXNvbHZlID0gdm9pZCAwO1xuICAgIHRoaXMuX3JlamVjdCA9IHZvaWQgMDtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgaWYgKHRoaXMucHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZTtcbiAgICB9XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdHVzLnR5cGUgPT09IFwicmVzb2x2ZWRcIikge1xuICAgICAgICByZXNvbHZlKHRoaXMuc3RhdHVzLnZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMudHlwZSA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgICAgIHJlamVjdCh0aGlzLnN0YXR1cy5lcnJvcik7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHRoaXMuX3JlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICB9XG4gIHJlc29sdmUodmFsdWUpIHtcbiAgICB2YXIgX2ExNztcbiAgICB0aGlzLnN0YXR1cyA9IHsgdHlwZTogXCJyZXNvbHZlZFwiLCB2YWx1ZSB9O1xuICAgIGlmICh0aGlzLnByb21pc2UpIHtcbiAgICAgIChfYTE3ID0gdGhpcy5fcmVzb2x2ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJlamVjdChlcnJvcikge1xuICAgIHZhciBfYTE3O1xuICAgIHRoaXMuc3RhdHVzID0geyB0eXBlOiBcInJlamVjdGVkXCIsIGVycm9yIH07XG4gICAgaWYgKHRoaXMucHJvbWlzZSkge1xuICAgICAgKF9hMTcgPSB0aGlzLl9yZWplY3QpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LmNhbGwodGhpcywgZXJyb3IpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gdXRpbC9jcmVhdGUtcmVzb2x2YWJsZS1wcm9taXNlLnRzXG5mdW5jdGlvbiBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpIHtcbiAgbGV0IHJlc29sdmU7XG4gIGxldCByZWplY3Q7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gcmVzO1xuICAgIHJlamVjdCA9IHJlajtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcHJvbWlzZSxcbiAgICByZXNvbHZlLFxuICAgIHJlamVjdFxuICB9O1xufVxuXG4vLyBjb3JlL3V0aWwvY3JlYXRlLXN0aXRjaGFibGUtc3RyZWFtLnRzXG5mdW5jdGlvbiBjcmVhdGVTdGl0Y2hhYmxlU3RyZWFtKCkge1xuICBsZXQgaW5uZXJTdHJlYW1SZWFkZXJzID0gW107XG4gIGxldCBjb250cm9sbGVyID0gbnVsbDtcbiAgbGV0IGlzQ2xvc2VkID0gZmFsc2U7XG4gIGxldCB3YWl0Rm9yTmV3U3RyZWFtID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgY29uc3QgcHJvY2Vzc1B1bGwgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKGlzQ2xvc2VkICYmIGlubmVyU3RyZWFtUmVhZGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlubmVyU3RyZWFtUmVhZGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHdhaXRGb3JOZXdTdHJlYW0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgICAgYXdhaXQgd2FpdEZvck5ld1N0cmVhbS5wcm9taXNlO1xuICAgICAgcmV0dXJuIHByb2Nlc3NQdWxsKCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBpbm5lclN0cmVhbVJlYWRlcnNbMF0ucmVhZCgpO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgaW5uZXJTdHJlYW1SZWFkZXJzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGF3YWl0IHByb2Nlc3NQdWxsKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDbG9zZWQpIHtcbiAgICAgICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgaW5uZXJTdHJlYW1SZWFkZXJzLnNoaWZ0KCk7XG4gICAgICBpZiAoaXNDbG9zZWQgJiYgaW5uZXJTdHJlYW1SZWFkZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIHN0cmVhbTogbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIHN0YXJ0KGNvbnRyb2xsZXJQYXJhbSkge1xuICAgICAgICBjb250cm9sbGVyID0gY29udHJvbGxlclBhcmFtO1xuICAgICAgfSxcbiAgICAgIHB1bGw6IHByb2Nlc3NQdWxsLFxuICAgICAgYXN5bmMgY2FuY2VsKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiBpbm5lclN0cmVhbVJlYWRlcnMpIHtcbiAgICAgICAgICBhd2FpdCByZWFkZXIuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5uZXJTdHJlYW1SZWFkZXJzID0gW107XG4gICAgICAgIGlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICBhZGRTdHJlYW06IChpbm5lclN0cmVhbSkgPT4ge1xuICAgICAgaWYgKGlzQ2xvc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhZGQgaW5uZXIgc3RyZWFtOiBvdXRlciBzdHJlYW0gaXMgY2xvc2VkXCIpO1xuICAgICAgfVxuICAgICAgaW5uZXJTdHJlYW1SZWFkZXJzLnB1c2goaW5uZXJTdHJlYW0uZ2V0UmVhZGVyKCkpO1xuICAgICAgd2FpdEZvck5ld1N0cmVhbS5yZXNvbHZlKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHcmFjZWZ1bGx5IGNsb3NlIHRoZSBvdXRlciBzdHJlYW0uIFRoaXMgd2lsbCBsZXQgdGhlIGlubmVyIHN0cmVhbXNcbiAgICAgKiBmaW5pc2ggcHJvY2Vzc2luZyBhbmQgdGhlbiBjbG9zZSB0aGUgb3V0ZXIgc3RyZWFtLlxuICAgICAqL1xuICAgIGNsb3NlOiAoKSA9PiB7XG4gICAgICBpc0Nsb3NlZCA9IHRydWU7XG4gICAgICB3YWl0Rm9yTmV3U3RyZWFtLnJlc29sdmUoKTtcbiAgICAgIGlmIChpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEltbWVkaWF0ZWx5IGNsb3NlIHRoZSBvdXRlciBzdHJlYW0uIFRoaXMgd2lsbCBjYW5jZWwgYWxsIGlubmVyIHN0cmVhbXNcbiAgICAgKiBhbmQgY2xvc2UgdGhlIG91dGVyIHN0cmVhbS5cbiAgICAgKi9cbiAgICB0ZXJtaW5hdGU6ICgpID0+IHtcbiAgICAgIGlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIHdhaXRGb3JOZXdTdHJlYW0ucmVzb2x2ZSgpO1xuICAgICAgaW5uZXJTdHJlYW1SZWFkZXJzLmZvckVhY2goKHJlYWRlcikgPT4gcmVhZGVyLmNhbmNlbCgpKTtcbiAgICAgIGlubmVyU3RyZWFtUmVhZGVycyA9IFtdO1xuICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5jbG9zZSgpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gY29yZS91dGlsL25vdy50c1xuZnVuY3Rpb24gbm93KCkge1xuICB2YXIgX2ExNywgX2I7XG4gIHJldHVybiAoX2IgPSAoX2ExNyA9IGdsb2JhbFRoaXMgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbFRoaXMucGVyZm9ybWFuY2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3Lm5vdygpKSAhPSBudWxsID8gX2IgOiBEYXRlLm5vdygpO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC9zdHJlYW0tb2JqZWN0LnRzXG52YXIgb3JpZ2luYWxHZW5lcmF0ZUlkMiA9IGNyZWF0ZUlkR2VuZXJhdG9yMih7IHByZWZpeDogXCJhaW9ialwiLCBzaXplOiAyNCB9KTtcbmZ1bmN0aW9uIHN0cmVhbU9iamVjdCh7XG4gIG1vZGVsLFxuICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICBzY2hlbWFOYW1lLFxuICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgbW9kZSxcbiAgb3V0cHV0ID0gXCJvYmplY3RcIixcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5LFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSxcbiAgcHJvdmlkZXJPcHRpb25zID0gZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEsXG4gIG9uRXJyb3IsXG4gIG9uRmluaXNoLFxuICBfaW50ZXJuYWw6IHtcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyA9IG9yaWdpbmFsR2VuZXJhdGVJZDIsXG4gICAgY3VycmVudERhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICBub3c6IG5vdzIgPSBub3dcbiAgfSA9IHt9LFxuICAuLi5zZXR0aW5nc1xufSkge1xuICB2YWxpZGF0ZU9iamVjdEdlbmVyYXRpb25JbnB1dCh7XG4gICAgb3V0cHV0LFxuICAgIG1vZGUsXG4gICAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgICBzY2hlbWFOYW1lLFxuICAgIHNjaGVtYURlc2NyaXB0aW9uXG4gIH0pO1xuICBjb25zdCBvdXRwdXRTdHJhdGVneSA9IGdldE91dHB1dFN0cmF0ZWd5KHsgb3V0cHV0LCBzY2hlbWE6IGlucHV0U2NoZW1hIH0pO1xuICBpZiAob3V0cHV0U3RyYXRlZ3kudHlwZSA9PT0gXCJuby1zY2hlbWFcIiAmJiBtb2RlID09PSB2b2lkIDApIHtcbiAgICBtb2RlID0gXCJqc29uXCI7XG4gIH1cbiAgcmV0dXJuIG5ldyBEZWZhdWx0U3RyZWFtT2JqZWN0UmVzdWx0KHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5ncyxcbiAgICBtYXhSZXRyaWVzLFxuICAgIGFib3J0U2lnbmFsLFxuICAgIG91dHB1dFN0cmF0ZWd5LFxuICAgIHN5c3RlbSxcbiAgICBwcm9tcHQsXG4gICAgbWVzc2FnZXMsXG4gICAgc2NoZW1hTmFtZSxcbiAgICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgbW9kZSxcbiAgICBvbkVycm9yLFxuICAgIG9uRmluaXNoLFxuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzLFxuICAgIGN1cnJlbnREYXRlLFxuICAgIG5vdzogbm93MlxuICB9KTtcbn1cbnZhciBEZWZhdWx0U3RyZWFtT2JqZWN0UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbW9kZWwsXG4gICAgaGVhZGVycyxcbiAgICB0ZWxlbWV0cnksXG4gICAgc2V0dGluZ3MsXG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbCxcbiAgICBvdXRwdXRTdHJhdGVneSxcbiAgICBzeXN0ZW0sXG4gICAgcHJvbXB0LFxuICAgIG1lc3NhZ2VzLFxuICAgIHNjaGVtYU5hbWUsXG4gICAgc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgcHJvdmlkZXJPcHRpb25zLFxuICAgIG1vZGUsXG4gICAgb25FcnJvcixcbiAgICBvbkZpbmlzaCxcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyxcbiAgICBjdXJyZW50RGF0ZSxcbiAgICBub3c6IG5vdzJcbiAgfSkge1xuICAgIHRoaXMub2JqZWN0UHJvbWlzZSA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIHRoaXMudXNhZ2VQcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5wcm92aWRlck1ldGFkYXRhUHJvbWlzZSA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIHRoaXMud2FybmluZ3NQcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5yZXF1ZXN0UHJvbWlzZSA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIHRoaXMucmVzcG9uc2VQcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgY29uc3QgeyBtYXhSZXRyaWVzLCByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoe1xuICAgICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZ1xuICAgIH0pO1xuICAgIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgbW9kZWwsXG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBoZWFkZXJzLFxuICAgICAgc2V0dGluZ3M6IHsgLi4uc2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICAgIH0pO1xuICAgIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IHN0aXRjaGFibGVTdHJlYW0gPSBjcmVhdGVTdGl0Y2hhYmxlU3RyZWFtKCk7XG4gICAgY29uc3QgZXZlbnRQcm9jZXNzb3IgPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgb25FcnJvciA9PSBudWxsID8gdm9pZCAwIDogb25FcnJvcih7IGVycm9yOiBjaHVuay5lcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYmFzZVN0cmVhbSA9IHN0aXRjaGFibGVTdHJlYW0uc3RyZWFtLnBpcGVUaHJvdWdoKGV2ZW50UHJvY2Vzc29yKTtcbiAgICByZWNvcmRTcGFuKHtcbiAgICAgIG5hbWU6IFwiYWkuc3RyZWFtT2JqZWN0XCIsXG4gICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLnN0cmVhbU9iamVjdFwiLFxuICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgfSksXG4gICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgIFwiYWkucHJvbXB0XCI6IHtcbiAgICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJhaS5zY2hlbWFcIjogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSAhPSBudWxsID8geyBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSkgfSA6IHZvaWQgMCxcbiAgICAgICAgICBcImFpLnNjaGVtYS5uYW1lXCI6IHNjaGVtYU5hbWUsXG4gICAgICAgICAgXCJhaS5zY2hlbWEuZGVzY3JpcHRpb25cIjogc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgICAgICAgXCJhaS5zZXR0aW5ncy5vdXRwdXRcIjogb3V0cHV0U3RyYXRlZ3kudHlwZSxcbiAgICAgICAgICBcImFpLnNldHRpbmdzLm1vZGVcIjogbW9kZVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIHRyYWNlcixcbiAgICAgIGVuZFdoZW5Eb25lOiBmYWxzZSxcbiAgICAgIGZuOiBhc3luYyAocm9vdFNwYW4pID0+IHtcbiAgICAgICAgdmFyIF9hMTcsIF9iO1xuICAgICAgICBpZiAobW9kZSA9PT0gXCJhdXRvXCIgfHwgbW9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgbW9kZSA9IG1vZGVsLmRlZmF1bHRPYmplY3RHZW5lcmF0aW9uTW9kZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2FsbE9wdGlvbnM7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lcjtcbiAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgY2FzZSBcImpzb25cIjoge1xuICAgICAgICAgICAgY29uc3Qgc3RhbmRhcmRpemVkUHJvbXB0ID0gc3RhbmRhcmRpemVQcm9tcHQoe1xuICAgICAgICAgICAgICBwcm9tcHQ6IHtcbiAgICAgICAgICAgICAgICBzeXN0ZW06IG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWEgPT0gbnVsbCA/IGluamVjdEpzb25JbnN0cnVjdGlvbih7IHByb21wdDogc3lzdGVtIH0pIDogbW9kZWwuc3VwcG9ydHNTdHJ1Y3R1cmVkT3V0cHV0cyA/IHN5c3RlbSA6IGluamVjdEpzb25JbnN0cnVjdGlvbih7XG4gICAgICAgICAgICAgICAgICBwcm9tcHQ6IHN5c3RlbSxcbiAgICAgICAgICAgICAgICAgIHNjaGVtYTogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlc1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB0b29sczogdm9pZCAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhbGxPcHRpb25zID0ge1xuICAgICAgICAgICAgICBtb2RlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3QtanNvblwiLFxuICAgICAgICAgICAgICAgIHNjaGVtYTogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSxcbiAgICAgICAgICAgICAgICBuYW1lOiBzY2hlbWFOYW1lLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBzY2hlbWFEZXNjcmlwdGlvblxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICAgICAgaW5wdXRGb3JtYXQ6IHN0YW5kYXJkaXplZFByb21wdC50eXBlLFxuICAgICAgICAgICAgICBwcm9tcHQ6IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgICAgICAgIHByb21wdDogc3RhbmRhcmRpemVkUHJvbXB0LFxuICAgICAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNJbWFnZVVybHM6IG1vZGVsLnN1cHBvcnRzSW1hZ2VVcmxzLFxuICAgICAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNVcmw6IChfYTE3ID0gbW9kZWwuc3VwcG9ydHNVcmwpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LmJpbmQobW9kZWwpXG4gICAgICAgICAgICAgICAgLy8gc3VwcG9ydCAndGhpcycgY29udGV4dFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJPcHRpb25zLFxuICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVyID0ge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06IChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLnRleHREZWx0YSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInJlc3BvbnNlLW1ldGFkYXRhXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ0b29sXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YW5kYXJkaXplZFByb21wdCA9IHN0YW5kYXJkaXplUHJvbXB0KHtcbiAgICAgICAgICAgICAgcHJvbXB0OiB7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9LFxuICAgICAgICAgICAgICB0b29sczogdm9pZCAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhbGxPcHRpb25zID0ge1xuICAgICAgICAgICAgICBtb2RlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3QtdG9vbFwiLFxuICAgICAgICAgICAgICAgIHRvb2w6IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgIG5hbWU6IHNjaGVtYU5hbWUgIT0gbnVsbCA/IHNjaGVtYU5hbWUgOiBcImpzb25cIixcbiAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBzY2hlbWFEZXNjcmlwdGlvbiAhPSBudWxsID8gc2NoZW1hRGVzY3JpcHRpb24gOiBcIlJlc3BvbmQgd2l0aCBhIEpTT04gb2JqZWN0LlwiLFxuICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyczogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgICAgICAgIGlucHV0Rm9ybWF0OiBzdGFuZGFyZGl6ZWRQcm9tcHQudHlwZSxcbiAgICAgICAgICAgICAgcHJvbXB0OiBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgICAgICAgICBwcm9tcHQ6IHN0YW5kYXJkaXplZFByb21wdCxcbiAgICAgICAgICAgICAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJscyxcbiAgICAgICAgICAgICAgICBtb2RlbFN1cHBvcnRzVXJsOiAoX2IgPSBtb2RlbC5zdXBwb3J0c1VybCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmJpbmQobW9kZWwpXG4gICAgICAgICAgICAgICAgLy8gc3VwcG9ydCAndGhpcycgY29udGV4dCxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyT3B0aW9ucyxcbiAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cmFuc2Zvcm1lciA9IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsLWRlbHRhXCI6XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay5hcmdzVGV4dERlbHRhKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwicmVzcG9uc2UtbWV0YWRhdGFcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSB2b2lkIDA6IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgXCJNb2RlbCBkb2VzIG5vdCBoYXZlIGEgZGVmYXVsdCBvYmplY3QgZ2VuZXJhdGlvbiBtb2RlLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gbW9kZTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbW9kZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmVzdWx0OiB7IHN0cmVhbSwgd2FybmluZ3MsIHJhd1Jlc3BvbnNlLCByZXF1ZXN0IH0sXG4gICAgICAgICAgZG9TdHJlYW1TcGFuLFxuICAgICAgICAgIHN0YXJ0VGltZXN0YW1wTXNcbiAgICAgICAgfSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5zdHJlYW1PYmplY3QuZG9TdHJlYW1cIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuc3RyZWFtT2JqZWN0LmRvU3RyZWFtXCIsXG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBcImFpLnByb21wdC5mb3JtYXRcIjoge1xuICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IGNhbGxPcHRpb25zLmlucHV0Rm9ybWF0XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoY2FsbE9wdGlvbnMucHJvbXB0KVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJhaS5zZXR0aW5ncy5tb2RlXCI6IG1vZGUsXG4gICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnN5c3RlbVwiOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBzZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubWF4X3Rva2Vuc1wiOiBzZXR0aW5ncy5tYXhUb2tlbnMsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI6IHNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IHNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX2tcIjogc2V0dGluZ3MudG9wSyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI6IHNldHRpbmdzLnRvcFBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICBlbmRXaGVuRG9uZTogZmFsc2UsXG4gICAgICAgICAgICBmbjogYXN5bmMgKGRvU3RyZWFtU3BhbjIpID0+ICh7XG4gICAgICAgICAgICAgIHN0YXJ0VGltZXN0YW1wTXM6IG5vdzIoKSxcbiAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuOiBkb1N0cmVhbVNwYW4yLFxuICAgICAgICAgICAgICByZXN1bHQ6IGF3YWl0IG1vZGVsLmRvU3RyZWFtKGNhbGxPcHRpb25zKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBzZWxmLnJlcXVlc3RQcm9taXNlLnJlc29sdmUocmVxdWVzdCAhPSBudWxsID8gcmVxdWVzdCA6IHt9KTtcbiAgICAgICAgbGV0IHVzYWdlO1xuICAgICAgICBsZXQgZmluaXNoUmVhc29uO1xuICAgICAgICBsZXQgcHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgbGV0IG9iamVjdDI7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgbGV0IGFjY3VtdWxhdGVkVGV4dCA9IFwiXCI7XG4gICAgICAgIGxldCB0ZXh0RGVsdGEgPSBcIlwiO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQzKCksXG4gICAgICAgICAgdGltZXN0YW1wOiBjdXJyZW50RGF0ZSgpLFxuICAgICAgICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWRcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGxhdGVzdE9iamVjdEpzb24gPSB2b2lkIDA7XG4gICAgICAgIGxldCBsYXRlc3RPYmplY3QgPSB2b2lkIDA7XG4gICAgICAgIGxldCBpc0ZpcnN0Q2h1bmsgPSB0cnVlO1xuICAgICAgICBsZXQgaXNGaXJzdERlbHRhID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRTdHJlYW0gPSBzdHJlYW0ucGlwZVRocm91Z2gobmV3IFRyYW5zZm9ybVN0cmVhbSh0cmFuc2Zvcm1lcikpLnBpcGVUaHJvdWdoKFxuICAgICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIHZhciBfYTE4LCBfYjIsIF9jO1xuICAgICAgICAgICAgICBpZiAoaXNGaXJzdENodW5rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNUb0ZpcnN0Q2h1bmsgPSBub3cyKCkgLSBzdGFydFRpbWVzdGFtcE1zO1xuICAgICAgICAgICAgICAgIGlzRmlyc3RDaHVuayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5hZGRFdmVudChcImFpLnN0cmVhbS5maXJzdENodW5rXCIsIHtcbiAgICAgICAgICAgICAgICAgIFwiYWkuc3RyZWFtLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgXCJhaS5zdHJlYW0ubXNUb0ZpcnN0Q2h1bmtcIjogbXNUb0ZpcnN0Q2h1bmtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRUZXh0ICs9IGNodW5rO1xuICAgICAgICAgICAgICAgIHRleHREZWx0YSArPSBjaHVuaztcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlOiBjdXJyZW50T2JqZWN0SnNvbiwgc3RhdGU6IHBhcnNlU3RhdGUgfSA9IHBhcnNlUGFydGlhbEpzb24oYWNjdW11bGF0ZWRUZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE9iamVjdEpzb24gIT09IHZvaWQgMCAmJiAhaXNEZWVwRXF1YWxEYXRhKGxhdGVzdE9iamVjdEpzb24sIGN1cnJlbnRPYmplY3RKc29uKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IG91dHB1dFN0cmF0ZWd5LnZhbGlkYXRlUGFydGlhbFJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjdXJyZW50T2JqZWN0SnNvbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dERlbHRhLFxuICAgICAgICAgICAgICAgICAgICBsYXRlc3RPYmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGlzRmlyc3REZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgaXNGaW5hbERlbHRhOiBwYXJzZVN0YXRlID09PSBcInN1Y2Nlc3NmdWwtcGFyc2VcIlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzICYmICFpc0RlZXBFcXVhbERhdGEoXG4gICAgICAgICAgICAgICAgICAgIGxhdGVzdE9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC52YWx1ZS5wYXJ0aWFsXG4gICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhdGVzdE9iamVjdEpzb24gPSBjdXJyZW50T2JqZWN0SnNvbjtcbiAgICAgICAgICAgICAgICAgICAgbGF0ZXN0T2JqZWN0ID0gdmFsaWRhdGlvblJlc3VsdC52YWx1ZS5wYXJ0aWFsO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBsYXRlc3RPYmplY3RcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dERlbHRhOiB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlLnRleHREZWx0YVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dERlbHRhID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaXNGaXJzdERlbHRhID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVzcG9uc2UtbWV0YWRhdGFcIjoge1xuICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAoX2ExOCA9IGNodW5rLmlkKSAhPSBudWxsID8gX2ExOCA6IHJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IChfYjIgPSBjaHVuay50aW1lc3RhbXApICE9IG51bGwgPyBfYjIgOiByZXNwb25zZS50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsSWQ6IChfYyA9IGNodW5rLm1vZGVsSWQpICE9IG51bGwgPyBfYyA6IHJlc3BvbnNlLm1vZGVsSWRcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgICAgICAgICBpZiAodGV4dERlbHRhICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwidGV4dC1kZWx0YVwiLCB0ZXh0RGVsdGEgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb24gPSBjaHVuay5maW5pc2hSZWFzb247XG4gICAgICAgICAgICAgICAgICB1c2FnZSA9IGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZShjaHVuay51c2FnZSk7XG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhID0gY2h1bmsucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IC4uLmNodW5rLCB1c2FnZSwgcmVzcG9uc2UgfSk7XG4gICAgICAgICAgICAgICAgICBzZWxmLnVzYWdlUHJvbWlzZS5yZXNvbHZlKHVzYWdlKTtcbiAgICAgICAgICAgICAgICAgIHNlbGYucHJvdmlkZXJNZXRhZGF0YVByb21pc2UucmVzb2x2ZShwcm92aWRlck1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgIHNlbGYucmVzcG9uc2VQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAuLi5yZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmF3UmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJhd1Jlc3BvbnNlLmhlYWRlcnNcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IG91dHB1dFN0cmF0ZWd5LnZhbGlkYXRlRmluYWxSZXN1bHQoXG4gICAgICAgICAgICAgICAgICAgIGxhdGVzdE9iamVjdEpzb24sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBhY2N1bXVsYXRlZFRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgdXNhZ2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0MiA9IHZhbGlkYXRpb25SZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub2JqZWN0UHJvbWlzZS5yZXNvbHZlKG9iamVjdDIpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiByZXNwb25zZSBkaWQgbm90IG1hdGNoIHNjaGVtYS5cIixcbiAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogdmFsaWRhdGlvblJlc3VsdC5lcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBhY2N1bXVsYXRlZFRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgdXNhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9iamVjdFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gaW52b2tlIG9uRmluaXNoIGNhbGxiYWNrIGFuZCByZXNvbHZlIHRvb2xSZXN1bHRzIHByb21pc2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGFib3V0IHRvIGNsb3NlOlxuICAgICAgICAgICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsVXNhZ2UgPSB1c2FnZSAhPSBudWxsID8gdXNhZ2UgOiB7XG4gICAgICAgICAgICAgICAgICBwcm9tcHRUb2tlbnM6IE5hTixcbiAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IE5hTixcbiAgICAgICAgICAgICAgICAgIHRvdGFsVG9rZW5zOiBOYU5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IGZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KG9iamVjdDIpXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmlkXCI6IHJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2UubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRpbWVzdGFtcFwiOiByZXNwb25zZS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiBmaW5hbFVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogZmluYWxVc2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5pZFwiOiByZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5tb2RlbFwiOiByZXNwb25zZS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2Vuc1wiOiBmaW5hbFVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5vdXRwdXRfdG9rZW5zXCI6IGZpbmFsVXNhZ2UuY29tcGxldGlvblRva2Vuc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJvb3RTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogZmluYWxVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IGZpbmFsVXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KG9iamVjdDIpXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYXdhaXQgKG9uRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaCh7XG4gICAgICAgICAgICAgICAgICB1c2FnZTogZmluYWxVc2FnZSxcbiAgICAgICAgICAgICAgICAgIG9iamVjdDogb2JqZWN0MixcbiAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJhd1Jlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByYXdSZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgd2FybmluZ3MsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwiZXJyb3JcIiwgZXJyb3I6IGVycm9yMiB9KTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByb290U3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHN0aXRjaGFibGVTdHJlYW0uYWRkU3RyZWFtKHRyYW5zZm9ybWVkU3RyZWFtKTtcbiAgICAgIH1cbiAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgIHN0aXRjaGFibGVTdHJlYW0uYWRkU3RyZWFtKFxuICAgICAgICBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwiZXJyb3JcIiwgZXJyb3IgfSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHN0aXRjaGFibGVTdHJlYW0uY2xvc2UoKTtcbiAgICB9KTtcbiAgICB0aGlzLm91dHB1dFN0cmF0ZWd5ID0gb3V0cHV0U3RyYXRlZ3k7XG4gIH1cbiAgZ2V0IG9iamVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5vYmplY3RQcm9taXNlLnZhbHVlO1xuICB9XG4gIGdldCB1c2FnZSgpIHtcbiAgICByZXR1cm4gdGhpcy51c2FnZVByb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyTWV0YWRhdGFQcm9taXNlLnZhbHVlO1xuICB9XG4gIGdldCBwcm92aWRlck1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyTWV0YWRhdGFQcm9taXNlLnZhbHVlO1xuICB9XG4gIGdldCB3YXJuaW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy53YXJuaW5nc1Byb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IHJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdFByb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IHJlc3BvbnNlKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlUHJvbWlzZS52YWx1ZTtcbiAgfVxuICBnZXQgcGFydGlhbE9iamVjdFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShcbiAgICAgIHRoaXMuYmFzZVN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay5vYmplY3QpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY2h1bmsgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgZ2V0IGVsZW1lbnRTdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0U3RyYXRlZ3kuY3JlYXRlRWxlbWVudFN0cmVhbSh0aGlzLmJhc2VTdHJlYW0pO1xuICB9XG4gIGdldCB0ZXh0U3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKFxuICAgICAgdGhpcy5iYXNlU3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay50ZXh0RGVsdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gY2h1bms7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjaHVuayB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBnZXQgZnVsbFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbSh0aGlzLmJhc2VTdHJlYW0pO1xuICB9XG4gIHBpcGVUZXh0U3RyZWFtVG9SZXNwb25zZShyZXNwb25zZSwgaW5pdCkge1xuICAgIHdyaXRlVG9TZXJ2ZXJSZXNwb25zZSh7XG4gICAgICByZXNwb25zZSxcbiAgICAgIHN0YXR1czogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiBwcmVwYXJlT3V0Z29pbmdIdHRwSGVhZGVycyhpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnMsIHtcbiAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KSxcbiAgICAgIHN0cmVhbTogdGhpcy50ZXh0U3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKVxuICAgIH0pO1xuICB9XG4gIHRvVGV4dFN0cmVhbVJlc3BvbnNlKGluaXQpIHtcbiAgICB2YXIgX2ExNztcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMudGV4dFN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSksIHtcbiAgICAgIHN0YXR1czogKF9hMTcgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTcgOiAyMDAsXG4gICAgICBoZWFkZXJzOiBwcmVwYXJlUmVzcG9uc2VIZWFkZXJzKGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVycywge1xuICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9nZW5lcmF0ZS10ZXh0LnRzXG5pbXBvcnQgeyBjcmVhdGVJZEdlbmVyYXRvciBhcyBjcmVhdGVJZEdlbmVyYXRvcjMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBlcnJvcnMvbm8tb3V0cHV0LXNwZWNpZmllZC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yOSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTkgPSBcIkFJX05vT3V0cHV0U3BlY2lmaWVkRXJyb3JcIjtcbnZhciBtYXJrZXI5ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU5fWA7XG52YXIgc3ltYm9sOSA9IFN5bWJvbC5mb3IobWFya2VyOSk7XG52YXIgX2E5O1xudmFyIE5vT3V0cHV0U3BlY2lmaWVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I5IHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSA9IFwiTm8gb3V0cHV0IHNwZWNpZmllZC5cIiB9ID0ge30pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU5LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E5XSA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjkuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI5KTtcbiAgfVxufTtcbl9hOSA9IHN5bWJvbDk7XG5cbi8vIGVycm9ycy90b29sLWV4ZWN1dGlvbi1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTAsIGdldEVycm9yTWVzc2FnZSBhcyBnZXRFcnJvck1lc3NhZ2UyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMTAgPSBcIkFJX1Rvb2xFeGVjdXRpb25FcnJvclwiO1xudmFyIG1hcmtlcjEwID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMH1gO1xudmFyIHN5bWJvbDEwID0gU3ltYm9sLmZvcihtYXJrZXIxMCk7XG52YXIgX2ExMDtcbnZhciBUb29sRXhlY3V0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxMCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0b29sQXJncyxcbiAgICB0b29sTmFtZSxcbiAgICB0b29sQ2FsbElkLFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBgRXJyb3IgZXhlY3V0aW5nIHRvb2wgJHt0b29sTmFtZX06ICR7Z2V0RXJyb3JNZXNzYWdlMihjYXVzZSl9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTAsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2ExMF0gPSB0cnVlO1xuICAgIHRoaXMudG9vbEFyZ3MgPSB0b29sQXJncztcbiAgICB0aGlzLnRvb2xOYW1lID0gdG9vbE5hbWU7XG4gICAgdGhpcy50b29sQ2FsbElkID0gdG9vbENhbGxJZDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMTAuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMCk7XG4gIH1cbn07XG5fYTEwID0gc3ltYm9sMTA7XG5cbi8vIGNvcmUvcHJvbXB0L3ByZXBhcmUtdG9vbHMtYW5kLXRvb2wtY2hvaWNlLnRzXG5pbXBvcnQgeyBhc1NjaGVtYSBhcyBhc1NjaGVtYTIgfSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuXG4vLyBjb3JlL3V0aWwvaXMtbm9uLWVtcHR5LW9iamVjdC50c1xuZnVuY3Rpb24gaXNOb25FbXB0eU9iamVjdChvYmplY3QyKSB7XG4gIHJldHVybiBvYmplY3QyICE9IG51bGwgJiYgT2JqZWN0LmtleXMob2JqZWN0MikubGVuZ3RoID4gMDtcbn1cblxuLy8gY29yZS9wcm9tcHQvcHJlcGFyZS10b29scy1hbmQtdG9vbC1jaG9pY2UudHNcbmZ1bmN0aW9uIHByZXBhcmVUb29sc0FuZFRvb2xDaG9pY2Uoe1xuICB0b29scyxcbiAgdG9vbENob2ljZSxcbiAgYWN0aXZlVG9vbHNcbn0pIHtcbiAgaWYgKCFpc05vbkVtcHR5T2JqZWN0KHRvb2xzKSkge1xuICAgIHJldHVybiB7XG4gICAgICB0b29sczogdm9pZCAwLFxuICAgICAgdG9vbENob2ljZTogdm9pZCAwXG4gICAgfTtcbiAgfVxuICBjb25zdCBmaWx0ZXJlZFRvb2xzID0gYWN0aXZlVG9vbHMgIT0gbnVsbCA/IE9iamVjdC5lbnRyaWVzKHRvb2xzKS5maWx0ZXIoXG4gICAgKFtuYW1lMTddKSA9PiBhY3RpdmVUb29scy5pbmNsdWRlcyhuYW1lMTcpXG4gICkgOiBPYmplY3QuZW50cmllcyh0b29scyk7XG4gIHJldHVybiB7XG4gICAgdG9vbHM6IGZpbHRlcmVkVG9vbHMubWFwKChbbmFtZTE3LCB0b29sMl0pID0+IHtcbiAgICAgIGNvbnN0IHRvb2xUeXBlID0gdG9vbDIudHlwZTtcbiAgICAgIHN3aXRjaCAodG9vbFR5cGUpIHtcbiAgICAgICAgY2FzZSB2b2lkIDA6XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICBuYW1lOiBuYW1lMTcsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogdG9vbDIuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBhc1NjaGVtYTIodG9vbDIucGFyYW1ldGVycykuanNvblNjaGVtYVxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJwcm92aWRlci1kZWZpbmVkXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwicHJvdmlkZXItZGVmaW5lZFwiLFxuICAgICAgICAgICAgbmFtZTogbmFtZTE3LFxuICAgICAgICAgICAgaWQ6IHRvb2wyLmlkLFxuICAgICAgICAgICAgYXJnczogdG9vbDIuYXJnc1xuICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSB0b29sVHlwZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHRvb2wgdHlwZTogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICB0b29sQ2hvaWNlOiB0b29sQ2hvaWNlID09IG51bGwgPyB7IHR5cGU6IFwiYXV0b1wiIH0gOiB0eXBlb2YgdG9vbENob2ljZSA9PT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogdG9vbENob2ljZSB9IDogeyB0eXBlOiBcInRvb2xcIiwgdG9vbE5hbWU6IHRvb2xDaG9pY2UudG9vbE5hbWUgfVxuICB9O1xufVxuXG4vLyBjb3JlL3V0aWwvc3BsaXQtb24tbGFzdC13aGl0ZXNwYWNlLnRzXG52YXIgbGFzdFdoaXRlc3BhY2VSZWdleHAgPSAvXihbXFxzXFxTXSo/KShcXHMrKShcXFMqKSQvO1xuZnVuY3Rpb24gc3BsaXRPbkxhc3RXaGl0ZXNwYWNlKHRleHQyKSB7XG4gIGNvbnN0IG1hdGNoID0gdGV4dDIubWF0Y2gobGFzdFdoaXRlc3BhY2VSZWdleHApO1xuICByZXR1cm4gbWF0Y2ggPyB7IHByZWZpeDogbWF0Y2hbMV0sIHdoaXRlc3BhY2U6IG1hdGNoWzJdLCBzdWZmaXg6IG1hdGNoWzNdIH0gOiB2b2lkIDA7XG59XG5cbi8vIGNvcmUvdXRpbC9yZW1vdmUtdGV4dC1hZnRlci1sYXN0LXdoaXRlc3BhY2UudHNcbmZ1bmN0aW9uIHJlbW92ZVRleHRBZnRlckxhc3RXaGl0ZXNwYWNlKHRleHQyKSB7XG4gIGNvbnN0IG1hdGNoID0gc3BsaXRPbkxhc3RXaGl0ZXNwYWNlKHRleHQyKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2gucHJlZml4ICsgbWF0Y2gud2hpdGVzcGFjZSA6IHRleHQyO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvcGFyc2UtdG9vbC1jYWxsLnRzXG5pbXBvcnQgeyBzYWZlUGFyc2VKU09OIGFzIHNhZmVQYXJzZUpTT04yLCBzYWZlVmFsaWRhdGVUeXBlcyBhcyBzYWZlVmFsaWRhdGVUeXBlczMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuaW1wb3J0IHsgYXNTY2hlbWEgYXMgYXNTY2hlbWEzIH0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcblxuLy8gZXJyb3JzL2ludmFsaWQtdG9vbC1hcmd1bWVudHMtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjExLCBnZXRFcnJvck1lc3NhZ2UgYXMgZ2V0RXJyb3JNZXNzYWdlMyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTExID0gXCJBSV9JbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yXCI7XG52YXIgbWFya2VyMTEgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTExfWA7XG52YXIgc3ltYm9sMTEgPSBTeW1ib2wuZm9yKG1hcmtlcjExKTtcbnZhciBfYTExO1xudmFyIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxMSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0b29sQXJncyxcbiAgICB0b29sTmFtZSxcbiAgICBjYXVzZSxcbiAgICBtZXNzYWdlID0gYEludmFsaWQgYXJndW1lbnRzIGZvciB0b29sICR7dG9vbE5hbWV9OiAke2dldEVycm9yTWVzc2FnZTMoXG4gICAgICBjYXVzZVxuICAgICl9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTEsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2ExMV0gPSB0cnVlO1xuICAgIHRoaXMudG9vbEFyZ3MgPSB0b29sQXJncztcbiAgICB0aGlzLnRvb2xOYW1lID0gdG9vbE5hbWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjExLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTEpO1xuICB9XG59O1xuX2ExMSA9IHN5bWJvbDExO1xuXG4vLyBlcnJvcnMvbm8tc3VjaC10b29sLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTEyID0gXCJBSV9Ob1N1Y2hUb29sRXJyb3JcIjtcbnZhciBtYXJrZXIxMiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTJ9YDtcbnZhciBzeW1ib2wxMiA9IFN5bWJvbC5mb3IobWFya2VyMTIpO1xudmFyIF9hMTI7XG52YXIgTm9TdWNoVG9vbEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMTIge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdG9vbE5hbWUsXG4gICAgYXZhaWxhYmxlVG9vbHMgPSB2b2lkIDAsXG4gICAgbWVzc2FnZSA9IGBNb2RlbCB0cmllZCB0byBjYWxsIHVuYXZhaWxhYmxlIHRvb2wgJyR7dG9vbE5hbWV9Jy4gJHthdmFpbGFibGVUb29scyA9PT0gdm9pZCAwID8gXCJObyB0b29scyBhcmUgYXZhaWxhYmxlLlwiIDogYEF2YWlsYWJsZSB0b29sczogJHthdmFpbGFibGVUb29scy5qb2luKFwiLCBcIil9LmB9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTIsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTEyXSA9IHRydWU7XG4gICAgdGhpcy50b29sTmFtZSA9IHRvb2xOYW1lO1xuICAgIHRoaXMuYXZhaWxhYmxlVG9vbHMgPSBhdmFpbGFibGVUb29scztcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMTIuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMik7XG4gIH1cbn07XG5fYTEyID0gc3ltYm9sMTI7XG5cbi8vIGVycm9ycy90b29sLWNhbGwtcmVwYWlyLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxMywgZ2V0RXJyb3JNZXNzYWdlIGFzIGdldEVycm9yTWVzc2FnZTQgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUxMyA9IFwiQUlfVG9vbENhbGxSZXBhaXJFcnJvclwiO1xudmFyIG1hcmtlcjEzID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxM31gO1xudmFyIHN5bWJvbDEzID0gU3ltYm9sLmZvcihtYXJrZXIxMyk7XG52YXIgX2ExMztcbnZhciBUb29sQ2FsbFJlcGFpckVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMTMge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY2F1c2UsXG4gICAgb3JpZ2luYWxFcnJvcixcbiAgICBtZXNzYWdlID0gYEVycm9yIHJlcGFpcmluZyB0b29sIGNhbGw6ICR7Z2V0RXJyb3JNZXNzYWdlNChjYXVzZSl9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTMsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2ExM10gPSB0cnVlO1xuICAgIHRoaXMub3JpZ2luYWxFcnJvciA9IG9yaWdpbmFsRXJyb3I7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjEzLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTMpO1xuICB9XG59O1xuX2ExMyA9IHN5bWJvbDEzO1xuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvcGFyc2UtdG9vbC1jYWxsLnRzXG5hc3luYyBmdW5jdGlvbiBwYXJzZVRvb2xDYWxsKHtcbiAgdG9vbENhbGwsXG4gIHRvb2xzLFxuICByZXBhaXJUb29sQ2FsbCxcbiAgc3lzdGVtLFxuICBtZXNzYWdlc1xufSkge1xuICBpZiAodG9vbHMgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBOb1N1Y2hUb29sRXJyb3IoeyB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUgfSk7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgZG9QYXJzZVRvb2xDYWxsKHsgdG9vbENhbGwsIHRvb2xzIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChyZXBhaXJUb29sQ2FsbCA9PSBudWxsIHx8ICEoTm9TdWNoVG9vbEVycm9yLmlzSW5zdGFuY2UoZXJyb3IpIHx8IEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IuaXNJbnN0YW5jZShlcnJvcikpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgbGV0IHJlcGFpcmVkVG9vbENhbGwgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICByZXBhaXJlZFRvb2xDYWxsID0gYXdhaXQgcmVwYWlyVG9vbENhbGwoe1xuICAgICAgICB0b29sQ2FsbCxcbiAgICAgICAgdG9vbHMsXG4gICAgICAgIHBhcmFtZXRlclNjaGVtYTogKHsgdG9vbE5hbWUgfSkgPT4gYXNTY2hlbWEzKHRvb2xzW3Rvb2xOYW1lXS5wYXJhbWV0ZXJzKS5qc29uU2NoZW1hLFxuICAgICAgICBzeXN0ZW0sXG4gICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICBlcnJvclxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAocmVwYWlyRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBUb29sQ2FsbFJlcGFpckVycm9yKHtcbiAgICAgICAgY2F1c2U6IHJlcGFpckVycm9yLFxuICAgICAgICBvcmlnaW5hbEVycm9yOiBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChyZXBhaXJlZFRvb2xDYWxsID09IG51bGwpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgZG9QYXJzZVRvb2xDYWxsKHsgdG9vbENhbGw6IHJlcGFpcmVkVG9vbENhbGwsIHRvb2xzIH0pO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBkb1BhcnNlVG9vbENhbGwoe1xuICB0b29sQ2FsbCxcbiAgdG9vbHNcbn0pIHtcbiAgY29uc3QgdG9vbE5hbWUgPSB0b29sQ2FsbC50b29sTmFtZTtcbiAgY29uc3QgdG9vbDIgPSB0b29sc1t0b29sTmFtZV07XG4gIGlmICh0b29sMiA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IE5vU3VjaFRvb2xFcnJvcih7XG4gICAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICBhdmFpbGFibGVUb29sczogT2JqZWN0LmtleXModG9vbHMpXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgc2NoZW1hID0gYXNTY2hlbWEzKHRvb2wyLnBhcmFtZXRlcnMpO1xuICBjb25zdCBwYXJzZVJlc3VsdCA9IHRvb2xDYWxsLmFyZ3MudHJpbSgpID09PSBcIlwiID8gc2FmZVZhbGlkYXRlVHlwZXMzKHsgdmFsdWU6IHt9LCBzY2hlbWEgfSkgOiBzYWZlUGFyc2VKU09OMih7IHRleHQ6IHRvb2xDYWxsLmFyZ3MsIHNjaGVtYSB9KTtcbiAgaWYgKHBhcnNlUmVzdWx0LnN1Y2Nlc3MgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRUb29sQXJndW1lbnRzRXJyb3Ioe1xuICAgICAgdG9vbE5hbWUsXG4gICAgICB0b29sQXJnczogdG9vbENhbGwuYXJncyxcbiAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvclxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgIHRvb2xOYW1lLFxuICAgIGFyZ3M6IHBhcnNlUmVzdWx0LnZhbHVlXG4gIH07XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9yZWFzb25pbmctZGV0YWlsLnRzXG5mdW5jdGlvbiBhc1JlYXNvbmluZ1RleHQocmVhc29uaW5nKSB7XG4gIGNvbnN0IHJlYXNvbmluZ1RleHQgPSByZWFzb25pbmcuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidGV4dFwiKS5tYXAoKHBhcnQpID0+IHBhcnQudGV4dCkuam9pbihcIlwiKTtcbiAgcmV0dXJuIHJlYXNvbmluZ1RleHQubGVuZ3RoID4gMCA/IHJlYXNvbmluZ1RleHQgOiB2b2lkIDA7XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC90by1yZXNwb25zZS1tZXNzYWdlcy50c1xuZnVuY3Rpb24gdG9SZXNwb25zZU1lc3NhZ2VzKHtcbiAgdGV4dDogdGV4dDIgPSBcIlwiLFxuICBmaWxlcyxcbiAgcmVhc29uaW5nLFxuICB0b29scyxcbiAgdG9vbENhbGxzLFxuICB0b29sUmVzdWx0cyxcbiAgbWVzc2FnZUlkLFxuICBnZW5lcmF0ZU1lc3NhZ2VJZFxufSkge1xuICBjb25zdCByZXNwb25zZU1lc3NhZ2VzID0gW107XG4gIGNvbnN0IGNvbnRlbnQgPSBbXTtcbiAgaWYgKHJlYXNvbmluZy5sZW5ndGggPiAwKSB7XG4gICAgY29udGVudC5wdXNoKFxuICAgICAgLi4ucmVhc29uaW5nLm1hcChcbiAgICAgICAgKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0ZXh0XCIgPyB7IC4uLnBhcnQsIHR5cGU6IFwicmVhc29uaW5nXCIgfSA6IHsgLi4ucGFydCwgdHlwZTogXCJyZWRhY3RlZC1yZWFzb25pbmdcIiB9XG4gICAgICApXG4gICAgKTtcbiAgfVxuICBpZiAoZmlsZXMubGVuZ3RoID4gMCkge1xuICAgIGNvbnRlbnQucHVzaChcbiAgICAgIC4uLmZpbGVzLm1hcCgoZmlsZSkgPT4gKHtcbiAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgIGRhdGE6IGZpbGUuYmFzZTY0LFxuICAgICAgICBtaW1lVHlwZTogZmlsZS5taW1lVHlwZVxuICAgICAgfSkpXG4gICAgKTtcbiAgfVxuICBpZiAodGV4dDIubGVuZ3RoID4gMCkge1xuICAgIGNvbnRlbnQucHVzaCh7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiB0ZXh0MiB9KTtcbiAgfVxuICBpZiAodG9vbENhbGxzLmxlbmd0aCA+IDApIHtcbiAgICBjb250ZW50LnB1c2goLi4udG9vbENhbGxzKTtcbiAgfVxuICBpZiAoY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKHtcbiAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICBjb250ZW50LFxuICAgICAgaWQ6IG1lc3NhZ2VJZFxuICAgIH0pO1xuICB9XG4gIGlmICh0b29sUmVzdWx0cy5sZW5ndGggPiAwKSB7XG4gICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKHtcbiAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgaWQ6IGdlbmVyYXRlTWVzc2FnZUlkKCksXG4gICAgICBjb250ZW50OiB0b29sUmVzdWx0cy5tYXAoKHRvb2xSZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgdG9vbDIgPSB0b29sc1t0b29sUmVzdWx0LnRvb2xOYW1lXTtcbiAgICAgICAgcmV0dXJuICh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIuZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQpICE9IG51bGwgPyB7XG4gICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xSZXN1bHQudG9vbENhbGxJZCxcbiAgICAgICAgICB0b29sTmFtZTogdG9vbFJlc3VsdC50b29sTmFtZSxcbiAgICAgICAgICByZXN1bHQ6IHRvb2wyLmV4cGVyaW1lbnRhbF90b1Rvb2xSZXN1bHRDb250ZW50KHRvb2xSZXN1bHQucmVzdWx0KSxcbiAgICAgICAgICBleHBlcmltZW50YWxfY29udGVudDogdG9vbDIuZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQoXG4gICAgICAgICAgICB0b29sUmVzdWx0LnJlc3VsdFxuICAgICAgICAgIClcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgdG9vbENhbGxJZDogdG9vbFJlc3VsdC50b29sQ2FsbElkLFxuICAgICAgICAgIHRvb2xOYW1lOiB0b29sUmVzdWx0LnRvb2xOYW1lLFxuICAgICAgICAgIHJlc3VsdDogdG9vbFJlc3VsdC5yZXN1bHRcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3BvbnNlTWVzc2FnZXM7XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9nZW5lcmF0ZS10ZXh0LnRzXG52YXIgb3JpZ2luYWxHZW5lcmF0ZUlkMyA9IGNyZWF0ZUlkR2VuZXJhdG9yMyh7XG4gIHByZWZpeDogXCJhaXR4dFwiLFxuICBzaXplOiAyNFxufSk7XG52YXIgb3JpZ2luYWxHZW5lcmF0ZU1lc3NhZ2VJZCA9IGNyZWF0ZUlkR2VuZXJhdG9yMyh7XG4gIHByZWZpeDogXCJtc2dcIixcbiAgc2l6ZTogMjRcbn0pO1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVUZXh0KHtcbiAgbW9kZWwsXG4gIHRvb2xzLFxuICB0b29sQ2hvaWNlLFxuICBzeXN0ZW0sXG4gIHByb21wdCxcbiAgbWVzc2FnZXMsXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzLFxuICBtYXhTdGVwcyA9IDEsXG4gIGV4cGVyaW1lbnRhbF9nZW5lcmF0ZU1lc3NhZ2VJZDogZ2VuZXJhdGVNZXNzYWdlSWQgPSBvcmlnaW5hbEdlbmVyYXRlTWVzc2FnZUlkLFxuICBleHBlcmltZW50YWxfb3V0cHV0OiBvdXRwdXQsXG4gIGV4cGVyaW1lbnRhbF9jb250aW51ZVN0ZXBzOiBjb250aW51ZVN0ZXBzID0gZmFsc2UsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEsXG4gIHByb3ZpZGVyT3B0aW9ucyA9IGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLFxuICBleHBlcmltZW50YWxfYWN0aXZlVG9vbHM6IGFjdGl2ZVRvb2xzLFxuICBleHBlcmltZW50YWxfcmVwYWlyVG9vbENhbGw6IHJlcGFpclRvb2xDYWxsLFxuICBfaW50ZXJuYWw6IHtcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyA9IG9yaWdpbmFsR2VuZXJhdGVJZDMsXG4gICAgY3VycmVudERhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICB9ID0ge30sXG4gIG9uU3RlcEZpbmlzaCxcbiAgLi4uc2V0dGluZ3Ncbn0pIHtcbiAgdmFyIF9hMTc7XG4gIGlmIChtYXhTdGVwcyA8IDEpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgcGFyYW1ldGVyOiBcIm1heFN0ZXBzXCIsXG4gICAgICB2YWx1ZTogbWF4U3RlcHMsXG4gICAgICBtZXNzYWdlOiBcIm1heFN0ZXBzIG11c3QgYmUgYXQgbGVhc3QgMVwiXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgeyBtYXhSZXRyaWVzLCByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoeyBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnIH0pO1xuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5nczogeyAuLi5zZXR0aW5ncywgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCBpbml0aWFsUHJvbXB0ID0gc3RhbmRhcmRpemVQcm9tcHQoe1xuICAgIHByb21wdDoge1xuICAgICAgc3lzdGVtOiAoX2ExNyA9IG91dHB1dCA9PSBudWxsID8gdm9pZCAwIDogb3V0cHV0LmluamVjdEludG9TeXN0ZW1Qcm9tcHQoeyBzeXN0ZW0sIG1vZGVsIH0pKSAhPSBudWxsID8gX2ExNyA6IHN5c3RlbSxcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2VzXG4gICAgfSxcbiAgICB0b29sc1xuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICBuYW1lOiBcImFpLmdlbmVyYXRlVGV4dFwiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmdlbmVyYXRlVGV4dFwiLFxuICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICB9KSxcbiAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgXCJhaS5wcm9tcHRcIjoge1xuICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9KVxuICAgICAgICB9LFxuICAgICAgICBcImFpLnNldHRpbmdzLm1heFN0ZXBzXCI6IG1heFN0ZXBzXG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgdmFyIF9hMTgsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaSwgX2osIF9rO1xuICAgICAgY29uc3QgbW9kZSA9IHtcbiAgICAgICAgdHlwZTogXCJyZWd1bGFyXCIsXG4gICAgICAgIC4uLnByZXBhcmVUb29sc0FuZFRvb2xDaG9pY2UoeyB0b29scywgdG9vbENob2ljZSwgYWN0aXZlVG9vbHMgfSlcbiAgICAgIH07XG4gICAgICBjb25zdCBjYWxsU2V0dGluZ3MgPSBwcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKTtcbiAgICAgIGxldCBjdXJyZW50TW9kZWxSZXNwb25zZTtcbiAgICAgIGxldCBjdXJyZW50VG9vbENhbGxzID0gW107XG4gICAgICBsZXQgY3VycmVudFRvb2xSZXN1bHRzID0gW107XG4gICAgICBsZXQgY3VycmVudFJlYXNvbmluZ0RldGFpbHMgPSBbXTtcbiAgICAgIGxldCBzdGVwQ291bnQgPSAwO1xuICAgICAgY29uc3QgcmVzcG9uc2VNZXNzYWdlcyA9IFtdO1xuICAgICAgbGV0IHRleHQyID0gXCJcIjtcbiAgICAgIGNvbnN0IHNvdXJjZXMgPSBbXTtcbiAgICAgIGNvbnN0IHN0ZXBzID0gW107XG4gICAgICBsZXQgdXNhZ2UgPSB7XG4gICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IDAsXG4gICAgICAgIHByb21wdFRva2VuczogMCxcbiAgICAgICAgdG90YWxUb2tlbnM6IDBcbiAgICAgIH07XG4gICAgICBsZXQgc3RlcFR5cGUgPSBcImluaXRpYWxcIjtcbiAgICAgIGRvIHtcbiAgICAgICAgY29uc3QgcHJvbXB0Rm9ybWF0ID0gc3RlcENvdW50ID09PSAwID8gaW5pdGlhbFByb21wdC50eXBlIDogXCJtZXNzYWdlc1wiO1xuICAgICAgICBjb25zdCBzdGVwSW5wdXRNZXNzYWdlcyA9IFtcbiAgICAgICAgICAuLi5pbml0aWFsUHJvbXB0Lm1lc3NhZ2VzLFxuICAgICAgICAgIC4uLnJlc3BvbnNlTWVzc2FnZXNcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgcHJvbXB0TWVzc2FnZXMgPSBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgICBwcm9tcHQ6IHtcbiAgICAgICAgICAgIHR5cGU6IHByb21wdEZvcm1hdCxcbiAgICAgICAgICAgIHN5c3RlbTogaW5pdGlhbFByb21wdC5zeXN0ZW0sXG4gICAgICAgICAgICBtZXNzYWdlczogc3RlcElucHV0TWVzc2FnZXNcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1vZGVsU3VwcG9ydHNJbWFnZVVybHM6IG1vZGVsLnN1cHBvcnRzSW1hZ2VVcmxzLFxuICAgICAgICAgIG1vZGVsU3VwcG9ydHNVcmw6IChfYTE4ID0gbW9kZWwuc3VwcG9ydHNVcmwpID09IG51bGwgPyB2b2lkIDAgOiBfYTE4LmJpbmQobW9kZWwpXG4gICAgICAgICAgLy8gc3VwcG9ydCAndGhpcycgY29udGV4dFxuICAgICAgICB9KTtcbiAgICAgICAgY3VycmVudE1vZGVsUmVzcG9uc2UgPSBhd2FpdCByZXRyeShcbiAgICAgICAgICAoKSA9PiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWkuZ2VuZXJhdGVUZXh0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZ2VuZXJhdGVUZXh0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LmZvcm1hdFwiOiB7IGlucHV0OiAoKSA9PiBwcm9tcHRGb3JtYXQgfSxcbiAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocHJvbXB0TWVzc2FnZXMpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImFpLnByb21wdC50b29sc1wiOiB7XG4gICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHRoZSBsYW5ndWFnZSBtb2RlbCBsZXZlbCB0b29sczpcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTE5O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9hMTkgPSBtb2RlLnRvb2xzKSA9PSBudWxsID8gdm9pZCAwIDogX2ExOS5tYXAoKHRvb2wyKSA9PiBKU09OLnN0cmluZ2lmeSh0b29sMikpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQudG9vbENob2ljZVwiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gbW9kZS50b29sQ2hvaWNlICE9IG51bGwgPyBKU09OLnN0cmluZ2lmeShtb2RlLnRvb2xDaG9pY2UpIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubW9kZWxcIjogbW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LmZyZXF1ZW5jeV9wZW5hbHR5XCI6IHNldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IHNldHRpbmdzLm1heFRva2VucyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnByZXNlbmNlX3BlbmFsdHlcIjogc2V0dGluZ3MucHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3Quc3RvcF9zZXF1ZW5jZXNcIjogc2V0dGluZ3Muc3RvcFNlcXVlbmNlcyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IHNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX2tcIjogc2V0dGluZ3MudG9wSyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI6IHNldHRpbmdzLnRvcFBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICBmbjogYXN5bmMgKHNwYW4yKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTE5LCBfYjIsIF9jMiwgX2QyLCBfZTIsIF9mMjtcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgICAgICAuLi5jYWxsU2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgaW5wdXRGb3JtYXQ6IHByb21wdEZvcm1hdCxcbiAgICAgICAgICAgICAgICByZXNwb25zZUZvcm1hdDogb3V0cHV0ID09IG51bGwgPyB2b2lkIDAgOiBvdXRwdXQucmVzcG9uc2VGb3JtYXQoeyBtb2RlbCB9KSxcbiAgICAgICAgICAgICAgICBwcm9tcHQ6IHByb21wdE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IChfYjIgPSAoX2ExOSA9IHJlc3VsdC5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTkuaWQpICE9IG51bGwgPyBfYjIgOiBnZW5lcmF0ZUlkMygpLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogKF9kMiA9IChfYzIgPSByZXN1bHQucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYzIudGltZXN0YW1wKSAhPSBudWxsID8gX2QyIDogY3VycmVudERhdGUoKSxcbiAgICAgICAgICAgICAgICBtb2RlbElkOiAoX2YyID0gKF9lMiA9IHJlc3VsdC5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lMi5tb2RlbElkKSAhPSBudWxsID8gX2YyIDogbW9kZWwubW9kZWxJZFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBzcGFuMi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiByZXN1bHQuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRleHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gcmVzdWx0LnRleHRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocmVzdWx0LnRvb2xDYWxscylcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5pZFwiOiByZXNwb25zZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGltZXN0YW1wXCI6IHJlc3BvbnNlRGF0YS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogcmVzdWx0LnVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IHJlc3VsdC51c2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmZpbmlzaF9yZWFzb25zXCI6IFtyZXN1bHQuZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5tb2RlbFwiOiByZXNwb25zZURhdGEubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI6IHJlc3VsdC51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogcmVzdWx0LnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4geyAuLi5yZXN1bHQsIHJlc3BvbnNlOiByZXNwb25zZURhdGEgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBjdXJyZW50VG9vbENhbGxzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgKChfYiA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnRvb2xDYWxscykgIT0gbnVsbCA/IF9iIDogW10pLm1hcChcbiAgICAgICAgICAgICh0b29sQ2FsbCkgPT4gcGFyc2VUb29sQ2FsbCh7XG4gICAgICAgICAgICAgIHRvb2xDYWxsLFxuICAgICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgICAgcmVwYWlyVG9vbENhbGwsXG4gICAgICAgICAgICAgIHN5c3RlbSxcbiAgICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgY3VycmVudFRvb2xSZXN1bHRzID0gdG9vbHMgPT0gbnVsbCA/IFtdIDogYXdhaXQgZXhlY3V0ZVRvb2xzKHtcbiAgICAgICAgICB0b29sQ2FsbHM6IGN1cnJlbnRUb29sQ2FsbHMsXG4gICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICBtZXNzYWdlczogc3RlcElucHV0TWVzc2FnZXMsXG4gICAgICAgICAgYWJvcnRTaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRVc2FnZSA9IGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZShcbiAgICAgICAgICBjdXJyZW50TW9kZWxSZXNwb25zZS51c2FnZVxuICAgICAgICApO1xuICAgICAgICB1c2FnZSA9IGFkZExhbmd1YWdlTW9kZWxVc2FnZSh1c2FnZSwgY3VycmVudFVzYWdlKTtcbiAgICAgICAgbGV0IG5leHRTdGVwVHlwZSA9IFwiZG9uZVwiO1xuICAgICAgICBpZiAoKytzdGVwQ291bnQgPCBtYXhTdGVwcykge1xuICAgICAgICAgIGlmIChjb250aW51ZVN0ZXBzICYmIGN1cnJlbnRNb2RlbFJlc3BvbnNlLmZpbmlzaFJlYXNvbiA9PT0gXCJsZW5ndGhcIiAmJiAvLyBvbmx5IHVzZSBjb250aW51ZSB3aGVuIHRoZXJlIGFyZSBubyB0b29sIGNhbGxzOlxuICAgICAgICAgIGN1cnJlbnRUb29sQ2FsbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBuZXh0U3RlcFR5cGUgPSBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIC8vIHRoZXJlIGFyZSB0b29sIGNhbGxzOlxuICAgICAgICAgICAgY3VycmVudFRvb2xDYWxscy5sZW5ndGggPiAwICYmIC8vIGFsbCBjdXJyZW50IHRvb2wgY2FsbHMgaGF2ZSByZXN1bHRzOlxuICAgICAgICAgICAgY3VycmVudFRvb2xSZXN1bHRzLmxlbmd0aCA9PT0gY3VycmVudFRvb2xDYWxscy5sZW5ndGhcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIG5leHRTdGVwVHlwZSA9IFwidG9vbC1yZXN1bHRcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxUZXh0ID0gKF9jID0gY3VycmVudE1vZGVsUmVzcG9uc2UudGV4dCkgIT0gbnVsbCA/IF9jIDogXCJcIjtcbiAgICAgICAgY29uc3Qgc3RlcFRleHRMZWFkaW5nV2hpdGVzcGFjZVRyaW1tZWQgPSBzdGVwVHlwZSA9PT0gXCJjb250aW51ZVwiICYmIC8vIG9ubHkgZm9yIGNvbnRpbnVlIHN0ZXBzXG4gICAgICAgIHRleHQyLnRyaW1FbmQoKSAhPT0gdGV4dDIgPyBvcmlnaW5hbFRleHQudHJpbVN0YXJ0KCkgOiBvcmlnaW5hbFRleHQ7XG4gICAgICAgIGNvbnN0IHN0ZXBUZXh0ID0gbmV4dFN0ZXBUeXBlID09PSBcImNvbnRpbnVlXCIgPyByZW1vdmVUZXh0QWZ0ZXJMYXN0V2hpdGVzcGFjZShzdGVwVGV4dExlYWRpbmdXaGl0ZXNwYWNlVHJpbW1lZCkgOiBzdGVwVGV4dExlYWRpbmdXaGl0ZXNwYWNlVHJpbW1lZDtcbiAgICAgICAgdGV4dDIgPSBuZXh0U3RlcFR5cGUgPT09IFwiY29udGludWVcIiB8fCBzdGVwVHlwZSA9PT0gXCJjb250aW51ZVwiID8gdGV4dDIgKyBzdGVwVGV4dCA6IHN0ZXBUZXh0O1xuICAgICAgICBjdXJyZW50UmVhc29uaW5nRGV0YWlscyA9IGFzUmVhc29uaW5nRGV0YWlscyhcbiAgICAgICAgICBjdXJyZW50TW9kZWxSZXNwb25zZS5yZWFzb25pbmdcbiAgICAgICAgKTtcbiAgICAgICAgc291cmNlcy5wdXNoKC4uLihfZCA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnNvdXJjZXMpICE9IG51bGwgPyBfZCA6IFtdKTtcbiAgICAgICAgaWYgKHN0ZXBUeXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IHJlc3BvbnNlTWVzc2FnZXNbcmVzcG9uc2VNZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAodHlwZW9mIGxhc3RNZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGxhc3RNZXNzYWdlLmNvbnRlbnQgKz0gc3RlcFRleHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RNZXNzYWdlLmNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgIHRleHQ6IHN0ZXBUZXh0LFxuICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXMucHVzaChcbiAgICAgICAgICAgIC4uLnRvUmVzcG9uc2VNZXNzYWdlcyh7XG4gICAgICAgICAgICAgIHRleHQ6IHRleHQyLFxuICAgICAgICAgICAgICBmaWxlczogYXNGaWxlcyhjdXJyZW50TW9kZWxSZXNwb25zZS5maWxlcyksXG4gICAgICAgICAgICAgIHJlYXNvbmluZzogYXNSZWFzb25pbmdEZXRhaWxzKGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJlYXNvbmluZyksXG4gICAgICAgICAgICAgIHRvb2xzOiB0b29scyAhPSBudWxsID8gdG9vbHMgOiB7fSxcbiAgICAgICAgICAgICAgdG9vbENhbGxzOiBjdXJyZW50VG9vbENhbGxzLFxuICAgICAgICAgICAgICB0b29sUmVzdWx0czogY3VycmVudFRvb2xSZXN1bHRzLFxuICAgICAgICAgICAgICBtZXNzYWdlSWQ6IGdlbmVyYXRlTWVzc2FnZUlkKCksXG4gICAgICAgICAgICAgIGdlbmVyYXRlTWVzc2FnZUlkXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFN0ZXBSZXN1bHQgPSB7XG4gICAgICAgICAgc3RlcFR5cGUsXG4gICAgICAgICAgdGV4dDogc3RlcFRleHQsXG4gICAgICAgICAgLy8gVE9ETyB2NTogcmVuYW1lIHJlYXNvbmluZyB0byByZWFzb25pbmdUZXh0IChhbmQgdXNlIHJlYXNvbmluZyBmb3IgY29tcG9zaXRlIGFycmF5KVxuICAgICAgICAgIHJlYXNvbmluZzogYXNSZWFzb25pbmdUZXh0KGN1cnJlbnRSZWFzb25pbmdEZXRhaWxzKSxcbiAgICAgICAgICByZWFzb25pbmdEZXRhaWxzOiBjdXJyZW50UmVhc29uaW5nRGV0YWlscyxcbiAgICAgICAgICBmaWxlczogYXNGaWxlcyhjdXJyZW50TW9kZWxSZXNwb25zZS5maWxlcyksXG4gICAgICAgICAgc291cmNlczogKF9lID0gY3VycmVudE1vZGVsUmVzcG9uc2Uuc291cmNlcykgIT0gbnVsbCA/IF9lIDogW10sXG4gICAgICAgICAgdG9vbENhbGxzOiBjdXJyZW50VG9vbENhbGxzLFxuICAgICAgICAgIHRvb2xSZXN1bHRzOiBjdXJyZW50VG9vbFJlc3VsdHMsXG4gICAgICAgICAgZmluaXNoUmVhc29uOiBjdXJyZW50TW9kZWxSZXNwb25zZS5maW5pc2hSZWFzb24sXG4gICAgICAgICAgdXNhZ2U6IGN1cnJlbnRVc2FnZSxcbiAgICAgICAgICB3YXJuaW5nczogY3VycmVudE1vZGVsUmVzcG9uc2Uud2FybmluZ3MsXG4gICAgICAgICAgbG9ncHJvYnM6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmxvZ3Byb2JzLFxuICAgICAgICAgIHJlcXVlc3Q6IChfZiA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJlcXVlc3QpICE9IG51bGwgPyBfZiA6IHt9LFxuICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAuLi5jdXJyZW50TW9kZWxSZXNwb25zZS5yZXNwb25zZSxcbiAgICAgICAgICAgIGhlYWRlcnM6IChfZyA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJhd1Jlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2cuaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IChfaCA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJhd1Jlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2guYm9keSxcbiAgICAgICAgICAgIC8vIGRlZXAgY2xvbmUgbXNncyB0byBhdm9pZCBtdXRhdGluZyBwYXN0IG1lc3NhZ2VzIGluIG11bHRpLXN0ZXA6XG4gICAgICAgICAgICBtZXNzYWdlczogc3RydWN0dXJlZENsb25lKHJlc3BvbnNlTWVzc2FnZXMpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjdXJyZW50TW9kZWxSZXNwb25zZS5wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBjdXJyZW50TW9kZWxSZXNwb25zZS5wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgIGlzQ29udGludWVkOiBuZXh0U3RlcFR5cGUgPT09IFwiY29udGludWVcIlxuICAgICAgICB9O1xuICAgICAgICBzdGVwcy5wdXNoKGN1cnJlbnRTdGVwUmVzdWx0KTtcbiAgICAgICAgYXdhaXQgKG9uU3RlcEZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25TdGVwRmluaXNoKGN1cnJlbnRTdGVwUmVzdWx0KSk7XG4gICAgICAgIHN0ZXBUeXBlID0gbmV4dFN0ZXBUeXBlO1xuICAgICAgfSB3aGlsZSAoc3RlcFR5cGUgIT09IFwiZG9uZVwiKTtcbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGV4dFwiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gY3VycmVudE1vZGVsUmVzcG9uc2UudGV4dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShjdXJyZW50TW9kZWxSZXNwb25zZS50b29sQ2FsbHMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogY3VycmVudE1vZGVsUmVzcG9uc2UudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0R2VuZXJhdGVUZXh0UmVzdWx0KHtcbiAgICAgICAgdGV4dDogdGV4dDIsXG4gICAgICAgIGZpbGVzOiBhc0ZpbGVzKGN1cnJlbnRNb2RlbFJlc3BvbnNlLmZpbGVzKSxcbiAgICAgICAgcmVhc29uaW5nOiBhc1JlYXNvbmluZ1RleHQoY3VycmVudFJlYXNvbmluZ0RldGFpbHMpLFxuICAgICAgICByZWFzb25pbmdEZXRhaWxzOiBjdXJyZW50UmVhc29uaW5nRGV0YWlscyxcbiAgICAgICAgc291cmNlcyxcbiAgICAgICAgb3V0cHV0UmVzb2x2ZXI6ICgpID0+IHtcbiAgICAgICAgICBpZiAob3V0cHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb091dHB1dFNwZWNpZmllZEVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvdXRwdXQucGFyc2VPdXRwdXQoXG4gICAgICAgICAgICB7IHRleHQ6IHRleHQyIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJlc3BvbnNlOiBjdXJyZW50TW9kZWxSZXNwb25zZS5yZXNwb25zZSxcbiAgICAgICAgICAgICAgdXNhZ2UsXG4gICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogY3VycmVudE1vZGVsUmVzcG9uc2UuZmluaXNoUmVhc29uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9vbENhbGxzOiBjdXJyZW50VG9vbENhbGxzLFxuICAgICAgICB0b29sUmVzdWx0czogY3VycmVudFRvb2xSZXN1bHRzLFxuICAgICAgICBmaW5pc2hSZWFzb246IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmZpbmlzaFJlYXNvbixcbiAgICAgICAgdXNhZ2UsXG4gICAgICAgIHdhcm5pbmdzOiBjdXJyZW50TW9kZWxSZXNwb25zZS53YXJuaW5ncyxcbiAgICAgICAgcmVxdWVzdDogKF9pID0gY3VycmVudE1vZGVsUmVzcG9uc2UucmVxdWVzdCkgIT0gbnVsbCA/IF9pIDoge30sXG4gICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgLi4uY3VycmVudE1vZGVsUmVzcG9uc2UucmVzcG9uc2UsXG4gICAgICAgICAgaGVhZGVyczogKF9qID0gY3VycmVudE1vZGVsUmVzcG9uc2UucmF3UmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfai5oZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IChfayA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJhd1Jlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2suYm9keSxcbiAgICAgICAgICBtZXNzYWdlczogcmVzcG9uc2VNZXNzYWdlc1xuICAgICAgICB9LFxuICAgICAgICBsb2dwcm9iczogY3VycmVudE1vZGVsUmVzcG9uc2UubG9ncHJvYnMsXG4gICAgICAgIHN0ZXBzLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjdXJyZW50TW9kZWxSZXNwb25zZS5wcm92aWRlck1ldGFkYXRhXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZVRvb2xzKHtcbiAgdG9vbENhbGxzLFxuICB0b29scyxcbiAgdHJhY2VyLFxuICB0ZWxlbWV0cnksXG4gIG1lc3NhZ2VzLFxuICBhYm9ydFNpZ25hbFxufSkge1xuICBjb25zdCB0b29sUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHRvb2xDYWxscy5tYXAoYXN5bmMgKHsgdG9vbENhbGxJZCwgdG9vbE5hbWUsIGFyZ3MgfSkgPT4ge1xuICAgICAgY29uc3QgdG9vbDIgPSB0b29sc1t0b29sTmFtZV07XG4gICAgICBpZiAoKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi5leGVjdXRlKSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWNvcmRTcGFuKHtcbiAgICAgICAgbmFtZTogXCJhaS50b29sQ2FsbFwiLFxuICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkudG9vbENhbGxcIixcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIFwiYWkudG9vbENhbGwubmFtZVwiOiB0b29sTmFtZSxcbiAgICAgICAgICAgIFwiYWkudG9vbENhbGwuaWRcIjogdG9vbENhbGxJZCxcbiAgICAgICAgICAgIFwiYWkudG9vbENhbGwuYXJnc1wiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoYXJncylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICB0cmFjZXIsXG4gICAgICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgdG9vbDIuZXhlY3V0ZShhcmdzLCB7XG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICAgICAgICBhYm9ydFNpZ25hbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiYWkudG9vbENhbGwucmVzdWx0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHJlc3VsdDIpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUb29sRXhlY3V0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgdG9vbEFyZ3M6IGFyZ3MsXG4gICAgICAgICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgdG9vbENhbGxJZCxcbiAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIHJlc3VsdFxuICAgICAgfTtcbiAgICB9KVxuICApO1xuICByZXR1cm4gdG9vbFJlc3VsdHMuZmlsdGVyKFxuICAgIChyZXN1bHQpID0+IHJlc3VsdCAhPSBudWxsXG4gICk7XG59XG52YXIgRGVmYXVsdEdlbmVyYXRlVGV4dFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMudGV4dCA9IG9wdGlvbnMudGV4dDtcbiAgICB0aGlzLmZpbGVzID0gb3B0aW9ucy5maWxlcztcbiAgICB0aGlzLnJlYXNvbmluZyA9IG9wdGlvbnMucmVhc29uaW5nO1xuICAgIHRoaXMucmVhc29uaW5nRGV0YWlscyA9IG9wdGlvbnMucmVhc29uaW5nRGV0YWlscztcbiAgICB0aGlzLnRvb2xDYWxscyA9IG9wdGlvbnMudG9vbENhbGxzO1xuICAgIHRoaXMudG9vbFJlc3VsdHMgPSBvcHRpb25zLnRvb2xSZXN1bHRzO1xuICAgIHRoaXMuZmluaXNoUmVhc29uID0gb3B0aW9ucy5maW5pc2hSZWFzb247XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gICAgdGhpcy53YXJuaW5ncyA9IG9wdGlvbnMud2FybmluZ3M7XG4gICAgdGhpcy5yZXF1ZXN0ID0gb3B0aW9ucy5yZXF1ZXN0O1xuICAgIHRoaXMucmVzcG9uc2UgPSBvcHRpb25zLnJlc3BvbnNlO1xuICAgIHRoaXMuc3RlcHMgPSBvcHRpb25zLnN0ZXBzO1xuICAgIHRoaXMuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgdGhpcy5wcm92aWRlck1ldGFkYXRhID0gb3B0aW9ucy5wcm92aWRlck1ldGFkYXRhO1xuICAgIHRoaXMubG9ncHJvYnMgPSBvcHRpb25zLmxvZ3Byb2JzO1xuICAgIHRoaXMub3V0cHV0UmVzb2x2ZXIgPSBvcHRpb25zLm91dHB1dFJlc29sdmVyO1xuICAgIHRoaXMuc291cmNlcyA9IG9wdGlvbnMuc291cmNlcztcbiAgfVxuICBnZXQgZXhwZXJpbWVudGFsX291dHB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRSZXNvbHZlcigpO1xuICB9XG59O1xuZnVuY3Rpb24gYXNSZWFzb25pbmdEZXRhaWxzKHJlYXNvbmluZykge1xuICBpZiAocmVhc29uaW5nID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKHR5cGVvZiByZWFzb25pbmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IHJlYXNvbmluZyB9XTtcbiAgfVxuICByZXR1cm4gcmVhc29uaW5nO1xufVxuZnVuY3Rpb24gYXNGaWxlcyhmaWxlcykge1xuICB2YXIgX2ExNztcbiAgcmV0dXJuIChfYTE3ID0gZmlsZXMgPT0gbnVsbCA/IHZvaWQgMCA6IGZpbGVzLm1hcCgoZmlsZSkgPT4gbmV3IERlZmF1bHRHZW5lcmF0ZWRGaWxlKGZpbGUpKSkgIT0gbnVsbCA/IF9hMTcgOiBbXTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L291dHB1dC50c1xudmFyIG91dHB1dF9leHBvcnRzID0ge307XG5fX2V4cG9ydChvdXRwdXRfZXhwb3J0cywge1xuICBvYmplY3Q6ICgpID0+IG9iamVjdCxcbiAgdGV4dDogKCkgPT4gdGV4dFxufSk7XG5pbXBvcnQgeyBzYWZlUGFyc2VKU09OIGFzIHNhZmVQYXJzZUpTT04zLCBzYWZlVmFsaWRhdGVUeXBlcyBhcyBzYWZlVmFsaWRhdGVUeXBlczQgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuaW1wb3J0IHtcbiAgYXNTY2hlbWEgYXMgYXNTY2hlbWE0LFxuICBwYXJzZVBhcnRpYWxKc29uIGFzIHBhcnNlUGFydGlhbEpzb24yXG59IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5cbi8vIGVycm9ycy9pbmRleC50c1xuaW1wb3J0IHtcbiAgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTYsXG4gIEFQSUNhbGxFcnJvciBhcyBBUElDYWxsRXJyb3IyLFxuICBFbXB0eVJlc3BvbnNlQm9keUVycm9yLFxuICBJbnZhbGlkUHJvbXB0RXJyb3IgYXMgSW52YWxpZFByb21wdEVycm9yMixcbiAgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yLFxuICBKU09OUGFyc2VFcnJvciBhcyBKU09OUGFyc2VFcnJvcjIsXG4gIExvYWRBUElLZXlFcnJvcixcbiAgTm9Db250ZW50R2VuZXJhdGVkRXJyb3IsXG4gIE5vU3VjaE1vZGVsRXJyb3IsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IgYXMgVHlwZVZhbGlkYXRpb25FcnJvcjMsXG4gIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yIGFzIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yMlxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuXG4vLyBlcnJvcnMvaW52YWxpZC1zdHJlYW0tcGFydC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTQgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUxNCA9IFwiQUlfSW52YWxpZFN0cmVhbVBhcnRFcnJvclwiO1xudmFyIG1hcmtlcjE0ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxNH1gO1xudmFyIHN5bWJvbDE0ID0gU3ltYm9sLmZvcihtYXJrZXIxNCk7XG52YXIgX2ExNDtcbnZhciBJbnZhbGlkU3RyZWFtUGFydEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMTQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY2h1bmssXG4gICAgbWVzc2FnZVxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTQsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTE0XSA9IHRydWU7XG4gICAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxNC5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjE0KTtcbiAgfVxufTtcbl9hMTQgPSBzeW1ib2wxNDtcblxuLy8gZXJyb3JzL21jcC1jbGllbnQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjE1IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMTUgPSBcIkFJX01DUENsaWVudEVycm9yXCI7XG52YXIgbWFya2VyMTUgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTE1fWA7XG52YXIgc3ltYm9sMTUgPSBTeW1ib2wuZm9yKG1hcmtlcjE1KTtcbnZhciBfYTE1O1xudmFyIE1DUENsaWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMTUge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbmFtZTogbmFtZTE3ID0gXCJNQ1BDbGllbnRFcnJvclwiLFxuICAgIG1lc3NhZ2UsXG4gICAgY2F1c2VcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTE3LCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hMTVdID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMTUuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxNSk7XG4gIH1cbn07XG5fYTE1ID0gc3ltYm9sMTU7XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9vdXRwdXQudHNcbnZhciB0ZXh0ID0gKCkgPT4gKHtcbiAgdHlwZTogXCJ0ZXh0XCIsXG4gIHJlc3BvbnNlRm9ybWF0OiAoKSA9PiAoeyB0eXBlOiBcInRleHRcIiB9KSxcbiAgaW5qZWN0SW50b1N5c3RlbVByb21wdCh7IHN5c3RlbSB9KSB7XG4gICAgcmV0dXJuIHN5c3RlbTtcbiAgfSxcbiAgcGFyc2VQYXJ0aWFsKHsgdGV4dDogdGV4dDIgfSkge1xuICAgIHJldHVybiB7IHBhcnRpYWw6IHRleHQyIH07XG4gIH0sXG4gIHBhcnNlT3V0cHV0KHsgdGV4dDogdGV4dDIgfSkge1xuICAgIHJldHVybiB0ZXh0MjtcbiAgfVxufSk7XG52YXIgb2JqZWN0ID0gKHtcbiAgc2NoZW1hOiBpbnB1dFNjaGVtYVxufSkgPT4ge1xuICBjb25zdCBzY2hlbWEgPSBhc1NjaGVtYTQoaW5wdXRTY2hlbWEpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgcmVzcG9uc2VGb3JtYXQ6ICh7IG1vZGVsIH0pID0+ICh7XG4gICAgICB0eXBlOiBcImpzb25cIixcbiAgICAgIHNjaGVtYTogbW9kZWwuc3VwcG9ydHNTdHJ1Y3R1cmVkT3V0cHV0cyA/IHNjaGVtYS5qc29uU2NoZW1hIDogdm9pZCAwXG4gICAgfSksXG4gICAgaW5qZWN0SW50b1N5c3RlbVByb21wdCh7IHN5c3RlbSwgbW9kZWwgfSkge1xuICAgICAgcmV0dXJuIG1vZGVsLnN1cHBvcnRzU3RydWN0dXJlZE91dHB1dHMgPyBzeXN0ZW0gOiBpbmplY3RKc29uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBwcm9tcHQ6IHN5c3RlbSxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWEuanNvblNjaGVtYVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBwYXJzZVBhcnRpYWwoeyB0ZXh0OiB0ZXh0MiB9KSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZVBhcnRpYWxKc29uMih0ZXh0Mik7XG4gICAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgICBjYXNlIFwiZmFpbGVkLXBhcnNlXCI6XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWQtaW5wdXRcIjpcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICBjYXNlIFwicmVwYWlyZWQtcGFyc2VcIjpcbiAgICAgICAgY2FzZSBcInN1Y2Nlc3NmdWwtcGFyc2VcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gTm90ZTogY3VycmVudGx5IG5vIHZhbGlkYXRpb24gb2YgcGFydGlhbCByZXN1bHRzOlxuICAgICAgICAgICAgcGFydGlhbDogcmVzdWx0LnZhbHVlXG4gICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSByZXN1bHQuc3RhdGU7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwYXJzZSBzdGF0ZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBwYXJzZU91dHB1dCh7IHRleHQ6IHRleHQyIH0sIGNvbnRleHQpIHtcbiAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gc2FmZVBhcnNlSlNPTjMoeyB0ZXh0OiB0ZXh0MiB9KTtcbiAgICAgIGlmICghcGFyc2VSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiBjb3VsZCBub3QgcGFyc2UgdGhlIHJlc3BvbnNlLlwiLFxuICAgICAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvcixcbiAgICAgICAgICB0ZXh0OiB0ZXh0MixcbiAgICAgICAgICByZXNwb25zZTogY29udGV4dC5yZXNwb25zZSxcbiAgICAgICAgICB1c2FnZTogY29udGV4dC51c2FnZSxcbiAgICAgICAgICBmaW5pc2hSZWFzb246IGNvbnRleHQuZmluaXNoUmVhc29uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IHNhZmVWYWxpZGF0ZVR5cGVzNCh7XG4gICAgICAgIHZhbHVlOiBwYXJzZVJlc3VsdC52YWx1ZSxcbiAgICAgICAgc2NoZW1hXG4gICAgICB9KTtcbiAgICAgIGlmICghdmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IHJlc3BvbnNlIGRpZCBub3QgbWF0Y2ggc2NoZW1hLlwiLFxuICAgICAgICAgIGNhdXNlOiB2YWxpZGF0aW9uUmVzdWx0LmVycm9yLFxuICAgICAgICAgIHRleHQ6IHRleHQyLFxuICAgICAgICAgIHJlc3BvbnNlOiBjb250ZXh0LnJlc3BvbnNlLFxuICAgICAgICAgIHVzYWdlOiBjb250ZXh0LnVzYWdlLFxuICAgICAgICAgIGZpbmlzaFJlYXNvbjogY29udGV4dC5maW5pc2hSZWFzb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsaWRhdGlvblJlc3VsdC52YWx1ZTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvc21vb3RoLXN0cmVhbS50c1xuaW1wb3J0IHsgZGVsYXkgYXMgb3JpZ2luYWxEZWxheSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyBJbnZhbGlkQXJndW1lbnRFcnJvciBhcyBJbnZhbGlkQXJndW1lbnRFcnJvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIENIVU5LSU5HX1JFR0VYUFMgPSB7XG4gIHdvcmQ6IC9cXFMrXFxzKy9tLFxuICBsaW5lOiAvXFxuKy9tXG59O1xuZnVuY3Rpb24gc21vb3RoU3RyZWFtKHtcbiAgZGVsYXlJbk1zID0gMTAsXG4gIGNodW5raW5nID0gXCJ3b3JkXCIsXG4gIF9pbnRlcm5hbDogeyBkZWxheTogZGVsYXkyID0gb3JpZ2luYWxEZWxheSB9ID0ge31cbn0gPSB7fSkge1xuICBsZXQgZGV0ZWN0Q2h1bms7XG4gIGlmICh0eXBlb2YgY2h1bmtpbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGRldGVjdENodW5rID0gKGJ1ZmZlcikgPT4ge1xuICAgICAgY29uc3QgbWF0Y2ggPSBjaHVua2luZyhidWZmZXIpO1xuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIW1hdGNoLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENodW5raW5nIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgbm9uLWVtcHR5IHN0cmluZy5gKTtcbiAgICAgIH1cbiAgICAgIGlmICghYnVmZmVyLnN0YXJ0c1dpdGgobWF0Y2gpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ2h1bmtpbmcgZnVuY3Rpb24gbXVzdCByZXR1cm4gYSBtYXRjaCB0aGF0IGlzIGEgcHJlZml4IG9mIHRoZSBidWZmZXIuIFJlY2VpdmVkOiBcIiR7bWF0Y2h9XCIgZXhwZWN0ZWQgdG8gc3RhcnQgd2l0aCBcIiR7YnVmZmVyfVwiYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY2h1bmtpbmdSZWdleCA9IHR5cGVvZiBjaHVua2luZyA9PT0gXCJzdHJpbmdcIiA/IENIVU5LSU5HX1JFR0VYUFNbY2h1bmtpbmddIDogY2h1bmtpbmc7XG4gICAgaWYgKGNodW5raW5nUmVnZXggPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yMih7XG4gICAgICAgIGFyZ3VtZW50OiBcImNodW5raW5nXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBDaHVua2luZyBtdXN0IGJlIFwid29yZFwiIG9yIFwibGluZVwiIG9yIGEgUmVnRXhwLiBSZWNlaXZlZDogJHtjaHVua2luZ31gXG4gICAgICB9KTtcbiAgICB9XG4gICAgZGV0ZWN0Q2h1bmsgPSAoYnVmZmVyKSA9PiB7XG4gICAgICBjb25zdCBtYXRjaCA9IGNodW5raW5nUmVnZXguZXhlYyhidWZmZXIpO1xuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgKG1hdGNoID09IG51bGwgPyB2b2lkIDAgOiBtYXRjaFswXSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gKCkgPT4ge1xuICAgIGxldCBidWZmZXIgPSBcIlwiO1xuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBpZiAoY2h1bmsudHlwZSAhPT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwidGV4dC1kZWx0YVwiLCB0ZXh0RGVsdGE6IGJ1ZmZlciB9KTtcbiAgICAgICAgICAgIGJ1ZmZlciA9IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlciArPSBjaHVuay50ZXh0RGVsdGE7XG4gICAgICAgIGxldCBtYXRjaDtcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IGRldGVjdENodW5rKGJ1ZmZlcikpICE9IG51bGwpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInRleHQtZGVsdGFcIiwgdGV4dERlbHRhOiBtYXRjaCB9KTtcbiAgICAgICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UobWF0Y2gubGVuZ3RoKTtcbiAgICAgICAgICBhd2FpdCBkZWxheTIoZGVsYXlJbk1zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvc3RyZWFtLXRleHQudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjE3IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IGNyZWF0ZUlkR2VuZXJhdG9yIGFzIGNyZWF0ZUlkR2VuZXJhdG9yNCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyBmb3JtYXREYXRhU3RyZWFtUGFydCBhcyBmb3JtYXREYXRhU3RyZWFtUGFydDIgfSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuXG4vLyB1dGlsL2FzLWFycmF5LnRzXG5mdW5jdGlvbiBhc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8gW10gOiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbn1cblxuLy8gdXRpbC9jb25zdW1lLXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24gY29uc3VtZVN0cmVhbSh7XG4gIHN0cmVhbSxcbiAgb25FcnJvclxufSkge1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIHRyeSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHsgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmIChkb25lKVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgb25FcnJvciA9PSBudWxsID8gdm9pZCAwIDogb25FcnJvcihlcnJvcik7XG4gIH0gZmluYWxseSB7XG4gICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gIH1cbn1cblxuLy8gY29yZS91dGlsL21lcmdlLXN0cmVhbXMudHNcbmZ1bmN0aW9uIG1lcmdlU3RyZWFtcyhzdHJlYW0xLCBzdHJlYW0yKSB7XG4gIGNvbnN0IHJlYWRlcjEgPSBzdHJlYW0xLmdldFJlYWRlcigpO1xuICBjb25zdCByZWFkZXIyID0gc3RyZWFtMi5nZXRSZWFkZXIoKTtcbiAgbGV0IGxhc3RSZWFkMSA9IHZvaWQgMDtcbiAgbGV0IGxhc3RSZWFkMiA9IHZvaWQgMDtcbiAgbGV0IHN0cmVhbTFEb25lID0gZmFsc2U7XG4gIGxldCBzdHJlYW0yRG9uZSA9IGZhbHNlO1xuICBhc3luYyBmdW5jdGlvbiByZWFkU3RyZWFtMShjb250cm9sbGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChsYXN0UmVhZDEgPT0gbnVsbCkge1xuICAgICAgICBsYXN0UmVhZDEgPSByZWFkZXIxLnJlYWQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxhc3RSZWFkMTtcbiAgICAgIGxhc3RSZWFkMSA9IHZvaWQgMDtcbiAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHJlc3VsdC52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZWFkU3RyZWFtMihjb250cm9sbGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChsYXN0UmVhZDIgPT0gbnVsbCkge1xuICAgICAgICBsYXN0UmVhZDIgPSByZWFkZXIyLnJlYWQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxhc3RSZWFkMjtcbiAgICAgIGxhc3RSZWFkMiA9IHZvaWQgMDtcbiAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHJlc3VsdC52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzdHJlYW0xRG9uZSkge1xuICAgICAgICAgIGF3YWl0IHJlYWRTdHJlYW0yKGNvbnRyb2xsZXIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtMkRvbmUpIHtcbiAgICAgICAgICBhd2FpdCByZWFkU3RyZWFtMShjb250cm9sbGVyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RSZWFkMSA9PSBudWxsKSB7XG4gICAgICAgICAgbGFzdFJlYWQxID0gcmVhZGVyMS5yZWFkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RSZWFkMiA9PSBudWxsKSB7XG4gICAgICAgICAgbGFzdFJlYWQyID0gcmVhZGVyMi5yZWFkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyByZXN1bHQsIHJlYWRlciB9ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICBsYXN0UmVhZDEudGhlbigocmVzdWx0MikgPT4gKHsgcmVzdWx0OiByZXN1bHQyLCByZWFkZXI6IHJlYWRlcjEgfSkpLFxuICAgICAgICAgIGxhc3RSZWFkMi50aGVuKChyZXN1bHQyKSA9PiAoeyByZXN1bHQ6IHJlc3VsdDIsIHJlYWRlcjogcmVhZGVyMiB9KSlcbiAgICAgICAgXSk7XG4gICAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVhZGVyID09PSByZWFkZXIxKSB7XG4gICAgICAgICAgbGFzdFJlYWQxID0gdm9pZCAwO1xuICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgYXdhaXQgcmVhZFN0cmVhbTIoY29udHJvbGxlcik7XG4gICAgICAgICAgICBzdHJlYW0xRG9uZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RSZWFkMiA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgIHN0cmVhbTJEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIGF3YWl0IHJlYWRTdHJlYW0xKGNvbnRyb2xsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgfSxcbiAgICBjYW5jZWwoKSB7XG4gICAgICByZWFkZXIxLmNhbmNlbCgpO1xuICAgICAgcmVhZGVyMi5jYW5jZWwoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvcnVuLXRvb2xzLXRyYW5zZm9ybWF0aW9uLnRzXG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcbmZ1bmN0aW9uIHJ1blRvb2xzVHJhbnNmb3JtYXRpb24oe1xuICB0b29scyxcbiAgZ2VuZXJhdG9yU3RyZWFtLFxuICB0b29sQ2FsbFN0cmVhbWluZyxcbiAgdHJhY2VyLFxuICB0ZWxlbWV0cnksXG4gIHN5c3RlbSxcbiAgbWVzc2FnZXMsXG4gIGFib3J0U2lnbmFsLFxuICByZXBhaXJUb29sQ2FsbFxufSkge1xuICBsZXQgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyID0gbnVsbDtcbiAgY29uc3QgdG9vbFJlc3VsdHNTdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgYWN0aXZlVG9vbENhbGxzID0ge307XG4gIGNvbnN0IG91dHN0YW5kaW5nVG9vbFJlc3VsdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgY2FuQ2xvc2UgPSBmYWxzZTtcbiAgbGV0IGZpbmlzaENodW5rID0gdm9pZCAwO1xuICBmdW5jdGlvbiBhdHRlbXB0Q2xvc2UoKSB7XG4gICAgaWYgKGNhbkNsb3NlICYmIG91dHN0YW5kaW5nVG9vbFJlc3VsdHMuc2l6ZSA9PT0gMCkge1xuICAgICAgaWYgKGZpbmlzaENodW5rICE9IG51bGwpIHtcbiAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoZmluaXNoQ2h1bmspO1xuICAgICAgfVxuICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmNsb3NlKCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGZvcndhcmRTdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IGNodW5rVHlwZSA9IGNodW5rLnR5cGU7XG4gICAgICBzd2l0Y2ggKGNodW5rVHlwZSkge1xuICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICBjYXNlIFwicmVhc29uaW5nXCI6XG4gICAgICAgIGNhc2UgXCJyZWFzb25pbmctc2lnbmF0dXJlXCI6XG4gICAgICAgIGNhc2UgXCJyZWRhY3RlZC1yZWFzb25pbmdcIjpcbiAgICAgICAgY2FzZSBcInNvdXJjZVwiOlxuICAgICAgICBjYXNlIFwicmVzcG9uc2UtbWV0YWRhdGFcIjpcbiAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICBuZXcgRGVmYXVsdEdlbmVyYXRlZEZpbGVXaXRoVHlwZSh7XG4gICAgICAgICAgICAgIGRhdGE6IGNodW5rLmRhdGEsXG4gICAgICAgICAgICAgIG1pbWVUeXBlOiBjaHVuay5taW1lVHlwZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b29sLWNhbGwtZGVsdGFcIjoge1xuICAgICAgICAgIGlmICh0b29sQ2FsbFN0cmVhbWluZykge1xuICAgICAgICAgICAgaWYgKCFhY3RpdmVUb29sQ2FsbHNbY2h1bmsudG9vbENhbGxJZF0pIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbC1zdHJlYW1pbmctc3RhcnRcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYWN0aXZlVG9vbENhbGxzW2NodW5rLnRvb2xDYWxsSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsLWRlbHRhXCIsXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgYXJnc1RleHREZWx0YTogY2h1bmsuYXJnc1RleHREZWx0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjoge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0b29sQ2FsbCA9IGF3YWl0IHBhcnNlVG9vbENhbGwoe1xuICAgICAgICAgICAgICB0b29sQ2FsbDogY2h1bmssXG4gICAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgICByZXBhaXJUb29sQ2FsbCxcbiAgICAgICAgICAgICAgc3lzdGVtLFxuICAgICAgICAgICAgICBtZXNzYWdlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodG9vbENhbGwpO1xuICAgICAgICAgICAgY29uc3QgdG9vbDIgPSB0b29sc1t0b29sQ2FsbC50b29sTmFtZV07XG4gICAgICAgICAgICBpZiAodG9vbDIuZXhlY3V0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRvb2xFeGVjdXRpb25JZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgICAgICAgb3V0c3RhbmRpbmdUb29sUmVzdWx0cy5hZGQodG9vbEV4ZWN1dGlvbklkKTtcbiAgICAgICAgICAgICAgcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJhaS50b29sQ2FsbFwiLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLnRvb2xDYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnRvb2xDYWxsLm5hbWVcIjogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudG9vbENhbGwuaWRcIjogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5hcmdzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHRvb2xDYWxsLmFyZ3MpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICAgICAgZm46IGFzeW5jIChzcGFuKSA9PiB0b29sMi5leGVjdXRlKHRvb2xDYWxsLmFyZ3MsIHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsXG4gICAgICAgICAgICAgICAgfSkudGhlbihcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIC4uLnRvb2xDYWxsLFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG91dHN0YW5kaW5nVG9vbFJlc3VsdHMuZGVsZXRlKHRvb2xFeGVjdXRpb25JZCk7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHRDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnRvb2xDYWxsLnJlc3VsdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBUb29sRXhlY3V0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xBcmdzOiB0b29sQ2FsbC5hcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG91dHN0YW5kaW5nVG9vbFJlc3VsdHMuZGVsZXRlKHRvb2xFeGVjdXRpb25JZCk7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHRDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJmaW5pc2hcIjoge1xuICAgICAgICAgIGZpbmlzaENodW5rID0ge1xuICAgICAgICAgICAgdHlwZTogXCJmaW5pc2hcIixcbiAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogY2h1bmsuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgbG9ncHJvYnM6IGNodW5rLmxvZ3Byb2JzLFxuICAgICAgICAgICAgdXNhZ2U6IGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZShjaHVuay51c2FnZSksXG4gICAgICAgICAgICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBjaHVua1R5cGU7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmhhbmRsZWQgY2h1bmsgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBmbHVzaCgpIHtcbiAgICAgIGNhbkNsb3NlID0gdHJ1ZTtcbiAgICAgIGF0dGVtcHRDbG9zZSgpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgIGdlbmVyYXRvclN0cmVhbS5waXBlVGhyb3VnaChmb3J3YXJkU3RyZWFtKS5waXBlVG8oXG4gICAgICAgICAgbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKSxcbiAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW0ucGlwZVRvKFxuICAgICAgICAgIG5ldyBXcml0YWJsZVN0cmVhbSh7XG4gICAgICAgICAgICB3cml0ZShjaHVuaykge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlKCkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgXSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L3N0cmVhbS10ZXh0LnRzXG52YXIgb3JpZ2luYWxHZW5lcmF0ZUlkNCA9IGNyZWF0ZUlkR2VuZXJhdG9yNCh7XG4gIHByZWZpeDogXCJhaXR4dFwiLFxuICBzaXplOiAyNFxufSk7XG52YXIgb3JpZ2luYWxHZW5lcmF0ZU1lc3NhZ2VJZDIgPSBjcmVhdGVJZEdlbmVyYXRvcjQoe1xuICBwcmVmaXg6IFwibXNnXCIsXG4gIHNpemU6IDI0XG59KTtcbmZ1bmN0aW9uIHN0cmVhbVRleHQoe1xuICBtb2RlbCxcbiAgdG9vbHMsXG4gIHRvb2xDaG9pY2UsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIG1heFN0ZXBzID0gMSxcbiAgZXhwZXJpbWVudGFsX2dlbmVyYXRlTWVzc2FnZUlkOiBnZW5lcmF0ZU1lc3NhZ2VJZCA9IG9yaWdpbmFsR2VuZXJhdGVNZXNzYWdlSWQyLFxuICBleHBlcmltZW50YWxfb3V0cHV0OiBvdXRwdXQsXG4gIGV4cGVyaW1lbnRhbF9jb250aW51ZVN0ZXBzOiBjb250aW51ZVN0ZXBzID0gZmFsc2UsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEsXG4gIHByb3ZpZGVyT3B0aW9ucyA9IGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLFxuICBleHBlcmltZW50YWxfdG9vbENhbGxTdHJlYW1pbmcgPSBmYWxzZSxcbiAgdG9vbENhbGxTdHJlYW1pbmcgPSBleHBlcmltZW50YWxfdG9vbENhbGxTdHJlYW1pbmcsXG4gIGV4cGVyaW1lbnRhbF9hY3RpdmVUb29sczogYWN0aXZlVG9vbHMsXG4gIGV4cGVyaW1lbnRhbF9yZXBhaXJUb29sQ2FsbDogcmVwYWlyVG9vbENhbGwsXG4gIGV4cGVyaW1lbnRhbF90cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgb25DaHVuayxcbiAgb25FcnJvcixcbiAgb25GaW5pc2gsXG4gIG9uU3RlcEZpbmlzaCxcbiAgX2ludGVybmFsOiB7XG4gICAgbm93OiBub3cyID0gbm93LFxuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzID0gb3JpZ2luYWxHZW5lcmF0ZUlkNCxcbiAgICBjdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gIH0gPSB7fSxcbiAgLi4uc2V0dGluZ3Ncbn0pIHtcbiAgcmV0dXJuIG5ldyBEZWZhdWx0U3RyZWFtVGV4dFJlc3VsdCh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3MsXG4gICAgbWF4UmV0cmllcyxcbiAgICBhYm9ydFNpZ25hbCxcbiAgICBzeXN0ZW0sXG4gICAgcHJvbXB0LFxuICAgIG1lc3NhZ2VzLFxuICAgIHRvb2xzLFxuICAgIHRvb2xDaG9pY2UsXG4gICAgdG9vbENhbGxTdHJlYW1pbmcsXG4gICAgdHJhbnNmb3JtczogYXNBcnJheSh0cmFuc2Zvcm0pLFxuICAgIGFjdGl2ZVRvb2xzLFxuICAgIHJlcGFpclRvb2xDYWxsLFxuICAgIG1heFN0ZXBzLFxuICAgIG91dHB1dCxcbiAgICBjb250aW51ZVN0ZXBzLFxuICAgIHByb3ZpZGVyT3B0aW9ucyxcbiAgICBvbkNodW5rLFxuICAgIG9uRXJyb3IsXG4gICAgb25GaW5pc2gsXG4gICAgb25TdGVwRmluaXNoLFxuICAgIG5vdzogbm93MixcbiAgICBjdXJyZW50RGF0ZSxcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyxcbiAgICBnZW5lcmF0ZU1lc3NhZ2VJZFxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU91dHB1dFRyYW5zZm9ybVN0cmVhbShvdXRwdXQpIHtcbiAgaWYgKCFvdXRwdXQpIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgcGFydDogY2h1bmssIHBhcnRpYWxPdXRwdXQ6IHZvaWQgMCB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBsZXQgdGV4dDIgPSBcIlwiO1xuICBsZXQgdGV4dENodW5rID0gXCJcIjtcbiAgbGV0IGxhc3RQdWJsaXNoZWRKc29uID0gXCJcIjtcbiAgZnVuY3Rpb24gcHVibGlzaFRleHRDaHVuayh7XG4gICAgY29udHJvbGxlcixcbiAgICBwYXJ0aWFsT3V0cHV0ID0gdm9pZCAwXG4gIH0pIHtcbiAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgcGFydDogeyB0eXBlOiBcInRleHQtZGVsdGFcIiwgdGV4dERlbHRhOiB0ZXh0Q2h1bmsgfSxcbiAgICAgIHBhcnRpYWxPdXRwdXRcbiAgICB9KTtcbiAgICB0ZXh0Q2h1bmsgPSBcIlwiO1xuICB9XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgIGlmIChjaHVuay50eXBlID09PSBcInN0ZXAtZmluaXNoXCIpIHtcbiAgICAgICAgcHVibGlzaFRleHRDaHVuayh7IGNvbnRyb2xsZXIgfSk7XG4gICAgICB9XG4gICAgICBpZiAoY2h1bmsudHlwZSAhPT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgcGFydDogY2h1bmssIHBhcnRpYWxPdXRwdXQ6IHZvaWQgMCB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGV4dDIgKz0gY2h1bmsudGV4dERlbHRhO1xuICAgICAgdGV4dENodW5rICs9IGNodW5rLnRleHREZWx0YTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG91dHB1dC5wYXJzZVBhcnRpYWwoeyB0ZXh0OiB0ZXh0MiB9KTtcbiAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjdXJyZW50SnNvbiA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdC5wYXJ0aWFsKTtcbiAgICAgICAgaWYgKGN1cnJlbnRKc29uICE9PSBsYXN0UHVibGlzaGVkSnNvbikge1xuICAgICAgICAgIHB1Ymxpc2hUZXh0Q2h1bmsoeyBjb250cm9sbGVyLCBwYXJ0aWFsT3V0cHV0OiByZXN1bHQucGFydGlhbCB9KTtcbiAgICAgICAgICBsYXN0UHVibGlzaGVkSnNvbiA9IGN1cnJlbnRKc29uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICBpZiAodGV4dENodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcHVibGlzaFRleHRDaHVuayh7IGNvbnRyb2xsZXIgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0U3RyZWFtVGV4dFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzLFxuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gICAgYWJvcnRTaWduYWwsXG4gICAgc3lzdGVtLFxuICAgIHByb21wdCxcbiAgICBtZXNzYWdlcyxcbiAgICB0b29scyxcbiAgICB0b29sQ2hvaWNlLFxuICAgIHRvb2xDYWxsU3RyZWFtaW5nLFxuICAgIHRyYW5zZm9ybXMsXG4gICAgYWN0aXZlVG9vbHMsXG4gICAgcmVwYWlyVG9vbENhbGwsXG4gICAgbWF4U3RlcHMsXG4gICAgb3V0cHV0LFxuICAgIGNvbnRpbnVlU3RlcHMsXG4gICAgcHJvdmlkZXJPcHRpb25zLFxuICAgIG5vdzogbm93MixcbiAgICBjdXJyZW50RGF0ZSxcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyxcbiAgICBnZW5lcmF0ZU1lc3NhZ2VJZCxcbiAgICBvbkNodW5rLFxuICAgIG9uRXJyb3IsXG4gICAgb25GaW5pc2gsXG4gICAgb25TdGVwRmluaXNoXG4gIH0pIHtcbiAgICB0aGlzLndhcm5pbmdzUHJvbWlzZSA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIHRoaXMudXNhZ2VQcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5maW5pc2hSZWFzb25Qcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5wcm92aWRlck1ldGFkYXRhUHJvbWlzZSA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIHRoaXMudGV4dFByb21pc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLnJlYXNvbmluZ1Byb21pc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLnJlYXNvbmluZ0RldGFpbHNQcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5zb3VyY2VzUHJvbWlzZSA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIHRoaXMuZmlsZXNQcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy50b29sQ2FsbHNQcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy50b29sUmVzdWx0c1Byb21pc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLnJlcXVlc3RQcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5yZXNwb25zZVByb21pc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLnN0ZXBzUHJvbWlzZSA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIHZhciBfYTE3O1xuICAgIGlmIChtYXhTdGVwcyA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhTdGVwc1wiLFxuICAgICAgICB2YWx1ZTogbWF4U3RlcHMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4U3RlcHMgbXVzdCBiZSBhdCBsZWFzdCAxXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLm91dHB1dCA9IG91dHB1dDtcbiAgICBsZXQgcmVjb3JkZWRTdGVwVGV4dCA9IFwiXCI7XG4gICAgbGV0IHJlY29yZGVkQ29udGludWF0aW9uVGV4dCA9IFwiXCI7XG4gICAgbGV0IHJlY29yZGVkRnVsbFRleHQgPSBcIlwiO1xuICAgIGxldCBzdGVwUmVhc29uaW5nID0gW107XG4gICAgbGV0IHN0ZXBGaWxlcyA9IFtdO1xuICAgIGxldCBhY3RpdmVSZWFzb25pbmdUZXh0ID0gdm9pZCAwO1xuICAgIGxldCByZWNvcmRlZFN0ZXBTb3VyY2VzID0gW107XG4gICAgY29uc3QgcmVjb3JkZWRTb3VyY2VzID0gW107XG4gICAgY29uc3QgcmVjb3JkZWRSZXNwb25zZSA9IHtcbiAgICAgIGlkOiBnZW5lcmF0ZUlkMygpLFxuICAgICAgdGltZXN0YW1wOiBjdXJyZW50RGF0ZSgpLFxuICAgICAgbW9kZWxJZDogbW9kZWwubW9kZWxJZCxcbiAgICAgIG1lc3NhZ2VzOiBbXVxuICAgIH07XG4gICAgbGV0IHJlY29yZGVkVG9vbENhbGxzID0gW107XG4gICAgbGV0IHJlY29yZGVkVG9vbFJlc3VsdHMgPSBbXTtcbiAgICBsZXQgcmVjb3JkZWRGaW5pc2hSZWFzb24gPSB2b2lkIDA7XG4gICAgbGV0IHJlY29yZGVkVXNhZ2UgPSB2b2lkIDA7XG4gICAgbGV0IHN0ZXBUeXBlID0gXCJpbml0aWFsXCI7XG4gICAgY29uc3QgcmVjb3JkZWRTdGVwcyA9IFtdO1xuICAgIGxldCByb290U3BhbjtcbiAgICBjb25zdCBldmVudFByb2Nlc3NvciA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIGNvbnN0IHsgcGFydCB9ID0gY2h1bms7XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidGV4dC1kZWx0YVwiIHx8IHBhcnQudHlwZSA9PT0gXCJyZWFzb25pbmdcIiB8fCBwYXJ0LnR5cGUgPT09IFwic291cmNlXCIgfHwgcGFydC50eXBlID09PSBcInRvb2wtY2FsbFwiIHx8IHBhcnQudHlwZSA9PT0gXCJ0b29sLXJlc3VsdFwiIHx8IHBhcnQudHlwZSA9PT0gXCJ0b29sLWNhbGwtc3RyZWFtaW5nLXN0YXJ0XCIgfHwgcGFydC50eXBlID09PSBcInRvb2wtY2FsbC1kZWx0YVwiKSB7XG4gICAgICAgICAgYXdhaXQgKG9uQ2h1bmsgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQ2h1bmsoeyBjaHVuazogcGFydCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgYXdhaXQgKG9uRXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRXJyb3IoeyBlcnJvcjogcGFydC5lcnJvciB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICByZWNvcmRlZFN0ZXBUZXh0ICs9IHBhcnQudGV4dERlbHRhO1xuICAgICAgICAgIHJlY29yZGVkQ29udGludWF0aW9uVGV4dCArPSBwYXJ0LnRleHREZWx0YTtcbiAgICAgICAgICByZWNvcmRlZEZ1bGxUZXh0ICs9IHBhcnQudGV4dERlbHRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwicmVhc29uaW5nXCIpIHtcbiAgICAgICAgICBpZiAoYWN0aXZlUmVhc29uaW5nVGV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhY3RpdmVSZWFzb25pbmdUZXh0ID0geyB0eXBlOiBcInRleHRcIiwgdGV4dDogcGFydC50ZXh0RGVsdGEgfTtcbiAgICAgICAgICAgIHN0ZXBSZWFzb25pbmcucHVzaChhY3RpdmVSZWFzb25pbmdUZXh0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlUmVhc29uaW5nVGV4dC50ZXh0ICs9IHBhcnQudGV4dERlbHRhO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInJlYXNvbmluZy1zaWduYXR1cmVcIikge1xuICAgICAgICAgIGlmIChhY3RpdmVSZWFzb25pbmdUZXh0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBSVNES0Vycm9yMTcoe1xuICAgICAgICAgICAgICBuYW1lOiBcIkludmFsaWRTdHJlYW1QYXJ0XCIsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IFwicmVhc29uaW5nLXNpZ25hdHVyZSB3aXRob3V0IHJlYXNvbmluZ1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWN0aXZlUmVhc29uaW5nVGV4dC5zaWduYXR1cmUgPSBwYXJ0LnNpZ25hdHVyZTtcbiAgICAgICAgICBhY3RpdmVSZWFzb25pbmdUZXh0ID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwicmVkYWN0ZWQtcmVhc29uaW5nXCIpIHtcbiAgICAgICAgICBzdGVwUmVhc29uaW5nLnB1c2goeyB0eXBlOiBcInJlZGFjdGVkXCIsIGRhdGE6IHBhcnQuZGF0YSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcImZpbGVcIikge1xuICAgICAgICAgIHN0ZXBGaWxlcy5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwic291cmNlXCIpIHtcbiAgICAgICAgICByZWNvcmRlZFNvdXJjZXMucHVzaChwYXJ0LnNvdXJjZSk7XG4gICAgICAgICAgcmVjb3JkZWRTdGVwU291cmNlcy5wdXNoKHBhcnQuc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRvb2wtY2FsbFwiKSB7XG4gICAgICAgICAgcmVjb3JkZWRUb29sQ2FsbHMucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIpIHtcbiAgICAgICAgICByZWNvcmRlZFRvb2xSZXN1bHRzLnB1c2gocGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJzdGVwLWZpbmlzaFwiKSB7XG4gICAgICAgICAgY29uc3Qgc3RlcE1lc3NhZ2VzID0gdG9SZXNwb25zZU1lc3NhZ2VzKHtcbiAgICAgICAgICAgIHRleHQ6IHJlY29yZGVkQ29udGludWF0aW9uVGV4dCxcbiAgICAgICAgICAgIGZpbGVzOiBzdGVwRmlsZXMsXG4gICAgICAgICAgICByZWFzb25pbmc6IHN0ZXBSZWFzb25pbmcsXG4gICAgICAgICAgICB0b29sczogdG9vbHMgIT0gbnVsbCA/IHRvb2xzIDoge30sXG4gICAgICAgICAgICB0b29sQ2FsbHM6IHJlY29yZGVkVG9vbENhbGxzLFxuICAgICAgICAgICAgdG9vbFJlc3VsdHM6IHJlY29yZGVkVG9vbFJlc3VsdHMsXG4gICAgICAgICAgICBtZXNzYWdlSWQ6IHBhcnQubWVzc2FnZUlkLFxuICAgICAgICAgICAgZ2VuZXJhdGVNZXNzYWdlSWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBjdXJyZW50U3RlcCA9IHJlY29yZGVkU3RlcHMubGVuZ3RoO1xuICAgICAgICAgIGxldCBuZXh0U3RlcFR5cGUgPSBcImRvbmVcIjtcbiAgICAgICAgICBpZiAoY3VycmVudFN0ZXAgKyAxIDwgbWF4U3RlcHMpIHtcbiAgICAgICAgICAgIGlmIChjb250aW51ZVN0ZXBzICYmIHBhcnQuZmluaXNoUmVhc29uID09PSBcImxlbmd0aFwiICYmIC8vIG9ubHkgdXNlIGNvbnRpbnVlIHdoZW4gdGhlcmUgYXJlIG5vIHRvb2wgY2FsbHM6XG4gICAgICAgICAgICByZWNvcmRlZFRvb2xDYWxscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgbmV4dFN0ZXBUeXBlID0gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgLy8gdGhlcmUgYXJlIHRvb2wgY2FsbHM6XG4gICAgICAgICAgICAgIHJlY29yZGVkVG9vbENhbGxzLmxlbmd0aCA+IDAgJiYgLy8gYWxsIGN1cnJlbnQgdG9vbCBjYWxscyBoYXZlIHJlc3VsdHM6XG4gICAgICAgICAgICAgIHJlY29yZGVkVG9vbFJlc3VsdHMubGVuZ3RoID09PSByZWNvcmRlZFRvb2xDYWxscy5sZW5ndGhcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBuZXh0U3RlcFR5cGUgPSBcInRvb2wtcmVzdWx0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdGVwUmVzdWx0ID0ge1xuICAgICAgICAgICAgc3RlcFR5cGUsXG4gICAgICAgICAgICB0ZXh0OiByZWNvcmRlZFN0ZXBUZXh0LFxuICAgICAgICAgICAgcmVhc29uaW5nOiBhc1JlYXNvbmluZ1RleHQoc3RlcFJlYXNvbmluZyksXG4gICAgICAgICAgICByZWFzb25pbmdEZXRhaWxzOiBzdGVwUmVhc29uaW5nLFxuICAgICAgICAgICAgZmlsZXM6IHN0ZXBGaWxlcyxcbiAgICAgICAgICAgIHNvdXJjZXM6IHJlY29yZGVkU3RlcFNvdXJjZXMsXG4gICAgICAgICAgICB0b29sQ2FsbHM6IHJlY29yZGVkVG9vbENhbGxzLFxuICAgICAgICAgICAgdG9vbFJlc3VsdHM6IHJlY29yZGVkVG9vbFJlc3VsdHMsXG4gICAgICAgICAgICBmaW5pc2hSZWFzb246IHBhcnQuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgdXNhZ2U6IHBhcnQudXNhZ2UsXG4gICAgICAgICAgICB3YXJuaW5nczogcGFydC53YXJuaW5ncyxcbiAgICAgICAgICAgIGxvZ3Byb2JzOiBwYXJ0LmxvZ3Byb2JzLFxuICAgICAgICAgICAgcmVxdWVzdDogcGFydC5yZXF1ZXN0LFxuICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgLi4ucGFydC5yZXNwb25zZSxcbiAgICAgICAgICAgICAgbWVzc2FnZXM6IFsuLi5yZWNvcmRlZFJlc3BvbnNlLm1lc3NhZ2VzLCAuLi5zdGVwTWVzc2FnZXNdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgaXNDb250aW51ZWQ6IHBhcnQuaXNDb250aW51ZWRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGF3YWl0IChvblN0ZXBGaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uU3RlcEZpbmlzaChjdXJyZW50U3RlcFJlc3VsdCkpO1xuICAgICAgICAgIHJlY29yZGVkU3RlcHMucHVzaChjdXJyZW50U3RlcFJlc3VsdCk7XG4gICAgICAgICAgcmVjb3JkZWRUb29sQ2FsbHMgPSBbXTtcbiAgICAgICAgICByZWNvcmRlZFRvb2xSZXN1bHRzID0gW107XG4gICAgICAgICAgcmVjb3JkZWRTdGVwVGV4dCA9IFwiXCI7XG4gICAgICAgICAgcmVjb3JkZWRTdGVwU291cmNlcyA9IFtdO1xuICAgICAgICAgIHN0ZXBSZWFzb25pbmcgPSBbXTtcbiAgICAgICAgICBzdGVwRmlsZXMgPSBbXTtcbiAgICAgICAgICBhY3RpdmVSZWFzb25pbmdUZXh0ID0gdm9pZCAwO1xuICAgICAgICAgIGlmIChuZXh0U3RlcFR5cGUgIT09IFwiZG9uZVwiKSB7XG4gICAgICAgICAgICBzdGVwVHlwZSA9IG5leHRTdGVwVHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5leHRTdGVwVHlwZSAhPT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgICAgICByZWNvcmRlZFJlc3BvbnNlLm1lc3NhZ2VzLnB1c2goLi4uc3RlcE1lc3NhZ2VzKTtcbiAgICAgICAgICAgIHJlY29yZGVkQ29udGludWF0aW9uVGV4dCA9IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwiZmluaXNoXCIpIHtcbiAgICAgICAgICByZWNvcmRlZFJlc3BvbnNlLmlkID0gcGFydC5yZXNwb25zZS5pZDtcbiAgICAgICAgICByZWNvcmRlZFJlc3BvbnNlLnRpbWVzdGFtcCA9IHBhcnQucmVzcG9uc2UudGltZXN0YW1wO1xuICAgICAgICAgIHJlY29yZGVkUmVzcG9uc2UubW9kZWxJZCA9IHBhcnQucmVzcG9uc2UubW9kZWxJZDtcbiAgICAgICAgICByZWNvcmRlZFJlc3BvbnNlLmhlYWRlcnMgPSBwYXJ0LnJlc3BvbnNlLmhlYWRlcnM7XG4gICAgICAgICAgcmVjb3JkZWRVc2FnZSA9IHBhcnQudXNhZ2U7XG4gICAgICAgICAgcmVjb3JkZWRGaW5pc2hSZWFzb24gPSBwYXJ0LmZpbmlzaFJlYXNvbjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgdmFyIF9hMTg7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHJlY29yZGVkU3RlcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGxhc3RTdGVwID0gcmVjb3JkZWRTdGVwc1tyZWNvcmRlZFN0ZXBzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHNlbGYud2FybmluZ3NQcm9taXNlLnJlc29sdmUobGFzdFN0ZXAud2FybmluZ3MpO1xuICAgICAgICAgIHNlbGYucmVxdWVzdFByb21pc2UucmVzb2x2ZShsYXN0U3RlcC5yZXF1ZXN0KTtcbiAgICAgICAgICBzZWxmLnJlc3BvbnNlUHJvbWlzZS5yZXNvbHZlKGxhc3RTdGVwLnJlc3BvbnNlKTtcbiAgICAgICAgICBzZWxmLnRvb2xDYWxsc1Byb21pc2UucmVzb2x2ZShsYXN0U3RlcC50b29sQ2FsbHMpO1xuICAgICAgICAgIHNlbGYudG9vbFJlc3VsdHNQcm9taXNlLnJlc29sdmUobGFzdFN0ZXAudG9vbFJlc3VsdHMpO1xuICAgICAgICAgIHNlbGYucHJvdmlkZXJNZXRhZGF0YVByb21pc2UucmVzb2x2ZShcbiAgICAgICAgICAgIGxhc3RTdGVwLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZWxmLnJlYXNvbmluZ1Byb21pc2UucmVzb2x2ZShsYXN0U3RlcC5yZWFzb25pbmcpO1xuICAgICAgICAgIHNlbGYucmVhc29uaW5nRGV0YWlsc1Byb21pc2UucmVzb2x2ZShsYXN0U3RlcC5yZWFzb25pbmdEZXRhaWxzKTtcbiAgICAgICAgICBjb25zdCBmaW5pc2hSZWFzb24gPSByZWNvcmRlZEZpbmlzaFJlYXNvbiAhPSBudWxsID8gcmVjb3JkZWRGaW5pc2hSZWFzb24gOiBcInVua25vd25cIjtcbiAgICAgICAgICBjb25zdCB1c2FnZSA9IHJlY29yZGVkVXNhZ2UgIT0gbnVsbCA/IHJlY29yZGVkVXNhZ2UgOiB7XG4gICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiBOYU4sXG4gICAgICAgICAgICBwcm9tcHRUb2tlbnM6IE5hTixcbiAgICAgICAgICAgIHRvdGFsVG9rZW5zOiBOYU5cbiAgICAgICAgICB9O1xuICAgICAgICAgIHNlbGYuZmluaXNoUmVhc29uUHJvbWlzZS5yZXNvbHZlKGZpbmlzaFJlYXNvbik7XG4gICAgICAgICAgc2VsZi51c2FnZVByb21pc2UucmVzb2x2ZSh1c2FnZSk7XG4gICAgICAgICAgc2VsZi50ZXh0UHJvbWlzZS5yZXNvbHZlKHJlY29yZGVkRnVsbFRleHQpO1xuICAgICAgICAgIHNlbGYuc291cmNlc1Byb21pc2UucmVzb2x2ZShyZWNvcmRlZFNvdXJjZXMpO1xuICAgICAgICAgIHNlbGYuZmlsZXNQcm9taXNlLnJlc29sdmUobGFzdFN0ZXAuZmlsZXMpO1xuICAgICAgICAgIHNlbGYuc3RlcHNQcm9taXNlLnJlc29sdmUocmVjb3JkZWRTdGVwcyk7XG4gICAgICAgICAgYXdhaXQgKG9uRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaCh7XG4gICAgICAgICAgICBmaW5pc2hSZWFzb24sXG4gICAgICAgICAgICBsb2dwcm9iczogdm9pZCAwLFxuICAgICAgICAgICAgdXNhZ2UsXG4gICAgICAgICAgICB0ZXh0OiByZWNvcmRlZEZ1bGxUZXh0LFxuICAgICAgICAgICAgcmVhc29uaW5nOiBsYXN0U3RlcC5yZWFzb25pbmcsXG4gICAgICAgICAgICByZWFzb25pbmdEZXRhaWxzOiBsYXN0U3RlcC5yZWFzb25pbmdEZXRhaWxzLFxuICAgICAgICAgICAgZmlsZXM6IGxhc3RTdGVwLmZpbGVzLFxuICAgICAgICAgICAgc291cmNlczogbGFzdFN0ZXAuc291cmNlcyxcbiAgICAgICAgICAgIHRvb2xDYWxsczogbGFzdFN0ZXAudG9vbENhbGxzLFxuICAgICAgICAgICAgdG9vbFJlc3VsdHM6IGxhc3RTdGVwLnRvb2xSZXN1bHRzLFxuICAgICAgICAgICAgcmVxdWVzdDogKF9hMTggPSBsYXN0U3RlcC5yZXF1ZXN0KSAhPSBudWxsID8gX2ExOCA6IHt9LFxuICAgICAgICAgICAgcmVzcG9uc2U6IGxhc3RTdGVwLnJlc3BvbnNlLFxuICAgICAgICAgICAgd2FybmluZ3M6IGxhc3RTdGVwLndhcm5pbmdzLFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbGFzdFN0ZXAucHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBsYXN0U3RlcC5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgIHN0ZXBzOiByZWNvcmRlZFN0ZXBzXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHJvb3RTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGV4dFwiOiB7IG91dHB1dDogKCkgPT4gcmVjb3JkZWRGdWxsVGV4dCB9LFxuICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2ExOTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoX2ExOSA9IGxhc3RTdGVwLnRvb2xDYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTkubGVuZ3RoKSA/IEpTT04uc3RyaW5naWZ5KGxhc3RTdGVwLnRvb2xDYWxscykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiB1c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IHVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHJvb3RTcGFuLmVuZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgc3RpdGNoYWJsZVN0cmVhbSA9IGNyZWF0ZVN0aXRjaGFibGVTdHJlYW0oKTtcbiAgICB0aGlzLmFkZFN0cmVhbSA9IHN0aXRjaGFibGVTdHJlYW0uYWRkU3RyZWFtO1xuICAgIHRoaXMuY2xvc2VTdHJlYW0gPSBzdGl0Y2hhYmxlU3RyZWFtLmNsb3NlO1xuICAgIGxldCBzdHJlYW0gPSBzdGl0Y2hhYmxlU3RyZWFtLnN0cmVhbTtcbiAgICBmb3IgKGNvbnN0IHRyYW5zZm9ybSBvZiB0cmFuc2Zvcm1zKSB7XG4gICAgICBzdHJlYW0gPSBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICAgIHRyYW5zZm9ybSh7XG4gICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgc3RvcFN0cmVhbSgpIHtcbiAgICAgICAgICAgIHN0aXRjaGFibGVTdHJlYW0udGVybWluYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5iYXNlU3RyZWFtID0gc3RyZWFtLnBpcGVUaHJvdWdoKGNyZWF0ZU91dHB1dFRyYW5zZm9ybVN0cmVhbShvdXRwdXQpKS5waXBlVGhyb3VnaChldmVudFByb2Nlc3Nvcik7XG4gICAgY29uc3QgeyBtYXhSZXRyaWVzLCByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoe1xuICAgICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZ1xuICAgIH0pO1xuICAgIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICAgIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgbW9kZWwsXG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBoZWFkZXJzLFxuICAgICAgc2V0dGluZ3M6IHsgLi4uc2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICAgIH0pO1xuICAgIGNvbnN0IGluaXRpYWxQcm9tcHQgPSBzdGFuZGFyZGl6ZVByb21wdCh7XG4gICAgICBwcm9tcHQ6IHtcbiAgICAgICAgc3lzdGVtOiAoX2ExNyA9IG91dHB1dCA9PSBudWxsID8gdm9pZCAwIDogb3V0cHV0LmluamVjdEludG9TeXN0ZW1Qcm9tcHQoeyBzeXN0ZW0sIG1vZGVsIH0pKSAhPSBudWxsID8gX2ExNyA6IHN5c3RlbSxcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICBtZXNzYWdlc1xuICAgICAgfSxcbiAgICAgIHRvb2xzXG4gICAgfSk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmVjb3JkU3Bhbih7XG4gICAgICBuYW1lOiBcImFpLnN0cmVhbVRleHRcIixcbiAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoeyBvcGVyYXRpb25JZDogXCJhaS5zdHJlYW1UZXh0XCIsIHRlbGVtZXRyeSB9KSxcbiAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgXCJhaS5wcm9tcHRcIjoge1xuICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImFpLnNldHRpbmdzLm1heFN0ZXBzXCI6IG1heFN0ZXBzXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgdHJhY2VyLFxuICAgICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgICAgZm46IGFzeW5jIChyb290U3BhbkFyZykgPT4ge1xuICAgICAgICByb290U3BhbiA9IHJvb3RTcGFuQXJnO1xuICAgICAgICBhc3luYyBmdW5jdGlvbiBzdHJlYW1TdGVwKHtcbiAgICAgICAgICBjdXJyZW50U3RlcCxcbiAgICAgICAgICByZXNwb25zZU1lc3NhZ2VzLFxuICAgICAgICAgIHVzYWdlLFxuICAgICAgICAgIHN0ZXBUeXBlOiBzdGVwVHlwZTIsXG4gICAgICAgICAgcHJldmlvdXNTdGVwVGV4dCxcbiAgICAgICAgICBoYXNMZWFkaW5nV2hpdGVzcGFjZSxcbiAgICAgICAgICBtZXNzYWdlSWRcbiAgICAgICAgfSkge1xuICAgICAgICAgIHZhciBfYTE4O1xuICAgICAgICAgIGNvbnN0IHByb21wdEZvcm1hdCA9IHJlc3BvbnNlTWVzc2FnZXMubGVuZ3RoID09PSAwID8gaW5pdGlhbFByb21wdC50eXBlIDogXCJtZXNzYWdlc1wiO1xuICAgICAgICAgIGNvbnN0IHN0ZXBJbnB1dE1lc3NhZ2VzID0gW1xuICAgICAgICAgICAgLi4uaW5pdGlhbFByb21wdC5tZXNzYWdlcyxcbiAgICAgICAgICAgIC4uLnJlc3BvbnNlTWVzc2FnZXNcbiAgICAgICAgICBdO1xuICAgICAgICAgIGNvbnN0IHByb21wdE1lc3NhZ2VzID0gYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgICAgICBwcm9tcHQ6IHtcbiAgICAgICAgICAgICAgdHlwZTogcHJvbXB0Rm9ybWF0LFxuICAgICAgICAgICAgICBzeXN0ZW06IGluaXRpYWxQcm9tcHQuc3lzdGVtLFxuICAgICAgICAgICAgICBtZXNzYWdlczogc3RlcElucHV0TWVzc2FnZXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJscyxcbiAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNVcmw6IChfYTE4ID0gbW9kZWwuc3VwcG9ydHNVcmwpID09IG51bGwgPyB2b2lkIDAgOiBfYTE4LmJpbmQobW9kZWwpXG4gICAgICAgICAgICAvLyBzdXBwb3J0ICd0aGlzJyBjb250ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgbW9kZSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwicmVndWxhclwiLFxuICAgICAgICAgICAgLi4ucHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSh7IHRvb2xzLCB0b29sQ2hvaWNlLCBhY3RpdmVUb29scyB9KVxuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgcmVzdWx0OiB7IHN0cmVhbTogc3RyZWFtMiwgd2FybmluZ3MsIHJhd1Jlc3BvbnNlLCByZXF1ZXN0IH0sXG4gICAgICAgICAgICBkb1N0cmVhbVNwYW4sXG4gICAgICAgICAgICBzdGFydFRpbWVzdGFtcE1zXG4gICAgICAgICAgfSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICAgKCkgPT4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICAgIG5hbWU6IFwiYWkuc3RyZWFtVGV4dC5kb1N0cmVhbVwiLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuc3RyZWFtVGV4dC5kb1N0cmVhbVwiLFxuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICBcImFpLnByb21wdC5mb3JtYXRcIjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gcHJvbXB0Rm9ybWF0XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQubWVzc2FnZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocHJvbXB0TWVzc2FnZXMpXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQudG9vbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHRoZSBsYW5ndWFnZSBtb2RlbCBsZXZlbCB0b29sczpcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgX2ExOTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9hMTkgPSBtb2RlLnRvb2xzKSA9PSBudWxsID8gdm9pZCAwIDogX2ExOS5tYXAoKHRvb2wyKSA9PiBKU09OLnN0cmluZ2lmeSh0b29sMikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQudG9vbENob2ljZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBtb2RlLnRvb2xDaG9pY2UgIT0gbnVsbCA/IEpTT04uc3RyaW5naWZ5KG1vZGUudG9vbENob2ljZSkgOiB2b2lkIDBcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LmZyZXF1ZW5jeV9wZW5hbHR5XCI6IHNldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogc2V0dGluZ3MubWF4VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI6IHNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3Quc3RvcF9zZXF1ZW5jZXNcIjogc2V0dGluZ3Muc3RvcFNlcXVlbmNlcyxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjogc2V0dGluZ3MudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9rXCI6IHNldHRpbmdzLnRvcEssXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI6IHNldHRpbmdzLnRvcFBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICAgIGVuZFdoZW5Eb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgZm46IGFzeW5jIChkb1N0cmVhbVNwYW4yKSA9PiAoe1xuICAgICAgICAgICAgICAgIHN0YXJ0VGltZXN0YW1wTXM6IG5vdzIoKSxcbiAgICAgICAgICAgICAgICAvLyBnZXQgYmVmb3JlIHRoZSBjYWxsXG4gICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuOiBkb1N0cmVhbVNwYW4yLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogYXdhaXQgbW9kZWwuZG9TdHJlYW0oe1xuICAgICAgICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgICAgICAgIC4uLnByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpLFxuICAgICAgICAgICAgICAgICAgaW5wdXRGb3JtYXQ6IHByb21wdEZvcm1hdCxcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlRm9ybWF0OiBvdXRwdXQgPT0gbnVsbCA/IHZvaWQgMCA6IG91dHB1dC5yZXNwb25zZUZvcm1hdCh7IG1vZGVsIH0pLFxuICAgICAgICAgICAgICAgICAgcHJvbXB0OiBwcm9tcHRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRTdHJlYW0gPSBydW5Ub29sc1RyYW5zZm9ybWF0aW9uKHtcbiAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgZ2VuZXJhdG9yU3RyZWFtOiBzdHJlYW0yLFxuICAgICAgICAgICAgdG9vbENhbGxTdHJlYW1pbmcsXG4gICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICBzeXN0ZW0sXG4gICAgICAgICAgICBtZXNzYWdlczogc3RlcElucHV0TWVzc2FnZXMsXG4gICAgICAgICAgICByZXBhaXJUb29sQ2FsbCxcbiAgICAgICAgICAgIGFib3J0U2lnbmFsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3Qgc3RlcFJlcXVlc3QgPSByZXF1ZXN0ICE9IG51bGwgPyByZXF1ZXN0IDoge307XG4gICAgICAgICAgY29uc3Qgc3RlcFRvb2xDYWxscyA9IFtdO1xuICAgICAgICAgIGNvbnN0IHN0ZXBUb29sUmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGNvbnN0IHN0ZXBSZWFzb25pbmcyID0gW107XG4gICAgICAgICAgY29uc3Qgc3RlcEZpbGVzMiA9IFtdO1xuICAgICAgICAgIGxldCBhY3RpdmVSZWFzb25pbmdUZXh0MiA9IHZvaWQgMDtcbiAgICAgICAgICBsZXQgc3RlcEZpbmlzaFJlYXNvbiA9IFwidW5rbm93blwiO1xuICAgICAgICAgIGxldCBzdGVwVXNhZ2UgPSB7XG4gICAgICAgICAgICBwcm9tcHRUb2tlbnM6IDAsXG4gICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiAwLFxuICAgICAgICAgICAgdG90YWxUb2tlbnM6IDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIGxldCBzdGVwUHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICBsZXQgc3RlcEZpcnN0Q2h1bmsgPSB0cnVlO1xuICAgICAgICAgIGxldCBzdGVwVGV4dCA9IFwiXCI7XG4gICAgICAgICAgbGV0IGZ1bGxTdGVwVGV4dCA9IHN0ZXBUeXBlMiA9PT0gXCJjb250aW51ZVwiID8gcHJldmlvdXNTdGVwVGV4dCA6IFwiXCI7XG4gICAgICAgICAgbGV0IHN0ZXBMb2dQcm9icztcbiAgICAgICAgICBsZXQgc3RlcFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgaWQ6IGdlbmVyYXRlSWQzKCksXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGN1cnJlbnREYXRlKCksXG4gICAgICAgICAgICBtb2RlbElkOiBtb2RlbC5tb2RlbElkXG4gICAgICAgICAgfTtcbiAgICAgICAgICBsZXQgY2h1bmtCdWZmZXIgPSBcIlwiO1xuICAgICAgICAgIGxldCBjaHVua1RleHRQdWJsaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICBsZXQgaW5XaGl0ZXNwYWNlUHJlZml4ID0gdHJ1ZTtcbiAgICAgICAgICBsZXQgaGFzV2hpdGVzcGFjZVN1ZmZpeCA9IGZhbHNlO1xuICAgICAgICAgIGFzeW5jIGZ1bmN0aW9uIHB1Ymxpc2hUZXh0Q2h1bmsoe1xuICAgICAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgICAgIGNodW5rXG4gICAgICAgICAgfSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgIHN0ZXBUZXh0ICs9IGNodW5rLnRleHREZWx0YTtcbiAgICAgICAgICAgIGZ1bGxTdGVwVGV4dCArPSBjaHVuay50ZXh0RGVsdGE7XG4gICAgICAgICAgICBjaHVua1RleHRQdWJsaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgaGFzV2hpdGVzcGFjZVN1ZmZpeCA9IGNodW5rLnRleHREZWx0YS50cmltRW5kKCkgIT09IGNodW5rLnRleHREZWx0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5hZGRTdHJlYW0oXG4gICAgICAgICAgICB0cmFuc2Zvcm1lZFN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgICAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2ExOSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgICAgaWYgKHN0ZXBGaXJzdENodW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1zVG9GaXJzdENodW5rID0gbm93MigpIC0gc3RhcnRUaW1lc3RhbXBNcztcbiAgICAgICAgICAgICAgICAgICAgc3RlcEZpcnN0Q2h1bmsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLmFkZEV2ZW50KFwiYWkuc3RyZWFtLmZpcnN0Q2h1bmtcIiwge1xuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubXNUb0ZpcnN0Q2h1bmtcIjogbXNUb0ZpcnN0Q2h1bmtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RlcC1zdGFydFwiLFxuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBzdGVwUmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5nczogd2FybmluZ3MgIT0gbnVsbCA/IHdhcm5pbmdzIDogW11cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIgJiYgY2h1bmsudGV4dERlbHRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb25zdCBjaHVua1R5cGUgPSBjaHVuay50eXBlO1xuICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaHVua1R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250aW51ZVN0ZXBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkQ2h1bmtUZXh0ID0gaW5XaGl0ZXNwYWNlUHJlZml4ICYmIGhhc0xlYWRpbmdXaGl0ZXNwYWNlID8gY2h1bmsudGV4dERlbHRhLnRyaW1TdGFydCgpIDogY2h1bmsudGV4dERlbHRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyaW1tZWRDaHVua1RleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5XaGl0ZXNwYWNlUHJlZml4ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVua0J1ZmZlciArPSB0cmltbWVkQ2h1bmtUZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BsaXQgPSBzcGxpdE9uTGFzdFdoaXRlc3BhY2UoY2h1bmtCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwbGl0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtCdWZmZXIgPSBzcGxpdC5zdWZmaXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHB1Ymxpc2hUZXh0Q2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bms6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dERlbHRhOiBzcGxpdC5wcmVmaXggKyBzcGxpdC53aGl0ZXNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcHVibGlzaFRleHRDaHVuayh7IGNvbnRyb2xsZXIsIGNodW5rIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVSZWFzb25pbmdUZXh0MiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVSZWFzb25pbmdUZXh0MiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNodW5rLnRleHREZWx0YVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBSZWFzb25pbmcyLnB1c2goYWN0aXZlUmVhc29uaW5nVGV4dDIpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVSZWFzb25pbmdUZXh0Mi50ZXh0ICs9IGNodW5rLnRleHREZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZy1zaWduYXR1cmVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZVJlYXNvbmluZ1RleHQyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkU3RyZWFtUGFydEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwicmVhc29uaW5nLXNpZ25hdHVyZSB3aXRob3V0IHJlYXNvbmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgYWN0aXZlUmVhc29uaW5nVGV4dDIuc2lnbmF0dXJlID0gY2h1bmsuc2lnbmF0dXJlO1xuICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVJlYXNvbmluZ1RleHQyID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZWRhY3RlZC1yZWFzb25pbmdcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcFJlYXNvbmluZzIucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJlZGFjdGVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBjaHVuay5kYXRhXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwVG9vbENhbGxzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwVG9vbFJlc3VsdHMucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlc3BvbnNlLW1ldGFkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogKF9hMTkgPSBjaHVuay5pZCkgIT0gbnVsbCA/IF9hMTkgOiBzdGVwUmVzcG9uc2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IChfYiA9IGNodW5rLnRpbWVzdGFtcCkgIT0gbnVsbCA/IF9iIDogc3RlcFJlc3BvbnNlLnRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsSWQ6IChfYyA9IGNodW5rLm1vZGVsSWQpICE9IG51bGwgPyBfYyA6IHN0ZXBSZXNwb25zZS5tb2RlbElkXG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwVXNhZ2UgPSBjaHVuay51c2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwRmluaXNoUmVhc29uID0gY2h1bmsuZmluaXNoUmVhc29uO1xuICAgICAgICAgICAgICAgICAgICAgIHN0ZXBQcm92aWRlck1ldGFkYXRhID0gY2h1bmsuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcExvZ1Byb2JzID0gY2h1bmsubG9ncHJvYnM7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgbXNUb0ZpbmlzaCA9IG5vdzIoKSAtIHN0YXJ0VGltZXN0YW1wTXM7XG4gICAgICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLmFkZEV2ZW50KFwiYWkuc3RyZWFtLmZpbmlzaFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1zVG9GaW5pc2hcIjogbXNUb0ZpbmlzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuYXZnQ29tcGxldGlvblRva2Vuc1BlclNlY29uZFwiOiAxZTMgKiBzdGVwVXNhZ2UuY29tcGxldGlvblRva2VucyAvIG1zVG9GaW5pc2hcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmlsZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcEZpbGVzMi5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzb3VyY2VcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1zdHJlYW1pbmctc3RhcnRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1kZWx0YVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcEZpbmlzaFJlYXNvbiA9IFwiZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gY2h1bmtUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjaHVuayB0eXBlOiAke2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gaW52b2tlIG9uRmluaXNoIGNhbGxiYWNrIGFuZCByZXNvbHZlIHRvb2xSZXN1bHRzIHByb21pc2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGFib3V0IHRvIGNsb3NlOlxuICAgICAgICAgICAgICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXBUb29sQ2FsbHNKc29uID0gc3RlcFRvb2xDYWxscy5sZW5ndGggPiAwID8gSlNPTi5zdHJpbmdpZnkoc3RlcFRvb2xDYWxscykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICBsZXQgbmV4dFN0ZXBUeXBlID0gXCJkb25lXCI7XG4gICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFN0ZXAgKyAxIDwgbWF4U3RlcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRpbnVlU3RlcHMgJiYgc3RlcEZpbmlzaFJlYXNvbiA9PT0gXCJsZW5ndGhcIiAmJiAvLyBvbmx5IHVzZSBjb250aW51ZSB3aGVuIHRoZXJlIGFyZSBubyB0b29sIGNhbGxzOlxuICAgICAgICAgICAgICAgICAgICBzdGVwVG9vbENhbGxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIG5leHRTdGVwVHlwZSA9IFwiY29udGludWVcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZSBhcmUgdG9vbCBjYWxsczpcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwVG9vbENhbGxzLmxlbmd0aCA+IDAgJiYgLy8gYWxsIGN1cnJlbnQgdG9vbCBjYWxscyBoYXZlIHJlc3VsdHM6XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcFRvb2xSZXN1bHRzLmxlbmd0aCA9PT0gc3RlcFRvb2xDYWxscy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFN0ZXBUeXBlID0gXCJ0b29sLXJlc3VsdFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoY29udGludWVTdGVwcyAmJiBjaHVua0J1ZmZlci5sZW5ndGggPiAwICYmIChuZXh0U3RlcFR5cGUgIT09IFwiY29udGludWVcIiB8fCAvLyB3aGVuIHRoZSBuZXh0IHN0ZXAgaXMgYSByZWd1bGFyIHN0ZXAsIHB1Ymxpc2ggdGhlIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgc3RlcFR5cGUyID09PSBcImNvbnRpbnVlXCIgJiYgIWNodW5rVGV4dFB1Ymxpc2hlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcHVibGlzaFRleHRDaHVuayh7XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgICAgICAgICAgICAgICBjaHVuazoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0RGVsdGE6IGNodW5rQnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtCdWZmZXIgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IHN0ZXBGaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGV4dFwiOiB7IG91dHB1dDogKCkgPT4gc3RlcFRleHQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gc3RlcFRvb2xDYWxsc0pzb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5pZFwiOiBzdGVwUmVzcG9uc2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogc3RlcFJlc3BvbnNlLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGltZXN0YW1wXCI6IHN0ZXBSZXNwb25zZS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogc3RlcFVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IHN0ZXBVc2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmZpbmlzaF9yZWFzb25zXCI6IFtzdGVwRmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuaWRcIjogc3RlcFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5tb2RlbFwiOiBzdGVwUmVzcG9uc2UubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI6IHN0ZXBVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogc3RlcFVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RlcC1maW5pc2hcIixcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICB1c2FnZTogc3RlcFVzYWdlLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBzdGVwUHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHN0ZXBQcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICBsb2dwcm9iczogc3RlcExvZ1Byb2JzLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBzdGVwUmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5zdGVwUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmF3UmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJhd1Jlc3BvbnNlLmhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZ3MsXG4gICAgICAgICAgICAgICAgICAgIGlzQ29udGludWVkOiBuZXh0U3RlcFR5cGUgPT09IFwiY29udGludWVcIixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUlkXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkVXNhZ2UgPSBhZGRMYW5ndWFnZU1vZGVsVXNhZ2UodXNhZ2UsIHN0ZXBVc2FnZSk7XG4gICAgICAgICAgICAgICAgICBpZiAobmV4dFN0ZXBUeXBlID09PSBcImRvbmVcIikge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZmluaXNoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIHVzYWdlOiBjb21iaW5lZFVzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHN0ZXBQcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBzdGVwUHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICBsb2dwcm9iczogc3RlcExvZ1Byb2JzLFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zdGVwUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiByYXdSZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogcmF3UmVzcG9uc2UuaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2xvc2VTdHJlYW0oKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGVwVHlwZTIgPT09IFwiY29udGludWVcIikge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gcmVzcG9uc2VNZXNzYWdlc1tyZXNwb25zZU1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGFzdE1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2UuY29udGVudCArPSBzdGVwVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2UuY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogc3RlcFRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4udG9SZXNwb25zZU1lc3NhZ2VzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogc3RlcFRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzOiBzdGVwRmlsZXMyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb25pbmc6IHN0ZXBSZWFzb25pbmcyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sczogdG9vbHMgIT0gbnVsbCA/IHRvb2xzIDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsczogc3RlcFRvb2xDYWxscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbFJlc3VsdHM6IHN0ZXBUb29sUmVzdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZU1lc3NhZ2VJZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHN0cmVhbVN0ZXAoe1xuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGVwOiBjdXJyZW50U3RlcCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICB1c2FnZTogY29tYmluZWRVc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwVHlwZTogbmV4dFN0ZXBUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzU3RlcFRleHQ6IGZ1bGxTdGVwVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICBoYXNMZWFkaW5nV2hpdGVzcGFjZTogaGFzV2hpdGVzcGFjZVN1ZmZpeCxcbiAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSWQ6IChcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgdGhlIHNhbWUgaWQgd2hlbiBjb250aW51aW5nIGEgc3RlcDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTdGVwVHlwZSA9PT0gXCJjb250aW51ZVwiID8gbWVzc2FnZUlkIDogZ2VuZXJhdGVNZXNzYWdlSWQoKVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgc3RyZWFtU3RlcCh7XG4gICAgICAgICAgY3VycmVudFN0ZXA6IDAsXG4gICAgICAgICAgcmVzcG9uc2VNZXNzYWdlczogW10sXG4gICAgICAgICAgdXNhZ2U6IHtcbiAgICAgICAgICAgIHByb21wdFRva2VuczogMCxcbiAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IDAsXG4gICAgICAgICAgICB0b3RhbFRva2VuczogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJldmlvdXNTdGVwVGV4dDogXCJcIixcbiAgICAgICAgICBzdGVwVHlwZTogXCJpbml0aWFsXCIsXG4gICAgICAgICAgaGFzTGVhZGluZ1doaXRlc3BhY2U6IGZhbHNlLFxuICAgICAgICAgIG1lc3NhZ2VJZDogZ2VuZXJhdGVNZXNzYWdlSWQoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgIHNlbGYuYWRkU3RyZWFtKFxuICAgICAgICBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwiZXJyb3JcIiwgZXJyb3IgfSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHNlbGYuY2xvc2VTdHJlYW0oKTtcbiAgICB9KTtcbiAgfVxuICBnZXQgd2FybmluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMud2FybmluZ3NQcm9taXNlLnZhbHVlO1xuICB9XG4gIGdldCB1c2FnZSgpIHtcbiAgICByZXR1cm4gdGhpcy51c2FnZVByb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IGZpbmlzaFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hSZWFzb25Qcm9taXNlLnZhbHVlO1xuICB9XG4gIGdldCBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlck1ldGFkYXRhUHJvbWlzZS52YWx1ZTtcbiAgfVxuICBnZXQgcHJvdmlkZXJNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlck1ldGFkYXRhUHJvbWlzZS52YWx1ZTtcbiAgfVxuICBnZXQgdGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0UHJvbWlzZS52YWx1ZTtcbiAgfVxuICBnZXQgcmVhc29uaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnJlYXNvbmluZ1Byb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IHJlYXNvbmluZ0RldGFpbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhc29uaW5nRGV0YWlsc1Byb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IHNvdXJjZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlc1Byb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IGZpbGVzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbGVzUHJvbWlzZS52YWx1ZTtcbiAgfVxuICBnZXQgdG9vbENhbGxzKCkge1xuICAgIHJldHVybiB0aGlzLnRvb2xDYWxsc1Byb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IHRvb2xSZXN1bHRzKCkge1xuICAgIHJldHVybiB0aGlzLnRvb2xSZXN1bHRzUHJvbWlzZS52YWx1ZTtcbiAgfVxuICBnZXQgcmVxdWVzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0UHJvbWlzZS52YWx1ZTtcbiAgfVxuICBnZXQgcmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzcG9uc2VQcm9taXNlLnZhbHVlO1xuICB9XG4gIGdldCBzdGVwcygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGVwc1Byb21pc2UudmFsdWU7XG4gIH1cbiAgLyoqXG4gIFNwbGl0IG91dCBhIG5ldyBzdHJlYW0gZnJvbSB0aGUgb3JpZ2luYWwgc3RyZWFtLlxuICBUaGUgb3JpZ2luYWwgc3RyZWFtIGlzIHJlcGxhY2VkIHRvIGFsbG93IGZvciBmdXJ0aGVyIHNwbGl0dGluZyxcbiAgc2luY2Ugd2UgZG8gbm90IGtub3cgaG93IG1hbnkgdGltZXMgdGhlIHN0cmVhbSB3aWxsIGJlIHNwbGl0LlxuICBcbiAgTm90ZTogdGhpcyBsZWFkcyB0byBidWZmZXJpbmcgdGhlIHN0cmVhbSBjb250ZW50IG9uIHRoZSBzZXJ2ZXIuXG4gIEhvd2V2ZXIsIHRoZSBMTE0gcmVzdWx0cyBhcmUgZXhwZWN0ZWQgdG8gYmUgc21hbGwgZW5vdWdoIHRvIG5vdCBjYXVzZSBpc3N1ZXMuXG4gICAgICovXG4gIHRlZVN0cmVhbSgpIHtcbiAgICBjb25zdCBbc3RyZWFtMSwgc3RyZWFtMl0gPSB0aGlzLmJhc2VTdHJlYW0udGVlKCk7XG4gICAgdGhpcy5iYXNlU3RyZWFtID0gc3RyZWFtMjtcbiAgICByZXR1cm4gc3RyZWFtMTtcbiAgfVxuICBnZXQgdGV4dFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShcbiAgICAgIHRoaXMudGVlU3RyZWFtKCkucGlwZVRocm91Z2goXG4gICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgIHRyYW5zZm9ybSh7IHBhcnQgfSwgY29udHJvbGxlcikge1xuICAgICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnQudGV4dERlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBnZXQgZnVsbFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShcbiAgICAgIHRoaXMudGVlU3RyZWFtKCkucGlwZVRocm91Z2goXG4gICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgIHRyYW5zZm9ybSh7IHBhcnQgfSwgY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGFzeW5jIGNvbnN1bWVTdHJlYW0ob3B0aW9ucykge1xuICAgIHZhciBfYTE3O1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBjb25zdW1lU3RyZWFtKHtcbiAgICAgICAgc3RyZWFtOiB0aGlzLmZ1bGxTdHJlYW0sXG4gICAgICAgIG9uRXJyb3I6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMub25FcnJvclxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIChfYTE3ID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5vbkVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jYWxsKG9wdGlvbnMsIGVycm9yKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGV4cGVyaW1lbnRhbF9wYXJ0aWFsT3V0cHV0U3RyZWFtKCkge1xuICAgIGlmICh0aGlzLm91dHB1dCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9PdXRwdXRTcGVjaWZpZWRFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShcbiAgICAgIHRoaXMudGVlU3RyZWFtKCkucGlwZVRocm91Z2goXG4gICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgIHRyYW5zZm9ybSh7IHBhcnRpYWxPdXRwdXQgfSwgY29udHJvbGxlcikge1xuICAgICAgICAgICAgaWYgKHBhcnRpYWxPdXRwdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUocGFydGlhbE91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgdG9EYXRhU3RyZWFtSW50ZXJuYWwoe1xuICAgIGdldEVycm9yTWVzc2FnZTogZ2V0RXJyb3JNZXNzYWdlNSA9ICgpID0+IFwiQW4gZXJyb3Igb2NjdXJyZWQuXCIsXG4gICAgLy8gbWFzayBlcnJvciBtZXNzYWdlcyBmb3Igc2FmZXR5IGJ5IGRlZmF1bHRcbiAgICBzZW5kVXNhZ2UgPSB0cnVlLFxuICAgIHNlbmRSZWFzb25pbmcgPSBmYWxzZSxcbiAgICBzZW5kU291cmNlcyA9IGZhbHNlLFxuICAgIGV4cGVyaW1lbnRhbF9zZW5kRmluaXNoID0gdHJ1ZVxuICB9KSB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbFN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm06IGFzeW5jIChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgICAgIGNvbnN0IGNodW5rVHlwZSA9IGNodW5rLnR5cGU7XG4gICAgICAgICAgc3dpdGNoIChjaHVua1R5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGZvcm1hdERhdGFTdHJlYW1QYXJ0MihcInRleHRcIiwgY2h1bmsudGV4dERlbHRhKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZ1wiOiB7XG4gICAgICAgICAgICAgIGlmIChzZW5kUmVhc29uaW5nKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgICAgZm9ybWF0RGF0YVN0cmVhbVBhcnQyKFwicmVhc29uaW5nXCIsIGNodW5rLnRleHREZWx0YSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJlZGFjdGVkLXJlYXNvbmluZ1wiOiB7XG4gICAgICAgICAgICAgIGlmIChzZW5kUmVhc29uaW5nKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgICAgZm9ybWF0RGF0YVN0cmVhbVBhcnQyKFwicmVkYWN0ZWRfcmVhc29uaW5nXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY2h1bmsuZGF0YVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZy1zaWduYXR1cmVcIjoge1xuICAgICAgICAgICAgICBpZiAoc2VuZFJlYXNvbmluZykge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICAgIGZvcm1hdERhdGFTdHJlYW1QYXJ0MihcInJlYXNvbmluZ19zaWduYXR1cmVcIiwge1xuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IGNodW5rLnNpZ25hdHVyZVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgZm9ybWF0RGF0YVN0cmVhbVBhcnQyKFwiZmlsZVwiLCB7XG4gICAgICAgICAgICAgICAgICBtaW1lVHlwZTogY2h1bmsubWltZVR5cGUsXG4gICAgICAgICAgICAgICAgICBkYXRhOiBjaHVuay5iYXNlNjRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzb3VyY2VcIjoge1xuICAgICAgICAgICAgICBpZiAoc2VuZFNvdXJjZXMpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgICBmb3JtYXREYXRhU3RyZWFtUGFydDIoXCJzb3VyY2VcIiwgY2h1bmsuc291cmNlKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsLXN0cmVhbWluZy1zdGFydFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICBmb3JtYXREYXRhU3RyZWFtUGFydDIoXCJ0b29sX2NhbGxfc3RyZWFtaW5nX3N0YXJ0XCIsIHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGwtZGVsdGFcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgZm9ybWF0RGF0YVN0cmVhbVBhcnQyKFwidG9vbF9jYWxsX2RlbHRhXCIsIHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICBhcmdzVGV4dERlbHRhOiBjaHVuay5hcmdzVGV4dERlbHRhXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgIGZvcm1hdERhdGFTdHJlYW1QYXJ0MihcInRvb2xfY2FsbFwiLCB7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgYXJnczogY2h1bmsuYXJnc1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtcmVzdWx0XCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgIGZvcm1hdERhdGFTdHJlYW1QYXJ0MihcInRvb2xfcmVzdWx0XCIsIHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICByZXN1bHQ6IGNodW5rLnJlc3VsdFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgIGZvcm1hdERhdGFTdHJlYW1QYXJ0MihcImVycm9yXCIsIGdldEVycm9yTWVzc2FnZTUoY2h1bmsuZXJyb3IpKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzdGVwLXN0YXJ0XCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgIGZvcm1hdERhdGFTdHJlYW1QYXJ0MihcInN0YXJ0X3N0ZXBcIiwge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZUlkOiBjaHVuay5tZXNzYWdlSWRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzdGVwLWZpbmlzaFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICBmb3JtYXREYXRhU3RyZWFtUGFydDIoXCJmaW5pc2hfc3RlcFwiLCB7XG4gICAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IGNodW5rLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgIHVzYWdlOiBzZW5kVXNhZ2UgPyB7XG4gICAgICAgICAgICAgICAgICAgIHByb21wdFRva2VuczogY2h1bmsudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiBjaHVuay51c2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gICAgICAgICAgICAgICAgICB9IDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgaXNDb250aW51ZWQ6IGNodW5rLmlzQ29udGludWVkXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6IHtcbiAgICAgICAgICAgICAgaWYgKGV4cGVyaW1lbnRhbF9zZW5kRmluaXNoKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgICAgZm9ybWF0RGF0YVN0cmVhbVBhcnQyKFwiZmluaXNoX21lc3NhZ2VcIiwge1xuICAgICAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IGNodW5rLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgdXNhZ2U6IHNlbmRVc2FnZSA/IHtcbiAgICAgICAgICAgICAgICAgICAgICBwcm9tcHRUb2tlbnM6IGNodW5rLnVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiBjaHVuay51c2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gICAgICAgICAgICAgICAgICAgIH0gOiB2b2lkIDBcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gY2h1bmtUeXBlO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY2h1bmsgdHlwZTogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgcGlwZURhdGFTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgc3RhdHVzLFxuICAgIHN0YXR1c1RleHQsXG4gICAgaGVhZGVycyxcbiAgICBkYXRhLFxuICAgIGdldEVycm9yTWVzc2FnZTogZ2V0RXJyb3JNZXNzYWdlNSxcbiAgICBzZW5kVXNhZ2UsXG4gICAgc2VuZFJlYXNvbmluZyxcbiAgICBzZW5kU291cmNlcyxcbiAgICBleHBlcmltZW50YWxfc2VuZEZpbmlzaFxuICB9ID0ge30pIHtcbiAgICB3cml0ZVRvU2VydmVyUmVzcG9uc2Uoe1xuICAgICAgcmVzcG9uc2UsXG4gICAgICBzdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogcHJlcGFyZU91dGdvaW5nSHR0cEhlYWRlcnMoaGVhZGVycywge1xuICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAgIGRhdGFTdHJlYW1WZXJzaW9uOiBcInYxXCJcbiAgICAgIH0pLFxuICAgICAgc3RyZWFtOiB0aGlzLnRvRGF0YVN0cmVhbSh7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIGdldEVycm9yTWVzc2FnZTogZ2V0RXJyb3JNZXNzYWdlNSxcbiAgICAgICAgc2VuZFVzYWdlLFxuICAgICAgICBzZW5kUmVhc29uaW5nLFxuICAgICAgICBzZW5kU291cmNlcyxcbiAgICAgICAgZXhwZXJpbWVudGFsX3NlbmRGaW5pc2hcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgcGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCBpbml0KSB7XG4gICAgd3JpdGVUb1NlcnZlclJlc3BvbnNlKHtcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgc3RhdHVzOiBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IHByZXBhcmVPdXRnb2luZ0h0dHBIZWFkZXJzKGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVycywge1xuICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAgICAgIH0pLFxuICAgICAgc3RyZWFtOiB0aGlzLnRleHRTdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpXG4gICAgfSk7XG4gIH1cbiAgLy8gVE9ETyBicmVha2luZyBjaGFuZ2UgNS4wOiByZW1vdmUgcGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpXG4gIHRvRGF0YVN0cmVhbShvcHRpb25zKSB7XG4gICAgY29uc3Qgc3RyZWFtID0gdGhpcy50b0RhdGFTdHJlYW1JbnRlcm5hbCh7XG4gICAgICBnZXRFcnJvck1lc3NhZ2U6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2V0RXJyb3JNZXNzYWdlLFxuICAgICAgc2VuZFVzYWdlOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnNlbmRVc2FnZSxcbiAgICAgIHNlbmRSZWFzb25pbmc6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc2VuZFJlYXNvbmluZyxcbiAgICAgIHNlbmRTb3VyY2VzOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnNlbmRTb3VyY2VzLFxuICAgICAgZXhwZXJpbWVudGFsX3NlbmRGaW5pc2g6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZXhwZXJpbWVudGFsX3NlbmRGaW5pc2hcbiAgICB9KS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSk7XG4gICAgcmV0dXJuIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGEpID8gbWVyZ2VTdHJlYW1zKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YS5zdHJlYW0sIHN0cmVhbSkgOiBzdHJlYW07XG4gIH1cbiAgbWVyZ2VJbnRvRGF0YVN0cmVhbSh3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICB3cml0ZXIubWVyZ2UoXG4gICAgICB0aGlzLnRvRGF0YVN0cmVhbUludGVybmFsKHtcbiAgICAgICAgZ2V0RXJyb3JNZXNzYWdlOiB3cml0ZXIub25FcnJvcixcbiAgICAgICAgc2VuZFVzYWdlOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnNlbmRVc2FnZSxcbiAgICAgICAgc2VuZFJlYXNvbmluZzogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5zZW5kUmVhc29uaW5nLFxuICAgICAgICBzZW5kU291cmNlczogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5zZW5kU291cmNlcyxcbiAgICAgICAgZXhwZXJpbWVudGFsX3NlbmRGaW5pc2g6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZXhwZXJpbWVudGFsX3NlbmRGaW5pc2hcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICB0b0RhdGFTdHJlYW1SZXNwb25zZSh7XG4gICAgaGVhZGVycyxcbiAgICBzdGF0dXMsXG4gICAgc3RhdHVzVGV4dCxcbiAgICBkYXRhLFxuICAgIGdldEVycm9yTWVzc2FnZTogZ2V0RXJyb3JNZXNzYWdlNSxcbiAgICBzZW5kVXNhZ2UsXG4gICAgc2VuZFJlYXNvbmluZyxcbiAgICBzZW5kU291cmNlcyxcbiAgICBleHBlcmltZW50YWxfc2VuZEZpbmlzaFxuICB9ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKFxuICAgICAgdGhpcy50b0RhdGFTdHJlYW0oe1xuICAgICAgICBkYXRhLFxuICAgICAgICBnZXRFcnJvck1lc3NhZ2U6IGdldEVycm9yTWVzc2FnZTUsXG4gICAgICAgIHNlbmRVc2FnZSxcbiAgICAgICAgc2VuZFJlYXNvbmluZyxcbiAgICAgICAgc2VuZFNvdXJjZXMsXG4gICAgICAgIGV4cGVyaW1lbnRhbF9zZW5kRmluaXNoXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiBwcmVwYXJlUmVzcG9uc2VIZWFkZXJzKGhlYWRlcnMsIHtcbiAgICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAgICAgZGF0YVN0cmVhbVZlcnNpb246IFwidjFcIlxuICAgICAgICB9KVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgdG9UZXh0U3RyZWFtUmVzcG9uc2UoaW5pdCkge1xuICAgIHZhciBfYTE3O1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy50ZXh0U3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKSwge1xuICAgICAgc3RhdHVzOiAoX2ExNyA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzKSAhPSBudWxsID8gX2ExNyA6IDIwMCxcbiAgICAgIGhlYWRlcnM6IHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzLCB7XG4gICAgICAgIGNvbnRlbnRUeXBlOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gZXJyb3JzL25vLXNwZWVjaC1nZW5lcmF0ZWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjE4IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBOb1NwZWVjaEdlbmVyYXRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMTgge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJBSV9Ob1NwZWVjaEdlbmVyYXRlZEVycm9yXCIsXG4gICAgICBtZXNzYWdlOiBcIk5vIHNwZWVjaCBhdWRpbyBnZW5lcmF0ZWQuXCJcbiAgICB9KTtcbiAgICB0aGlzLnJlc3BvbnNlcyA9IG9wdGlvbnMucmVzcG9uc2VzO1xuICB9XG59O1xuXG4vLyBjb3JlL2dlbmVyYXRlLXNwZWVjaC9nZW5lcmF0ZWQtYXVkaW8tZmlsZS50c1xudmFyIERlZmF1bHRHZW5lcmF0ZWRBdWRpb0ZpbGUgPSBjbGFzcyBleHRlbmRzIERlZmF1bHRHZW5lcmF0ZWRGaWxlIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRhdGEsXG4gICAgbWltZVR5cGVcbiAgfSkge1xuICAgIHN1cGVyKHsgZGF0YSwgbWltZVR5cGUgfSk7XG4gICAgbGV0IGZvcm1hdCA9IFwibXAzXCI7XG4gICAgaWYgKG1pbWVUeXBlKSB7XG4gICAgICBjb25zdCBtaW1lVHlwZVBhcnRzID0gbWltZVR5cGUuc3BsaXQoXCIvXCIpO1xuICAgICAgaWYgKG1pbWVUeXBlUGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGlmIChtaW1lVHlwZSAhPT0gXCJhdWRpby9tcGVnXCIpIHtcbiAgICAgICAgICBmb3JtYXQgPSBtaW1lVHlwZVBhcnRzWzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZm9ybWF0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQXVkaW8gZm9ybWF0IG11c3QgYmUgcHJvdmlkZWQgb3IgZGV0ZXJtaW5hYmxlIGZyb20gbWltZVR5cGVcIlxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG4gIH1cbn07XG5cbi8vIGNvcmUvZ2VuZXJhdGUtc3BlZWNoL2dlbmVyYXRlLXNwZWVjaC50c1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVTcGVlY2goe1xuICBtb2RlbCxcbiAgdGV4dDogdGV4dDIsXG4gIHZvaWNlLFxuICBvdXRwdXRGb3JtYXQsXG4gIGluc3RydWN0aW9ucyxcbiAgc3BlZWQsXG4gIHByb3ZpZGVyT3B0aW9ucyA9IHt9LFxuICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVyc1xufSkge1xuICB2YXIgX2ExNztcbiAgY29uc3QgeyByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoeyBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnIH0pO1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXRyeShcbiAgICAoKSA9PiBtb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgIHRleHQ6IHRleHQyLFxuICAgICAgdm9pY2UsXG4gICAgICBvdXRwdXRGb3JtYXQsXG4gICAgICBpbnN0cnVjdGlvbnMsXG4gICAgICBzcGVlZCxcbiAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgIH0pXG4gICk7XG4gIGlmICghcmVzdWx0LmF1ZGlvIHx8IHJlc3VsdC5hdWRpby5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgTm9TcGVlY2hHZW5lcmF0ZWRFcnJvcih7IHJlc3BvbnNlczogW3Jlc3VsdC5yZXNwb25zZV0gfSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBEZWZhdWx0U3BlZWNoUmVzdWx0KHtcbiAgICBhdWRpbzogbmV3IERlZmF1bHRHZW5lcmF0ZWRBdWRpb0ZpbGUoe1xuICAgICAgZGF0YTogcmVzdWx0LmF1ZGlvLFxuICAgICAgbWltZVR5cGU6IChfYTE3ID0gZGV0ZWN0TWltZVR5cGUoe1xuICAgICAgICBkYXRhOiByZXN1bHQuYXVkaW8sXG4gICAgICAgIHNpZ25hdHVyZXM6IGF1ZGlvTWltZVR5cGVTaWduYXR1cmVzXG4gICAgICB9KSkgIT0gbnVsbCA/IF9hMTcgOiBcImF1ZGlvL21wM1wiXG4gICAgfSksXG4gICAgd2FybmluZ3M6IHJlc3VsdC53YXJuaW5ncyxcbiAgICByZXNwb25zZXM6IFtyZXN1bHQucmVzcG9uc2VdLFxuICAgIHByb3ZpZGVyTWV0YWRhdGE6IHJlc3VsdC5wcm92aWRlck1ldGFkYXRhXG4gIH0pO1xufVxudmFyIERlZmF1bHRTcGVlY2hSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX2ExNztcbiAgICB0aGlzLmF1ZGlvID0gb3B0aW9ucy5hdWRpbztcbiAgICB0aGlzLndhcm5pbmdzID0gb3B0aW9ucy53YXJuaW5ncztcbiAgICB0aGlzLnJlc3BvbnNlcyA9IG9wdGlvbnMucmVzcG9uc2VzO1xuICAgIHRoaXMucHJvdmlkZXJNZXRhZGF0YSA9IChfYTE3ID0gb3B0aW9ucy5wcm92aWRlck1ldGFkYXRhKSAhPSBudWxsID8gX2ExNyA6IHt9O1xuICB9XG59O1xuXG4vLyBlcnJvcnMvbm8tdHJhbnNjcmlwdC1nZW5lcmF0ZWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjE5IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBOb1RyYW5zY3JpcHRHZW5lcmF0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjE5IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiQUlfTm9UcmFuc2NyaXB0R2VuZXJhdGVkRXJyb3JcIixcbiAgICAgIG1lc3NhZ2U6IFwiTm8gdHJhbnNjcmlwdCBnZW5lcmF0ZWQuXCJcbiAgICB9KTtcbiAgICB0aGlzLnJlc3BvbnNlcyA9IG9wdGlvbnMucmVzcG9uc2VzO1xuICB9XG59O1xuXG4vLyBjb3JlL3RyYW5zY3JpYmUvdHJhbnNjcmliZS50c1xuYXN5bmMgZnVuY3Rpb24gdHJhbnNjcmliZSh7XG4gIG1vZGVsLFxuICBhdWRpbyxcbiAgcHJvdmlkZXJPcHRpb25zID0ge30sXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzXG59KSB7XG4gIGNvbnN0IHsgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHsgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyB9KTtcbiAgY29uc3QgYXVkaW9EYXRhID0gYXVkaW8gaW5zdGFuY2VvZiBVUkwgPyAoYXdhaXQgZG93bmxvYWQoeyB1cmw6IGF1ZGlvIH0pKS5kYXRhIDogY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGF1ZGlvKTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmV0cnkoXG4gICAgKCkgPT4ge1xuICAgICAgdmFyIF9hMTc7XG4gICAgICByZXR1cm4gbW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgIGF1ZGlvOiBhdWRpb0RhdGEsXG4gICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgICAgIG1lZGlhVHlwZTogKF9hMTcgPSBkZXRlY3RNaW1lVHlwZSh7XG4gICAgICAgICAgZGF0YTogYXVkaW9EYXRhLFxuICAgICAgICAgIHNpZ25hdHVyZXM6IGF1ZGlvTWltZVR5cGVTaWduYXR1cmVzXG4gICAgICAgIH0pKSAhPSBudWxsID8gX2ExNyA6IFwiYXVkaW8vd2F2XCJcbiAgICAgIH0pO1xuICAgIH1cbiAgKTtcbiAgaWYgKCFyZXN1bHQudGV4dCkge1xuICAgIHRocm93IG5ldyBOb1RyYW5zY3JpcHRHZW5lcmF0ZWRFcnJvcih7IHJlc3BvbnNlczogW3Jlc3VsdC5yZXNwb25zZV0gfSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBEZWZhdWx0VHJhbnNjcmlwdGlvblJlc3VsdCh7XG4gICAgdGV4dDogcmVzdWx0LnRleHQsXG4gICAgc2VnbWVudHM6IHJlc3VsdC5zZWdtZW50cyxcbiAgICBsYW5ndWFnZTogcmVzdWx0Lmxhbmd1YWdlLFxuICAgIGR1cmF0aW9uSW5TZWNvbmRzOiByZXN1bHQuZHVyYXRpb25JblNlY29uZHMsXG4gICAgd2FybmluZ3M6IHJlc3VsdC53YXJuaW5ncyxcbiAgICByZXNwb25zZXM6IFtyZXN1bHQucmVzcG9uc2VdLFxuICAgIHByb3ZpZGVyTWV0YWRhdGE6IHJlc3VsdC5wcm92aWRlck1ldGFkYXRhXG4gIH0pO1xufVxudmFyIERlZmF1bHRUcmFuc2NyaXB0aW9uUmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9hMTc7XG4gICAgdGhpcy50ZXh0ID0gb3B0aW9ucy50ZXh0O1xuICAgIHRoaXMuc2VnbWVudHMgPSBvcHRpb25zLnNlZ21lbnRzO1xuICAgIHRoaXMubGFuZ3VhZ2UgPSBvcHRpb25zLmxhbmd1YWdlO1xuICAgIHRoaXMuZHVyYXRpb25JblNlY29uZHMgPSBvcHRpb25zLmR1cmF0aW9uSW5TZWNvbmRzO1xuICAgIHRoaXMud2FybmluZ3MgPSBvcHRpb25zLndhcm5pbmdzO1xuICAgIHRoaXMucmVzcG9uc2VzID0gb3B0aW9ucy5yZXNwb25zZXM7XG4gICAgdGhpcy5wcm92aWRlck1ldGFkYXRhID0gKF9hMTcgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGEpICE9IG51bGwgPyBfYTE3IDoge307XG4gIH1cbn07XG5cbi8vIGNvcmUvdXRpbC9tZXJnZS1vYmplY3RzLnRzXG5mdW5jdGlvbiBtZXJnZU9iamVjdHModGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKHRhcmdldCA9PT0gdm9pZCAwICYmIHNvdXJjZSA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG4gIGlmIChzb3VyY2UgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0geyAuLi50YXJnZXQgfTtcbiAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZVZhbHVlID0gc291cmNlW2tleV07XG4gICAgICBpZiAoc291cmNlVmFsdWUgPT09IHZvaWQgMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCB0YXJnZXRWYWx1ZSA9IGtleSBpbiB0YXJnZXQgPyB0YXJnZXRba2V5XSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IGlzU291cmNlT2JqZWN0ID0gc291cmNlVmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHNvdXJjZVZhbHVlID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHNvdXJjZVZhbHVlKSAmJiAhKHNvdXJjZVZhbHVlIGluc3RhbmNlb2YgRGF0ZSkgJiYgIShzb3VyY2VWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCk7XG4gICAgICBjb25zdCBpc1RhcmdldE9iamVjdCA9IHRhcmdldFZhbHVlICE9PSBudWxsICYmIHRhcmdldFZhbHVlICE9PSB2b2lkIDAgJiYgdHlwZW9mIHRhcmdldFZhbHVlID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHRhcmdldFZhbHVlKSAmJiAhKHRhcmdldFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkgJiYgISh0YXJnZXRWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCk7XG4gICAgICBpZiAoaXNTb3VyY2VPYmplY3QgJiYgaXNUYXJnZXRPYmplY3QpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZU9iamVjdHMoXG4gICAgICAgICAgdGFyZ2V0VmFsdWUsXG4gICAgICAgICAgc291cmNlVmFsdWVcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gc291cmNlVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIGNvcmUvbWlkZGxld2FyZS9kZWZhdWx0LXNldHRpbmdzLW1pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIGRlZmF1bHRTZXR0aW5nc01pZGRsZXdhcmUoe1xuICBzZXR0aW5nc1xufSkge1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmVWZXJzaW9uOiBcInYxXCIsXG4gICAgdHJhbnNmb3JtUGFyYW1zOiBhc3luYyAoeyBwYXJhbXMgfSkgPT4ge1xuICAgICAgdmFyIF9hMTc7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zZXR0aW5ncyxcbiAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtZXJnZU9iamVjdHMoXG4gICAgICAgICAgc2V0dGluZ3MucHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICBwYXJhbXMucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICApLFxuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIHRlbXBlcmF0dXJlIDBcbiAgICAgICAgLy8gVE9ETyByZW1vdmUgd2hlbiB0ZW1wZXJhdHVyZSBkZWZhdWx0cyB0byB1bmRlZmluZWRcbiAgICAgICAgdGVtcGVyYXR1cmU6IHBhcmFtcy50ZW1wZXJhdHVyZSA9PT0gMCB8fCBwYXJhbXMudGVtcGVyYXR1cmUgPT0gbnVsbCA/IChfYTE3ID0gc2V0dGluZ3MudGVtcGVyYXR1cmUpICE9IG51bGwgPyBfYTE3IDogMCA6IHBhcmFtcy50ZW1wZXJhdHVyZVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbi8vIGNvcmUvdXRpbC9nZXQtcG90ZW50aWFsLXN0YXJ0LWluZGV4LnRzXG5mdW5jdGlvbiBnZXRQb3RlbnRpYWxTdGFydEluZGV4KHRleHQyLCBzZWFyY2hlZFRleHQpIHtcbiAgaWYgKHNlYXJjaGVkVGV4dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBkaXJlY3RJbmRleCA9IHRleHQyLmluZGV4T2Yoc2VhcmNoZWRUZXh0KTtcbiAgaWYgKGRpcmVjdEluZGV4ICE9PSAtMSkge1xuICAgIHJldHVybiBkaXJlY3RJbmRleDtcbiAgfVxuICBmb3IgKGxldCBpID0gdGV4dDIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBzdWZmaXggPSB0ZXh0Mi5zdWJzdHJpbmcoaSk7XG4gICAgaWYgKHNlYXJjaGVkVGV4dC5zdGFydHNXaXRoKHN1ZmZpeCkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gY29yZS9taWRkbGV3YXJlL2V4dHJhY3QtcmVhc29uaW5nLW1pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIGV4dHJhY3RSZWFzb25pbmdNaWRkbGV3YXJlKHtcbiAgdGFnTmFtZSxcbiAgc2VwYXJhdG9yID0gXCJcXG5cIixcbiAgc3RhcnRXaXRoUmVhc29uaW5nID0gZmFsc2Vcbn0pIHtcbiAgY29uc3Qgb3BlbmluZ1RhZyA9IGA8JHt0YWdOYW1lfT5gO1xuICBjb25zdCBjbG9zaW5nVGFnID0gYDwvJHt0YWdOYW1lfT5gO1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmVWZXJzaW9uOiBcInYxXCIsXG4gICAgd3JhcEdlbmVyYXRlOiBhc3luYyAoeyBkb0dlbmVyYXRlIH0pID0+IHtcbiAgICAgIGNvbnN0IHsgdGV4dDogcmF3VGV4dCwgLi4ucmVzdCB9ID0gYXdhaXQgZG9HZW5lcmF0ZSgpO1xuICAgICAgaWYgKHJhd1RleHQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4geyB0ZXh0OiByYXdUZXh0LCAuLi5yZXN0IH07XG4gICAgICB9XG4gICAgICBjb25zdCB0ZXh0MiA9IHN0YXJ0V2l0aFJlYXNvbmluZyA/IG9wZW5pbmdUYWcgKyByYXdUZXh0IDogcmF3VGV4dDtcbiAgICAgIGNvbnN0IHJlZ2V4cCA9IG5ldyBSZWdFeHAoYCR7b3BlbmluZ1RhZ30oLio/KSR7Y2xvc2luZ1RhZ31gLCBcImdzXCIpO1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IEFycmF5LmZyb20odGV4dDIubWF0Y2hBbGwocmVnZXhwKSk7XG4gICAgICBpZiAoIW1hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7IHRleHQ6IHRleHQyLCAuLi5yZXN0IH07XG4gICAgICB9XG4gICAgICBjb25zdCByZWFzb25pbmcgPSBtYXRjaGVzLm1hcCgobWF0Y2gpID0+IG1hdGNoWzFdKS5qb2luKHNlcGFyYXRvcik7XG4gICAgICBsZXQgdGV4dFdpdGhvdXRSZWFzb25pbmcgPSB0ZXh0MjtcbiAgICAgIGZvciAobGV0IGkgPSBtYXRjaGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hlc1tpXTtcbiAgICAgICAgY29uc3QgYmVmb3JlTWF0Y2ggPSB0ZXh0V2l0aG91dFJlYXNvbmluZy5zbGljZSgwLCBtYXRjaC5pbmRleCk7XG4gICAgICAgIGNvbnN0IGFmdGVyTWF0Y2ggPSB0ZXh0V2l0aG91dFJlYXNvbmluZy5zbGljZShcbiAgICAgICAgICBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aFxuICAgICAgICApO1xuICAgICAgICB0ZXh0V2l0aG91dFJlYXNvbmluZyA9IGJlZm9yZU1hdGNoICsgKGJlZm9yZU1hdGNoLmxlbmd0aCA+IDAgJiYgYWZ0ZXJNYXRjaC5sZW5ndGggPiAwID8gc2VwYXJhdG9yIDogXCJcIikgKyBhZnRlck1hdGNoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgLi4ucmVzdCwgdGV4dDogdGV4dFdpdGhvdXRSZWFzb25pbmcsIHJlYXNvbmluZyB9O1xuICAgIH0sXG4gICAgd3JhcFN0cmVhbTogYXN5bmMgKHsgZG9TdHJlYW0gfSkgPT4ge1xuICAgICAgY29uc3QgeyBzdHJlYW0sIC4uLnJlc3QgfSA9IGF3YWl0IGRvU3RyZWFtKCk7XG4gICAgICBsZXQgaXNGaXJzdFJlYXNvbmluZyA9IHRydWU7XG4gICAgICBsZXQgaXNGaXJzdFRleHQgPSB0cnVlO1xuICAgICAgbGV0IGFmdGVyU3dpdGNoID0gZmFsc2U7XG4gICAgICBsZXQgaXNSZWFzb25pbmcgPSBzdGFydFdpdGhSZWFzb25pbmc7XG4gICAgICBsZXQgYnVmZmVyID0gXCJcIjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cmVhbTogc3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGNodW5rLnR5cGUgIT09IFwidGV4dC1kZWx0YVwiKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnVmZmVyICs9IGNodW5rLnRleHREZWx0YTtcbiAgICAgICAgICAgICAgZnVuY3Rpb24gcHVibGlzaCh0ZXh0Mikge1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0Mi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXggPSBhZnRlclN3aXRjaCAmJiAoaXNSZWFzb25pbmcgPyAhaXNGaXJzdFJlYXNvbmluZyA6ICFpc0ZpcnN0VGV4dCkgPyBzZXBhcmF0b3IgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogaXNSZWFzb25pbmcgPyBcInJlYXNvbmluZ1wiIDogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgIHRleHREZWx0YTogcHJlZml4ICsgdGV4dDJcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgYWZ0ZXJTd2l0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1JlYXNvbmluZykge1xuICAgICAgICAgICAgICAgICAgICBpc0ZpcnN0UmVhc29uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpc0ZpcnN0VGV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFRhZyA9IGlzUmVhc29uaW5nID8gY2xvc2luZ1RhZyA6IG9wZW5pbmdUYWc7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IGdldFBvdGVudGlhbFN0YXJ0SW5kZXgoYnVmZmVyLCBuZXh0VGFnKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBwdWJsaXNoKGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICBidWZmZXIgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHB1Ymxpc2goYnVmZmVyLnNsaWNlKDAsIHN0YXJ0SW5kZXgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3VuZEZ1bGxNYXRjaCA9IHN0YXJ0SW5kZXggKyBuZXh0VGFnLmxlbmd0aCA8PSBidWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZEZ1bGxNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKHN0YXJ0SW5kZXggKyBuZXh0VGFnLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICBpc1JlYXNvbmluZyA9ICFpc1JlYXNvbmluZztcbiAgICAgICAgICAgICAgICAgIGFmdGVyU3dpdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKHN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApLFxuICAgICAgICAuLi5yZXN0XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gY29yZS9taWRkbGV3YXJlL3NpbXVsYXRlLXN0cmVhbWluZy1taWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBzaW11bGF0ZVN0cmVhbWluZ01pZGRsZXdhcmUoKSB7XG4gIHJldHVybiB7XG4gICAgbWlkZGxld2FyZVZlcnNpb246IFwidjFcIixcbiAgICB3cmFwU3RyZWFtOiBhc3luYyAoeyBkb0dlbmVyYXRlIH0pID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRvR2VuZXJhdGUoKTtcbiAgICAgIGNvbnN0IHNpbXVsYXRlZFN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInJlc3BvbnNlLW1ldGFkYXRhXCIsIC4uLnJlc3VsdC5yZXNwb25zZSB9KTtcbiAgICAgICAgICBpZiAocmVzdWx0LnJlYXNvbmluZykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQucmVhc29uaW5nID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICAgICAgICB0ZXh0RGVsdGE6IHJlc3VsdC5yZWFzb25pbmdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlYXNvbmluZyBvZiByZXN1bHQucmVhc29uaW5nKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChyZWFzb25pbmcudHlwZSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dERlbHRhOiByZWFzb25pbmcudGV4dFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlYXNvbmluZy5zaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZy1zaWduYXR1cmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogcmVhc29uaW5nLnNpZ25hdHVyZVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2FzZSBcInJlZGFjdGVkXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJlZGFjdGVkLXJlYXNvbmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHJlYXNvbmluZy5kYXRhXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdC50ZXh0KSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgICAgICAgdGV4dERlbHRhOiByZXN1bHQudGV4dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQudG9vbENhbGxzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsIG9mIHJlc3VsdC50b29sQ2FsbHMpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsVHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3NUZXh0RGVsdGE6IHRvb2xDYWxsLmFyZ3NcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICAgICAgICAuLi50b29sQ2FsbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZmluaXNoXCIsXG4gICAgICAgICAgICBmaW5pc2hSZWFzb246IHJlc3VsdC5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICB1c2FnZTogcmVzdWx0LnVzYWdlLFxuICAgICAgICAgICAgbG9ncHJvYnM6IHJlc3VsdC5sb2dwcm9icyxcbiAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHJlc3VsdC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cmVhbTogc2ltdWxhdGVkU3RyZWFtLFxuICAgICAgICByYXdDYWxsOiByZXN1bHQucmF3Q2FsbCxcbiAgICAgICAgcmF3UmVzcG9uc2U6IHJlc3VsdC5yYXdSZXNwb25zZSxcbiAgICAgICAgd2FybmluZ3M6IHJlc3VsdC53YXJuaW5nc1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbi8vIGNvcmUvbWlkZGxld2FyZS93cmFwLWxhbmd1YWdlLW1vZGVsLnRzXG52YXIgd3JhcExhbmd1YWdlTW9kZWwgPSAoe1xuICBtb2RlbCxcbiAgbWlkZGxld2FyZTogbWlkZGxld2FyZUFyZyxcbiAgbW9kZWxJZCxcbiAgcHJvdmlkZXJJZFxufSkgPT4ge1xuICByZXR1cm4gYXNBcnJheShtaWRkbGV3YXJlQXJnKS5yZXZlcnNlKCkucmVkdWNlKCh3cmFwcGVkTW9kZWwsIG1pZGRsZXdhcmUpID0+IHtcbiAgICByZXR1cm4gZG9XcmFwKHsgbW9kZWw6IHdyYXBwZWRNb2RlbCwgbWlkZGxld2FyZSwgbW9kZWxJZCwgcHJvdmlkZXJJZCB9KTtcbiAgfSwgbW9kZWwpO1xufTtcbnZhciBkb1dyYXAgPSAoe1xuICBtb2RlbCxcbiAgbWlkZGxld2FyZTogeyB0cmFuc2Zvcm1QYXJhbXMsIHdyYXBHZW5lcmF0ZSwgd3JhcFN0cmVhbSB9LFxuICBtb2RlbElkLFxuICBwcm92aWRlcklkXG59KSA9PiB7XG4gIHZhciBfYTE3O1xuICBhc3luYyBmdW5jdGlvbiBkb1RyYW5zZm9ybSh7XG4gICAgcGFyYW1zLFxuICAgIHR5cGVcbiAgfSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1QYXJhbXMgPyBhd2FpdCB0cmFuc2Zvcm1QYXJhbXMoeyBwYXJhbXMsIHR5cGUgfSkgOiBwYXJhbXM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzcGVjaWZpY2F0aW9uVmVyc2lvbjogXCJ2MVwiLFxuICAgIHByb3ZpZGVyOiBwcm92aWRlcklkICE9IG51bGwgPyBwcm92aWRlcklkIDogbW9kZWwucHJvdmlkZXIsXG4gICAgbW9kZWxJZDogbW9kZWxJZCAhPSBudWxsID8gbW9kZWxJZCA6IG1vZGVsLm1vZGVsSWQsXG4gICAgZGVmYXVsdE9iamVjdEdlbmVyYXRpb25Nb2RlOiBtb2RlbC5kZWZhdWx0T2JqZWN0R2VuZXJhdGlvbk1vZGUsXG4gICAgc3VwcG9ydHNJbWFnZVVybHM6IG1vZGVsLnN1cHBvcnRzSW1hZ2VVcmxzLFxuICAgIHN1cHBvcnRzVXJsOiAoX2ExNyA9IG1vZGVsLnN1cHBvcnRzVXJsKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5iaW5kKG1vZGVsKSxcbiAgICBzdXBwb3J0c1N0cnVjdHVyZWRPdXRwdXRzOiBtb2RlbC5zdXBwb3J0c1N0cnVjdHVyZWRPdXRwdXRzLFxuICAgIGFzeW5jIGRvR2VuZXJhdGUocGFyYW1zKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZFBhcmFtcyA9IGF3YWl0IGRvVHJhbnNmb3JtKHsgcGFyYW1zLCB0eXBlOiBcImdlbmVyYXRlXCIgfSk7XG4gICAgICBjb25zdCBkb0dlbmVyYXRlID0gYXN5bmMgKCkgPT4gbW9kZWwuZG9HZW5lcmF0ZSh0cmFuc2Zvcm1lZFBhcmFtcyk7XG4gICAgICBjb25zdCBkb1N0cmVhbSA9IGFzeW5jICgpID0+IG1vZGVsLmRvU3RyZWFtKHRyYW5zZm9ybWVkUGFyYW1zKTtcbiAgICAgIHJldHVybiB3cmFwR2VuZXJhdGUgPyB3cmFwR2VuZXJhdGUoe1xuICAgICAgICBkb0dlbmVyYXRlLFxuICAgICAgICBkb1N0cmVhbSxcbiAgICAgICAgcGFyYW1zOiB0cmFuc2Zvcm1lZFBhcmFtcyxcbiAgICAgICAgbW9kZWxcbiAgICAgIH0pIDogZG9HZW5lcmF0ZSgpO1xuICAgIH0sXG4gICAgYXN5bmMgZG9TdHJlYW0ocGFyYW1zKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZFBhcmFtcyA9IGF3YWl0IGRvVHJhbnNmb3JtKHsgcGFyYW1zLCB0eXBlOiBcInN0cmVhbVwiIH0pO1xuICAgICAgY29uc3QgZG9HZW5lcmF0ZSA9IGFzeW5jICgpID0+IG1vZGVsLmRvR2VuZXJhdGUodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgY29uc3QgZG9TdHJlYW0gPSBhc3luYyAoKSA9PiBtb2RlbC5kb1N0cmVhbSh0cmFuc2Zvcm1lZFBhcmFtcyk7XG4gICAgICByZXR1cm4gd3JhcFN0cmVhbSA/IHdyYXBTdHJlYW0oeyBkb0dlbmVyYXRlLCBkb1N0cmVhbSwgcGFyYW1zOiB0cmFuc2Zvcm1lZFBhcmFtcywgbW9kZWwgfSkgOiBkb1N0cmVhbSgpO1xuICAgIH1cbiAgfTtcbn07XG52YXIgZXhwZXJpbWVudGFsX3dyYXBMYW5ndWFnZU1vZGVsID0gd3JhcExhbmd1YWdlTW9kZWw7XG5cbi8vIGNvcmUvcHJvbXB0L2FwcGVuZC1jbGllbnQtbWVzc2FnZS50c1xuZnVuY3Rpb24gYXBwZW5kQ2xpZW50TWVzc2FnZSh7XG4gIG1lc3NhZ2VzLFxuICBtZXNzYWdlXG59KSB7XG4gIHJldHVybiBbXG4gICAgLi4ubWVzc2FnZXMubGVuZ3RoID4gMCAmJiBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXS5pZCA9PT0gbWVzc2FnZS5pZCA/IG1lc3NhZ2VzLnNsaWNlKDAsIC0xKSA6IG1lc3NhZ2VzLFxuICAgIG1lc3NhZ2VcbiAgXTtcbn1cblxuLy8gY29yZS9wcm9tcHQvYXBwZW5kLXJlc3BvbnNlLW1lc3NhZ2VzLnRzXG5pbXBvcnQge1xuICBleHRyYWN0TWF4VG9vbEludm9jYXRpb25TdGVwXG59IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IyMCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBhcHBlbmRSZXNwb25zZU1lc3NhZ2VzKHtcbiAgbWVzc2FnZXMsXG4gIHJlc3BvbnNlTWVzc2FnZXMsXG4gIF9pbnRlcm5hbDogeyBjdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpIH0gPSB7fVxufSkge1xuICB2YXIgX2ExNywgX2IsIF9jLCBfZDtcbiAgY29uc3QgY2xvbmVkTWVzc2FnZXMgPSBzdHJ1Y3R1cmVkQ2xvbmUobWVzc2FnZXMpO1xuICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgcmVzcG9uc2VNZXNzYWdlcykge1xuICAgIGNvbnN0IHJvbGUgPSBtZXNzYWdlLnJvbGU7XG4gICAgY29uc3QgbGFzdE1lc3NhZ2UgPSBjbG9uZWRNZXNzYWdlc1tjbG9uZWRNZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBpc0xhc3RNZXNzYWdlQXNzaXN0YW50ID0gbGFzdE1lc3NhZ2Uucm9sZSA9PT0gXCJhc3Npc3RhbnRcIjtcbiAgICBzd2l0Y2ggKHJvbGUpIHtcbiAgICAgIGNhc2UgXCJhc3Npc3RhbnRcIjoge1xuICAgICAgICBsZXQgZ2V0VG9vbEludm9jYXRpb25zMiA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICAgICAgICByZXR1cm4gKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIgPyBbXSA6IG1lc3NhZ2UuY29udGVudC5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0b29sLWNhbGxcIikpLm1hcCgoY2FsbCkgPT4gKHtcbiAgICAgICAgICAgIHN0YXRlOiBcImNhbGxcIixcbiAgICAgICAgICAgIHN0ZXAsXG4gICAgICAgICAgICBhcmdzOiBjYWxsLmFyZ3MsXG4gICAgICAgICAgICB0b29sQ2FsbElkOiBjYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICB0b29sTmFtZTogY2FsbC50b29sTmFtZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldFRvb2xJbnZvY2F0aW9ucyA9IGdldFRvb2xJbnZvY2F0aW9uczI7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gW3sgdHlwZTogXCJzdGVwLXN0YXJ0XCIgfV07XG4gICAgICAgIGxldCB0ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgIGxldCByZWFzb25pbmdUZXh0Q29udGVudCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB0ZXh0Q29udGVudCA9IG1lc3NhZ2UuY29udGVudDtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgdGV4dDogbWVzc2FnZS5jb250ZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IHJlYXNvbmluZ1BhcnQgPSB2b2lkIDA7XG4gICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIG1lc3NhZ2UuY29udGVudCkge1xuICAgICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgICAgICAgICAgIHJlYXNvbmluZ1BhcnQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdGV4dENvbnRlbnQgKz0gcGFydC50ZXh0O1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICB0ZXh0OiBwYXJ0LnRleHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nXCI6IHtcbiAgICAgICAgICAgICAgICBpZiAocmVhc29uaW5nUGFydCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZWFzb25pbmdQYXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICByZWFzb25pbmc6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IFtdXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgcGFydHMucHVzaChyZWFzb25pbmdQYXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVhc29uaW5nVGV4dENvbnRlbnQgPSAocmVhc29uaW5nVGV4dENvbnRlbnQgIT0gbnVsbCA/IHJlYXNvbmluZ1RleHRDb250ZW50IDogXCJcIikgKyBwYXJ0LnRleHQ7XG4gICAgICAgICAgICAgICAgcmVhc29uaW5nUGFydC5yZWFzb25pbmcgKz0gcGFydC50ZXh0O1xuICAgICAgICAgICAgICAgIHJlYXNvbmluZ1BhcnQuZGV0YWlscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBwYXJ0LnNpZ25hdHVyZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgXCJyZWRhY3RlZC1yZWFzb25pbmdcIjoge1xuICAgICAgICAgICAgICAgIGlmIChyZWFzb25pbmdQYXJ0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJlYXNvbmluZ1BhcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbmluZzogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogW11cbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHJlYXNvbmluZ1BhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWFzb25pbmdQYXJ0LmRldGFpbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInJlZGFjdGVkXCIsXG4gICAgICAgICAgICAgICAgICBkYXRhOiBwYXJ0LmRhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQuZGF0YSBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFJU0RLRXJyb3IyMCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiSW52YWxpZEFzc2lzdGFudEZpbGVEYXRhXCIsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiRmlsZSBkYXRhIGNhbm5vdCBiZSBhIFVSTFwiXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBwYXJ0Lm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgZGF0YTogY29udmVydERhdGFDb250ZW50VG9CYXNlNjRTdHJpbmcocGFydC5kYXRhKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMYXN0TWVzc2FnZUFzc2lzdGFudCkge1xuICAgICAgICAgIGNvbnN0IG1heFN0ZXAgPSBleHRyYWN0TWF4VG9vbEludm9jYXRpb25TdGVwKFxuICAgICAgICAgICAgbGFzdE1lc3NhZ2UudG9vbEludm9jYXRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgICAoX2ExNyA9IGxhc3RNZXNzYWdlLnBhcnRzKSAhPSBudWxsID8gX2ExNyA6IGxhc3RNZXNzYWdlLnBhcnRzID0gW107XG4gICAgICAgICAgbGFzdE1lc3NhZ2UuY29udGVudCA9IHRleHRDb250ZW50O1xuICAgICAgICAgIGxhc3RNZXNzYWdlLnJlYXNvbmluZyA9IHJlYXNvbmluZ1RleHRDb250ZW50O1xuICAgICAgICAgIGxhc3RNZXNzYWdlLnBhcnRzLnB1c2goLi4ucGFydHMpO1xuICAgICAgICAgIGxhc3RNZXNzYWdlLnRvb2xJbnZvY2F0aW9ucyA9IFtcbiAgICAgICAgICAgIC4uLihfYiA9IGxhc3RNZXNzYWdlLnRvb2xJbnZvY2F0aW9ucykgIT0gbnVsbCA/IF9iIDogW10sXG4gICAgICAgICAgICAuLi5nZXRUb29sSW52b2NhdGlvbnMyKG1heFN0ZXAgPT09IHZvaWQgMCA/IDAgOiBtYXhTdGVwICsgMSlcbiAgICAgICAgICBdO1xuICAgICAgICAgIGdldFRvb2xJbnZvY2F0aW9uczIobWF4U3RlcCA9PT0gdm9pZCAwID8gMCA6IG1heFN0ZXAgKyAxKS5tYXAoKGNhbGwpID0+ICh7XG4gICAgICAgICAgICB0eXBlOiBcInRvb2wtaW52b2NhdGlvblwiLFxuICAgICAgICAgICAgdG9vbEludm9jYXRpb246IGNhbGxcbiAgICAgICAgICB9KSkuZm9yRWFjaCgocGFydCkgPT4ge1xuICAgICAgICAgICAgbGFzdE1lc3NhZ2UucGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9uZWRNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgICBpZDogbWVzc2FnZS5pZCxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogY3VycmVudERhdGUoKSxcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlIGEgY3JlYXRlZEF0IGRhdGUgZm9yIHRoZSBtZXNzYWdlLCB3aWxsIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGNsaWVudFxuICAgICAgICAgICAgY29udGVudDogdGV4dENvbnRlbnQsXG4gICAgICAgICAgICByZWFzb25pbmc6IHJlYXNvbmluZ1RleHRDb250ZW50LFxuICAgICAgICAgICAgdG9vbEludm9jYXRpb25zOiBnZXRUb29sSW52b2NhdGlvbnMyKDApLFxuICAgICAgICAgICAgcGFydHM6IFtcbiAgICAgICAgICAgICAgLi4ucGFydHMsXG4gICAgICAgICAgICAgIC4uLmdldFRvb2xJbnZvY2F0aW9uczIoMCkubWFwKChjYWxsKSA9PiAoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1pbnZvY2F0aW9uXCIsXG4gICAgICAgICAgICAgICAgdG9vbEludm9jYXRpb246IGNhbGxcbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwidG9vbFwiOiB7XG4gICAgICAgIChfYyA9IGxhc3RNZXNzYWdlLnRvb2xJbnZvY2F0aW9ucykgIT0gbnVsbCA/IF9jIDogbGFzdE1lc3NhZ2UudG9vbEludm9jYXRpb25zID0gW107XG4gICAgICAgIGlmIChsYXN0TWVzc2FnZS5yb2xlICE9PSBcImFzc2lzdGFudFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFRvb2wgcmVzdWx0IG11c3QgZm9sbG93IGFuIGFzc2lzdGFudCBtZXNzYWdlOiAke2xhc3RNZXNzYWdlLnJvbGV9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgKF9kID0gbGFzdE1lc3NhZ2UucGFydHMpICE9IG51bGwgPyBfZCA6IGxhc3RNZXNzYWdlLnBhcnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgY29udGVudFBhcnQgb2YgbWVzc2FnZS5jb250ZW50KSB7XG4gICAgICAgICAgY29uc3QgdG9vbENhbGwgPSBsYXN0TWVzc2FnZS50b29sSW52b2NhdGlvbnMuZmluZChcbiAgICAgICAgICAgIChjYWxsKSA9PiBjYWxsLnRvb2xDYWxsSWQgPT09IGNvbnRlbnRQYXJ0LnRvb2xDYWxsSWRcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IHRvb2xDYWxsUGFydCA9IGxhc3RNZXNzYWdlLnBhcnRzLmZpbmQoXG4gICAgICAgICAgICAocGFydCkgPT4gcGFydC50eXBlID09PSBcInRvb2wtaW52b2NhdGlvblwiICYmIHBhcnQudG9vbEludm9jYXRpb24udG9vbENhbGxJZCA9PT0gY29udGVudFBhcnQudG9vbENhbGxJZFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCF0b29sQ2FsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG9vbCBjYWxsIG5vdCBmb3VuZCBpbiBwcmV2aW91cyBtZXNzYWdlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b29sQ2FsbC5zdGF0ZSA9IFwicmVzdWx0XCI7XG4gICAgICAgICAgY29uc3QgdG9vbFJlc3VsdCA9IHRvb2xDYWxsO1xuICAgICAgICAgIHRvb2xSZXN1bHQucmVzdWx0ID0gY29udGVudFBhcnQucmVzdWx0O1xuICAgICAgICAgIGlmICh0b29sQ2FsbFBhcnQpIHtcbiAgICAgICAgICAgIHRvb2xDYWxsUGFydC50b29sSW52b2NhdGlvbiA9IHRvb2xSZXN1bHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RNZXNzYWdlLnBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtaW52b2NhdGlvblwiLFxuICAgICAgICAgICAgICB0b29sSW52b2NhdGlvbjogdG9vbFJlc3VsdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gcm9sZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtZXNzYWdlIHJvbGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsb25lZE1lc3NhZ2VzO1xufVxuXG4vLyBjb3JlL3JlZ2lzdHJ5L2N1c3RvbS1wcm92aWRlci50c1xuaW1wb3J0IHsgTm9TdWNoTW9kZWxFcnJvciBhcyBOb1N1Y2hNb2RlbEVycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBjdXN0b21Qcm92aWRlcih7XG4gIGxhbmd1YWdlTW9kZWxzLFxuICB0ZXh0RW1iZWRkaW5nTW9kZWxzLFxuICBpbWFnZU1vZGVscyxcbiAgZmFsbGJhY2tQcm92aWRlclxufSkge1xuICByZXR1cm4ge1xuICAgIGxhbmd1YWdlTW9kZWwobW9kZWxJZCkge1xuICAgICAgaWYgKGxhbmd1YWdlTW9kZWxzICE9IG51bGwgJiYgbW9kZWxJZCBpbiBsYW5ndWFnZU1vZGVscykge1xuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VNb2RlbHNbbW9kZWxJZF07XG4gICAgICB9XG4gICAgICBpZiAoZmFsbGJhY2tQcm92aWRlcikge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tQcm92aWRlci5sYW5ndWFnZU1vZGVsKG1vZGVsSWQpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3IyKHsgbW9kZWxJZCwgbW9kZWxUeXBlOiBcImxhbmd1YWdlTW9kZWxcIiB9KTtcbiAgICB9LFxuICAgIHRleHRFbWJlZGRpbmdNb2RlbChtb2RlbElkKSB7XG4gICAgICBpZiAodGV4dEVtYmVkZGluZ01vZGVscyAhPSBudWxsICYmIG1vZGVsSWQgaW4gdGV4dEVtYmVkZGluZ01vZGVscykge1xuICAgICAgICByZXR1cm4gdGV4dEVtYmVkZGluZ01vZGVsc1ttb2RlbElkXTtcbiAgICAgIH1cbiAgICAgIGlmIChmYWxsYmFja1Byb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1Byb3ZpZGVyLnRleHRFbWJlZGRpbmdNb2RlbChtb2RlbElkKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yMih7IG1vZGVsSWQsIG1vZGVsVHlwZTogXCJ0ZXh0RW1iZWRkaW5nTW9kZWxcIiB9KTtcbiAgICB9LFxuICAgIGltYWdlTW9kZWwobW9kZWxJZCkge1xuICAgICAgaWYgKGltYWdlTW9kZWxzICE9IG51bGwgJiYgbW9kZWxJZCBpbiBpbWFnZU1vZGVscykge1xuICAgICAgICByZXR1cm4gaW1hZ2VNb2RlbHNbbW9kZWxJZF07XG4gICAgICB9XG4gICAgICBpZiAoZmFsbGJhY2tQcm92aWRlciA9PSBudWxsID8gdm9pZCAwIDogZmFsbGJhY2tQcm92aWRlci5pbWFnZU1vZGVsKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1Byb3ZpZGVyLmltYWdlTW9kZWwobW9kZWxJZCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjIoeyBtb2RlbElkLCBtb2RlbFR5cGU6IFwiaW1hZ2VNb2RlbFwiIH0pO1xuICAgIH1cbiAgfTtcbn1cbnZhciBleHBlcmltZW50YWxfY3VzdG9tUHJvdmlkZXIgPSBjdXN0b21Qcm92aWRlcjtcblxuLy8gY29yZS9yZWdpc3RyeS9uby1zdWNoLXByb3ZpZGVyLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IyMSwgTm9TdWNoTW9kZWxFcnJvciBhcyBOb1N1Y2hNb2RlbEVycm9yMyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTE2ID0gXCJBSV9Ob1N1Y2hQcm92aWRlckVycm9yXCI7XG52YXIgbWFya2VyMTYgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTE2fWA7XG52YXIgc3ltYm9sMTYgPSBTeW1ib2wuZm9yKG1hcmtlcjE2KTtcbnZhciBfYTE2O1xudmFyIE5vU3VjaFByb3ZpZGVyRXJyb3IgPSBjbGFzcyBleHRlbmRzIE5vU3VjaE1vZGVsRXJyb3IzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1vZGVsSWQsXG4gICAgbW9kZWxUeXBlLFxuICAgIHByb3ZpZGVySWQsXG4gICAgYXZhaWxhYmxlUHJvdmlkZXJzLFxuICAgIG1lc3NhZ2UgPSBgTm8gc3VjaCBwcm92aWRlcjogJHtwcm92aWRlcklkfSAoYXZhaWxhYmxlIHByb3ZpZGVyczogJHthdmFpbGFibGVQcm92aWRlcnMuam9pbigpfSlgXG4gIH0pIHtcbiAgICBzdXBlcih7IGVycm9yTmFtZTogbmFtZTE2LCBtb2RlbElkLCBtb2RlbFR5cGUsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTE2XSA9IHRydWU7XG4gICAgdGhpcy5wcm92aWRlcklkID0gcHJvdmlkZXJJZDtcbiAgICB0aGlzLmF2YWlsYWJsZVByb3ZpZGVycyA9IGF2YWlsYWJsZVByb3ZpZGVycztcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMjEuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxNik7XG4gIH1cbn07XG5fYTE2ID0gc3ltYm9sMTY7XG5cbi8vIGNvcmUvcmVnaXN0cnkvcHJvdmlkZXItcmVnaXN0cnkudHNcbmltcG9ydCB7IE5vU3VjaE1vZGVsRXJyb3IgYXMgTm9TdWNoTW9kZWxFcnJvcjQgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gY3JlYXRlUHJvdmlkZXJSZWdpc3RyeShwcm92aWRlcnMsIHtcbiAgc2VwYXJhdG9yID0gXCI6XCJcbn0gPSB7fSkge1xuICBjb25zdCByZWdpc3RyeSA9IG5ldyBEZWZhdWx0UHJvdmlkZXJSZWdpc3RyeSh7XG4gICAgc2VwYXJhdG9yXG4gIH0pO1xuICBmb3IgKGNvbnN0IFtpZCwgcHJvdmlkZXJdIG9mIE9iamVjdC5lbnRyaWVzKHByb3ZpZGVycykpIHtcbiAgICByZWdpc3RyeS5yZWdpc3RlclByb3ZpZGVyKHsgaWQsIHByb3ZpZGVyIH0pO1xuICB9XG4gIHJldHVybiByZWdpc3RyeTtcbn1cbnZhciBleHBlcmltZW50YWxfY3JlYXRlUHJvdmlkZXJSZWdpc3RyeSA9IGNyZWF0ZVByb3ZpZGVyUmVnaXN0cnk7XG52YXIgRGVmYXVsdFByb3ZpZGVyUmVnaXN0cnkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHsgc2VwYXJhdG9yIH0pIHtcbiAgICB0aGlzLnByb3ZpZGVycyA9IHt9O1xuICAgIHRoaXMuc2VwYXJhdG9yID0gc2VwYXJhdG9yO1xuICB9XG4gIHJlZ2lzdGVyUHJvdmlkZXIoe1xuICAgIGlkLFxuICAgIHByb3ZpZGVyXG4gIH0pIHtcbiAgICB0aGlzLnByb3ZpZGVyc1tpZF0gPSBwcm92aWRlcjtcbiAgfVxuICBnZXRQcm92aWRlcihpZCkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5wcm92aWRlcnNbaWRdO1xuICAgIGlmIChwcm92aWRlciA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoUHJvdmlkZXJFcnJvcih7XG4gICAgICAgIG1vZGVsSWQ6IGlkLFxuICAgICAgICBtb2RlbFR5cGU6IFwibGFuZ3VhZ2VNb2RlbFwiLFxuICAgICAgICBwcm92aWRlcklkOiBpZCxcbiAgICAgICAgYXZhaWxhYmxlUHJvdmlkZXJzOiBPYmplY3Qua2V5cyh0aGlzLnByb3ZpZGVycylcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvdmlkZXI7XG4gIH1cbiAgc3BsaXRJZChpZCwgbW9kZWxUeXBlKSB7XG4gICAgY29uc3QgaW5kZXggPSBpZC5pbmRleE9mKHRoaXMuc2VwYXJhdG9yKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjQoe1xuICAgICAgICBtb2RlbElkOiBpZCxcbiAgICAgICAgbW9kZWxUeXBlLFxuICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCAke21vZGVsVHlwZX0gaWQgZm9yIHJlZ2lzdHJ5OiAke2lkfSAobXVzdCBiZSBpbiB0aGUgZm9ybWF0IFwicHJvdmlkZXJJZCR7dGhpcy5zZXBhcmF0b3J9bW9kZWxJZFwiKWBcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gW2lkLnNsaWNlKDAsIGluZGV4KSwgaWQuc2xpY2UoaW5kZXggKyB0aGlzLnNlcGFyYXRvci5sZW5ndGgpXTtcbiAgfVxuICBsYW5ndWFnZU1vZGVsKGlkKSB7XG4gICAgdmFyIF9hMTcsIF9iO1xuICAgIGNvbnN0IFtwcm92aWRlcklkLCBtb2RlbElkXSA9IHRoaXMuc3BsaXRJZChpZCwgXCJsYW5ndWFnZU1vZGVsXCIpO1xuICAgIGNvbnN0IG1vZGVsID0gKF9iID0gKF9hMTcgPSB0aGlzLmdldFByb3ZpZGVyKHByb3ZpZGVySWQpKS5sYW5ndWFnZU1vZGVsKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTE3LCBtb2RlbElkKTtcbiAgICBpZiAobW9kZWwgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3I0KHsgbW9kZWxJZDogaWQsIG1vZGVsVHlwZTogXCJsYW5ndWFnZU1vZGVsXCIgfSk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuICB0ZXh0RW1iZWRkaW5nTW9kZWwoaWQpIHtcbiAgICB2YXIgX2ExNztcbiAgICBjb25zdCBbcHJvdmlkZXJJZCwgbW9kZWxJZF0gPSB0aGlzLnNwbGl0SWQoaWQsIFwidGV4dEVtYmVkZGluZ01vZGVsXCIpO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcm92aWRlcklkKTtcbiAgICBjb25zdCBtb2RlbCA9IChfYTE3ID0gcHJvdmlkZXIudGV4dEVtYmVkZGluZ01vZGVsKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jYWxsKHByb3ZpZGVyLCBtb2RlbElkKTtcbiAgICBpZiAobW9kZWwgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3I0KHtcbiAgICAgICAgbW9kZWxJZDogaWQsXG4gICAgICAgIG1vZGVsVHlwZTogXCJ0ZXh0RW1iZWRkaW5nTW9kZWxcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuICBpbWFnZU1vZGVsKGlkKSB7XG4gICAgdmFyIF9hMTc7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcImltYWdlTW9kZWxcIik7XG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByb3ZpZGVySWQpO1xuICAgIGNvbnN0IG1vZGVsID0gKF9hMTcgPSBwcm92aWRlci5pbWFnZU1vZGVsKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jYWxsKHByb3ZpZGVyLCBtb2RlbElkKTtcbiAgICBpZiAobW9kZWwgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3I0KHsgbW9kZWxJZDogaWQsIG1vZGVsVHlwZTogXCJpbWFnZU1vZGVsXCIgfSk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbiAgfVxufTtcblxuLy8gY29yZS90b29sL21jcC9tY3AtY2xpZW50LnRzXG5pbXBvcnQgeyBqc29uU2NoZW1hIH0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcblxuLy8gY29yZS90b29sL3Rvb2wudHNcbmZ1bmN0aW9uIHRvb2wodG9vbDIpIHtcbiAgcmV0dXJuIHRvb2wyO1xufVxuXG4vLyBjb3JlL3Rvb2wvbWNwL21jcC1zc2UtdHJhbnNwb3J0LnRzXG5pbXBvcnQgeyBjcmVhdGVFdmVudFNvdXJjZVBhcnNlclN0cmVhbSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIGNvcmUvdG9vbC9tY3AvanNvbi1ycGMtbWVzc2FnZS50c1xuaW1wb3J0IHsgeiBhcyB6OSB9IGZyb20gXCJ6b2RcIjtcblxuLy8gY29yZS90b29sL21jcC90eXBlcy50c1xuaW1wb3J0IHsgeiBhcyB6OCB9IGZyb20gXCJ6b2RcIjtcbnZhciBMQVRFU1RfUFJPVE9DT0xfVkVSU0lPTiA9IFwiMjAyNC0xMS0wNVwiO1xudmFyIFNVUFBPUlRFRF9QUk9UT0NPTF9WRVJTSU9OUyA9IFtcbiAgTEFURVNUX1BST1RPQ09MX1ZFUlNJT04sXG4gIFwiMjAyNC0xMC0wN1wiXG5dO1xudmFyIENsaWVudE9yU2VydmVySW1wbGVtZW50YXRpb25TY2hlbWEgPSB6OC5vYmplY3Qoe1xuICBuYW1lOiB6OC5zdHJpbmcoKSxcbiAgdmVyc2lvbjogejguc3RyaW5nKClcbn0pLnBhc3N0aHJvdWdoKCk7XG52YXIgQmFzZVBhcmFtc1NjaGVtYSA9IHo4Lm9iamVjdCh7XG4gIF9tZXRhOiB6OC5vcHRpb25hbCh6OC5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkpXG59KS5wYXNzdGhyb3VnaCgpO1xudmFyIFJlc3VsdFNjaGVtYSA9IEJhc2VQYXJhbXNTY2hlbWE7XG52YXIgUmVxdWVzdFNjaGVtYSA9IHo4Lm9iamVjdCh7XG4gIG1ldGhvZDogejguc3RyaW5nKCksXG4gIHBhcmFtczogejgub3B0aW9uYWwoQmFzZVBhcmFtc1NjaGVtYSlcbn0pO1xudmFyIFNlcnZlckNhcGFiaWxpdGllc1NjaGVtYSA9IHo4Lm9iamVjdCh7XG4gIGV4cGVyaW1lbnRhbDogejgub3B0aW9uYWwoejgub2JqZWN0KHt9KS5wYXNzdGhyb3VnaCgpKSxcbiAgbG9nZ2luZzogejgub3B0aW9uYWwoejgub2JqZWN0KHt9KS5wYXNzdGhyb3VnaCgpKSxcbiAgcHJvbXB0czogejgub3B0aW9uYWwoXG4gICAgejgub2JqZWN0KHtcbiAgICAgIGxpc3RDaGFuZ2VkOiB6OC5vcHRpb25hbCh6OC5ib29sZWFuKCkpXG4gICAgfSkucGFzc3Rocm91Z2goKVxuICApLFxuICByZXNvdXJjZXM6IHo4Lm9wdGlvbmFsKFxuICAgIHo4Lm9iamVjdCh7XG4gICAgICBzdWJzY3JpYmU6IHo4Lm9wdGlvbmFsKHo4LmJvb2xlYW4oKSksXG4gICAgICBsaXN0Q2hhbmdlZDogejgub3B0aW9uYWwoejguYm9vbGVhbigpKVxuICAgIH0pLnBhc3N0aHJvdWdoKClcbiAgKSxcbiAgdG9vbHM6IHo4Lm9wdGlvbmFsKFxuICAgIHo4Lm9iamVjdCh7XG4gICAgICBsaXN0Q2hhbmdlZDogejgub3B0aW9uYWwoejguYm9vbGVhbigpKVxuICAgIH0pLnBhc3N0aHJvdWdoKClcbiAgKVxufSkucGFzc3Rocm91Z2goKTtcbnZhciBJbml0aWFsaXplUmVzdWx0U2NoZW1hID0gUmVzdWx0U2NoZW1hLmV4dGVuZCh7XG4gIHByb3RvY29sVmVyc2lvbjogejguc3RyaW5nKCksXG4gIGNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzU2NoZW1hLFxuICBzZXJ2ZXJJbmZvOiBDbGllbnRPclNlcnZlckltcGxlbWVudGF0aW9uU2NoZW1hLFxuICBpbnN0cnVjdGlvbnM6IHo4Lm9wdGlvbmFsKHo4LnN0cmluZygpKVxufSk7XG52YXIgUGFnaW5hdGVkUmVzdWx0U2NoZW1hID0gUmVzdWx0U2NoZW1hLmV4dGVuZCh7XG4gIG5leHRDdXJzb3I6IHo4Lm9wdGlvbmFsKHo4LnN0cmluZygpKVxufSk7XG52YXIgVG9vbFNjaGVtYSA9IHo4Lm9iamVjdCh7XG4gIG5hbWU6IHo4LnN0cmluZygpLFxuICBkZXNjcmlwdGlvbjogejgub3B0aW9uYWwoejguc3RyaW5nKCkpLFxuICBpbnB1dFNjaGVtYTogejgub2JqZWN0KHtcbiAgICB0eXBlOiB6OC5saXRlcmFsKFwib2JqZWN0XCIpLFxuICAgIHByb3BlcnRpZXM6IHo4Lm9wdGlvbmFsKHo4Lm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSlcbiAgfSkucGFzc3Rocm91Z2goKVxufSkucGFzc3Rocm91Z2goKTtcbnZhciBMaXN0VG9vbHNSZXN1bHRTY2hlbWEgPSBQYWdpbmF0ZWRSZXN1bHRTY2hlbWEuZXh0ZW5kKHtcbiAgdG9vbHM6IHo4LmFycmF5KFRvb2xTY2hlbWEpXG59KTtcbnZhciBUZXh0Q29udGVudFNjaGVtYSA9IHo4Lm9iamVjdCh7XG4gIHR5cGU6IHo4LmxpdGVyYWwoXCJ0ZXh0XCIpLFxuICB0ZXh0OiB6OC5zdHJpbmcoKVxufSkucGFzc3Rocm91Z2goKTtcbnZhciBJbWFnZUNvbnRlbnRTY2hlbWEgPSB6OC5vYmplY3Qoe1xuICB0eXBlOiB6OC5saXRlcmFsKFwiaW1hZ2VcIiksXG4gIGRhdGE6IHo4LnN0cmluZygpLmJhc2U2NCgpLFxuICBtaW1lVHlwZTogejguc3RyaW5nKClcbn0pLnBhc3N0aHJvdWdoKCk7XG52YXIgUmVzb3VyY2VDb250ZW50c1NjaGVtYSA9IHo4Lm9iamVjdCh7XG4gIC8qKlxuICAgKiBUaGUgVVJJIG9mIHRoaXMgcmVzb3VyY2UuXG4gICAqL1xuICB1cmk6IHo4LnN0cmluZygpLFxuICAvKipcbiAgICogVGhlIE1JTUUgdHlwZSBvZiB0aGlzIHJlc291cmNlLCBpZiBrbm93bi5cbiAgICovXG4gIG1pbWVUeXBlOiB6OC5vcHRpb25hbCh6OC5zdHJpbmcoKSlcbn0pLnBhc3N0aHJvdWdoKCk7XG52YXIgVGV4dFJlc291cmNlQ29udGVudHNTY2hlbWEgPSBSZXNvdXJjZUNvbnRlbnRzU2NoZW1hLmV4dGVuZCh7XG4gIHRleHQ6IHo4LnN0cmluZygpXG59KTtcbnZhciBCbG9iUmVzb3VyY2VDb250ZW50c1NjaGVtYSA9IFJlc291cmNlQ29udGVudHNTY2hlbWEuZXh0ZW5kKHtcbiAgYmxvYjogejguc3RyaW5nKCkuYmFzZTY0KClcbn0pO1xudmFyIEVtYmVkZGVkUmVzb3VyY2VTY2hlbWEgPSB6OC5vYmplY3Qoe1xuICB0eXBlOiB6OC5saXRlcmFsKFwicmVzb3VyY2VcIiksXG4gIHJlc291cmNlOiB6OC51bmlvbihbVGV4dFJlc291cmNlQ29udGVudHNTY2hlbWEsIEJsb2JSZXNvdXJjZUNvbnRlbnRzU2NoZW1hXSlcbn0pLnBhc3N0aHJvdWdoKCk7XG52YXIgQ2FsbFRvb2xSZXN1bHRTY2hlbWEgPSBSZXN1bHRTY2hlbWEuZXh0ZW5kKHtcbiAgY29udGVudDogejguYXJyYXkoXG4gICAgejgudW5pb24oW1RleHRDb250ZW50U2NoZW1hLCBJbWFnZUNvbnRlbnRTY2hlbWEsIEVtYmVkZGVkUmVzb3VyY2VTY2hlbWFdKVxuICApLFxuICBpc0Vycm9yOiB6OC5ib29sZWFuKCkuZGVmYXVsdChmYWxzZSkub3B0aW9uYWwoKVxufSkub3IoXG4gIFJlc3VsdFNjaGVtYS5leHRlbmQoe1xuICAgIHRvb2xSZXN1bHQ6IHo4LnVua25vd24oKVxuICB9KVxuKTtcblxuLy8gY29yZS90b29sL21jcC9qc29uLXJwYy1tZXNzYWdlLnRzXG52YXIgSlNPTlJQQ19WRVJTSU9OID0gXCIyLjBcIjtcbnZhciBKU09OUlBDUmVxdWVzdFNjaGVtYSA9IHo5Lm9iamVjdCh7XG4gIGpzb25ycGM6IHo5LmxpdGVyYWwoSlNPTlJQQ19WRVJTSU9OKSxcbiAgaWQ6IHo5LnVuaW9uKFt6OS5zdHJpbmcoKSwgejkubnVtYmVyKCkuaW50KCldKVxufSkubWVyZ2UoUmVxdWVzdFNjaGVtYSkuc3RyaWN0KCk7XG52YXIgSlNPTlJQQ1Jlc3BvbnNlU2NoZW1hID0gejkub2JqZWN0KHtcbiAganNvbnJwYzogejkubGl0ZXJhbChKU09OUlBDX1ZFUlNJT04pLFxuICBpZDogejkudW5pb24oW3o5LnN0cmluZygpLCB6OS5udW1iZXIoKS5pbnQoKV0pLFxuICByZXN1bHQ6IFJlc3VsdFNjaGVtYVxufSkuc3RyaWN0KCk7XG52YXIgSlNPTlJQQ0Vycm9yU2NoZW1hID0gejkub2JqZWN0KHtcbiAganNvbnJwYzogejkubGl0ZXJhbChKU09OUlBDX1ZFUlNJT04pLFxuICBpZDogejkudW5pb24oW3o5LnN0cmluZygpLCB6OS5udW1iZXIoKS5pbnQoKV0pLFxuICBlcnJvcjogejkub2JqZWN0KHtcbiAgICBjb2RlOiB6OS5udW1iZXIoKS5pbnQoKSxcbiAgICBtZXNzYWdlOiB6OS5zdHJpbmcoKSxcbiAgICBkYXRhOiB6OS5vcHRpb25hbCh6OS51bmtub3duKCkpXG4gIH0pXG59KS5zdHJpY3QoKTtcbnZhciBKU09OUlBDTm90aWZpY2F0aW9uU2NoZW1hID0gejkub2JqZWN0KHtcbiAganNvbnJwYzogejkubGl0ZXJhbChKU09OUlBDX1ZFUlNJT04pXG59KS5tZXJnZShcbiAgejkub2JqZWN0KHtcbiAgICBtZXRob2Q6IHo5LnN0cmluZygpLFxuICAgIHBhcmFtczogejkub3B0aW9uYWwoQmFzZVBhcmFtc1NjaGVtYSlcbiAgfSlcbikuc3RyaWN0KCk7XG52YXIgSlNPTlJQQ01lc3NhZ2VTY2hlbWEgPSB6OS51bmlvbihbXG4gIEpTT05SUENSZXF1ZXN0U2NoZW1hLFxuICBKU09OUlBDTm90aWZpY2F0aW9uU2NoZW1hLFxuICBKU09OUlBDUmVzcG9uc2VTY2hlbWEsXG4gIEpTT05SUENFcnJvclNjaGVtYVxuXSk7XG5cbi8vIGNvcmUvdG9vbC9tY3AvbWNwLXNzZS10cmFuc3BvcnQudHNcbnZhciBTc2VNQ1BUcmFuc3BvcnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1cmwsXG4gICAgaGVhZGVyc1xuICB9KSB7XG4gICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnVybCA9IG5ldyBVUkwodXJsKTtcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICB9XG4gIGFzeW5jIHN0YXJ0KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3QgZXN0YWJsaXNoQ29ubmVjdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgdmFyIF9hMTcsIF9iLCBfYztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKTtcbiAgICAgICAgICBoZWFkZXJzLnNldChcIkFjY2VwdFwiLCBcInRleHQvZXZlbnQtc3RyZWFtXCIpO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGhpcy51cmwuaHJlZiwge1xuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogKF9hMTcgPSB0aGlzLmFib3J0Q29udHJvbGxlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuc2lnbmFsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5vayB8fCAhcmVzcG9uc2UuYm9keSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICAgICAgICBtZXNzYWdlOiBgTUNQIFNTRSBUcmFuc3BvcnQgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAoX2IgPSB0aGlzLm9uZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzdHJlYW0gPSByZXNwb25zZS5ib2R5LnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKS5waXBlVGhyb3VnaChjcmVhdGVFdmVudFNvdXJjZVBhcnNlclN0cmVhbSgpKTtcbiAgICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgY29uc3QgcHJvY2Vzc0V2ZW50cyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTE4LCBfYjIsIF9jMjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJNQ1AgU1NFIFRyYW5zcG9ydCBFcnJvcjogQ29ubmVjdGlvbiBjbG9zZWQgdW5leHBlY3RlZGx5XCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXZlbnQsIGRhdGEgfSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChldmVudCA9PT0gXCJlbmRwb2ludFwiKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmVuZHBvaW50ID0gbmV3IFVSTChkYXRhLCB0aGlzLnVybCk7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmRwb2ludC5vcmlnaW4gIT09IHRoaXMudXJsLm9yaWdpbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBNQ1AgU1NFIFRyYW5zcG9ydCBFcnJvcjogRW5kcG9pbnQgb3JpZ2luIGRvZXMgbm90IG1hdGNoIGNvbm5lY3Rpb24gb3JpZ2luOiAke3RoaXMuZW5kcG9pbnQub3JpZ2lufWBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudCA9PT0gXCJtZXNzYWdlXCIpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBKU09OUlBDTWVzc2FnZVNjaGVtYS5wYXJzZShcbiAgICAgICAgICAgICAgICAgICAgICBKU09OLnBhcnNlKGRhdGEpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIChfYTE4ID0gdGhpcy5vbm1lc3NhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTE4LmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gbmV3IE1DUENsaWVudEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIk1DUCBTU0UgVHJhbnNwb3J0IEVycm9yOiBGYWlsZWQgdG8gcGFyc2UgbWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgKF9iMiA9IHRoaXMub25lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKF9jMiA9IHRoaXMub25lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jMi5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuc3NlQ29ubmVjdGlvbiA9IHtcbiAgICAgICAgICAgIGNsb3NlOiAoKSA9PiByZWFkZXIuY2FuY2VsKClcbiAgICAgICAgICB9O1xuICAgICAgICAgIHByb2Nlc3NFdmVudHMoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAoX2MgPSB0aGlzLm9uZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZXN0YWJsaXNoQ29ubmVjdGlvbigpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIHZhciBfYTE3LCBfYiwgX2M7XG4gICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAoX2ExNyA9IHRoaXMuc3NlQ29ubmVjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2xvc2UoKTtcbiAgICAoX2IgPSB0aGlzLmFib3J0Q29udHJvbGxlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmFib3J0KCk7XG4gICAgKF9jID0gdGhpcy5vbmNsb3NlKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbCh0aGlzKTtcbiAgfVxuICBhc3luYyBzZW5kKG1lc3NhZ2UpIHtcbiAgICB2YXIgX2ExNywgX2IsIF9jO1xuICAgIGlmICghdGhpcy5lbmRwb2ludCB8fCAhdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IFwiTUNQIFNTRSBUcmFuc3BvcnQgRXJyb3I6IE5vdCBjb25uZWN0ZWRcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKTtcbiAgICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICAgIGNvbnN0IGluaXQgPSB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpLFxuICAgICAgICBzaWduYWw6IChfYTE3ID0gdGhpcy5hYm9ydENvbnRyb2xsZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LnNpZ25hbFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGhpcy5lbmRwb2ludCwgaW5pdCk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IHRleHQyID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpLmNhdGNoKCgpID0+IG51bGwpO1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogYE1DUCBTU0UgVHJhbnNwb3J0IEVycm9yOiBQT1NUaW5nIHRvIGVuZHBvaW50IChIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfSk6ICR7dGV4dDJ9YFxuICAgICAgICB9KTtcbiAgICAgICAgKF9iID0gdGhpcy5vbmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgKF9jID0gdGhpcy5vbmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59O1xuXG4vLyBjb3JlL3Rvb2wvbWNwL21jcC10cmFuc3BvcnQudHNcbmZ1bmN0aW9uIGNyZWF0ZU1jcFRyYW5zcG9ydChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy50eXBlICE9PSBcInNzZVwiKSB7XG4gICAgdGhyb3cgbmV3IE1DUENsaWVudEVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IFwiVW5zdXBwb3J0ZWQgb3IgaW52YWxpZCB0cmFuc3BvcnQgY29uZmlndXJhdGlvbi4gSWYgeW91IGFyZSB1c2luZyBhIGN1c3RvbSB0cmFuc3BvcnQsIG1ha2Ugc3VyZSBpdCBpbXBsZW1lbnRzIHRoZSBNQ1BUcmFuc3BvcnQgaW50ZXJmYWNlLlwiXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBTc2VNQ1BUcmFuc3BvcnQoY29uZmlnKTtcbn1cbmZ1bmN0aW9uIGlzQ3VzdG9tTWNwVHJhbnNwb3J0KHRyYW5zcG9ydCkge1xuICByZXR1cm4gXCJzdGFydFwiIGluIHRyYW5zcG9ydCAmJiB0eXBlb2YgdHJhbnNwb3J0LnN0YXJ0ID09PSBcImZ1bmN0aW9uXCIgJiYgXCJzZW5kXCIgaW4gdHJhbnNwb3J0ICYmIHR5cGVvZiB0cmFuc3BvcnQuc2VuZCA9PT0gXCJmdW5jdGlvblwiICYmIFwiY2xvc2VcIiBpbiB0cmFuc3BvcnQgJiYgdHlwZW9mIHRyYW5zcG9ydC5jbG9zZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG4vLyBjb3JlL3Rvb2wvbWNwL21jcC1jbGllbnQudHNcbnZhciBDTElFTlRfVkVSU0lPTiA9IFwiMS4wLjBcIjtcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZU1DUENsaWVudChjb25maWcpIHtcbiAgY29uc3QgY2xpZW50ID0gbmV3IE1DUENsaWVudChjb25maWcpO1xuICBhd2FpdCBjbGllbnQuaW5pdCgpO1xuICByZXR1cm4gY2xpZW50O1xufVxudmFyIE1DUENsaWVudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHRyYW5zcG9ydDogdHJhbnNwb3J0Q29uZmlnLFxuICAgIG5hbWU6IG5hbWUxNyA9IFwiYWktc2RrLW1jcC1jbGllbnRcIixcbiAgICBvblVuY2F1Z2h0RXJyb3JcbiAgfSkge1xuICAgIHRoaXMucmVxdWVzdE1lc3NhZ2VJZCA9IDA7XG4gICAgdGhpcy5yZXNwb25zZUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnNlcnZlckNhcGFiaWxpdGllcyA9IHt9O1xuICAgIHRoaXMuaXNDbG9zZWQgPSB0cnVlO1xuICAgIHRoaXMub25VbmNhdWdodEVycm9yID0gb25VbmNhdWdodEVycm9yO1xuICAgIGlmIChpc0N1c3RvbU1jcFRyYW5zcG9ydCh0cmFuc3BvcnRDb25maWcpKSB7XG4gICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydENvbmZpZztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50cmFuc3BvcnQgPSBjcmVhdGVNY3BUcmFuc3BvcnQodHJhbnNwb3J0Q29uZmlnKTtcbiAgICB9XG4gICAgdGhpcy50cmFuc3BvcnQub25jbG9zZSA9ICgpID0+IHRoaXMub25DbG9zZSgpO1xuICAgIHRoaXMudHJhbnNwb3J0Lm9uZXJyb3IgPSAoZXJyb3IpID0+IHRoaXMub25FcnJvcihlcnJvcik7XG4gICAgdGhpcy50cmFuc3BvcnQub25tZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgIGlmIChcIm1ldGhvZFwiIGluIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5vbkVycm9yKFxuICAgICAgICAgIG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIlVuc3VwcG9ydGVkIG1lc3NhZ2UgdHlwZVwiXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5vblJlc3BvbnNlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgdGhpcy5jbGllbnRJbmZvID0ge1xuICAgICAgbmFtZTogbmFtZTE3LFxuICAgICAgdmVyc2lvbjogQ0xJRU5UX1ZFUlNJT05cbiAgICB9O1xuICB9XG4gIGFzeW5jIGluaXQoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMudHJhbnNwb3J0LnN0YXJ0KCk7XG4gICAgICB0aGlzLmlzQ2xvc2VkID0gZmFsc2U7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICByZXF1ZXN0OiB7XG4gICAgICAgICAgbWV0aG9kOiBcImluaXRpYWxpemVcIixcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIHByb3RvY29sVmVyc2lvbjogTEFURVNUX1BST1RPQ09MX1ZFUlNJT04sXG4gICAgICAgICAgICBjYXBhYmlsaXRpZXM6IHt9LFxuICAgICAgICAgICAgY2xpZW50SW5mbzogdGhpcy5jbGllbnRJbmZvXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZXN1bHRTY2hlbWE6IEluaXRpYWxpemVSZXN1bHRTY2hlbWFcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogXCJTZXJ2ZXIgc2VudCBpbnZhbGlkIGluaXRpYWxpemUgcmVzdWx0XCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIVNVUFBPUlRFRF9QUk9UT0NPTF9WRVJTSU9OUy5pbmNsdWRlcyhyZXN1bHQucHJvdG9jb2xWZXJzaW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IGBTZXJ2ZXIncyBwcm90b2NvbCB2ZXJzaW9uIGlzIG5vdCBzdXBwb3J0ZWQ6ICR7cmVzdWx0LnByb3RvY29sVmVyc2lvbn1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXJ2ZXJDYXBhYmlsaXRpZXMgPSByZXN1bHQuY2FwYWJpbGl0aWVzO1xuICAgICAgYXdhaXQgdGhpcy5ub3RpZmljYXRpb24oe1xuICAgICAgICBtZXRob2Q6IFwibm90aWZpY2F0aW9ucy9pbml0aWFsaXplZFwiXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBhd2FpdCB0aGlzLmNsb3NlKCk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY2xvc2UoKSB7XG4gICAgdmFyIF9hMTc7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpXG4gICAgICByZXR1cm47XG4gICAgYXdhaXQgKChfYTE3ID0gdGhpcy50cmFuc3BvcnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LmNsb3NlKCkpO1xuICAgIHRoaXMub25DbG9zZSgpO1xuICB9XG4gIGFzeW5jIHJlcXVlc3Qoe1xuICAgIHJlcXVlc3QsXG4gICAgcmVzdWx0U2NoZW1hLFxuICAgIG9wdGlvbnNcbiAgfSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KFxuICAgICAgICAgIG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIkF0dGVtcHRlZCB0byBzZW5kIGEgcmVxdWVzdCBmcm9tIGEgY2xvc2VkIGNsaWVudFwiXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpZ25hbCA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsO1xuICAgICAgc2lnbmFsID09IG51bGwgPyB2b2lkIDAgOiBzaWduYWwudGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2VJZCA9IHRoaXMucmVxdWVzdE1lc3NhZ2VJZCsrO1xuICAgICAgY29uc3QganNvbnJwY1JlcXVlc3QgPSB7XG4gICAgICAgIC4uLnJlcXVlc3QsXG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIGlkOiBtZXNzYWdlSWRcbiAgICAgIH07XG4gICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnJlc3BvbnNlSGFuZGxlcnMuZGVsZXRlKG1lc3NhZ2VJZCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5yZXNwb25zZUhhbmRsZXJzLnNldChtZXNzYWdlSWQsIChyZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAoc2lnbmFsID09IG51bGwgPyB2b2lkIDAgOiBzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIHJldHVybiByZWplY3QoXG4gICAgICAgICAgICBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICAgICAgICBtZXNzYWdlOiBcIlJlcXVlc3Qgd2FzIGFib3J0ZWRcIixcbiAgICAgICAgICAgICAgY2F1c2U6IHNpZ25hbC5yZWFzb25cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiByZWplY3QocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzdWx0U2NoZW1hLnBhcnNlKHJlc3BvbnNlLnJlc3VsdCk7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnN0IHBhcnNlRXJyb3IgPSBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogXCJGYWlsZWQgdG8gcGFyc2Ugc2VydmVyIGluaXRpYWxpemF0aW9uIHJlc3VsdFwiLFxuICAgICAgICAgICAgY2F1c2U6IGVycm9yXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVqZWN0KHBhcnNlRXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMudHJhbnNwb3J0LnNlbmQoanNvbnJwY1JlcXVlc3QpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBsaXN0VG9vbHMoe1xuICAgIHBhcmFtcyxcbiAgICBvcHRpb25zXG4gIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5zZXJ2ZXJDYXBhYmlsaXRpZXMudG9vbHMpIHtcbiAgICAgIHRocm93IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBTZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCB0b29sc2BcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCh7XG4gICAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kOiBcInRvb2xzL2xpc3RcIiwgcGFyYW1zIH0sXG4gICAgICAgIHJlc3VsdFNjaGVtYTogTGlzdFRvb2xzUmVzdWx0U2NoZW1hLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNhbGxUb29sKHtcbiAgICBuYW1lOiBuYW1lMTcsXG4gICAgYXJncyxcbiAgICBvcHRpb25zXG4gIH0pIHtcbiAgICBpZiAoIXRoaXMuc2VydmVyQ2FwYWJpbGl0aWVzLnRvb2xzKSB7XG4gICAgICB0aHJvdyBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBgU2VydmVyIGRvZXMgbm90IHN1cHBvcnQgdG9vbHNgXG4gICAgICB9KTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICByZXF1ZXN0OiB7IG1ldGhvZDogXCJ0b29scy9jYWxsXCIsIHBhcmFtczogeyBuYW1lOiBuYW1lMTcsIGFyZ3VtZW50czogYXJncyB9IH0sXG4gICAgICAgIHJlc3VsdFNjaGVtYTogQ2FsbFRvb2xSZXN1bHRTY2hlbWEsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBzaWduYWw6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuYWJvcnRTaWduYWxcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBub3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3QganNvbnJwY05vdGlmaWNhdGlvbiA9IHtcbiAgICAgIC4uLm5vdGlmaWNhdGlvbixcbiAgICAgIGpzb25ycGM6IFwiMi4wXCJcbiAgICB9O1xuICAgIGF3YWl0IHRoaXMudHJhbnNwb3J0LnNlbmQoanNvbnJwY05vdGlmaWNhdGlvbik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzZXQgb2YgQUkgU0RLIHRvb2xzIGZyb20gdGhlIE1DUCBzZXJ2ZXJcbiAgICogQHJldHVybnMgQSByZWNvcmQgb2YgdG9vbCBuYW1lcyB0byB0aGVpciBpbXBsZW1lbnRhdGlvbnNcbiAgICovXG4gIGFzeW5jIHRvb2xzKHtcbiAgICBzY2hlbWFzID0gXCJhdXRvbWF0aWNcIlxuICB9ID0ge30pIHtcbiAgICB2YXIgX2ExNztcbiAgICBjb25zdCB0b29scyA9IHt9O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBsaXN0VG9vbHNSZXN1bHQgPSBhd2FpdCB0aGlzLmxpc3RUb29scygpO1xuICAgICAgZm9yIChjb25zdCB7IG5hbWU6IG5hbWUxNywgZGVzY3JpcHRpb24sIGlucHV0U2NoZW1hIH0gb2YgbGlzdFRvb2xzUmVzdWx0LnRvb2xzKSB7XG4gICAgICAgIGlmIChzY2hlbWFzICE9PSBcImF1dG9tYXRpY1wiICYmICEobmFtZTE3IGluIHNjaGVtYXMpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHNjaGVtYXMgPT09IFwiYXV0b21hdGljXCIgPyBqc29uU2NoZW1hKHtcbiAgICAgICAgICAuLi5pbnB1dFNjaGVtYSxcbiAgICAgICAgICBwcm9wZXJ0aWVzOiAoX2ExNyA9IGlucHV0U2NoZW1hLnByb3BlcnRpZXMpICE9IG51bGwgPyBfYTE3IDoge30sXG4gICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlXG4gICAgICAgIH0pIDogc2NoZW1hc1tuYW1lMTddLnBhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCB0b29sV2l0aEV4ZWN1dGUgPSB0b29sKHtcbiAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgIGV4ZWN1dGU6IGFzeW5jIChhcmdzLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2ExODtcbiAgICAgICAgICAgIChfYTE4ID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5hYm9ydFNpZ25hbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTgudGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNhbGxUb29sKHtcbiAgICAgICAgICAgICAgbmFtZTogbmFtZTE3LFxuICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0b29sc1tuYW1lMTddID0gdG9vbFdpdGhFeGVjdXRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRvb2xzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgb25DbG9zZSgpIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICBtZXNzYWdlOiBcIkNvbm5lY3Rpb24gY2xvc2VkXCJcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgdGhpcy5yZXNwb25zZUhhbmRsZXJzLnZhbHVlcygpKSB7XG4gICAgICBoYW5kbGVyKGVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5yZXNwb25zZUhhbmRsZXJzLmNsZWFyKCk7XG4gIH1cbiAgb25FcnJvcihlcnJvcikge1xuICAgIGlmICh0aGlzLm9uVW5jYXVnaHRFcnJvcikge1xuICAgICAgdGhpcy5vblVuY2F1Z2h0RXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICBvblJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgbWVzc2FnZUlkID0gTnVtYmVyKHJlc3BvbnNlLmlkKTtcbiAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5yZXNwb25zZUhhbmRsZXJzLmdldChtZXNzYWdlSWQpO1xuICAgIGlmIChoYW5kbGVyID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBQcm90b2NvbCBlcnJvcjogUmVjZWl2ZWQgYSByZXNwb25zZSBmb3IgYW4gdW5rbm93biBtZXNzYWdlIElEOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIHJlc3BvbnNlXG4gICAgICAgICl9YFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMucmVzcG9uc2VIYW5kbGVycy5kZWxldGUobWVzc2FnZUlkKTtcbiAgICBoYW5kbGVyKFxuICAgICAgXCJyZXN1bHRcIiBpbiByZXNwb25zZSA/IHJlc3BvbnNlIDogbmV3IE1DUENsaWVudEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogcmVzcG9uc2UuZXJyb3IubWVzc2FnZSxcbiAgICAgICAgY2F1c2U6IHJlc3BvbnNlLmVycm9yXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn07XG5cbi8vIGNvcmUvdXRpbC9jb3NpbmUtc2ltaWxhcml0eS50c1xuZnVuY3Rpb24gY29zaW5lU2ltaWxhcml0eSh2ZWN0b3IxLCB2ZWN0b3IyLCBvcHRpb25zKSB7XG4gIGlmICh2ZWN0b3IxLmxlbmd0aCAhPT0gdmVjdG9yMi5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgcGFyYW1ldGVyOiBcInZlY3RvcjEsdmVjdG9yMlwiLFxuICAgICAgdmFsdWU6IHsgdmVjdG9yMUxlbmd0aDogdmVjdG9yMS5sZW5ndGgsIHZlY3RvcjJMZW5ndGg6IHZlY3RvcjIubGVuZ3RoIH0sXG4gICAgICBtZXNzYWdlOiBgVmVjdG9ycyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoYFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IG4gPSB2ZWN0b3IxLmxlbmd0aDtcbiAgaWYgKG4gPT09IDApIHtcbiAgICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50aHJvd0Vycm9yRm9yRW1wdHlWZWN0b3JzKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwidmVjdG9yMVwiLFxuICAgICAgICB2YWx1ZTogdmVjdG9yMSxcbiAgICAgICAgbWVzc2FnZTogXCJWZWN0b3JzIGNhbm5vdCBiZSBlbXB0eVwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgbGV0IG1hZ25pdHVkZVNxdWFyZWQxID0gMDtcbiAgbGV0IG1hZ25pdHVkZVNxdWFyZWQyID0gMDtcbiAgbGV0IGRvdFByb2R1Y3QgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGNvbnN0IHZhbHVlMSA9IHZlY3RvcjFbaV07XG4gICAgY29uc3QgdmFsdWUyID0gdmVjdG9yMltpXTtcbiAgICBtYWduaXR1ZGVTcXVhcmVkMSArPSB2YWx1ZTEgKiB2YWx1ZTE7XG4gICAgbWFnbml0dWRlU3F1YXJlZDIgKz0gdmFsdWUyICogdmFsdWUyO1xuICAgIGRvdFByb2R1Y3QgKz0gdmFsdWUxICogdmFsdWUyO1xuICB9XG4gIHJldHVybiBtYWduaXR1ZGVTcXVhcmVkMSA9PT0gMCB8fCBtYWduaXR1ZGVTcXVhcmVkMiA9PT0gMCA/IDAgOiBkb3RQcm9kdWN0IC8gKE1hdGguc3FydChtYWduaXR1ZGVTcXVhcmVkMSkgKiBNYXRoLnNxcnQobWFnbml0dWRlU3F1YXJlZDIpKTtcbn1cblxuLy8gY29yZS91dGlsL3NpbXVsYXRlLXJlYWRhYmxlLXN0cmVhbS50c1xuaW1wb3J0IHsgZGVsYXkgYXMgZGVsYXlGdW5jdGlvbiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5mdW5jdGlvbiBzaW11bGF0ZVJlYWRhYmxlU3RyZWFtKHtcbiAgY2h1bmtzLFxuICBpbml0aWFsRGVsYXlJbk1zID0gMCxcbiAgY2h1bmtEZWxheUluTXMgPSAwLFxuICBfaW50ZXJuYWxcbn0pIHtcbiAgdmFyIF9hMTc7XG4gIGNvbnN0IGRlbGF5MiA9IChfYTE3ID0gX2ludGVybmFsID09IG51bGwgPyB2b2lkIDAgOiBfaW50ZXJuYWwuZGVsYXkpICE9IG51bGwgPyBfYTE3IDogZGVsYXlGdW5jdGlvbjtcbiAgbGV0IGluZGV4ID0gMDtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICBpZiAoaW5kZXggPCBjaHVua3MubGVuZ3RoKSB7XG4gICAgICAgIGF3YWl0IGRlbGF5MihpbmRleCA9PT0gMCA/IGluaXRpYWxEZWxheUluTXMgOiBjaHVua0RlbGF5SW5Ncyk7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVua3NbaW5kZXgrK10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8vIHN0cmVhbXMvYXNzaXN0YW50LXJlc3BvbnNlLnRzXG5pbXBvcnQge1xuICBmb3JtYXRBc3Npc3RhbnRTdHJlYW1QYXJ0IGFzIGZvcm1hdEFzc2lzdGFudFN0cmVhbVBhcnQyXG59IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5mdW5jdGlvbiBBc3Npc3RhbnRSZXNwb25zZSh7IHRocmVhZElkLCBtZXNzYWdlSWQgfSwgcHJvY2VzczIpIHtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICB2YXIgX2ExNztcbiAgICAgIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICBjb25zdCBzZW5kTWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICBmb3JtYXRBc3Npc3RhbnRTdHJlYW1QYXJ0MihcImFzc2lzdGFudF9tZXNzYWdlXCIsIG1lc3NhZ2UpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNlbmREYXRhTWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICBmb3JtYXRBc3Npc3RhbnRTdHJlYW1QYXJ0MihcImRhdGFfbWVzc2FnZVwiLCBtZXNzYWdlKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzZW5kRXJyb3IgPSAoZXJyb3JNZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0QXNzaXN0YW50U3RyZWFtUGFydDIoXCJlcnJvclwiLCBlcnJvck1lc3NhZ2UpKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGZvcndhcmRTdHJlYW0gPSBhc3luYyAoc3RyZWFtMikgPT4ge1xuICAgICAgICB2YXIgX2ExOCwgX2I7XG4gICAgICAgIGxldCByZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2Ygc3RyZWFtMikge1xuICAgICAgICAgIHN3aXRjaCAodmFsdWUuZXZlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0aHJlYWQubWVzc2FnZS5jcmVhdGVkXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICAgIGZvcm1hdEFzc2lzdGFudFN0cmVhbVBhcnQyKFwiYXNzaXN0YW50X21lc3NhZ2VcIiwge1xuICAgICAgICAgICAgICAgICAgICBpZDogdmFsdWUuZGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IHsgdmFsdWU6IFwiXCIgfSB9XVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRocmVhZC5tZXNzYWdlLmRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IChfYTE4ID0gdmFsdWUuZGF0YS5kZWx0YS5jb250ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2ExOFswXTtcbiAgICAgICAgICAgICAgaWYgKChjb250ZW50ID09IG51bGwgPyB2b2lkIDAgOiBjb250ZW50LnR5cGUpID09PSBcInRleHRcIiAmJiAoKF9iID0gY29udGVudC50ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2IudmFsdWUpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdEFzc2lzdGFudFN0cmVhbVBhcnQyKFwidGV4dFwiLCBjb250ZW50LnRleHQudmFsdWUpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0aHJlYWQucnVuLmNvbXBsZXRlZFwiOlxuICAgICAgICAgICAgY2FzZSBcInRocmVhZC5ydW4ucmVxdWlyZXNfYWN0aW9uXCI6IHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUuZGF0YTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgZm9ybWF0QXNzaXN0YW50U3RyZWFtUGFydDIoXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIsIHtcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgbWVzc2FnZUlkXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHByb2Nlc3MyKHtcbiAgICAgICAgICBzZW5kTWVzc2FnZSxcbiAgICAgICAgICBzZW5kRGF0YU1lc3NhZ2UsXG4gICAgICAgICAgZm9yd2FyZFN0cmVhbVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHNlbmRFcnJvcigoX2ExNyA9IGVycm9yLm1lc3NhZ2UpICE9IG51bGwgPyBfYTE3IDogYCR7ZXJyb3J9YCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICB9LFxuICAgIGNhbmNlbCgpIHtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKHN0cmVhbSwge1xuICAgIHN0YXR1czogMjAwLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3RyZWFtcy9sYW5nY2hhaW4tYWRhcHRlci50c1xudmFyIGxhbmdjaGFpbl9hZGFwdGVyX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGxhbmdjaGFpbl9hZGFwdGVyX2V4cG9ydHMsIHtcbiAgbWVyZ2VJbnRvRGF0YVN0cmVhbTogKCkgPT4gbWVyZ2VJbnRvRGF0YVN0cmVhbSxcbiAgdG9EYXRhU3RyZWFtOiAoKSA9PiB0b0RhdGFTdHJlYW0sXG4gIHRvRGF0YVN0cmVhbVJlc3BvbnNlOiAoKSA9PiB0b0RhdGFTdHJlYW1SZXNwb25zZVxufSk7XG5pbXBvcnQgeyBmb3JtYXREYXRhU3RyZWFtUGFydCBhcyBmb3JtYXREYXRhU3RyZWFtUGFydDQgfSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuXG4vLyBzdHJlYW1zL3N0cmVhbS1jYWxsYmFja3MudHNcbmZ1bmN0aW9uIGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcyA9IHt9KSB7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGxldCBhZ2dyZWdhdGVkUmVzcG9uc2UgPSBcIlwiO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uU3RhcnQpXG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblN0YXJ0KCk7XG4gICAgfSxcbiAgICBhc3luYyB0cmFuc2Zvcm0obWVzc2FnZSwgY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHRFbmNvZGVyLmVuY29kZShtZXNzYWdlKSk7XG4gICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgIGlmIChjYWxsYmFja3Mub25Ub2tlbilcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uVG9rZW4obWVzc2FnZSk7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uVGV4dCAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25UZXh0KG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgZmx1c2goKSB7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uQ29tcGxldGlvbikge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25Db21wbGV0aW9uKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uRmluYWwpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uRmluYWwoYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzdHJlYW1zL2xhbmdjaGFpbi1hZGFwdGVyLnRzXG5mdW5jdGlvbiB0b0RhdGFTdHJlYW1JbnRlcm5hbChzdHJlYW0sIGNhbGxiYWNrcykge1xuICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgdHJhbnNmb3JtOiBhc3luYyAodmFsdWUsIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgdmFyIF9hMTc7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJldmVudFwiIGluIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlLmV2ZW50ID09PSBcIm9uX2NoYXRfbW9kZWxfc3RyZWFtXCIpIHtcbiAgICAgICAgICAgIGZvcndhcmRBSU1lc3NhZ2VDaHVuayhcbiAgICAgICAgICAgICAgKF9hMTcgPSB2YWx1ZS5kYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jaHVuayxcbiAgICAgICAgICAgICAgY29udHJvbGxlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvcndhcmRBSU1lc3NhZ2VDaHVuayh2YWx1ZSwgY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfSlcbiAgKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChuZXcgVGV4dERlY29kZXJTdHJlYW0oKSkucGlwZVRocm91Z2goXG4gICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICB0cmFuc2Zvcm06IGFzeW5jIChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZm9ybWF0RGF0YVN0cmVhbVBhcnQ0KFwidGV4dFwiLCBjaHVuaykpO1xuICAgICAgfVxuICAgIH0pXG4gICk7XG59XG5mdW5jdGlvbiB0b0RhdGFTdHJlYW0oc3RyZWFtLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIHRvRGF0YVN0cmVhbUludGVybmFsKHN0cmVhbSwgY2FsbGJhY2tzKS5waXBlVGhyb3VnaChcbiAgICBuZXcgVGV4dEVuY29kZXJTdHJlYW0oKVxuICApO1xufVxuZnVuY3Rpb24gdG9EYXRhU3RyZWFtUmVzcG9uc2Uoc3RyZWFtLCBvcHRpb25zKSB7XG4gIHZhciBfYTE3O1xuICBjb25zdCBkYXRhU3RyZWFtID0gdG9EYXRhU3RyZWFtSW50ZXJuYWwoXG4gICAgc3RyZWFtLFxuICAgIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FsbGJhY2tzXG4gICkucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpO1xuICBjb25zdCBkYXRhID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhO1xuICBjb25zdCBpbml0ID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5pbml0O1xuICBjb25zdCByZXNwb25zZVN0cmVhbSA9IGRhdGEgPyBtZXJnZVN0cmVhbXMoZGF0YS5zdHJlYW0sIGRhdGFTdHJlYW0pIDogZGF0YVN0cmVhbTtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZShyZXNwb25zZVN0cmVhbSwge1xuICAgIHN0YXR1czogKF9hMTcgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTcgOiAyMDAsXG4gICAgc3RhdHVzVGV4dDogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzLCB7XG4gICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICBkYXRhU3RyZWFtVmVyc2lvbjogXCJ2MVwiXG4gICAgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiBtZXJnZUludG9EYXRhU3RyZWFtKHN0cmVhbSwgb3B0aW9ucykge1xuICBvcHRpb25zLmRhdGFTdHJlYW0ubWVyZ2UodG9EYXRhU3RyZWFtSW50ZXJuYWwoc3RyZWFtLCBvcHRpb25zLmNhbGxiYWNrcykpO1xufVxuZnVuY3Rpb24gZm9yd2FyZEFJTWVzc2FnZUNodW5rKGNodW5rLCBjb250cm9sbGVyKSB7XG4gIGlmICh0eXBlb2YgY2h1bmsuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay5jb250ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb250ZW50ID0gY2h1bmsuY29udGVudDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29udGVudCkge1xuICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGl0ZW0udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHN0cmVhbXMvbGxhbWFpbmRleC1hZGFwdGVyLnRzXG52YXIgbGxhbWFpbmRleF9hZGFwdGVyX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGxsYW1haW5kZXhfYWRhcHRlcl9leHBvcnRzLCB7XG4gIG1lcmdlSW50b0RhdGFTdHJlYW06ICgpID0+IG1lcmdlSW50b0RhdGFTdHJlYW0yLFxuICB0b0RhdGFTdHJlYW06ICgpID0+IHRvRGF0YVN0cmVhbTIsXG4gIHRvRGF0YVN0cmVhbVJlc3BvbnNlOiAoKSA9PiB0b0RhdGFTdHJlYW1SZXNwb25zZTJcbn0pO1xuaW1wb3J0IHsgY29udmVydEFzeW5jSXRlcmF0b3JUb1JlYWRhYmxlU3RyZWFtIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IGZvcm1hdERhdGFTdHJlYW1QYXJ0IGFzIGZvcm1hdERhdGFTdHJlYW1QYXJ0NSB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5mdW5jdGlvbiB0b0RhdGFTdHJlYW1JbnRlcm5hbDIoc3RyZWFtLCBjYWxsYmFja3MpIHtcbiAgY29uc3QgdHJpbVN0YXJ0ID0gdHJpbVN0YXJ0T2ZTdHJlYW0oKTtcbiAgcmV0dXJuIGNvbnZlcnRBc3luY0l0ZXJhdG9yVG9SZWFkYWJsZVN0cmVhbShzdHJlYW1bU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkpLnBpcGVUaHJvdWdoKFxuICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgYXN5bmMgdHJhbnNmb3JtKG1lc3NhZ2UsIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRyaW1TdGFydChtZXNzYWdlLmRlbHRhKSk7XG4gICAgICB9XG4gICAgfSlcbiAgKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChuZXcgVGV4dERlY29kZXJTdHJlYW0oKSkucGlwZVRocm91Z2goXG4gICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICB0cmFuc2Zvcm06IGFzeW5jIChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZm9ybWF0RGF0YVN0cmVhbVBhcnQ1KFwidGV4dFwiLCBjaHVuaykpO1xuICAgICAgfVxuICAgIH0pXG4gICk7XG59XG5mdW5jdGlvbiB0b0RhdGFTdHJlYW0yKHN0cmVhbSwgY2FsbGJhY2tzKSB7XG4gIHJldHVybiB0b0RhdGFTdHJlYW1JbnRlcm5hbDIoc3RyZWFtLCBjYWxsYmFja3MpLnBpcGVUaHJvdWdoKFxuICAgIG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpXG4gICk7XG59XG5mdW5jdGlvbiB0b0RhdGFTdHJlYW1SZXNwb25zZTIoc3RyZWFtLCBvcHRpb25zID0ge30pIHtcbiAgdmFyIF9hMTc7XG4gIGNvbnN0IHsgaW5pdCwgZGF0YSwgY2FsbGJhY2tzIH0gPSBvcHRpb25zO1xuICBjb25zdCBkYXRhU3RyZWFtID0gdG9EYXRhU3RyZWFtSW50ZXJuYWwyKHN0cmVhbSwgY2FsbGJhY2tzKS5waXBlVGhyb3VnaChcbiAgICBuZXcgVGV4dEVuY29kZXJTdHJlYW0oKVxuICApO1xuICBjb25zdCByZXNwb25zZVN0cmVhbSA9IGRhdGEgPyBtZXJnZVN0cmVhbXMoZGF0YS5zdHJlYW0sIGRhdGFTdHJlYW0pIDogZGF0YVN0cmVhbTtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZShyZXNwb25zZVN0cmVhbSwge1xuICAgIHN0YXR1czogKF9hMTcgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTcgOiAyMDAsXG4gICAgc3RhdHVzVGV4dDogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzLCB7XG4gICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICBkYXRhU3RyZWFtVmVyc2lvbjogXCJ2MVwiXG4gICAgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiBtZXJnZUludG9EYXRhU3RyZWFtMihzdHJlYW0sIG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5kYXRhU3RyZWFtLm1lcmdlKHRvRGF0YVN0cmVhbUludGVybmFsMihzdHJlYW0sIG9wdGlvbnMuY2FsbGJhY2tzKSk7XG59XG5mdW5jdGlvbiB0cmltU3RhcnRPZlN0cmVhbSgpIHtcbiAgbGV0IGlzU3RyZWFtU3RhcnQgPSB0cnVlO1xuICByZXR1cm4gKHRleHQyKSA9PiB7XG4gICAgaWYgKGlzU3RyZWFtU3RhcnQpIHtcbiAgICAgIHRleHQyID0gdGV4dDIudHJpbVN0YXJ0KCk7XG4gICAgICBpZiAodGV4dDIpXG4gICAgICAgIGlzU3RyZWFtU3RhcnQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQyO1xuICB9O1xufVxuXG4vLyBzdHJlYW1zL3N0cmVhbS1kYXRhLnRzXG5pbXBvcnQgeyBmb3JtYXREYXRhU3RyZWFtUGFydCBhcyBmb3JtYXREYXRhU3RyZWFtUGFydDYgfSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuXG4vLyB1dGlsL2NvbnN0YW50cy50c1xudmFyIEhBTkdJTkdfU1RSRUFNX1dBUk5JTkdfVElNRV9NUyA9IDE1ICogMWUzO1xuXG4vLyBzdHJlYW1zL3N0cmVhbS1kYXRhLnRzXG52YXIgU3RyZWFtRGF0YSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5lbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgdGhpcy5jb250cm9sbGVyID0gbnVsbDtcbiAgICB0aGlzLmlzQ2xvc2VkID0gZmFsc2U7XG4gICAgdGhpcy53YXJuaW5nVGltZW91dCA9IG51bGw7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5zdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgc3RhcnQ6IGFzeW5jIChjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIHNlbGYuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgICAgc2VsZi53YXJuaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBcIlRoZSBkYXRhIHN0cmVhbSBpcyBoYW5naW5nLiBEaWQgeW91IGZvcmdldCB0byBjbG9zZSBpdCB3aXRoIGBkYXRhLmNsb3NlKClgP1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0sIEhBTkdJTkdfU1RSRUFNX1dBUk5JTkdfVElNRV9NUyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwdWxsOiAoY29udHJvbGxlcikgPT4ge1xuICAgICAgfSxcbiAgICAgIGNhbmNlbDogKHJlYXNvbikgPT4ge1xuICAgICAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBTdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIGNvbnRyb2xsZXIgaXMgbm90IGluaXRpYWxpemVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5jb250cm9sbGVyLmNsb3NlKCk7XG4gICAgdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMud2FybmluZ1RpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLndhcm5pbmdUaW1lb3V0KTtcbiAgICB9XG4gIH1cbiAgYXBwZW5kKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNvbnRyb2xsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmVhbSBjb250cm9sbGVyIGlzIG5vdCBpbml0aWFsaXplZC5cIik7XG4gICAgfVxuICAgIHRoaXMuY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgdGhpcy5lbmNvZGVyLmVuY29kZShmb3JtYXREYXRhU3RyZWFtUGFydDYoXCJkYXRhXCIsIFt2YWx1ZV0pKVxuICAgICk7XG4gIH1cbiAgYXBwZW5kTWVzc2FnZUFubm90YXRpb24odmFsdWUpIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBTdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIGNvbnRyb2xsZXIgaXMgbm90IGluaXRpYWxpemVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5jb250cm9sbGVyLmVucXVldWUoXG4gICAgICB0aGlzLmVuY29kZXIuZW5jb2RlKGZvcm1hdERhdGFTdHJlYW1QYXJ0NihcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiwgW3ZhbHVlXSkpXG4gICAgKTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIEFJU0RLRXJyb3IxNiBhcyBBSVNES0Vycm9yLFxuICBBUElDYWxsRXJyb3IyIGFzIEFQSUNhbGxFcnJvcixcbiAgQXNzaXN0YW50UmVzcG9uc2UsXG4gIERvd25sb2FkRXJyb3IsXG4gIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IsXG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcixcbiAgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IsXG4gIEludmFsaWRQcm9tcHRFcnJvcjIgYXMgSW52YWxpZFByb21wdEVycm9yLFxuICBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IsXG4gIEludmFsaWRTdHJlYW1QYXJ0RXJyb3IsXG4gIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IsXG4gIEpTT05QYXJzZUVycm9yMiBhcyBKU09OUGFyc2VFcnJvcixcbiAgbGFuZ2NoYWluX2FkYXB0ZXJfZXhwb3J0cyBhcyBMYW5nQ2hhaW5BZGFwdGVyLFxuICBsbGFtYWluZGV4X2FkYXB0ZXJfZXhwb3J0cyBhcyBMbGFtYUluZGV4QWRhcHRlcixcbiAgTG9hZEFQSUtleUVycm9yLFxuICBNQ1BDbGllbnRFcnJvcixcbiAgTWVzc2FnZUNvbnZlcnNpb25FcnJvcixcbiAgTm9Db250ZW50R2VuZXJhdGVkRXJyb3IsXG4gIE5vSW1hZ2VHZW5lcmF0ZWRFcnJvcixcbiAgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcixcbiAgTm9PdXRwdXRTcGVjaWZpZWRFcnJvcixcbiAgTm9TdWNoTW9kZWxFcnJvcixcbiAgTm9TdWNoUHJvdmlkZXJFcnJvcixcbiAgTm9TdWNoVG9vbEVycm9yLFxuICBvdXRwdXRfZXhwb3J0cyBhcyBPdXRwdXQsXG4gIFJldHJ5RXJyb3IsXG4gIFN0cmVhbURhdGEsXG4gIFRvb2xDYWxsUmVwYWlyRXJyb3IsXG4gIFRvb2xFeGVjdXRpb25FcnJvcixcbiAgVHlwZVZhbGlkYXRpb25FcnJvcjMgYXMgVHlwZVZhbGlkYXRpb25FcnJvcixcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IyIGFzIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yLFxuICBhcHBlbmRDbGllbnRNZXNzYWdlLFxuICBhcHBlbmRSZXNwb25zZU1lc3NhZ2VzLFxuICBjb252ZXJ0VG9Db3JlTWVzc2FnZXMsXG4gIGNvcmVBc3Npc3RhbnRNZXNzYWdlU2NoZW1hLFxuICBjb3JlTWVzc2FnZVNjaGVtYSxcbiAgY29yZVN5c3RlbU1lc3NhZ2VTY2hlbWEsXG4gIGNvcmVUb29sTWVzc2FnZVNjaGVtYSxcbiAgY29yZVVzZXJNZXNzYWdlU2NoZW1hLFxuICBjb3NpbmVTaW1pbGFyaXR5LFxuICBjcmVhdGVEYXRhU3RyZWFtLFxuICBjcmVhdGVEYXRhU3RyZWFtUmVzcG9uc2UsXG4gIGNyZWF0ZUlkR2VuZXJhdG9yNSBhcyBjcmVhdGVJZEdlbmVyYXRvcixcbiAgY3JlYXRlUHJvdmlkZXJSZWdpc3RyeSxcbiAgY3VzdG9tUHJvdmlkZXIsXG4gIGRlZmF1bHRTZXR0aW5nc01pZGRsZXdhcmUsXG4gIGVtYmVkLFxuICBlbWJlZE1hbnksXG4gIGNyZWF0ZU1DUENsaWVudCBhcyBleHBlcmltZW50YWxfY3JlYXRlTUNQQ2xpZW50LFxuICBleHBlcmltZW50YWxfY3JlYXRlUHJvdmlkZXJSZWdpc3RyeSxcbiAgZXhwZXJpbWVudGFsX2N1c3RvbVByb3ZpZGVyLFxuICBnZW5lcmF0ZUltYWdlIGFzIGV4cGVyaW1lbnRhbF9nZW5lcmF0ZUltYWdlLFxuICBnZW5lcmF0ZVNwZWVjaCBhcyBleHBlcmltZW50YWxfZ2VuZXJhdGVTcGVlY2gsXG4gIHRyYW5zY3JpYmUgYXMgZXhwZXJpbWVudGFsX3RyYW5zY3JpYmUsXG4gIGV4cGVyaW1lbnRhbF93cmFwTGFuZ3VhZ2VNb2RlbCxcbiAgZXh0cmFjdFJlYXNvbmluZ01pZGRsZXdhcmUsXG4gIGZvcm1hdEFzc2lzdGFudFN0cmVhbVBhcnQsXG4gIGZvcm1hdERhdGFTdHJlYW1QYXJ0MyBhcyBmb3JtYXREYXRhU3RyZWFtUGFydCxcbiAgZ2VuZXJhdGVJZDIgYXMgZ2VuZXJhdGVJZCxcbiAgZ2VuZXJhdGVPYmplY3QsXG4gIGdlbmVyYXRlVGV4dCxcbiAganNvblNjaGVtYTIgYXMganNvblNjaGVtYSxcbiAgcGFyc2VBc3Npc3RhbnRTdHJlYW1QYXJ0LFxuICBwYXJzZURhdGFTdHJlYW1QYXJ0LFxuICBwaXBlRGF0YVN0cmVhbVRvUmVzcG9uc2UsXG4gIHByb2Nlc3NEYXRhU3RyZWFtLFxuICBwcm9jZXNzVGV4dFN0cmVhbSxcbiAgc2ltdWxhdGVSZWFkYWJsZVN0cmVhbSxcbiAgc2ltdWxhdGVTdHJlYW1pbmdNaWRkbGV3YXJlLFxuICBzbW9vdGhTdHJlYW0sXG4gIHN0cmVhbU9iamVjdCxcbiAgc3RyZWFtVGV4dCxcbiAgdG9vbCxcbiAgd3JhcExhbmd1YWdlTW9kZWwsXG4gIHpvZFNjaGVtYVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiX19kZWZQcm9wIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUxNyIsImdldCIsImVudW1lcmFibGUiLCJjcmVhdGVJZEdlbmVyYXRvciIsImNyZWF0ZUlkR2VuZXJhdG9yNSIsImdlbmVyYXRlSWQiLCJnZW5lcmF0ZUlkMiIsImZvcm1hdEFzc2lzdGFudFN0cmVhbVBhcnQiLCJmb3JtYXREYXRhU3RyZWFtUGFydCIsImZvcm1hdERhdGFTdHJlYW1QYXJ0MyIsImpzb25TY2hlbWEiLCJqc29uU2NoZW1hMiIsInBhcnNlQXNzaXN0YW50U3RyZWFtUGFydCIsInBhcnNlRGF0YVN0cmVhbVBhcnQiLCJwcm9jZXNzRGF0YVN0cmVhbSIsInByb2Nlc3NUZXh0U3RyZWFtIiwiem9kU2NoZW1hIiwiY3JlYXRlRGF0YVN0cmVhbSIsImV4ZWN1dGUiLCJvbkVycm9yIiwiY29udHJvbGxlciIsIm9uZ29pbmdTdHJlYW1Qcm9taXNlcyIsInN0cmVhbSIsIlJlYWRhYmxlU3RyZWFtIiwic3RhcnQiLCJjb250cm9sbGVyQXJnIiwic2FmZUVucXVldWUiLCJkYXRhIiwiZW5xdWV1ZSIsImVycm9yIiwicmVzdWx0Iiwid3JpdGUiLCJ3cml0ZURhdGEiLCJ3cml0ZU1lc3NhZ2VBbm5vdGF0aW9uIiwiYW5ub3RhdGlvbiIsIndyaXRlU291cmNlIiwic291cmNlIiwibWVyZ2UiLCJzdHJlYW1BcmciLCJwdXNoIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwiZG9uZSIsInZhbHVlIiwicmVhZCIsImNhdGNoIiwid2FpdEZvclN0cmVhbXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsImxlbmd0aCIsInNoaWZ0IiwiZmluYWxseSIsImNsb3NlIiwicHJlcGFyZVJlc3BvbnNlSGVhZGVycyIsImhlYWRlcnMiLCJjb250ZW50VHlwZSIsImRhdGFTdHJlYW1WZXJzaW9uIiwicmVzcG9uc2VIZWFkZXJzIiwiSGVhZGVycyIsImhhcyIsInNldCIsImNyZWF0ZURhdGFTdHJlYW1SZXNwb25zZSIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJSZXNwb25zZSIsInBpcGVUaHJvdWdoIiwiVGV4dEVuY29kZXJTdHJlYW0iLCJwcmVwYXJlT3V0Z29pbmdIdHRwSGVhZGVycyIsIm91dGdvaW5nSGVhZGVycyIsImtleSIsImVudHJpZXMiLCJ3cml0ZVRvU2VydmVyUmVzcG9uc2UiLCJyZXNwb25zZSIsIndyaXRlSGVhZCIsImVuZCIsInBpcGVEYXRhU3RyZWFtVG9SZXNwb25zZSIsIkFJU0RLRXJyb3IiLCJuYW1lIiwibWFya2VyIiwic3ltYm9sIiwiU3ltYm9sIiwiZm9yIiwiX2EiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsImNvbnN0cnVjdG9yIiwicGFyYW1ldGVyIiwibWVzc2FnZSIsImlzSW5zdGFuY2UiLCJoYXNNYXJrZXIiLCJBUElDYWxsRXJyb3IiLCJkZWxheSIsImdldEVycm9yTWVzc2FnZSIsImlzQWJvcnRFcnJvciIsIkFJU0RLRXJyb3IyIiwibmFtZTIiLCJtYXJrZXIyIiwic3ltYm9sMiIsIl9hMiIsIlJldHJ5RXJyb3IiLCJyZWFzb24iLCJlcnJvcnMiLCJsYXN0RXJyb3IiLCJyZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYiLCJtYXhSZXRyaWVzIiwiaW5pdGlhbERlbGF5SW5NcyIsImJhY2tvZmZGYWN0b3IiLCJmIiwiX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZiIsImRlbGF5SW5NcyIsImVycm9yTWVzc2FnZSIsIm5ld0Vycm9ycyIsInRyeU51bWJlciIsIkVycm9yIiwiaXNSZXRyeWFibGUiLCJwcmVwYXJlUmV0cmllcyIsIk51bWJlciIsImlzSW50ZWdlciIsIm1heFJldHJpZXNSZXN1bHQiLCJyZXRyeSIsImFzc2VtYmxlT3BlcmF0aW9uTmFtZSIsIm9wZXJhdGlvbklkIiwidGVsZW1ldHJ5IiwiZnVuY3Rpb25JZCIsImdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzIiwibW9kZWwiLCJzZXR0aW5ncyIsIl9hMTciLCJwcm92aWRlciIsIm1vZGVsSWQiLCJyZWR1Y2UiLCJhdHRyaWJ1dGVzIiwibWV0YWRhdGEiLCJ0cmFjZSIsIm5vb3BUcmFjZXIiLCJzdGFydFNwYW4iLCJub29wU3BhbiIsInN0YXJ0QWN0aXZlU3BhbiIsImFyZzEiLCJhcmcyIiwiYXJnMyIsInNwYW5Db250ZXh0Iiwibm9vcFNwYW5Db250ZXh0Iiwic2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlcyIsImFkZEV2ZW50IiwiYWRkTGluayIsImFkZExpbmtzIiwic2V0U3RhdHVzIiwidXBkYXRlTmFtZSIsImlzUmVjb3JkaW5nIiwicmVjb3JkRXhjZXB0aW9uIiwidHJhY2VJZCIsInNwYW5JZCIsInRyYWNlRmxhZ3MiLCJnZXRUcmFjZXIiLCJpc0VuYWJsZWQiLCJ0cmFjZXIiLCJTcGFuU3RhdHVzQ29kZSIsInJlY29yZFNwYW4iLCJmbiIsImVuZFdoZW5Eb25lIiwic3BhbiIsInN0YWNrIiwiY29kZSIsIkVSUk9SIiwic2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyIsImF0dHJpYnV0ZXMyIiwiaW5wdXQiLCJyZWNvcmRJbnB1dHMiLCJvdXRwdXQiLCJyZWNvcmRPdXRwdXRzIiwiZW1iZWQiLCJtYXhSZXRyaWVzQXJnIiwiYWJvcnRTaWduYWwiLCJleHBlcmltZW50YWxfdGVsZW1ldHJ5IiwiYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMiLCJKU09OIiwic3RyaW5naWZ5IiwiZW1iZWRkaW5nIiwidXNhZ2UiLCJyYXdSZXNwb25zZSIsImRvRW1iZWRTcGFuIiwibW9kZWxSZXNwb25zZSIsImRvRW1iZWQiLCJ2YWx1ZXMiLCJlbWJlZGRpbmcyIiwiZW1iZWRkaW5ncyIsInVzYWdlMiIsInRva2VucyIsIk5hTiIsIm1hcCIsImVtYmVkZGluZzMiLCJEZWZhdWx0RW1iZWRSZXN1bHQiLCJvcHRpb25zIiwic3BsaXRBcnJheSIsImFycmF5IiwiY2h1bmtTaXplIiwiaSIsInNsaWNlIiwiZW1iZWRNYW55IiwibWF4RW1iZWRkaW5nc1BlckNhbGwiLCJlbWJlZGRpbmdzMiIsImVtYmVkZGluZ3MzIiwiRGVmYXVsdEVtYmVkTWFueVJlc3VsdCIsInZhbHVlQ2h1bmtzIiwiY2h1bmsiLCJyZXNwb25zZUVtYmVkZGluZ3MiLCJBSVNES0Vycm9yMyIsIm5hbWUzIiwibWFya2VyMyIsInN5bWJvbDMiLCJfYTMiLCJOb0ltYWdlR2VuZXJhdGVkRXJyb3IiLCJjYXVzZSIsInJlc3BvbnNlcyIsImNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkiLCJjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0IiwiRGVmYXVsdEdlbmVyYXRlZEZpbGUiLCJtaW1lVHlwZSIsImlzVWludDhBcnJheSIsIlVpbnQ4QXJyYXkiLCJiYXNlNjREYXRhIiwidWludDhBcnJheURhdGEiLCJiYXNlNjQiLCJ1aW50OEFycmF5IiwiRGVmYXVsdEdlbmVyYXRlZEZpbGVXaXRoVHlwZSIsInR5cGUiLCJjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5MiIsImltYWdlTWltZVR5cGVTaWduYXR1cmVzIiwiYnl0ZXNQcmVmaXgiLCJiYXNlNjRQcmVmaXgiLCJhdWRpb01pbWVUeXBlU2lnbmF0dXJlcyIsInN0cmlwSUQzIiwiYnl0ZXMiLCJpZDNTaXplIiwic3RyaXBJRDNUYWdzSWZQcmVzZW50IiwiaGFzSWQzIiwic3RhcnRzV2l0aCIsImRldGVjdE1pbWVUeXBlIiwic2lnbmF0dXJlcyIsInByb2Nlc3NlZERhdGEiLCJzaWduYXR1cmUiLCJldmVyeSIsImJ5dGUiLCJpbmRleCIsImdlbmVyYXRlSW1hZ2UiLCJwcm9tcHQiLCJuIiwic2l6ZSIsImFzcGVjdFJhdGlvIiwic2VlZCIsInByb3ZpZGVyT3B0aW9ucyIsIm1heEltYWdlc1BlckNhbGwiLCJjYWxsQ291bnQiLCJNYXRoIiwiY2VpbCIsImNhbGxJbWFnZUNvdW50cyIsIkFycmF5IiwiZnJvbSIsIl8iLCJyZW1haW5kZXIiLCJyZXN1bHRzIiwiY2FsbEltYWdlQ291bnQiLCJkb0dlbmVyYXRlIiwiaW1hZ2VzIiwid2FybmluZ3MiLCJpbWFnZSIsIl9hMTgiLCJEZWZhdWx0R2VuZXJhdGVJbWFnZVJlc3VsdCIsIkpTT05QYXJzZUVycm9yIiwiVHlwZVZhbGlkYXRpb25FcnJvciIsIlR5cGVWYWxpZGF0aW9uRXJyb3IyIiwic2FmZVBhcnNlSlNPTiIsIkFJU0RLRXJyb3I0IiwibmFtZTQiLCJtYXJrZXI0Iiwic3ltYm9sNCIsIl9hNCIsIk5vT2JqZWN0R2VuZXJhdGVkRXJyb3IiLCJ0ZXh0IiwidGV4dDIiLCJmaW5pc2hSZWFzb24iLCJBSVNES0Vycm9yNSIsIm5hbWU1IiwibWFya2VyNSIsInN5bWJvbDUiLCJfYTUiLCJEb3dubG9hZEVycm9yIiwidXJsIiwic3RhdHVzQ29kZSIsImRvd25sb2FkIiwidXJsVGV4dCIsInRvU3RyaW5nIiwiZmV0Y2giLCJvayIsImFycmF5QnVmZmVyIiwiY29udmVydEJhc2U2NFRvVWludDhBcnJheTMiLCJjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0MiIsIkFJU0RLRXJyb3I2IiwibmFtZTYiLCJtYXJrZXI2Iiwic3ltYm9sNiIsIl9hNiIsIkludmFsaWREYXRhQ29udGVudEVycm9yIiwiY29udGVudCIsInoiLCJkYXRhQ29udGVudFNjaGVtYSIsInVuaW9uIiwic3RyaW5nIiwiaW5zdGFuY2VvZiIsIkFycmF5QnVmZmVyIiwiY3VzdG9tIiwiX2IiLCJnbG9iYWxUaGlzIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJjb252ZXJ0RGF0YUNvbnRlbnRUb0Jhc2U2NFN0cmluZyIsImNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheSIsImNvbnZlcnRVaW50OEFycmF5VG9UZXh0IiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJBSVNES0Vycm9yNyIsIm5hbWU3IiwibWFya2VyNyIsInN5bWJvbDciLCJfYTciLCJJbnZhbGlkTWVzc2FnZVJvbGVFcnJvciIsInJvbGUiLCJzcGxpdERhdGFVcmwiLCJkYXRhVXJsIiwiaGVhZGVyIiwiYmFzZTY0Q29udGVudCIsInNwbGl0IiwiY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCIsIm1vZGVsU3VwcG9ydHNJbWFnZVVybHMiLCJtb2RlbFN1cHBvcnRzVXJsIiwiZG93bmxvYWRJbXBsZW1lbnRhdGlvbiIsImRvd25sb2FkZWRBc3NldHMiLCJkb3dubG9hZEFzc2V0cyIsIm1lc3NhZ2VzIiwic3lzdGVtIiwiY29udmVydFRvTGFuZ3VhZ2VNb2RlbE1lc3NhZ2UiLCJfYyIsIl9kIiwiX2UiLCJfZiIsInByb3ZpZGVyTWV0YWRhdGEiLCJleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSIsInBhcnQiLCJjb252ZXJ0UGFydFRvTGFuZ3VhZ2VNb2RlbFBhcnQiLCJmaWx0ZXIiLCJVUkwiLCJmaWxlbmFtZSIsInRvb2xDYWxsSWQiLCJ0b29sTmFtZSIsImFyZ3MiLCJleHBlcmltZW50YWxfY29udGVudCIsImlzRXJyb3IiLCJfZXhoYXVzdGl2ZUNoZWNrIiwidXJscyIsImlzQXJyYXkiLCJmbGF0IiwiZG93bmxvYWRlZEltYWdlcyIsImZyb21FbnRyaWVzIiwibm9ybWFsaXplZERhdGEiLCJwcm90b2NvbCIsImRhdGFVcmxNaW1lVHlwZSIsImRvd25sb2FkZWRGaWxlIiwicHJlcGFyZUNhbGxTZXR0aW5ncyIsIm1heFRva2VucyIsInRlbXBlcmF0dXJlIiwidG9wUCIsInRvcEsiLCJwcmVzZW5jZVBlbmFsdHkiLCJmcmVxdWVuY3lQZW5hbHR5Iiwic3RvcFNlcXVlbmNlcyIsIkludmFsaWRQcm9tcHRFcnJvciIsInNhZmVWYWxpZGF0ZVR5cGVzIiwiejciLCJhdHRhY2htZW50c1RvUGFydHMiLCJhdHRhY2htZW50cyIsInBhcnRzIiwiYXR0YWNobWVudCIsIkFJU0RLRXJyb3I4IiwibmFtZTgiLCJtYXJrZXI4Iiwic3ltYm9sOCIsIl9hOCIsIk1lc3NhZ2VDb252ZXJzaW9uRXJyb3IiLCJvcmlnaW5hbE1lc3NhZ2UiLCJjb252ZXJ0VG9Db3JlTWVzc2FnZXMiLCJ0b29scyIsImNvcmVNZXNzYWdlcyIsImlzTGFzdE1lc3NhZ2UiLCJleHBlcmltZW50YWxfYXR0YWNobWVudHMiLCJ0ZXh0UGFydHMiLCJwcm9jZXNzQmxvY2syIiwiY29udGVudDIiLCJibG9jayIsImRldGFpbCIsImRldGFpbHMiLCJ0b29sSW52b2NhdGlvbiIsInN0ZXBJbnZvY2F0aW9ucyIsInRvb2wyIiwiZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQiLCJibG9ja0hhc1Rvb2xJbnZvY2F0aW9ucyIsImN1cnJlbnRTdGVwIiwicHJvY2Vzc0Jsb2NrIiwic3RlcCIsInRvb2xJbnZvY2F0aW9ucyIsIm1heFN0ZXAiLCJtYXgiLCJpMiIsImRldGVjdFByb21wdFR5cGUiLCJjaGFyYWN0ZXJpc3RpY3MiLCJkZXRlY3RTaW5nbGVNZXNzYWdlQ2hhcmFjdGVyaXN0aWNzIiwic29tZSIsImMiLCJpbmNsdWRlcyIsIno2IiwiejMiLCJ6MiIsImpzb25WYWx1ZVNjaGVtYSIsImxhenkiLCJudWxsIiwibnVtYmVyIiwiYm9vbGVhbiIsInJlY29yZCIsInByb3ZpZGVyTWV0YWRhdGFTY2hlbWEiLCJ6NSIsIno0IiwidG9vbFJlc3VsdENvbnRlbnRTY2hlbWEiLCJvYmplY3QiLCJsaXRlcmFsIiwib3B0aW9uYWwiLCJ0ZXh0UGFydFNjaGVtYSIsImltYWdlUGFydFNjaGVtYSIsImZpbGVQYXJ0U2NoZW1hIiwicmVhc29uaW5nUGFydFNjaGVtYSIsInJlZGFjdGVkUmVhc29uaW5nUGFydFNjaGVtYSIsInRvb2xDYWxsUGFydFNjaGVtYSIsInVua25vd24iLCJ0b29sUmVzdWx0UGFydFNjaGVtYSIsImNvcmVTeXN0ZW1NZXNzYWdlU2NoZW1hIiwiY29yZVVzZXJNZXNzYWdlU2NoZW1hIiwiY29yZUFzc2lzdGFudE1lc3NhZ2VTY2hlbWEiLCJjb3JlVG9vbE1lc3NhZ2VTY2hlbWEiLCJjb3JlTWVzc2FnZVNjaGVtYSIsInN0YW5kYXJkaXplUHJvbXB0IiwicHJvbXB0VHlwZSIsInZhbGlkYXRpb25SZXN1bHQiLCJzY2hlbWEiLCJzdWNjZXNzIiwiY2FsY3VsYXRlTGFuZ3VhZ2VNb2RlbFVzYWdlIiwicHJvbXB0VG9rZW5zIiwiY29tcGxldGlvblRva2VucyIsInRvdGFsVG9rZW5zIiwiYWRkTGFuZ3VhZ2VNb2RlbFVzYWdlIiwidXNhZ2UxIiwiREVGQVVMVF9TQ0hFTUFfUFJFRklYIiwiREVGQVVMVF9TQ0hFTUFfU1VGRklYIiwiREVGQVVMVF9HRU5FUklDX1NVRkZJWCIsImluamVjdEpzb25JbnN0cnVjdGlvbiIsInNjaGVtYVByZWZpeCIsInNjaGVtYVN1ZmZpeCIsImxpbmUiLCJqb2luIiwiaXNKU09OQXJyYXkiLCJpc0pTT05PYmplY3QiLCJVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvciIsInNhZmVWYWxpZGF0ZVR5cGVzMiIsImFzU2NoZW1hIiwiY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbSIsIlRyYW5zZm9ybVN0cmVhbSIsImFzeW5jSXRlcmF0b3IiLCJuZXh0Iiwibm9TY2hlbWFPdXRwdXRTdHJhdGVneSIsInZhbGlkYXRlUGFydGlhbFJlc3VsdCIsInRleHREZWx0YSIsInBhcnRpYWwiLCJ2YWxpZGF0ZUZpbmFsUmVzdWx0IiwiY29udGV4dCIsImNyZWF0ZUVsZW1lbnRTdHJlYW0iLCJmdW5jdGlvbmFsaXR5Iiwib2JqZWN0T3V0cHV0U3RyYXRlZ3kiLCJhcnJheU91dHB1dFN0cmF0ZWd5IiwiJHNjaGVtYSIsIml0ZW1TY2hlbWEiLCJwcm9wZXJ0aWVzIiwiZWxlbWVudHMiLCJpdGVtcyIsInJlcXVpcmVkIiwiYWRkaXRpb25hbFByb3BlcnRpZXMiLCJsYXRlc3RPYmplY3QiLCJpc0ZpcnN0RGVsdGEiLCJpc0ZpbmFsRGVsdGEiLCJpbnB1dEFycmF5IiwicmVzdWx0QXJyYXkiLCJlbGVtZW50IiwicHVibGlzaGVkRWxlbWVudENvdW50Iiwib3JpZ2luYWxTdHJlYW0iLCJwdWJsaXNoZWRFbGVtZW50cyIsInRyYW5zZm9ybSIsImVudW1PdXRwdXRTdHJhdGVneSIsImVudW1WYWx1ZXMiLCJlbnVtIiwiZ2V0T3V0cHV0U3RyYXRlZ3kiLCJ2YWxpZGF0ZU9iamVjdEdlbmVyYXRpb25JbnB1dCIsIm1vZGUiLCJzY2hlbWFOYW1lIiwic2NoZW1hRGVzY3JpcHRpb24iLCJvcmlnaW5hbEdlbmVyYXRlSWQiLCJwcmVmaXgiLCJnZW5lcmF0ZU9iamVjdCIsImlucHV0U2NoZW1hIiwiZXhwZXJpbWVudGFsX3JlcGFpclRleHQiLCJyZXBhaXJUZXh0IiwiX2ludGVybmFsIiwiZ2VuZXJhdGVJZDMiLCJjdXJyZW50RGF0ZSIsIkRhdGUiLCJvdXRwdXRTdHJhdGVneSIsImRlZmF1bHRPYmplY3RHZW5lcmF0aW9uTW9kZSIsInJlcXVlc3QiLCJsb2dwcm9icyIsInJlc3VsdFByb3ZpZGVyTWV0YWRhdGEiLCJzdGFuZGFyZGl6ZWRQcm9tcHQiLCJzdXBwb3J0c1N0cnVjdHVyZWRPdXRwdXRzIiwicHJvbXB0TWVzc2FnZXMiLCJzdXBwb3J0c0ltYWdlVXJscyIsInN1cHBvcnRzVXJsIiwiYmluZCIsImdlbmVyYXRlUmVzdWx0Iiwic3BhbjIiLCJfYjIiLCJfYzIiLCJfZDIiLCJyZXN1bHQyIiwiZGVzY3JpcHRpb24iLCJpbnB1dEZvcm1hdCIsInJlc3BvbnNlRGF0YSIsImlkIiwidGltZXN0YW1wIiwidG9JU09TdHJpbmciLCJvYmplY3RUZXh0IiwiX2ciLCJfaCIsInRvb2wiLCJwYXJhbWV0ZXJzIiwidG9vbENhbGxzIiwicHJvY2Vzc1Jlc3VsdCIsInBhcnNlUmVzdWx0Iiwib2JqZWN0MiIsInJlcGFpcmVkVGV4dCIsIkRlZmF1bHRHZW5lcmF0ZU9iamVjdFJlc3VsdCIsImJvZHkiLCJ0b0pzb25SZXNwb25zZSIsImluaXQiLCJjcmVhdGVJZEdlbmVyYXRvcjIiLCJpc0RlZXBFcXVhbERhdGEiLCJwYXJzZVBhcnRpYWxKc29uIiwiRGVsYXllZFByb21pc2UiLCJfcmVzb2x2ZSIsIl9yZWplY3QiLCJwcm9taXNlIiwicmVqZWN0IiwiY2FsbCIsImNyZWF0ZVJlc29sdmFibGVQcm9taXNlIiwicmVzIiwicmVqIiwiY3JlYXRlU3RpdGNoYWJsZVN0cmVhbSIsImlubmVyU3RyZWFtUmVhZGVycyIsImlzQ2xvc2VkIiwid2FpdEZvck5ld1N0cmVhbSIsInByb2Nlc3NQdWxsIiwiY29udHJvbGxlclBhcmFtIiwicHVsbCIsImNhbmNlbCIsImFkZFN0cmVhbSIsImlubmVyU3RyZWFtIiwidGVybWluYXRlIiwiZm9yRWFjaCIsIm5vdyIsInBlcmZvcm1hbmNlIiwib3JpZ2luYWxHZW5lcmF0ZUlkMiIsInN0cmVhbU9iamVjdCIsIm9uRmluaXNoIiwibm93MiIsIkRlZmF1bHRTdHJlYW1PYmplY3RSZXN1bHQiLCJvYmplY3RQcm9taXNlIiwidXNhZ2VQcm9taXNlIiwicHJvdmlkZXJNZXRhZGF0YVByb21pc2UiLCJ3YXJuaW5nc1Byb21pc2UiLCJyZXF1ZXN0UHJvbWlzZSIsInJlc3BvbnNlUHJvbWlzZSIsInNlbGYiLCJzdGl0Y2hhYmxlU3RyZWFtIiwiZXZlbnRQcm9jZXNzb3IiLCJiYXNlU3RyZWFtIiwicm9vdFNwYW4iLCJjYWxsT3B0aW9ucyIsInRyYW5zZm9ybWVyIiwiYXJnc1RleHREZWx0YSIsImRvU3RyZWFtU3BhbiIsInN0YXJ0VGltZXN0YW1wTXMiLCJkb1N0cmVhbVNwYW4yIiwiZG9TdHJlYW0iLCJhY2N1bXVsYXRlZFRleHQiLCJsYXRlc3RPYmplY3RKc29uIiwiaXNGaXJzdENodW5rIiwidHJhbnNmb3JtZWRTdHJlYW0iLCJtc1RvRmlyc3RDaHVuayIsImN1cnJlbnRPYmplY3RKc29uIiwic3RhdGUiLCJwYXJzZVN0YXRlIiwiZmx1c2giLCJmaW5hbFVzYWdlIiwiZXJyb3IyIiwicGFydGlhbE9iamVjdFN0cmVhbSIsImVsZW1lbnRTdHJlYW0iLCJ0ZXh0U3RyZWFtIiwiZnVsbFN0cmVhbSIsInBpcGVUZXh0U3RyZWFtVG9SZXNwb25zZSIsInRvVGV4dFN0cmVhbVJlc3BvbnNlIiwiY3JlYXRlSWRHZW5lcmF0b3IzIiwiQUlTREtFcnJvcjkiLCJuYW1lOSIsIm1hcmtlcjkiLCJzeW1ib2w5IiwiX2E5IiwiTm9PdXRwdXRTcGVjaWZpZWRFcnJvciIsIkFJU0RLRXJyb3IxMCIsImdldEVycm9yTWVzc2FnZTIiLCJuYW1lMTAiLCJtYXJrZXIxMCIsInN5bWJvbDEwIiwiX2ExMCIsIlRvb2xFeGVjdXRpb25FcnJvciIsInRvb2xBcmdzIiwiYXNTY2hlbWEyIiwiaXNOb25FbXB0eU9iamVjdCIsImtleXMiLCJwcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlIiwidG9vbENob2ljZSIsImFjdGl2ZVRvb2xzIiwiZmlsdGVyZWRUb29scyIsInRvb2xUeXBlIiwiZXhoYXVzdGl2ZUNoZWNrIiwibGFzdFdoaXRlc3BhY2VSZWdleHAiLCJzcGxpdE9uTGFzdFdoaXRlc3BhY2UiLCJtYXRjaCIsIndoaXRlc3BhY2UiLCJzdWZmaXgiLCJyZW1vdmVUZXh0QWZ0ZXJMYXN0V2hpdGVzcGFjZSIsInNhZmVQYXJzZUpTT04yIiwic2FmZVZhbGlkYXRlVHlwZXMzIiwiYXNTY2hlbWEzIiwiQUlTREtFcnJvcjExIiwiZ2V0RXJyb3JNZXNzYWdlMyIsIm5hbWUxMSIsIm1hcmtlcjExIiwic3ltYm9sMTEiLCJfYTExIiwiSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvciIsIkFJU0RLRXJyb3IxMiIsIm5hbWUxMiIsIm1hcmtlcjEyIiwic3ltYm9sMTIiLCJfYTEyIiwiTm9TdWNoVG9vbEVycm9yIiwiYXZhaWxhYmxlVG9vbHMiLCJBSVNES0Vycm9yMTMiLCJnZXRFcnJvck1lc3NhZ2U0IiwibmFtZTEzIiwibWFya2VyMTMiLCJzeW1ib2wxMyIsIl9hMTMiLCJUb29sQ2FsbFJlcGFpckVycm9yIiwib3JpZ2luYWxFcnJvciIsInBhcnNlVG9vbENhbGwiLCJ0b29sQ2FsbCIsInJlcGFpclRvb2xDYWxsIiwiZG9QYXJzZVRvb2xDYWxsIiwicmVwYWlyZWRUb29sQ2FsbCIsInBhcmFtZXRlclNjaGVtYSIsInJlcGFpckVycm9yIiwidHJpbSIsImFzUmVhc29uaW5nVGV4dCIsInJlYXNvbmluZyIsInJlYXNvbmluZ1RleHQiLCJ0b1Jlc3BvbnNlTWVzc2FnZXMiLCJmaWxlcyIsInRvb2xSZXN1bHRzIiwibWVzc2FnZUlkIiwiZ2VuZXJhdGVNZXNzYWdlSWQiLCJyZXNwb25zZU1lc3NhZ2VzIiwiZmlsZSIsInRvb2xSZXN1bHQiLCJvcmlnaW5hbEdlbmVyYXRlSWQzIiwib3JpZ2luYWxHZW5lcmF0ZU1lc3NhZ2VJZCIsImdlbmVyYXRlVGV4dCIsIm1heFN0ZXBzIiwiZXhwZXJpbWVudGFsX2dlbmVyYXRlTWVzc2FnZUlkIiwiZXhwZXJpbWVudGFsX291dHB1dCIsImV4cGVyaW1lbnRhbF9jb250aW51ZVN0ZXBzIiwiY29udGludWVTdGVwcyIsImV4cGVyaW1lbnRhbF9hY3RpdmVUb29scyIsImV4cGVyaW1lbnRhbF9yZXBhaXJUb29sQ2FsbCIsIm9uU3RlcEZpbmlzaCIsImluaXRpYWxQcm9tcHQiLCJpbmplY3RJbnRvU3lzdGVtUHJvbXB0IiwiX2kiLCJfaiIsIl9rIiwiY2FsbFNldHRpbmdzIiwiY3VycmVudE1vZGVsUmVzcG9uc2UiLCJjdXJyZW50VG9vbENhbGxzIiwiY3VycmVudFRvb2xSZXN1bHRzIiwiY3VycmVudFJlYXNvbmluZ0RldGFpbHMiLCJzdGVwQ291bnQiLCJzb3VyY2VzIiwic3RlcHMiLCJzdGVwVHlwZSIsInByb21wdEZvcm1hdCIsInN0ZXBJbnB1dE1lc3NhZ2VzIiwiX2ExOSIsIl9lMiIsIl9mMiIsInJlc3BvbnNlRm9ybWF0IiwiZXhlY3V0ZVRvb2xzIiwiY3VycmVudFVzYWdlIiwibmV4dFN0ZXBUeXBlIiwib3JpZ2luYWxUZXh0Iiwic3RlcFRleHRMZWFkaW5nV2hpdGVzcGFjZVRyaW1tZWQiLCJ0cmltRW5kIiwidHJpbVN0YXJ0Iiwic3RlcFRleHQiLCJhc1JlYXNvbmluZ0RldGFpbHMiLCJsYXN0TWVzc2FnZSIsImFzRmlsZXMiLCJjdXJyZW50U3RlcFJlc3VsdCIsInJlYXNvbmluZ0RldGFpbHMiLCJzdHJ1Y3R1cmVkQ2xvbmUiLCJpc0NvbnRpbnVlZCIsIkRlZmF1bHRHZW5lcmF0ZVRleHRSZXN1bHQiLCJvdXRwdXRSZXNvbHZlciIsInBhcnNlT3V0cHV0IiwiaWdub3JlZCIsIm91dHB1dF9leHBvcnRzIiwic2FmZVBhcnNlSlNPTjMiLCJzYWZlVmFsaWRhdGVUeXBlczQiLCJhc1NjaGVtYTQiLCJwYXJzZVBhcnRpYWxKc29uMiIsIkFJU0RLRXJyb3IxNiIsIkFQSUNhbGxFcnJvcjIiLCJFbXB0eVJlc3BvbnNlQm9keUVycm9yIiwiSW52YWxpZFByb21wdEVycm9yMiIsIkludmFsaWRSZXNwb25zZURhdGFFcnJvciIsIkpTT05QYXJzZUVycm9yMiIsIkxvYWRBUElLZXlFcnJvciIsIk5vQ29udGVudEdlbmVyYXRlZEVycm9yIiwiTm9TdWNoTW9kZWxFcnJvciIsIlR5cGVWYWxpZGF0aW9uRXJyb3IzIiwiVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IyIiwiQUlTREtFcnJvcjE0IiwibmFtZTE0IiwibWFya2VyMTQiLCJzeW1ib2wxNCIsIl9hMTQiLCJJbnZhbGlkU3RyZWFtUGFydEVycm9yIiwiQUlTREtFcnJvcjE1IiwibmFtZTE1IiwibWFya2VyMTUiLCJzeW1ib2wxNSIsIl9hMTUiLCJNQ1BDbGllbnRFcnJvciIsInBhcnNlUGFydGlhbCIsIm9yaWdpbmFsRGVsYXkiLCJJbnZhbGlkQXJndW1lbnRFcnJvcjIiLCJDSFVOS0lOR19SRUdFWFBTIiwid29yZCIsInNtb290aFN0cmVhbSIsImNodW5raW5nIiwiZGVsYXkyIiwiZGV0ZWN0Q2h1bmsiLCJidWZmZXIiLCJjaHVua2luZ1JlZ2V4IiwiYXJndW1lbnQiLCJleGVjIiwiQUlTREtFcnJvcjE3IiwiY3JlYXRlSWRHZW5lcmF0b3I0IiwiZm9ybWF0RGF0YVN0cmVhbVBhcnQyIiwiYXNBcnJheSIsImNvbnN1bWVTdHJlYW0iLCJyZWxlYXNlTG9jayIsIm1lcmdlU3RyZWFtcyIsInN0cmVhbTEiLCJzdHJlYW0yIiwicmVhZGVyMSIsInJlYWRlcjIiLCJsYXN0UmVhZDEiLCJsYXN0UmVhZDIiLCJzdHJlYW0xRG9uZSIsInN0cmVhbTJEb25lIiwicmVhZFN0cmVhbTEiLCJyZWFkU3RyZWFtMiIsInJhY2UiLCJ0aGVuIiwicnVuVG9vbHNUcmFuc2Zvcm1hdGlvbiIsImdlbmVyYXRvclN0cmVhbSIsInRvb2xDYWxsU3RyZWFtaW5nIiwidG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyIiwidG9vbFJlc3VsdHNTdHJlYW0iLCJhY3RpdmVUb29sQ2FsbHMiLCJvdXRzdGFuZGluZ1Rvb2xSZXN1bHRzIiwiU2V0IiwiY2FuQ2xvc2UiLCJmaW5pc2hDaHVuayIsImF0dGVtcHRDbG9zZSIsImZvcndhcmRTdHJlYW0iLCJjaHVua1R5cGUiLCJ0b29sRXhlY3V0aW9uSWQiLCJhZGQiLCJkZWxldGUiLCJwaXBlVG8iLCJXcml0YWJsZVN0cmVhbSIsIm9yaWdpbmFsR2VuZXJhdGVJZDQiLCJvcmlnaW5hbEdlbmVyYXRlTWVzc2FnZUlkMiIsInN0cmVhbVRleHQiLCJleHBlcmltZW50YWxfdG9vbENhbGxTdHJlYW1pbmciLCJleHBlcmltZW50YWxfdHJhbnNmb3JtIiwib25DaHVuayIsIkRlZmF1bHRTdHJlYW1UZXh0UmVzdWx0IiwidHJhbnNmb3JtcyIsImNyZWF0ZU91dHB1dFRyYW5zZm9ybVN0cmVhbSIsInBhcnRpYWxPdXRwdXQiLCJ0ZXh0Q2h1bmsiLCJsYXN0UHVibGlzaGVkSnNvbiIsInB1Ymxpc2hUZXh0Q2h1bmsiLCJjdXJyZW50SnNvbiIsImZpbmlzaFJlYXNvblByb21pc2UiLCJ0ZXh0UHJvbWlzZSIsInJlYXNvbmluZ1Byb21pc2UiLCJyZWFzb25pbmdEZXRhaWxzUHJvbWlzZSIsInNvdXJjZXNQcm9taXNlIiwiZmlsZXNQcm9taXNlIiwidG9vbENhbGxzUHJvbWlzZSIsInRvb2xSZXN1bHRzUHJvbWlzZSIsInN0ZXBzUHJvbWlzZSIsInJlY29yZGVkU3RlcFRleHQiLCJyZWNvcmRlZENvbnRpbnVhdGlvblRleHQiLCJyZWNvcmRlZEZ1bGxUZXh0Iiwic3RlcFJlYXNvbmluZyIsInN0ZXBGaWxlcyIsImFjdGl2ZVJlYXNvbmluZ1RleHQiLCJyZWNvcmRlZFN0ZXBTb3VyY2VzIiwicmVjb3JkZWRTb3VyY2VzIiwicmVjb3JkZWRSZXNwb25zZSIsInJlY29yZGVkVG9vbENhbGxzIiwicmVjb3JkZWRUb29sUmVzdWx0cyIsInJlY29yZGVkRmluaXNoUmVhc29uIiwicmVjb3JkZWRVc2FnZSIsInJlY29yZGVkU3RlcHMiLCJzdGVwTWVzc2FnZXMiLCJsYXN0U3RlcCIsImNsb3NlU3RyZWFtIiwic3RvcFN0cmVhbSIsInJvb3RTcGFuQXJnIiwic3RyZWFtU3RlcCIsInN0ZXBUeXBlMiIsInByZXZpb3VzU3RlcFRleHQiLCJoYXNMZWFkaW5nV2hpdGVzcGFjZSIsInN0ZXBSZXF1ZXN0Iiwic3RlcFRvb2xDYWxscyIsInN0ZXBUb29sUmVzdWx0cyIsInN0ZXBSZWFzb25pbmcyIiwic3RlcEZpbGVzMiIsImFjdGl2ZVJlYXNvbmluZ1RleHQyIiwic3RlcEZpbmlzaFJlYXNvbiIsInN0ZXBVc2FnZSIsInN0ZXBQcm92aWRlck1ldGFkYXRhIiwic3RlcEZpcnN0Q2h1bmsiLCJmdWxsU3RlcFRleHQiLCJzdGVwTG9nUHJvYnMiLCJzdGVwUmVzcG9uc2UiLCJjaHVua0J1ZmZlciIsImNodW5rVGV4dFB1Ymxpc2hlZCIsImluV2hpdGVzcGFjZVByZWZpeCIsImhhc1doaXRlc3BhY2VTdWZmaXgiLCJ0cmltbWVkQ2h1bmtUZXh0IiwibXNUb0ZpbmlzaCIsInN0ZXBUb29sQ2FsbHNKc29uIiwiY29tYmluZWRVc2FnZSIsInRlZVN0cmVhbSIsInRlZSIsImV4cGVyaW1lbnRhbF9wYXJ0aWFsT3V0cHV0U3RyZWFtIiwidG9EYXRhU3RyZWFtSW50ZXJuYWwiLCJnZXRFcnJvck1lc3NhZ2U1Iiwic2VuZFVzYWdlIiwic2VuZFJlYXNvbmluZyIsInNlbmRTb3VyY2VzIiwiZXhwZXJpbWVudGFsX3NlbmRGaW5pc2giLCJ0b0RhdGFTdHJlYW0iLCJtZXJnZUludG9EYXRhU3RyZWFtIiwid3JpdGVyIiwidG9EYXRhU3RyZWFtUmVzcG9uc2UiLCJBSVNES0Vycm9yMTgiLCJOb1NwZWVjaEdlbmVyYXRlZEVycm9yIiwiRGVmYXVsdEdlbmVyYXRlZEF1ZGlvRmlsZSIsImZvcm1hdCIsIm1pbWVUeXBlUGFydHMiLCJnZW5lcmF0ZVNwZWVjaCIsInZvaWNlIiwib3V0cHV0Rm9ybWF0IiwiaW5zdHJ1Y3Rpb25zIiwic3BlZWQiLCJhdWRpbyIsIkRlZmF1bHRTcGVlY2hSZXN1bHQiLCJBSVNES0Vycm9yMTkiLCJOb1RyYW5zY3JpcHRHZW5lcmF0ZWRFcnJvciIsInRyYW5zY3JpYmUiLCJhdWRpb0RhdGEiLCJtZWRpYVR5cGUiLCJEZWZhdWx0VHJhbnNjcmlwdGlvblJlc3VsdCIsInNlZ21lbnRzIiwibGFuZ3VhZ2UiLCJkdXJhdGlvbkluU2Vjb25kcyIsIm1lcmdlT2JqZWN0cyIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5Iiwic291cmNlVmFsdWUiLCJ0YXJnZXRWYWx1ZSIsImlzU291cmNlT2JqZWN0IiwiUmVnRXhwIiwiaXNUYXJnZXRPYmplY3QiLCJkZWZhdWx0U2V0dGluZ3NNaWRkbGV3YXJlIiwibWlkZGxld2FyZVZlcnNpb24iLCJ0cmFuc2Zvcm1QYXJhbXMiLCJwYXJhbXMiLCJnZXRQb3RlbnRpYWxTdGFydEluZGV4Iiwic2VhcmNoZWRUZXh0IiwiZGlyZWN0SW5kZXgiLCJpbmRleE9mIiwic3Vic3RyaW5nIiwiZXh0cmFjdFJlYXNvbmluZ01pZGRsZXdhcmUiLCJ0YWdOYW1lIiwic2VwYXJhdG9yIiwic3RhcnRXaXRoUmVhc29uaW5nIiwib3BlbmluZ1RhZyIsImNsb3NpbmdUYWciLCJ3cmFwR2VuZXJhdGUiLCJyYXdUZXh0IiwicmVzdCIsInJlZ2V4cCIsIm1hdGNoZXMiLCJtYXRjaEFsbCIsInRleHRXaXRob3V0UmVhc29uaW5nIiwiYmVmb3JlTWF0Y2giLCJhZnRlck1hdGNoIiwid3JhcFN0cmVhbSIsImlzRmlyc3RSZWFzb25pbmciLCJpc0ZpcnN0VGV4dCIsImFmdGVyU3dpdGNoIiwiaXNSZWFzb25pbmciLCJwdWJsaXNoIiwibmV4dFRhZyIsInN0YXJ0SW5kZXgiLCJmb3VuZEZ1bGxNYXRjaCIsInNpbXVsYXRlU3RyZWFtaW5nTWlkZGxld2FyZSIsInNpbXVsYXRlZFN0cmVhbSIsInRvb2xDYWxsVHlwZSIsInJhd0NhbGwiLCJ3cmFwTGFuZ3VhZ2VNb2RlbCIsIm1pZGRsZXdhcmUiLCJtaWRkbGV3YXJlQXJnIiwicHJvdmlkZXJJZCIsInJldmVyc2UiLCJ3cmFwcGVkTW9kZWwiLCJkb1dyYXAiLCJkb1RyYW5zZm9ybSIsInNwZWNpZmljYXRpb25WZXJzaW9uIiwidHJhbnNmb3JtZWRQYXJhbXMiLCJleHBlcmltZW50YWxfd3JhcExhbmd1YWdlTW9kZWwiLCJhcHBlbmRDbGllbnRNZXNzYWdlIiwiZXh0cmFjdE1heFRvb2xJbnZvY2F0aW9uU3RlcCIsIkFJU0RLRXJyb3IyMCIsImFwcGVuZFJlc3BvbnNlTWVzc2FnZXMiLCJjbG9uZWRNZXNzYWdlcyIsImlzTGFzdE1lc3NhZ2VBc3Npc3RhbnQiLCJnZXRUb29sSW52b2NhdGlvbnMyIiwiZ2V0VG9vbEludm9jYXRpb25zIiwidGV4dENvbnRlbnQiLCJyZWFzb25pbmdUZXh0Q29udGVudCIsInJlYXNvbmluZ1BhcnQiLCJjcmVhdGVkQXQiLCJjb250ZW50UGFydCIsImZpbmQiLCJ0b29sQ2FsbFBhcnQiLCJOb1N1Y2hNb2RlbEVycm9yMiIsImN1c3RvbVByb3ZpZGVyIiwibGFuZ3VhZ2VNb2RlbHMiLCJ0ZXh0RW1iZWRkaW5nTW9kZWxzIiwiaW1hZ2VNb2RlbHMiLCJmYWxsYmFja1Byb3ZpZGVyIiwibGFuZ3VhZ2VNb2RlbCIsIm1vZGVsVHlwZSIsInRleHRFbWJlZGRpbmdNb2RlbCIsImltYWdlTW9kZWwiLCJleHBlcmltZW50YWxfY3VzdG9tUHJvdmlkZXIiLCJBSVNES0Vycm9yMjEiLCJOb1N1Y2hNb2RlbEVycm9yMyIsIm5hbWUxNiIsIm1hcmtlcjE2Iiwic3ltYm9sMTYiLCJfYTE2IiwiTm9TdWNoUHJvdmlkZXJFcnJvciIsImF2YWlsYWJsZVByb3ZpZGVycyIsImVycm9yTmFtZSIsIk5vU3VjaE1vZGVsRXJyb3I0IiwiY3JlYXRlUHJvdmlkZXJSZWdpc3RyeSIsInByb3ZpZGVycyIsInJlZ2lzdHJ5IiwiRGVmYXVsdFByb3ZpZGVyUmVnaXN0cnkiLCJyZWdpc3RlclByb3ZpZGVyIiwiZXhwZXJpbWVudGFsX2NyZWF0ZVByb3ZpZGVyUmVnaXN0cnkiLCJnZXRQcm92aWRlciIsInNwbGl0SWQiLCJjcmVhdGVFdmVudFNvdXJjZVBhcnNlclN0cmVhbSIsIno5IiwiejgiLCJMQVRFU1RfUFJPVE9DT0xfVkVSU0lPTiIsIlNVUFBPUlRFRF9QUk9UT0NPTF9WRVJTSU9OUyIsIkNsaWVudE9yU2VydmVySW1wbGVtZW50YXRpb25TY2hlbWEiLCJ2ZXJzaW9uIiwicGFzc3Rocm91Z2giLCJCYXNlUGFyYW1zU2NoZW1hIiwiX21ldGEiLCJSZXN1bHRTY2hlbWEiLCJSZXF1ZXN0U2NoZW1hIiwibWV0aG9kIiwiU2VydmVyQ2FwYWJpbGl0aWVzU2NoZW1hIiwiZXhwZXJpbWVudGFsIiwibG9nZ2luZyIsInByb21wdHMiLCJsaXN0Q2hhbmdlZCIsInJlc291cmNlcyIsInN1YnNjcmliZSIsIkluaXRpYWxpemVSZXN1bHRTY2hlbWEiLCJleHRlbmQiLCJwcm90b2NvbFZlcnNpb24iLCJjYXBhYmlsaXRpZXMiLCJzZXJ2ZXJJbmZvIiwiUGFnaW5hdGVkUmVzdWx0U2NoZW1hIiwibmV4dEN1cnNvciIsIlRvb2xTY2hlbWEiLCJMaXN0VG9vbHNSZXN1bHRTY2hlbWEiLCJUZXh0Q29udGVudFNjaGVtYSIsIkltYWdlQ29udGVudFNjaGVtYSIsIlJlc291cmNlQ29udGVudHNTY2hlbWEiLCJ1cmkiLCJUZXh0UmVzb3VyY2VDb250ZW50c1NjaGVtYSIsIkJsb2JSZXNvdXJjZUNvbnRlbnRzU2NoZW1hIiwiYmxvYiIsIkVtYmVkZGVkUmVzb3VyY2VTY2hlbWEiLCJyZXNvdXJjZSIsIkNhbGxUb29sUmVzdWx0U2NoZW1hIiwiZGVmYXVsdCIsIm9yIiwiSlNPTlJQQ19WRVJTSU9OIiwiSlNPTlJQQ1JlcXVlc3RTY2hlbWEiLCJqc29ucnBjIiwiaW50Iiwic3RyaWN0IiwiSlNPTlJQQ1Jlc3BvbnNlU2NoZW1hIiwiSlNPTlJQQ0Vycm9yU2NoZW1hIiwiSlNPTlJQQ05vdGlmaWNhdGlvblNjaGVtYSIsIkpTT05SUENNZXNzYWdlU2NoZW1hIiwiU3NlTUNQVHJhbnNwb3J0IiwiY29ubmVjdGVkIiwiYWJvcnRDb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwiZXN0YWJsaXNoQ29ubmVjdGlvbiIsImhyZWYiLCJzaWduYWwiLCJvbmVycm9yIiwiVGV4dERlY29kZXJTdHJlYW0iLCJwcm9jZXNzRXZlbnRzIiwiZXZlbnQiLCJlbmRwb2ludCIsIm9yaWdpbiIsInBhcnNlIiwib25tZXNzYWdlIiwiZSIsInNzZUNvbm5lY3Rpb24iLCJhYm9ydCIsIm9uY2xvc2UiLCJzZW5kIiwiY3JlYXRlTWNwVHJhbnNwb3J0IiwiY29uZmlnIiwiaXNDdXN0b21NY3BUcmFuc3BvcnQiLCJ0cmFuc3BvcnQiLCJDTElFTlRfVkVSU0lPTiIsImNyZWF0ZU1DUENsaWVudCIsImNsaWVudCIsIk1DUENsaWVudCIsInRyYW5zcG9ydENvbmZpZyIsIm9uVW5jYXVnaHRFcnJvciIsInJlcXVlc3RNZXNzYWdlSWQiLCJyZXNwb25zZUhhbmRsZXJzIiwiTWFwIiwic2VydmVyQ2FwYWJpbGl0aWVzIiwib25DbG9zZSIsIm9uUmVzcG9uc2UiLCJjbGllbnRJbmZvIiwicmVzdWx0U2NoZW1hIiwibm90aWZpY2F0aW9uIiwidGhyb3dJZkFib3J0ZWQiLCJqc29ucnBjUmVxdWVzdCIsImNsZWFudXAiLCJhYm9ydGVkIiwicGFyc2VFcnJvciIsImxpc3RUb29scyIsImNhbGxUb29sIiwiYXJndW1lbnRzIiwianNvbnJwY05vdGlmaWNhdGlvbiIsInNjaGVtYXMiLCJsaXN0VG9vbHNSZXN1bHQiLCJ0b29sV2l0aEV4ZWN1dGUiLCJoYW5kbGVyIiwiY2xlYXIiLCJjb3NpbmVTaW1pbGFyaXR5IiwidmVjdG9yMSIsInZlY3RvcjIiLCJ2ZWN0b3IxTGVuZ3RoIiwidmVjdG9yMkxlbmd0aCIsInRocm93RXJyb3JGb3JFbXB0eVZlY3RvcnMiLCJtYWduaXR1ZGVTcXVhcmVkMSIsIm1hZ25pdHVkZVNxdWFyZWQyIiwiZG90UHJvZHVjdCIsInZhbHVlMSIsInZhbHVlMiIsInNxcnQiLCJkZWxheUZ1bmN0aW9uIiwic2ltdWxhdGVSZWFkYWJsZVN0cmVhbSIsImNodW5rcyIsImNodW5rRGVsYXlJbk1zIiwiZm9ybWF0QXNzaXN0YW50U3RyZWFtUGFydDIiLCJBc3Npc3RhbnRSZXNwb25zZSIsInRocmVhZElkIiwicHJvY2VzczIiLCJ0ZXh0RW5jb2RlciIsIlRleHRFbmNvZGVyIiwic2VuZE1lc3NhZ2UiLCJlbmNvZGUiLCJzZW5kRGF0YU1lc3NhZ2UiLCJzZW5kRXJyb3IiLCJkZWx0YSIsImxhbmdjaGFpbl9hZGFwdGVyX2V4cG9ydHMiLCJmb3JtYXREYXRhU3RyZWFtUGFydDQiLCJjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lciIsImNhbGxiYWNrcyIsImFnZ3JlZ2F0ZWRSZXNwb25zZSIsIm9uU3RhcnQiLCJvblRva2VuIiwib25UZXh0Iiwib25Db21wbGV0aW9uIiwib25GaW5hbCIsImZvcndhcmRBSU1lc3NhZ2VDaHVuayIsImRhdGFTdHJlYW0iLCJyZXNwb25zZVN0cmVhbSIsIml0ZW0iLCJsbGFtYWluZGV4X2FkYXB0ZXJfZXhwb3J0cyIsIm1lcmdlSW50b0RhdGFTdHJlYW0yIiwidG9EYXRhU3RyZWFtMiIsInRvRGF0YVN0cmVhbVJlc3BvbnNlMiIsImNvbnZlcnRBc3luY0l0ZXJhdG9yVG9SZWFkYWJsZVN0cmVhbSIsImZvcm1hdERhdGFTdHJlYW1QYXJ0NSIsInRvRGF0YVN0cmVhbUludGVybmFsMiIsInRyaW1TdGFydE9mU3RyZWFtIiwiaXNTdHJlYW1TdGFydCIsImZvcm1hdERhdGFTdHJlYW1QYXJ0NiIsIkhBTkdJTkdfU1RSRUFNX1dBUk5JTkdfVElNRV9NUyIsIlN0cmVhbURhdGEiLCJlbmNvZGVyIiwid2FybmluZ1RpbWVvdXQiLCJwcm9jZXNzIiwic2V0VGltZW91dCIsImNvbnNvbGUiLCJ3YXJuIiwiY2xlYXJUaW1lb3V0IiwiYXBwZW5kIiwiYXBwZW5kTWVzc2FnZUFubm90YXRpb24iLCJMYW5nQ2hhaW5BZGFwdGVyIiwiTGxhbWFJbmRleEFkYXB0ZXIiLCJPdXRwdXQiLCJleHBlcmltZW50YWxfY3JlYXRlTUNQQ2xpZW50IiwiZXhwZXJpbWVudGFsX2dlbmVyYXRlSW1hZ2UiLCJleHBlcmltZW50YWxfZ2VuZXJhdGVTcGVlY2giLCJleHBlcmltZW50YWxfdHJhbnNjcmliZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/dist/index.mjs\n");

/***/ })

};
;